"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stream-io";
exports.ids = ["vendor-chunks/@stream-io"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/@stream-io/video-client/dist/index.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   AudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ AudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   AxiosError: () => (/* reexport safe */ axios__WEBPACK_IMPORTED_MODULE_1__.AxiosError),\n/* harmony export */   Browsers: () => (/* binding */ browsers),\n/* harmony export */   Call: () => (/* binding */ Call),\n/* harmony export */   CallState: () => (/* binding */ CallState),\n/* harmony export */   CallType: () => (/* binding */ CallType),\n/* harmony export */   CallTypes: () => (/* binding */ CallTypes),\n/* harmony export */   CallingState: () => (/* binding */ CallingState),\n/* harmony export */   CameraManager: () => (/* binding */ CameraManager),\n/* harmony export */   CameraManagerState: () => (/* binding */ CameraManagerState),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   DebounceType: () => (/* binding */ DebounceType),\n/* harmony export */   DynascaleManager: () => (/* binding */ DynascaleManager),\n/* harmony export */   ErrorFromResponse: () => (/* binding */ ErrorFromResponse),\n/* harmony export */   InputMediaDeviceManager: () => (/* binding */ InputMediaDeviceManager),\n/* harmony export */   InputMediaDeviceManagerState: () => (/* binding */ InputMediaDeviceManagerState),\n/* harmony export */   MicrophoneManager: () => (/* binding */ MicrophoneManager),\n/* harmony export */   MicrophoneManagerState: () => (/* binding */ MicrophoneManagerState),\n/* harmony export */   OwnCapability: () => (/* binding */ OwnCapability),\n/* harmony export */   RecordSettingsRequestModeEnum: () => (/* binding */ RecordSettingsRequestModeEnum),\n/* harmony export */   RecordSettingsRequestQualityEnum: () => (/* binding */ RecordSettingsRequestQualityEnum),\n/* harmony export */   RxUtils: () => (/* binding */ rxUtils),\n/* harmony export */   ScreenShareManager: () => (/* binding */ ScreenShareManager),\n/* harmony export */   ScreenShareState: () => (/* binding */ ScreenShareState),\n/* harmony export */   SfuEvents: () => (/* binding */ events),\n/* harmony export */   SfuModels: () => (/* binding */ models),\n/* harmony export */   SpeakerManager: () => (/* binding */ SpeakerManager),\n/* harmony export */   SpeakerState: () => (/* binding */ SpeakerState),\n/* harmony export */   StreamSfuClient: () => (/* binding */ StreamSfuClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   StreamVideoReadOnlyStateStore: () => (/* binding */ StreamVideoReadOnlyStateStore),\n/* harmony export */   StreamVideoWriteableStateStore: () => (/* binding */ StreamVideoWriteableStateStore),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranscriptionSettingsRequestModeEnum: () => (/* binding */ TranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoSettingsRequestCameraFacingEnum),\n/* harmony export */   ViewportTracker: () => (/* binding */ ViewportTracker),\n/* harmony export */   VisibilityState: () => (/* binding */ VisibilityState),\n/* harmony export */   checkIfAudioOutputChangeSupported: () => (/* binding */ checkIfAudioOutputChangeSupported),\n/* harmony export */   combineComparators: () => (/* binding */ combineComparators),\n/* harmony export */   conditional: () => (/* binding */ conditional),\n/* harmony export */   createSoundDetector: () => (/* binding */ createSoundDetector),\n/* harmony export */   defaultSortPreset: () => (/* binding */ defaultSortPreset),\n/* harmony export */   descending: () => (/* binding */ descending),\n/* harmony export */   deviceIds$: () => (/* binding */ deviceIds$),\n/* harmony export */   disposeOfMediaStream: () => (/* binding */ disposeOfMediaStream),\n/* harmony export */   dominantSpeaker: () => (/* binding */ dominantSpeaker),\n/* harmony export */   getAudioDevices: () => (/* binding */ getAudioDevices),\n/* harmony export */   getAudioOutputDevices: () => (/* binding */ getAudioOutputDevices),\n/* harmony export */   getAudioStream: () => (/* binding */ getAudioStream),\n/* harmony export */   getClientDetails: () => (/* binding */ getClientDetails),\n/* harmony export */   getDeviceInfo: () => (/* binding */ getDeviceInfo),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   getOSInfo: () => (/* binding */ getOSInfo),\n/* harmony export */   getScreenShareStream: () => (/* binding */ getScreenShareStream),\n/* harmony export */   getSdkInfo: () => (/* binding */ getSdkInfo),\n/* harmony export */   getVideoDevices: () => (/* binding */ getVideoDevices),\n/* harmony export */   getVideoStream: () => (/* binding */ getVideoStream),\n/* harmony export */   getWebRTCInfo: () => (/* binding */ getWebRTCInfo),\n/* harmony export */   livestreamOrAudioRoomSortPreset: () => (/* binding */ livestreamOrAudioRoomSortPreset),\n/* harmony export */   logLevels: () => (/* binding */ logLevels),\n/* harmony export */   logToConsole: () => (/* binding */ logToConsole),\n/* harmony export */   name: () => (/* binding */ name),\n/* harmony export */   noopComparator: () => (/* binding */ noopComparator),\n/* harmony export */   paginatedLayoutSortPreset: () => (/* binding */ paginatedLayoutSortPreset),\n/* harmony export */   pinned: () => (/* binding */ pinned),\n/* harmony export */   publishingAudio: () => (/* binding */ publishingAudio),\n/* harmony export */   publishingVideo: () => (/* binding */ publishingVideo),\n/* harmony export */   reactionType: () => (/* binding */ reactionType),\n/* harmony export */   role: () => (/* binding */ role),\n/* harmony export */   screenSharing: () => (/* binding */ screenSharing),\n/* harmony export */   setDeviceInfo: () => (/* binding */ setDeviceInfo),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setLogger: () => (/* binding */ setLogger),\n/* harmony export */   setOSInfo: () => (/* binding */ setOSInfo),\n/* harmony export */   setSdkInfo: () => (/* binding */ setSdkInfo),\n/* harmony export */   setWebRTCInfo: () => (/* binding */ setWebRTCInfo),\n/* harmony export */   speakerLayoutSortPreset: () => (/* binding */ speakerLayoutSortPreset),\n/* harmony export */   speaking: () => (/* binding */ speaking)\n/* harmony export */ });\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"(ssr)/./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/message-type.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n/* harmony import */ var _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @protobuf-ts/twirp-transport */ \"(ssr)/./node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-transport.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/merge.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/pairwise.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/of.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/debounce.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdp-transform */ \"(ssr)/./node_modules/sdp-transform/lib/index.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ua-parser-js */ \"(ssr)/./node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! isomorphic-ws */ \"(ssr)/./node_modules/isomorphic-ws/node.js\");\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! base64-js */ \"(ssr)/./node_modules/base64-js/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @export\n */ const AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const AudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: \"firebase\",\n    APN: \"apn\",\n    HUAWEI: \"huawei\",\n    XIAOMI: \"xiaomi\"\n};\n/**\n * All possibility of string to use\n * @export\n */ const OwnCapability = {\n    BLOCK_USERS: \"block-users\",\n    CREATE_CALL: \"create-call\",\n    CREATE_REACTION: \"create-reaction\",\n    END_CALL: \"end-call\",\n    JOIN_BACKSTAGE: \"join-backstage\",\n    JOIN_CALL: \"join-call\",\n    JOIN_ENDED_CALL: \"join-ended-call\",\n    MUTE_USERS: \"mute-users\",\n    PIN_FOR_EVERYONE: \"pin-for-everyone\",\n    READ_CALL: \"read-call\",\n    REMOVE_CALL_MEMBER: \"remove-call-member\",\n    SCREENSHARE: \"screenshare\",\n    SEND_AUDIO: \"send-audio\",\n    SEND_VIDEO: \"send-video\",\n    START_BROADCAST_CALL: \"start-broadcast-call\",\n    START_RECORD_CALL: \"start-record-call\",\n    START_TRANSCRIPTION_CALL: \"start-transcription-call\",\n    STOP_BROADCAST_CALL: \"stop-broadcast-call\",\n    STOP_RECORD_CALL: \"stop-record-call\",\n    STOP_TRANSCRIPTION_CALL: \"stop-transcription-call\",\n    UPDATE_CALL: \"update-call\",\n    UPDATE_CALL_MEMBER: \"update-call-member\",\n    UPDATE_CALL_PERMISSIONS: \"update-call-permissions\",\n    UPDATE_CALL_SETTINGS: \"update-call-settings\"\n};\n/**\n * @export\n */ const RecordSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const RecordSettingsRequestQualityEnum = {\n    _360P: \"360p\",\n    _480P: \"480p\",\n    _720P: \"720p\",\n    _1080P: \"1080p\",\n    _1440P: \"1440p\"\n};\n/**\n * @export\n */ const TranscriptionSettingsModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const TranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const VideoSettingsCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\n/**\n * @export\n */ const VideoSettingsRequestCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\nclass ErrorFromResponse extends Error {\n}\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n *  The JSON representation for `NullValue` is JSON `null`.\n *\n * @generated from protobuf enum google.protobuf.NullValue\n */ var NullValue;\n(function(NullValue) {\n    /**\n     * Null value.\n     *\n     * @generated from protobuf enum value: NULL_VALUE = 0;\n     */ NullValue[NullValue[\"NULL_VALUE\"] = 0] = \"NULL_VALUE\";\n})(NullValue || (NullValue = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass Struct$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Struct\", [\n            {\n                no: 1,\n                name: \"fields\",\n                kind: \"map\",\n                K: 9 /*ScalarType.STRING*/ ,\n                V: {\n                    kind: \"message\",\n                    T: ()=>Value\n                }\n            }\n        ]);\n    }\n    /**\n     * Encode `Struct` to JSON object.\n     */ internalJsonWrite(message, options) {\n        let json = {};\n        for (let [k, v] of Object.entries(message.fields)){\n            json[k] = Value.toJson(v);\n        }\n        return json;\n    }\n    /**\n     * Decode `Struct` from JSON object.\n     */ internalJsonRead(json, options, target) {\n        if (!(0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_8__.isJsonObject)(json)) throw new globalThis.Error(\"Unable to parse message \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_8__.typeofJsonValue)(json) + \".\");\n        if (!target) target = this.create();\n        for (let [k, v] of globalThis.Object.entries(json)){\n            target.fields[k] = Value.fromJson(v);\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fields = {};\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* map<string, google.protobuf.Value> fields */ 1:\n                    this.binaryReadMap1(message.fields, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    binaryReadMap1(map, reader, options) {\n        let len = reader.uint32(), end = reader.pos + len, key, val;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = Value.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default:\n                    throw new globalThis.Error(\"unknown map entry field for field google.protobuf.Struct.fields\");\n            }\n        }\n        map[key ?? \"\"] = val ?? Value.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* map<string, google.protobuf.Value> fields = 1; */ for (let k of globalThis.Object.keys(message.fields)){\n            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork().tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(k);\n            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork();\n            Value.internalBinaryWrite(message.fields[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Struct\n */ const Struct = new Struct$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Value$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Value\", [\n            {\n                no: 1,\n                name: \"null_value\",\n                kind: \"enum\",\n                oneof: \"kind\",\n                T: ()=>[\n                        \"google.protobuf.NullValue\",\n                        NullValue\n                    ]\n            },\n            {\n                no: 2,\n                name: \"number_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 1 /*ScalarType.DOUBLE*/ \n            },\n            {\n                no: 3,\n                name: \"string_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"bool_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 5,\n                name: \"struct_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"list_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>ListValue\n            }\n        ]);\n    }\n    /**\n     * Encode `Value` to JSON value.\n     */ internalJsonWrite(message, options) {\n        if (message.kind.oneofKind === undefined) throw new globalThis.Error();\n        switch(message.kind.oneofKind){\n            case undefined:\n                throw new globalThis.Error();\n            case \"boolValue\":\n                return message.kind.boolValue;\n            case \"nullValue\":\n                return null;\n            case \"numberValue\":\n                let numberValue = message.kind.numberValue;\n                if (typeof numberValue == \"number\" && !Number.isFinite(numberValue)) throw new globalThis.Error();\n                return numberValue;\n            case \"stringValue\":\n                return message.kind.stringValue;\n            case \"listValue\":\n                let listValueField = this.fields.find((f)=>f.no === 6);\n                if (listValueField?.kind !== \"message\") throw new globalThis.Error();\n                return listValueField.T().toJson(message.kind.listValue);\n            case \"structValue\":\n                let structValueField = this.fields.find((f)=>f.no === 5);\n                if (structValueField?.kind !== \"message\") throw new globalThis.Error();\n                return structValueField.T().toJson(message.kind.structValue);\n        }\n    }\n    /**\n     * Decode `Value` from JSON value.\n     */ internalJsonRead(json, options, target) {\n        if (!target) target = this.create();\n        switch(typeof json){\n            case \"number\":\n                target.kind = {\n                    oneofKind: \"numberValue\",\n                    numberValue: json\n                };\n                break;\n            case \"string\":\n                target.kind = {\n                    oneofKind: \"stringValue\",\n                    stringValue: json\n                };\n                break;\n            case \"boolean\":\n                target.kind = {\n                    oneofKind: \"boolValue\",\n                    boolValue: json\n                };\n                break;\n            case \"object\":\n                if (json === null) {\n                    target.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: NullValue.NULL_VALUE\n                    };\n                } else if (globalThis.Array.isArray(json)) {\n                    target.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.fromJson(json)\n                    };\n                } else {\n                    target.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.fromJson(json)\n                    };\n                }\n                break;\n            default:\n                throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_8__.typeofJsonValue)(json));\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.kind = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* google.protobuf.NullValue null_value */ 1:\n                    message.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: reader.int32()\n                    };\n                    break;\n                case /* double number_value */ 2:\n                    message.kind = {\n                        oneofKind: \"numberValue\",\n                        numberValue: reader.double()\n                    };\n                    break;\n                case /* string string_value */ 3:\n                    message.kind = {\n                        oneofKind: \"stringValue\",\n                        stringValue: reader.string()\n                    };\n                    break;\n                case /* bool bool_value */ 4:\n                    message.kind = {\n                        oneofKind: \"boolValue\",\n                        boolValue: reader.bool()\n                    };\n                    break;\n                case /* google.protobuf.Struct struct_value */ 5:\n                    message.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.internalBinaryRead(reader, reader.uint32(), options, message.kind.structValue)\n                    };\n                    break;\n                case /* google.protobuf.ListValue list_value */ 6:\n                    message.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.internalBinaryRead(reader, reader.uint32(), options, message.kind.listValue)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* google.protobuf.NullValue null_value = 1; */ if (message.kind.oneofKind === \"nullValue\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.kind.nullValue);\n        /* double number_value = 2; */ if (message.kind.oneofKind === \"numberValue\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Bit64).double(message.kind.numberValue);\n        /* string string_value = 3; */ if (message.kind.oneofKind === \"stringValue\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.kind.stringValue);\n        /* bool bool_value = 4; */ if (message.kind.oneofKind === \"boolValue\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.kind.boolValue);\n        /* google.protobuf.Struct struct_value = 5; */ if (message.kind.oneofKind === \"structValue\") Struct.internalBinaryWrite(message.kind.structValue, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.ListValue list_value = 6; */ if (message.kind.oneofKind === \"listValue\") ListValue.internalBinaryWrite(message.kind.listValue, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Value\n */ const Value = new Value$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ListValue$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"google.protobuf.ListValue\", [\n            {\n                no: 1,\n                name: \"values\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Value\n            }\n        ]);\n    }\n    /**\n     * Encode `ListValue` to JSON array.\n     */ internalJsonWrite(message, options) {\n        return message.values.map((v)=>Value.toJson(v));\n    }\n    /**\n     * Decode `ListValue` from JSON array.\n     */ internalJsonRead(json, options, target) {\n        if (!globalThis.Array.isArray(json)) throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_8__.typeofJsonValue)(json));\n        if (!target) target = this.create();\n        let values = json.map((v)=>Value.fromJson(v));\n        target.values.push(...values);\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.values = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated google.protobuf.Value values */ 1:\n                    message.values.push(Value.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated google.protobuf.Value values = 1; */ for(let i = 0; i < message.values.length; i++)Value.internalBinaryWrite(message.values[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.ListValue\n */ const ListValue = new ListValue$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Timestamp\", [\n            {\n                no: 1,\n                name: \"seconds\",\n                kind: \"scalar\",\n                T: 3 /*ScalarType.INT64*/ \n            },\n            {\n                no: 2,\n                name: \"nanos\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    /**\n     * Creates a new `Timestamp` for the current time.\n     */ now() {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript Date.\n     */ toDate(message) {\n        return new Date(_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a `Timestamp`.\n     */ fromDate(date) {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonWrite(message, options) {\n        let ms = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new Error(\"Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (message.nanos < 0) throw new Error(\"Unable to encode invalid Timestamp to JSON. Nanos must not be negative.\");\n        let z = \"Z\";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            else if (nanosStr.substring(6) === \"000\") z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            else z = \".\" + nanosStr + \"Z\";\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonRead(json, options, target) {\n        if (typeof json !== \"string\") throw new Error(\"Unable to parse Timestamp from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_8__.typeofJsonValue)(json) + \".\");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) throw new Error(\"Unable to parse Timestamp from JSON. Invalid format.\");\n        let ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) throw new Error(\"Unable to parse Timestamp from JSON. Invalid value.\");\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new globalThis.Error(\"Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (!target) target = this.create();\n        target.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.PbLong.from(ms / 1000).toString();\n        target.nanos = 0;\n        if (matches[7]) target.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.seconds = \"0\";\n        message.nanos = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int64 seconds */ 1:\n                    message.seconds = reader.int64().toString();\n                    break;\n                case /* int32 nanos */ 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int64 seconds = 1; */ if (message.seconds !== \"0\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int64(message.seconds);\n        /* int32 nanos = 2; */ if (message.nanos !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.nanos);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Timestamp\n */ const Timestamp = new Timestamp$Type();\n/**\n * @generated from protobuf enum stream.video.sfu.models.PeerType\n */ var PeerType;\n(function(PeerType) {\n    /**\n     * todo fix me (marcelo)\n     *\n     * @generated from protobuf enum value: PEER_TYPE_PUBLISHER_UNSPECIFIED = 0;\n     */ PeerType[PeerType[\"PUBLISHER_UNSPECIFIED\"] = 0] = \"PUBLISHER_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PEER_TYPE_SUBSCRIBER = 1;\n     */ PeerType[PeerType[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(PeerType || (PeerType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ConnectionQuality\n */ var ConnectionQuality;\n(function(ConnectionQuality) {\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_UNSPECIFIED = 0;\n     */ ConnectionQuality[ConnectionQuality[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_POOR = 1;\n     */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 1] = \"POOR\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_GOOD = 2;\n     */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 2] = \"GOOD\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_EXCELLENT = 3;\n     */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 3] = \"EXCELLENT\";\n})(ConnectionQuality || (ConnectionQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_LOW_UNSPECIFIED = 0;\n     */ VideoQuality[VideoQuality[\"LOW_UNSPECIFIED\"] = 0] = \"LOW_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_MID = 1;\n     */ VideoQuality[VideoQuality[\"MID\"] = 1] = \"MID\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_HIGH = 2;\n     */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_OFF = 3;\n     */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_UNSPECIFIED = 0;\n     */ TrackType[TrackType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_AUDIO = 1;\n     */ TrackType[TrackType[\"AUDIO\"] = 1] = \"AUDIO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_VIDEO = 2;\n     */ TrackType[TrackType[\"VIDEO\"] = 2] = \"VIDEO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE = 3;\n     */ TrackType[TrackType[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE_AUDIO = 4;\n     */ TrackType[TrackType[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackType || (TrackType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ErrorCode\n */ var ErrorCode;\n(function(ErrorCode) {\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNSPECIFIED = 0;\n     */ ErrorCode[ErrorCode[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_NOT_FOUND = 100;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_NOT_FOUND\"] = 100] = \"PUBLISH_TRACK_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACKS_MISMATCH = 101;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACKS_MISMATCH\"] = 101] = \"PUBLISH_TRACKS_MISMATCH\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_OUT_OF_ORDER = 102;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_OUT_OF_ORDER\"] = 102] = \"PUBLISH_TRACK_OUT_OF_ORDER\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND = 103;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\"] = 103] = \"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_LIVE_ENDED = 104;\n     */ ErrorCode[ErrorCode[\"LIVE_ENDED\"] = 104] = \"LIVE_ENDED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_NOT_FOUND = 200;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_NOT_FOUND\"] = 200] = \"PARTICIPANT_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING_OUT = 201;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING_OUT\"] = 201] = \"PARTICIPANT_MIGRATING_OUT\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATION_FAILED = 202;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATION_FAILED\"] = 202] = \"PARTICIPANT_MIGRATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING = 203;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING\"] = 203] = \"PARTICIPANT_MIGRATING\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_RECONNECT_FAILED = 204;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_RECONNECT_FAILED\"] = 204] = \"PARTICIPANT_RECONNECT_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MEDIA_TRANSPORT_FAILURE = 205;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\"] = 205] = \"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_CALL_NOT_FOUND = 300;\n     */ ErrorCode[ErrorCode[\"CALL_NOT_FOUND\"] = 300] = \"CALL_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_REQUEST_VALIDATION_FAILED = 400;\n     */ ErrorCode[ErrorCode[\"REQUEST_VALIDATION_FAILED\"] = 400] = \"REQUEST_VALIDATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNAUTHENTICATED = 401;\n     */ ErrorCode[ErrorCode[\"UNAUTHENTICATED\"] = 401] = \"UNAUTHENTICATED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PERMISSION_DENIED = 403;\n     */ ErrorCode[ErrorCode[\"PERMISSION_DENIED\"] = 403] = \"PERMISSION_DENIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_TOO_MANY_REQUESTS = 429;\n     */ ErrorCode[ErrorCode[\"TOO_MANY_REQUESTS\"] = 429] = \"TOO_MANY_REQUESTS\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_INTERNAL_SERVER_ERROR = 500;\n     */ ErrorCode[ErrorCode[\"INTERNAL_SERVER_ERROR\"] = 500] = \"INTERNAL_SERVER_ERROR\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_SHUTTING_DOWN = 600;\n     */ ErrorCode[ErrorCode[\"SFU_SHUTTING_DOWN\"] = 600] = \"SFU_SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_FULL = 700;\n     */ ErrorCode[ErrorCode[\"SFU_FULL\"] = 700] = \"SFU_FULL\";\n})(ErrorCode || (ErrorCode = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.SdkType\n */ var SdkType;\n(function(SdkType) {\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNSPECIFIED = 0;\n     */ SdkType[SdkType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT = 1;\n     */ SdkType[SdkType[\"REACT\"] = 1] = \"REACT\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANGULAR = 2;\n     */ SdkType[SdkType[\"ANGULAR\"] = 2] = \"ANGULAR\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANDROID = 3;\n     */ SdkType[SdkType[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_IOS = 4;\n     */ SdkType[SdkType[\"IOS\"] = 4] = \"IOS\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_FLUTTER = 5;\n     */ SdkType[SdkType[\"FLUTTER\"] = 5] = \"FLUTTER\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT_NATIVE = 6;\n     */ SdkType[SdkType[\"REACT_NATIVE\"] = 6] = \"REACT_NATIVE\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNITY = 7;\n     */ SdkType[SdkType[\"UNITY\"] = 7] = \"UNITY\";\n})(SdkType || (SdkType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackUnpublishReason\n */ var TrackUnpublishReason;\n(function(TrackUnpublishReason) {\n    /**\n     * Default value which is used when the specific reason\n     * for muting the track is not known.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_UNSPECIFIED = 0;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * Represents user muting their tracks.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_USER_MUTED = 1;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"USER_MUTED\"] = 1] = \"USER_MUTED\";\n    /**\n     * Represents muting the track because the permission to\n     * publish the track has been revoked.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_PERMISSION_REVOKED = 2;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"PERMISSION_REVOKED\"] = 2] = \"PERMISSION_REVOKED\";\n    /**\n     * Represents muting the track due to moderation actions.\n     * This is different from permission revoked because the\n     * participant can unmute themselves here whereas in case\n     * of \"permission revoke\" it is not possible until the\n     * call permissions are updated.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_MODERATION = 3;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"MODERATION\"] = 3] = \"MODERATION\";\n})(TrackUnpublishReason || (TrackUnpublishReason = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.GoAwayReason\n */ var GoAwayReason;\n(function(GoAwayReason) {\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_UNSPECIFIED = 0;\n     */ GoAwayReason[GoAwayReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_SHUTTING_DOWN = 1;\n     */ GoAwayReason[GoAwayReason[\"SHUTTING_DOWN\"] = 1] = \"SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_REBALANCE = 2;\n     */ GoAwayReason[GoAwayReason[\"REBALANCE\"] = 2] = \"REBALANCE\";\n})(GoAwayReason || (GoAwayReason = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallState\", [\n            {\n                no: 1,\n                name: \"participants\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Participant\n            },\n            {\n                no: 2,\n                name: \"started_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 3,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            },\n            {\n                no: 4,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.participants = [];\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Participant participants */ 1:\n                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* google.protobuf.Timestamp started_at */ 2:\n                    message.startedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);\n                    break;\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 3:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                case /* repeated stream.video.sfu.models.Pin pins */ 4:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Participant participants = 1; */ for(let i = 0; i < message.participants.length; i++)Participant.internalBinaryWrite(message.participants[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp started_at = 2; */ if (message.startedAt) Timestamp.internalBinaryWrite(message.startedAt, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ParticipantCount participant_count = 3; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.models.Pin pins = 4; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallState\n */ const CallState$1 = new CallState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ParticipantCount\", [\n            {\n                no: 1,\n                name: \"total\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"anonymous\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.total = 0;\n        message.anonymous = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 total */ 1:\n                    message.total = reader.uint32();\n                    break;\n                case /* uint32 anonymous */ 2:\n                    message.anonymous = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 total = 1; */ if (message.total !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.total);\n        /* uint32 anonymous = 2; */ if (message.anonymous !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.anonymous);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ParticipantCount\n */ const ParticipantCount = new ParticipantCount$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Pin$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Pin\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Pin\n */ const Pin = new Pin$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Participant$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Participant\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"published_tracks\",\n                kind: \"enum\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"joined_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 5,\n                name: \"track_lookup_prefix\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            },\n            {\n                no: 7,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"is_dominant_speaker\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"audio_level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 10,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 11,\n                name: \"image\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 12,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 13,\n                name: \"roles\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.publishedTracks = [];\n        message.trackLookupPrefix = \"\";\n        message.connectionQuality = 0;\n        message.isSpeaking = false;\n        message.isDominantSpeaker = false;\n        message.audioLevel = 0;\n        message.name = \"\";\n        message.image = \"\";\n        message.roles = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackType published_tracks */ 3:\n                    if (wireType === _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited) for(let e = reader.int32() + reader.pos; reader.pos < e;)message.publishedTracks.push(reader.int32());\n                    else message.publishedTracks.push(reader.int32());\n                    break;\n                case /* google.protobuf.Timestamp joined_at */ 4:\n                    message.joinedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.joinedAt);\n                    break;\n                case /* string track_lookup_prefix */ 5:\n                    message.trackLookupPrefix = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 6:\n                    message.connectionQuality = reader.int32();\n                    break;\n                case /* bool is_speaking */ 7:\n                    message.isSpeaking = reader.bool();\n                    break;\n                case /* bool is_dominant_speaker */ 8:\n                    message.isDominantSpeaker = reader.bool();\n                    break;\n                case /* float audio_level */ 9:\n                    message.audioLevel = reader.float();\n                    break;\n                case /* string name */ 10:\n                    message.name = reader.string();\n                    break;\n                case /* string image */ 11:\n                    message.image = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 12:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* repeated string roles */ 13:\n                    message.roles.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackType published_tracks = 3; */ if (message.publishedTracks.length) {\n            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork();\n            for(let i = 0; i < message.publishedTracks.length; i++)writer.int32(message.publishedTracks[i]);\n            writer.join();\n        }\n        /* google.protobuf.Timestamp joined_at = 4; */ if (message.joinedAt) Timestamp.internalBinaryWrite(message.joinedAt, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* string track_lookup_prefix = 5; */ if (message.trackLookupPrefix !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.trackLookupPrefix);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 6; */ if (message.connectionQuality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.connectionQuality);\n        /* bool is_speaking = 7; */ if (message.isSpeaking !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.isSpeaking);\n        /* bool is_dominant_speaker = 8; */ if (message.isDominantSpeaker !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.isDominantSpeaker);\n        /* float audio_level = 9; */ if (message.audioLevel !== 0) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Bit32).float(message.audioLevel);\n        /* string name = 10; */ if (message.name !== \"\") writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.name);\n        /* string image = 11; */ if (message.image !== \"\") writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.image);\n        /* google.protobuf.Struct custom = 12; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated string roles = 13; */ for(let i = 0; i < message.roles.length; i++)writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.roles[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Participant\n */ const Participant = new Participant$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass StreamQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.StreamQuality\", [\n            {\n                no: 1,\n                name: \"video_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.videoQuality = 0;\n        message.userId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.VideoQuality video_quality */ 1:\n                    message.videoQuality = reader.int32();\n                    break;\n                case /* string user_id */ 2:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.VideoQuality video_quality = 1; */ if (message.videoQuality !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.videoQuality);\n        /* string user_id = 2; */ if (message.userId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.StreamQuality\n */ const StreamQuality = new StreamQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoDimension$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoDimension\", [\n            {\n                no: 1,\n                name: \"width\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"height\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.width = 0;\n        message.height = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 width */ 1:\n                    message.width = reader.uint32();\n                    break;\n                case /* uint32 height */ 2:\n                    message.height = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 width = 1; */ if (message.width !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.width);\n        /* uint32 height = 2; */ if (message.height !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.height);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoDimension\n */ const VideoDimension = new VideoDimension$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoLayer\", [\n            {\n                no: 1,\n                name: \"rid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"video_dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            },\n            {\n                no: 4,\n                name: \"bitrate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"fps\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 6,\n                name: \"quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.rid = \"\";\n        message.bitrate = 0;\n        message.fps = 0;\n        message.quality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string rid */ 1:\n                    message.rid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension video_dimension */ 2:\n                    message.videoDimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.videoDimension);\n                    break;\n                case /* uint32 bitrate */ 4:\n                    message.bitrate = reader.uint32();\n                    break;\n                case /* uint32 fps */ 5:\n                    message.fps = reader.uint32();\n                    break;\n                case /* stream.video.sfu.models.VideoQuality quality */ 6:\n                    message.quality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string rid = 1; */ if (message.rid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.rid);\n        /* stream.video.sfu.models.VideoDimension video_dimension = 2; */ if (message.videoDimension) VideoDimension.internalBinaryWrite(message.videoDimension, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 bitrate = 4; */ if (message.bitrate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.bitrate);\n        /* uint32 fps = 5; */ if (message.fps !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.fps);\n        /* stream.video.sfu.models.VideoQuality quality = 6; */ if (message.quality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.quality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoLayer\n */ const VideoLayer = new VideoLayer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Codec$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Codec\", [\n            {\n                no: 1,\n                name: \"payload_type\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"fmtp_line\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"clock_rate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"encoding_parameters\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"feedbacks\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.payloadType = 0;\n        message.name = \"\";\n        message.fmtpLine = \"\";\n        message.clockRate = 0;\n        message.encodingParameters = \"\";\n        message.feedbacks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 payload_type */ 1:\n                    message.payloadType = reader.uint32();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string fmtp_line */ 3:\n                    message.fmtpLine = reader.string();\n                    break;\n                case /* uint32 clock_rate */ 4:\n                    message.clockRate = reader.uint32();\n                    break;\n                case /* string encoding_parameters */ 5:\n                    message.encodingParameters = reader.string();\n                    break;\n                case /* repeated string feedbacks */ 6:\n                    message.feedbacks.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 payload_type = 1; */ if (message.payloadType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.payloadType);\n        /* string name = 2; */ if (message.name !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.name);\n        /* string fmtp_line = 3; */ if (message.fmtpLine !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.fmtpLine);\n        /* uint32 clock_rate = 4; */ if (message.clockRate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.clockRate);\n        /* string encoding_parameters = 5; */ if (message.encodingParameters !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.encodingParameters);\n        /* repeated string feedbacks = 6; */ for(let i = 0; i < message.feedbacks.length; i++)writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.feedbacks[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Codec\n */ const Codec = new Codec$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet ICETrickle$Type$1 = class ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.iceCandidate);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ICETrickle\n */ const ICETrickle$1 = new ICETrickle$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.TrackInfo\", [\n            {\n                no: 1,\n                name: \"track_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayer\n            },\n            {\n                no: 6,\n                name: \"mid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 7,\n                name: \"dtx\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"stereo\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"red\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackId = \"\";\n        message.trackType = 0;\n        message.layers = [];\n        message.mid = \"\";\n        message.dtx = false;\n        message.stereo = false;\n        message.red = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string track_id */ 1:\n                    message.trackId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 2:\n                    message.trackType = reader.int32();\n                    break;\n                case /* repeated stream.video.sfu.models.VideoLayer layers */ 5:\n                    message.layers.push(VideoLayer.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* string mid */ 6:\n                    message.mid = reader.string();\n                    break;\n                case /* bool dtx */ 7:\n                    message.dtx = reader.bool();\n                    break;\n                case /* bool stereo */ 8:\n                    message.stereo = reader.bool();\n                    break;\n                case /* bool red */ 9:\n                    message.red = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string track_id = 1; */ if (message.trackId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.trackId);\n        /* stream.video.sfu.models.TrackType track_type = 2; */ if (message.trackType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.trackType);\n        /* repeated stream.video.sfu.models.VideoLayer layers = 5; */ for(let i = 0; i < message.layers.length; i++)VideoLayer.internalBinaryWrite(message.layers[i], writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* string mid = 6; */ if (message.mid !== \"\") writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.mid);\n        /* bool dtx = 7; */ if (message.dtx !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.dtx);\n        /* bool stereo = 8; */ if (message.stereo !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.stereo);\n        /* bool red = 9; */ if (message.red !== false) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.red);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.TrackInfo\n */ const TrackInfo = new TrackInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Call$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Call\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"created_by_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"host_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"created_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 7,\n                name: \"updated_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = \"\";\n        message.id = \"\";\n        message.createdByUserId = \"\";\n        message.hostUserId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string type */ 1:\n                    message.type = reader.string();\n                    break;\n                case /* string id */ 2:\n                    message.id = reader.string();\n                    break;\n                case /* string created_by_user_id */ 3:\n                    message.createdByUserId = reader.string();\n                    break;\n                case /* string host_user_id */ 4:\n                    message.hostUserId = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 5:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* google.protobuf.Timestamp created_at */ 6:\n                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);\n                    break;\n                case /* google.protobuf.Timestamp updated_at */ 7:\n                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string type = 1; */ if (message.type !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.type);\n        /* string id = 2; */ if (message.id !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.id);\n        /* string created_by_user_id = 3; */ if (message.createdByUserId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.createdByUserId);\n        /* string host_user_id = 4; */ if (message.hostUserId !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.hostUserId);\n        /* google.protobuf.Struct custom = 5; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp created_at = 6; */ if (message.createdAt) Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp updated_at = 7; */ if (message.updatedAt) Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Call\n */ const Call$1 = new Call$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet Error$Type$1 = class Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Error\", [\n            {\n                no: 1,\n                name: \"code\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ErrorCode\",\n                        ErrorCode,\n                        \"ERROR_CODE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"should_retry\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.code = 0;\n        message.message = \"\";\n        message.shouldRetry = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ErrorCode code */ 1:\n                    message.code = reader.int32();\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                case /* bool should_retry */ 3:\n                    message.shouldRetry = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ErrorCode code = 1; */ if (message.code !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.code);\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.message);\n        /* bool should_retry = 3; */ if (message.shouldRetry !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.shouldRetry);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Error\n */ const Error$2 = new Error$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ClientDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ClientDetails\", [\n            {\n                no: 1,\n                name: \"sdk\",\n                kind: \"message\",\n                T: ()=>Sdk\n            },\n            {\n                no: 2,\n                name: \"os\",\n                kind: \"message\",\n                T: ()=>OS\n            },\n            {\n                no: 3,\n                name: \"browser\",\n                kind: \"message\",\n                T: ()=>Browser\n            },\n            {\n                no: 4,\n                name: \"device\",\n                kind: \"message\",\n                T: ()=>Device\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Sdk sdk */ 1:\n                    message.sdk = Sdk.internalBinaryRead(reader, reader.uint32(), options, message.sdk);\n                    break;\n                case /* stream.video.sfu.models.OS os */ 2:\n                    message.os = OS.internalBinaryRead(reader, reader.uint32(), options, message.os);\n                    break;\n                case /* stream.video.sfu.models.Browser browser */ 3:\n                    message.browser = Browser.internalBinaryRead(reader, reader.uint32(), options, message.browser);\n                    break;\n                case /* stream.video.sfu.models.Device device */ 4:\n                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Sdk sdk = 1; */ if (message.sdk) Sdk.internalBinaryWrite(message.sdk, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.OS os = 2; */ if (message.os) OS.internalBinaryWrite(message.os, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Browser browser = 3; */ if (message.browser) Browser.internalBinaryWrite(message.browser, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Device device = 4; */ if (message.device) Device.internalBinaryWrite(message.device, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ClientDetails\n */ const ClientDetails = new ClientDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Sdk$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Sdk\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.SdkType\",\n                        SdkType,\n                        \"SDK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"major\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"minor\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"patch\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = 0;\n        message.major = \"\";\n        message.minor = \"\";\n        message.patch = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.SdkType type */ 1:\n                    message.type = reader.int32();\n                    break;\n                case /* string major */ 2:\n                    message.major = reader.string();\n                    break;\n                case /* string minor */ 3:\n                    message.minor = reader.string();\n                    break;\n                case /* string patch */ 4:\n                    message.patch = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.SdkType type = 1; */ if (message.type !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.type);\n        /* string major = 2; */ if (message.major !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.major);\n        /* string minor = 3; */ if (message.minor !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.minor);\n        /* string patch = 4; */ if (message.patch !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.patch);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Sdk\n */ const Sdk = new Sdk$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass OS$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.OS\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"architecture\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        message.architecture = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                case /* string architecture */ 3:\n                    message.architecture = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.version);\n        /* string architecture = 3; */ if (message.architecture !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.architecture);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.OS\n */ const OS = new OS$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Browser$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Browser\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Browser\n */ const Browser = new Browser$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Device$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Device\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Device\n */ const Device = new Device$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrants$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallGrants\", [\n            {\n                no: 1,\n                name: \"can_publish_audio\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"can_publish_video\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"can_screenshare\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.canPublishAudio = false;\n        message.canPublishVideo = false;\n        message.canScreenshare = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool can_publish_audio */ 1:\n                    message.canPublishAudio = reader.bool();\n                    break;\n                case /* bool can_publish_video */ 2:\n                    message.canPublishVideo = reader.bool();\n                    break;\n                case /* bool can_screenshare */ 3:\n                    message.canScreenshare = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool can_publish_audio = 1; */ if (message.canPublishAudio !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.canPublishAudio);\n        /* bool can_publish_video = 2; */ if (message.canPublishVideo !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.canPublishVideo);\n        /* bool can_screenshare = 3; */ if (message.canScreenshare !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.canScreenshare);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallGrants\n */ const CallGrants = new CallGrants$Type();\nvar models = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Browser: Browser,\n    Call: Call$1,\n    CallGrants: CallGrants,\n    CallState: CallState$1,\n    ClientDetails: ClientDetails,\n    Codec: Codec,\n    get ConnectionQuality () {\n        return ConnectionQuality;\n    },\n    Device: Device,\n    Error: Error$2,\n    get ErrorCode () {\n        return ErrorCode;\n    },\n    get GoAwayReason () {\n        return GoAwayReason;\n    },\n    ICETrickle: ICETrickle$1,\n    OS: OS,\n    Participant: Participant,\n    ParticipantCount: ParticipantCount,\n    get PeerType () {\n        return PeerType;\n    },\n    Pin: Pin,\n    Sdk: Sdk,\n    get SdkType () {\n        return SdkType;\n    },\n    StreamQuality: StreamQuality,\n    TrackInfo: TrackInfo,\n    get TrackType () {\n        return TrackType;\n    },\n    get TrackUnpublishReason () {\n        return TrackUnpublishReason;\n    },\n    VideoDimension: VideoDimension,\n    VideoLayer: VideoLayer,\n    get VideoQuality () {\n        return VideoQuality;\n    }\n});\n/* eslint-disable */ // @generated by protobuf-ts 2.9.3 with parameter long_type_string,client_generic,server_none,eslint_disable\n// @generated from protobuf file \"video/sfu/signal_rpc/signal.proto\" (package \"stream.video.sfu.signal\", syntax proto3)\n// tslint:disable\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendStatsRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendStatsRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"subscriber_stats\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"publisher_stats\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"webrtc_version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"sdk\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"sdk_version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.subscriberStats = \"\";\n        message.publisherStats = \"\";\n        message.webrtcVersion = \"\";\n        message.sdk = \"\";\n        message.sdkVersion = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* string subscriber_stats */ 2:\n                    message.subscriberStats = reader.string();\n                    break;\n                case /* string publisher_stats */ 3:\n                    message.publisherStats = reader.string();\n                    break;\n                case /* string webrtc_version */ 4:\n                    message.webrtcVersion = reader.string();\n                    break;\n                case /* string sdk */ 5:\n                    message.sdk = reader.string();\n                    break;\n                case /* string sdk_version */ 6:\n                    message.sdkVersion = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* string subscriber_stats = 2; */ if (message.subscriberStats !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.subscriberStats);\n        /* string publisher_stats = 3; */ if (message.publisherStats !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.publisherStats);\n        /* string webrtc_version = 4; */ if (message.webrtcVersion !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.webrtcVersion);\n        /* string sdk = 5; */ if (message.sdk !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sdk);\n        /* string sdk_version = 6; */ if (message.sdkVersion !== \"\") writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sdkVersion);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendStatsRequest\n */ const SendStatsRequest = new SendStatsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendStatsResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendStatsResponse\", [\n            {\n                no: 1,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 1:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 1; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendStatsResponse\n */ const SendStatsResponse = new SendStatsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.PeerType peer_type */ 2:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.PeerType peer_type = 2; */ if (message.peerType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartRequest\n */ const ICERestartRequest = new ICERestartRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartResponse\", [\n            {\n                no: 1,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 1:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 1; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartResponse\n */ const ICERestartResponse = new ICERestartResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"mute_states\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackMuteState\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.muteStates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackMuteState mute_states */ 3:\n                    message.muteStates.push(TrackMuteState.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackMuteState mute_states = 3; */ for(let i = 0; i < message.muteStates.length; i++)TrackMuteState.internalBinaryWrite(message.muteStates[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesRequest\n */ const UpdateMuteStatesRequest = new UpdateMuteStatesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesResponse\n */ const UpdateMuteStatesResponse = new UpdateMuteStatesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackMuteState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackMuteState\", [\n            {\n                no: 1,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackType = 0;\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.TrackType track_type */ 1:\n                    message.trackType = reader.int32();\n                    break;\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.TrackType track_type = 1; */ if (message.trackType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.trackType);\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackMuteState\n */ const TrackMuteState = new TrackMuteState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.AudioMuteChanged\", [\n            {\n                no: 1,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 1:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 1; */ if (message.muted !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.AudioMuteChanged\n */ new AudioMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.VideoMuteChanged\", [\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.VideoMuteChanged\n */ new VideoMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsRequest\", [\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks */ 3:\n                    message.tracks.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsRequest\n */ const UpdateSubscriptionsRequest = new UpdateSubscriptionsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsResponse\n */ const UpdateSubscriptionsResponse = new UpdateSubscriptionsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackSubscriptionDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackSubscriptionDetails\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.trackType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 3:\n                    message.trackType = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension dimension */ 4:\n                    message.dimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.dimension);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType track_type = 3; */ if (message.trackType !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.trackType);\n        /* stream.video.sfu.models.VideoDimension dimension = 4; */ if (message.dimension) VideoDimension.internalBinaryWrite(message.dimension, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackSubscriptionDetails\n */ const TrackSubscriptionDetails = new TrackSubscriptionDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerRequest\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.peerType);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerRequest\n */ const SendAnswerRequest = new SendAnswerRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerResponse\n */ const SendAnswerResponse = new SendAnswerResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickleResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICETrickleResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICETrickleResponse\n */ const ICETrickleResponse = new ICETrickleResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherRequest\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo tracks */ 3:\n                    message.tracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackInfo tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackInfo.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherRequest\n */ const SetPublisherRequest = new SetPublisherRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherResponse\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.iceRestart = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* bool ice_restart */ 3:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* bool ice_restart = 3; */ if (message.iceRestart !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.iceRestart);\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherResponse\n */ const SetPublisherResponse = new SetPublisherResponse$Type();\n/**\n * @generated ServiceType for protobuf service stream.video.sfu.signal.SignalServer\n */ const SignalServer = new _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_12__.ServiceType(\"stream.video.sfu.signal.SignalServer\", [\n    {\n        name: \"SetPublisher\",\n        options: {},\n        I: SetPublisherRequest,\n        O: SetPublisherResponse\n    },\n    {\n        name: \"SendAnswer\",\n        options: {},\n        I: SendAnswerRequest,\n        O: SendAnswerResponse\n    },\n    {\n        name: \"IceTrickle\",\n        options: {},\n        I: ICETrickle$1,\n        O: ICETrickleResponse\n    },\n    {\n        name: \"UpdateSubscriptions\",\n        options: {},\n        I: UpdateSubscriptionsRequest,\n        O: UpdateSubscriptionsResponse\n    },\n    {\n        name: \"UpdateMuteStates\",\n        options: {},\n        I: UpdateMuteStatesRequest,\n        O: UpdateMuteStatesResponse\n    },\n    {\n        name: \"IceRestart\",\n        options: {},\n        I: ICERestartRequest,\n        O: ICERestartResponse\n    },\n    {\n        name: \"SendStats\",\n        options: {},\n        I: SendStatsRequest,\n        O: SendStatsResponse\n    }\n]);\n/**\n * @generated from protobuf enum stream.video.sfu.event.VideoLayerSetting.Priority\n */ var VideoLayerSetting_Priority;\n(function(VideoLayerSetting_Priority) {\n    /**\n     * @generated from protobuf enum value: PRIORITY_HIGH_UNSPECIFIED = 0;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"HIGH_UNSPECIFIED\"] = 0] = \"HIGH_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_LOW = 1;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"LOW\"] = 1] = \"LOW\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_MEDIUM = 2;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"MEDIUM\"] = 2] = \"MEDIUM\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_VERY_LOW = 3;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"VERY_LOW\"] = 3] = \"VERY_LOW\";\n})(VideoLayerSetting_Priority || (VideoLayerSetting_Priority = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuEvent$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuEvent\", [\n            {\n                no: 1,\n                name: \"subscriber_offer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>SubscriberOffer\n            },\n            {\n                no: 2,\n                name: \"publisher_answer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PublisherAnswer\n            },\n            {\n                no: 3,\n                name: \"connection_quality_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ConnectionQualityChanged\n            },\n            {\n                no: 4,\n                name: \"audio_level_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>AudioLevelChanged\n            },\n            {\n                no: 5,\n                name: \"ice_trickle\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICETrickle$1\n            },\n            {\n                no: 6,\n                name: \"change_publish_quality\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ChangePublishQuality\n            },\n            {\n                no: 10,\n                name: \"participant_joined\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantJoined\n            },\n            {\n                no: 11,\n                name: \"participant_left\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantLeft\n            },\n            {\n                no: 12,\n                name: \"dominant_speaker_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>DominantSpeakerChanged\n            },\n            {\n                no: 13,\n                name: \"join_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>JoinResponse\n            },\n            {\n                no: 14,\n                name: \"health_check_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>HealthCheckResponse\n            },\n            {\n                no: 16,\n                name: \"track_published\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackPublished\n            },\n            {\n                no: 17,\n                name: \"track_unpublished\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackUnpublished\n            },\n            {\n                no: 18,\n                name: \"error\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>Error$1\n            },\n            {\n                no: 19,\n                name: \"call_grants_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>CallGrantsUpdated\n            },\n            {\n                no: 20,\n                name: \"go_away\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>GoAway\n            },\n            {\n                no: 21,\n                name: \"ice_restart\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICERestart\n            },\n            {\n                no: 22,\n                name: \"pins_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PinsChanged\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.eventPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.SubscriberOffer subscriber_offer */ 1:\n                    message.eventPayload = {\n                        oneofKind: \"subscriberOffer\",\n                        subscriberOffer: SubscriberOffer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.subscriberOffer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PublisherAnswer publisher_answer */ 2:\n                    message.eventPayload = {\n                        oneofKind: \"publisherAnswer\",\n                        publisherAnswer: PublisherAnswer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.publisherAnswer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed */ 3:\n                    message.eventPayload = {\n                        oneofKind: \"connectionQualityChanged\",\n                        connectionQualityChanged: ConnectionQualityChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.connectionQualityChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.AudioLevelChanged audio_level_changed */ 4:\n                    message.eventPayload = {\n                        oneofKind: \"audioLevelChanged\",\n                        audioLevelChanged: AudioLevelChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.audioLevelChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.models.ICETrickle ice_trickle */ 5:\n                    message.eventPayload = {\n                        oneofKind: \"iceTrickle\",\n                        iceTrickle: ICETrickle$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceTrickle)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ChangePublishQuality change_publish_quality */ 6:\n                    message.eventPayload = {\n                        oneofKind: \"changePublishQuality\",\n                        changePublishQuality: ChangePublishQuality.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.changePublishQuality)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantJoined participant_joined */ 10:\n                    message.eventPayload = {\n                        oneofKind: \"participantJoined\",\n                        participantJoined: ParticipantJoined.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantJoined)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantLeft participant_left */ 11:\n                    message.eventPayload = {\n                        oneofKind: \"participantLeft\",\n                        participantLeft: ParticipantLeft.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantLeft)\n                    };\n                    break;\n                case /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed */ 12:\n                    message.eventPayload = {\n                        oneofKind: \"dominantSpeakerChanged\",\n                        dominantSpeakerChanged: DominantSpeakerChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.dominantSpeakerChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.JoinResponse join_response */ 13:\n                    message.eventPayload = {\n                        oneofKind: \"joinResponse\",\n                        joinResponse: JoinResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.joinResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckResponse health_check_response */ 14:\n                    message.eventPayload = {\n                        oneofKind: \"healthCheckResponse\",\n                        healthCheckResponse: HealthCheckResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.healthCheckResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackPublished track_published */ 16:\n                    message.eventPayload = {\n                        oneofKind: \"trackPublished\",\n                        trackPublished: TrackPublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackPublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackUnpublished track_unpublished */ 17:\n                    message.eventPayload = {\n                        oneofKind: \"trackUnpublished\",\n                        trackUnpublished: TrackUnpublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackUnpublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.Error error */ 18:\n                    message.eventPayload = {\n                        oneofKind: \"error\",\n                        error: Error$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.error)\n                    };\n                    break;\n                case /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated */ 19:\n                    message.eventPayload = {\n                        oneofKind: \"callGrantsUpdated\",\n                        callGrantsUpdated: CallGrantsUpdated.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.callGrantsUpdated)\n                    };\n                    break;\n                case /* stream.video.sfu.event.GoAway go_away */ 20:\n                    message.eventPayload = {\n                        oneofKind: \"goAway\",\n                        goAway: GoAway.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.goAway)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ICERestart ice_restart */ 21:\n                    message.eventPayload = {\n                        oneofKind: \"iceRestart\",\n                        iceRestart: ICERestart.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceRestart)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PinsChanged pins_updated */ 22:\n                    message.eventPayload = {\n                        oneofKind: \"pinsUpdated\",\n                        pinsUpdated: PinsChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.pinsUpdated)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.SubscriberOffer subscriber_offer = 1; */ if (message.eventPayload.oneofKind === \"subscriberOffer\") SubscriberOffer.internalBinaryWrite(message.eventPayload.subscriberOffer, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PublisherAnswer publisher_answer = 2; */ if (message.eventPayload.oneofKind === \"publisherAnswer\") PublisherAnswer.internalBinaryWrite(message.eventPayload.publisherAnswer, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed = 3; */ if (message.eventPayload.oneofKind === \"connectionQualityChanged\") ConnectionQualityChanged.internalBinaryWrite(message.eventPayload.connectionQualityChanged, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.AudioLevelChanged audio_level_changed = 4; */ if (message.eventPayload.oneofKind === \"audioLevelChanged\") AudioLevelChanged.internalBinaryWrite(message.eventPayload.audioLevelChanged, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ICETrickle ice_trickle = 5; */ if (message.eventPayload.oneofKind === \"iceTrickle\") ICETrickle$1.internalBinaryWrite(message.eventPayload.iceTrickle, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ChangePublishQuality change_publish_quality = 6; */ if (message.eventPayload.oneofKind === \"changePublishQuality\") ChangePublishQuality.internalBinaryWrite(message.eventPayload.changePublishQuality, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantJoined participant_joined = 10; */ if (message.eventPayload.oneofKind === \"participantJoined\") ParticipantJoined.internalBinaryWrite(message.eventPayload.participantJoined, writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantLeft participant_left = 11; */ if (message.eventPayload.oneofKind === \"participantLeft\") ParticipantLeft.internalBinaryWrite(message.eventPayload.participantLeft, writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed = 12; */ if (message.eventPayload.oneofKind === \"dominantSpeakerChanged\") DominantSpeakerChanged.internalBinaryWrite(message.eventPayload.dominantSpeakerChanged, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.JoinResponse join_response = 13; */ if (message.eventPayload.oneofKind === \"joinResponse\") JoinResponse.internalBinaryWrite(message.eventPayload.joinResponse, writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckResponse health_check_response = 14; */ if (message.eventPayload.oneofKind === \"healthCheckResponse\") HealthCheckResponse.internalBinaryWrite(message.eventPayload.healthCheckResponse, writer.tag(14, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackPublished track_published = 16; */ if (message.eventPayload.oneofKind === \"trackPublished\") TrackPublished.internalBinaryWrite(message.eventPayload.trackPublished, writer.tag(16, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackUnpublished track_unpublished = 17; */ if (message.eventPayload.oneofKind === \"trackUnpublished\") TrackUnpublished.internalBinaryWrite(message.eventPayload.trackUnpublished, writer.tag(17, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Error error = 18; */ if (message.eventPayload.oneofKind === \"error\") Error$1.internalBinaryWrite(message.eventPayload.error, writer.tag(18, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated = 19; */ if (message.eventPayload.oneofKind === \"callGrantsUpdated\") CallGrantsUpdated.internalBinaryWrite(message.eventPayload.callGrantsUpdated, writer.tag(19, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.GoAway go_away = 20; */ if (message.eventPayload.oneofKind === \"goAway\") GoAway.internalBinaryWrite(message.eventPayload.goAway, writer.tag(20, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ICERestart ice_restart = 21; */ if (message.eventPayload.oneofKind === \"iceRestart\") ICERestart.internalBinaryWrite(message.eventPayload.iceRestart, writer.tag(21, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PinsChanged pins_updated = 22; */ if (message.eventPayload.oneofKind === \"pinsUpdated\") PinsChanged.internalBinaryWrite(message.eventPayload.pinsUpdated, writer.tag(22, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuEvent\n */ const SfuEvent = new SfuEvent$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PinsChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PinsChanged\", [\n            {\n                no: 1,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Pin pins */ 1:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Pin pins = 1; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PinsChanged\n */ const PinsChanged = new PinsChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Error\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Error\n */ const Error$1 = new Error$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.iceCandidate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICETrickle\n */ const ICETrickle = new ICETrickle$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestart$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICERestart\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICERestart\n */ const ICERestart = new ICERestart$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuRequest\", [\n            {\n                no: 1,\n                name: \"join_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>JoinRequest\n            },\n            {\n                no: 2,\n                name: \"health_check_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>HealthCheckRequest\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.requestPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.JoinRequest join_request */ 1:\n                    message.requestPayload = {\n                        oneofKind: \"joinRequest\",\n                        joinRequest: JoinRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.joinRequest)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckRequest health_check_request */ 2:\n                    message.requestPayload = {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: HealthCheckRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.healthCheckRequest)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.JoinRequest join_request = 1; */ if (message.requestPayload.oneofKind === \"joinRequest\") JoinRequest.internalBinaryWrite(message.requestPayload.joinRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckRequest health_check_request = 2; */ if (message.requestPayload.oneofKind === \"healthCheckRequest\") HealthCheckRequest.internalBinaryWrite(message.requestPayload.healthCheckRequest, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuRequest\n */ const SfuRequest = new SfuRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckRequest\", []);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckRequest\n */ const HealthCheckRequest = new HealthCheckRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckResponse\", [\n            {\n                no: 1,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 1:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ParticipantCount participant_count = 1; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckResponse\n */ const HealthCheckResponse = new HealthCheckResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackPublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackPublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 4:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.Participant participant = 4; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackPublished\n */ const TrackPublished = new TrackPublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackUnpublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackUnpublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"cause\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackUnpublishReason\",\n                        TrackUnpublishReason,\n                        \"TRACK_UNPUBLISH_REASON_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        message.cause = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.TrackUnpublishReason cause */ 4:\n                    message.cause = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 5:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.TrackUnpublishReason cause = 4; */ if (message.cause !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.cause);\n        /* stream.video.sfu.models.Participant participant = 5; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackUnpublished\n */ const TrackUnpublished = new TrackUnpublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinRequest\", [\n            {\n                no: 1,\n                name: \"token\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"subscriber_sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"client_details\",\n                kind: \"message\",\n                T: ()=>ClientDetails\n            },\n            {\n                no: 5,\n                name: \"migration\",\n                kind: \"message\",\n                T: ()=>Migration\n            },\n            {\n                no: 6,\n                name: \"fast_reconnect\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.token = \"\";\n        message.sessionId = \"\";\n        message.subscriberSdp = \"\";\n        message.fastReconnect = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string token */ 1:\n                    message.token = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* string subscriber_sdp */ 3:\n                    message.subscriberSdp = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ClientDetails client_details */ 4:\n                    message.clientDetails = ClientDetails.internalBinaryRead(reader, reader.uint32(), options, message.clientDetails);\n                    break;\n                case /* stream.video.sfu.event.Migration migration */ 5:\n                    message.migration = Migration.internalBinaryRead(reader, reader.uint32(), options, message.migration);\n                    break;\n                case /* bool fast_reconnect */ 6:\n                    message.fastReconnect = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string token = 1; */ if (message.token !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.token);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* string subscriber_sdp = 3; */ if (message.subscriberSdp !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.subscriberSdp);\n        /* stream.video.sfu.models.ClientDetails client_details = 4; */ if (message.clientDetails) ClientDetails.internalBinaryWrite(message.clientDetails, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Migration migration = 5; */ if (message.migration) Migration.internalBinaryWrite(message.migration, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* bool fast_reconnect = 6; */ if (message.fastReconnect !== false) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.fastReconnect);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinRequest\n */ const JoinRequest = new JoinRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Migration$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Migration\", [\n            {\n                no: 1,\n                name: \"from_sfu_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"announced_tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            },\n            {\n                no: 3,\n                name: \"subscriptions\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fromSfuId = \"\";\n        message.announcedTracks = [];\n        message.subscriptions = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string from_sfu_id */ 1:\n                    message.fromSfuId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo announced_tracks */ 2:\n                    message.announcedTracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions */ 3:\n                    message.subscriptions.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string from_sfu_id = 1; */ if (message.fromSfuId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.fromSfuId);\n        /* repeated stream.video.sfu.models.TrackInfo announced_tracks = 2; */ for(let i = 0; i < message.announcedTracks.length; i++)TrackInfo.internalBinaryWrite(message.announcedTracks[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions = 3; */ for(let i = 0; i < message.subscriptions.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.subscriptions[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Migration\n */ const Migration = new Migration$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinResponse\", [\n            {\n                no: 1,\n                name: \"call_state\",\n                kind: \"message\",\n                T: ()=>CallState$1\n            },\n            {\n                no: 2,\n                name: \"reconnected\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reconnected = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallState call_state */ 1:\n                    message.callState = CallState$1.internalBinaryRead(reader, reader.uint32(), options, message.callState);\n                    break;\n                case /* bool reconnected */ 2:\n                    message.reconnected = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallState call_state = 1; */ if (message.callState) CallState$1.internalBinaryWrite(message.callState, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* bool reconnected = 2; */ if (message.reconnected !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.reconnected);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinResponse\n */ const JoinResponse = new JoinResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantJoined$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantJoined\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantJoined\n */ const ParticipantJoined = new ParticipantJoined$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantLeft$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantLeft\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantLeft\n */ const ParticipantLeft = new ParticipantLeft$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscriberOffer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SubscriberOffer\", [\n            {\n                no: 1,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.iceRestart = false;\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool ice_restart */ 1:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool ice_restart = 1; */ if (message.iceRestart !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.iceRestart);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SubscriberOffer\n */ const SubscriberOffer = new SubscriberOffer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublisherAnswer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PublisherAnswer\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PublisherAnswer\n */ const PublisherAnswer = new PublisherAnswer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityChanged\", [\n            {\n                no: 1,\n                name: \"connection_quality_updates\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>ConnectionQualityInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.connectionQualityUpdates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates */ 1:\n                    message.connectionQualityUpdates.push(ConnectionQualityInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates = 1; */ for(let i = 0; i < message.connectionQualityUpdates.length; i++)ConnectionQualityInfo.internalBinaryWrite(message.connectionQualityUpdates[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityChanged\n */ const ConnectionQualityChanged = new ConnectionQualityChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityInfo\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.connectionQuality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 3:\n                    message.connectionQuality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 3; */ if (message.connectionQuality !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.connectionQuality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityInfo\n */ const ConnectionQualityInfo = new ConnectionQualityInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DominantSpeakerChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.DominantSpeakerChanged\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.DominantSpeakerChanged\n */ const DominantSpeakerChanged = new DominantSpeakerChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevel$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevel\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 4,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.level = 0;\n        message.isSpeaking = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* float level */ 3:\n                    message.level = reader.float();\n                    break;\n                case /* bool is_speaking */ 4:\n                    message.isSpeaking = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.sessionId);\n        /* float level = 3; */ if (message.level !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Bit32).float(message.level);\n        /* bool is_speaking = 4; */ if (message.isSpeaking !== false) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.isSpeaking);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevel\n */ const AudioLevel = new AudioLevel$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevelChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevelChanged\", [\n            {\n                no: 1,\n                name: \"audio_levels\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioLevel\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioLevels = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioLevel audio_levels */ 1:\n                    message.audioLevels.push(AudioLevel.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioLevel audio_levels = 1; */ for(let i = 0; i < message.audioLevels.length; i++)AudioLevel.internalBinaryWrite(message.audioLevels[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevelChanged\n */ const AudioLevelChanged = new AudioLevelChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioMediaRequest\", [\n            {\n                no: 1,\n                name: \"channel_count\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.channelCount = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 channel_count */ 1:\n                    message.channelCount = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 channel_count = 1; */ if (message.channelCount !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.channelCount);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioMediaRequest\n */ const AudioMediaRequest = new AudioMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>AudioMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.AudioMediaRequest media_request */ 1:\n                    message.mediaRequest = AudioMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.AudioMediaRequest media_request = 1; */ if (message.mediaRequest) AudioMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioSender\n */ const AudioSender = new AudioSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoMediaRequest\", [\n            {\n                no: 1,\n                name: \"ideal_height\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 2,\n                name: \"ideal_width\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 3,\n                name: \"ideal_frame_rate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.idealHeight = 0;\n        message.idealWidth = 0;\n        message.idealFrameRate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 ideal_height */ 1:\n                    message.idealHeight = reader.int32();\n                    break;\n                case /* int32 ideal_width */ 2:\n                    message.idealWidth = reader.int32();\n                    break;\n                case /* int32 ideal_frame_rate */ 3:\n                    message.idealFrameRate = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 ideal_height = 1; */ if (message.idealHeight !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.idealHeight);\n        /* int32 ideal_width = 2; */ if (message.idealWidth !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.idealWidth);\n        /* int32 ideal_frame_rate = 3; */ if (message.idealFrameRate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.idealFrameRate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoMediaRequest\n */ const VideoMediaRequest = new VideoMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayerSetting$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoLayerSetting\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"active\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"max_bitrate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 4,\n                name: \"scale_resolution_down_by\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 5,\n                name: \"priority\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.event.VideoLayerSetting.Priority\",\n                        VideoLayerSetting_Priority,\n                        \"PRIORITY_\"\n                    ]\n            },\n            {\n                no: 6,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 7,\n                name: \"max_framerate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.active = false;\n        message.maxBitrate = 0;\n        message.scaleResolutionDownBy = 0;\n        message.priority = 0;\n        message.maxFramerate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* bool active */ 2:\n                    message.active = reader.bool();\n                    break;\n                case /* int32 max_bitrate */ 3:\n                    message.maxBitrate = reader.int32();\n                    break;\n                case /* float scale_resolution_down_by */ 4:\n                    message.scaleResolutionDownBy = reader.float();\n                    break;\n                case /* stream.video.sfu.event.VideoLayerSetting.Priority priority */ 5:\n                    message.priority = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 6:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* uint32 max_framerate */ 7:\n                    message.maxFramerate = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.name);\n        /* bool active = 2; */ if (message.active !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).bool(message.active);\n        /* int32 max_bitrate = 3; */ if (message.maxBitrate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.maxBitrate);\n        /* float scale_resolution_down_by = 4; */ if (message.scaleResolutionDownBy !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Bit32).float(message.scaleResolutionDownBy);\n        /* stream.video.sfu.event.VideoLayerSetting.Priority priority = 5; */ if (message.priority !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.priority);\n        /* stream.video.sfu.models.Codec codec = 6; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 max_framerate = 7; */ if (message.maxFramerate !== 0) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).uint32(message.maxFramerate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoLayerSetting\n */ const VideoLayerSetting = new VideoLayerSetting$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>VideoMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 3,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayerSetting\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.layers = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.VideoMediaRequest media_request */ 1:\n                    message.mediaRequest = VideoMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* repeated stream.video.sfu.event.VideoLayerSetting layers */ 3:\n                    message.layers.push(VideoLayerSetting.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.VideoMediaRequest media_request = 1; */ if (message.mediaRequest) VideoMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoLayerSetting layers = 3; */ for(let i = 0; i < message.layers.length; i++)VideoLayerSetting.internalBinaryWrite(message.layers[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoSender\n */ const VideoSender = new VideoSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ChangePublishQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ChangePublishQuality\", [\n            {\n                no: 1,\n                name: \"audio_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioSender\n            },\n            {\n                no: 2,\n                name: \"video_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoSender\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioSenders = [];\n        message.videoSenders = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioSender audio_senders */ 1:\n                    message.audioSenders.push(AudioSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.event.VideoSender video_senders */ 2:\n                    message.videoSenders.push(VideoSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioSender audio_senders = 1; */ for(let i = 0; i < message.audioSenders.length; i++)AudioSender.internalBinaryWrite(message.audioSenders[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoSender video_senders = 2; */ for(let i = 0; i < message.videoSenders.length; i++)VideoSender.internalBinaryWrite(message.videoSenders[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ChangePublishQuality\n */ const ChangePublishQuality = new ChangePublishQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrantsUpdated$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.CallGrantsUpdated\", [\n            {\n                no: 1,\n                name: \"current_grants\",\n                kind: \"message\",\n                T: ()=>CallGrants\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.message = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallGrants current_grants */ 1:\n                    message.currentGrants = CallGrants.internalBinaryRead(reader, reader.uint32(), options, message.currentGrants);\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallGrants current_grants = 1; */ if (message.currentGrants) CallGrants.internalBinaryWrite(message.currentGrants, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).fork(), options).join();\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.LengthDelimited).string(message.message);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.CallGrantsUpdated\n */ const CallGrantsUpdated = new CallGrantsUpdated$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GoAway$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_7__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.GoAway\", [\n            {\n                no: 1,\n                name: \"reason\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.GoAwayReason\",\n                        GoAwayReason,\n                        \"GO_AWAY_REASON_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reason = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.GoAwayReason reason */ 1:\n                    message.reason = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.GoAwayReason reason = 1; */ if (message.reason !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.WireType.Varint).int32(message.reason);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.GoAway\n */ const GoAway = new GoAway$Type();\nvar events = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AudioLevel: AudioLevel,\n    AudioLevelChanged: AudioLevelChanged,\n    AudioMediaRequest: AudioMediaRequest,\n    AudioSender: AudioSender,\n    CallGrantsUpdated: CallGrantsUpdated,\n    ChangePublishQuality: ChangePublishQuality,\n    ConnectionQualityChanged: ConnectionQualityChanged,\n    ConnectionQualityInfo: ConnectionQualityInfo,\n    DominantSpeakerChanged: DominantSpeakerChanged,\n    Error: Error$1,\n    GoAway: GoAway,\n    HealthCheckRequest: HealthCheckRequest,\n    HealthCheckResponse: HealthCheckResponse,\n    ICERestart: ICERestart,\n    ICETrickle: ICETrickle,\n    JoinRequest: JoinRequest,\n    JoinResponse: JoinResponse,\n    Migration: Migration,\n    ParticipantJoined: ParticipantJoined,\n    ParticipantLeft: ParticipantLeft,\n    PinsChanged: PinsChanged,\n    PublisherAnswer: PublisherAnswer,\n    SfuEvent: SfuEvent,\n    SfuRequest: SfuRequest,\n    SubscriberOffer: SubscriberOffer,\n    TrackPublished: TrackPublished,\n    TrackUnpublished: TrackUnpublished,\n    VideoLayerSetting: VideoLayerSetting,\n    get VideoLayerSetting_Priority () {\n        return VideoLayerSetting_Priority;\n    },\n    VideoMediaRequest: VideoMediaRequest,\n    VideoSender: VideoSender\n});\nvar VisibilityState;\n(function(VisibilityState) {\n    VisibilityState[\"UNKNOWN\"] = \"UNKNOWN\";\n    VisibilityState[\"VISIBLE\"] = \"VISIBLE\";\n    VisibilityState[\"INVISIBLE\"] = \"INVISIBLE\";\n})(VisibilityState || (VisibilityState = {}));\nvar DebounceType;\n(function(DebounceType) {\n    DebounceType[DebounceType[\"IMMEDIATE\"] = 20] = \"IMMEDIATE\";\n    DebounceType[DebounceType[\"FAST\"] = 100] = \"FAST\";\n    DebounceType[DebounceType[\"MEDIUM\"] = 600] = \"MEDIUM\";\n    DebounceType[DebounceType[\"SLOW\"] = 1200] = \"SLOW\";\n})(DebounceType || (DebounceType = {}));\n/**\n * @generated from protobuf service stream.video.sfu.signal.SignalServer\n */ class SignalServerClient {\n    constructor(_transport){\n        this._transport = _transport;\n        this.typeName = SignalServer.typeName;\n        this.methods = SignalServer.methods;\n        this.options = SignalServer.options;\n    }\n    /**\n     * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V\n     *\n     * @generated from protobuf rpc: SetPublisher(stream.video.sfu.signal.SetPublisherRequest) returns (stream.video.sfu.signal.SetPublisherResponse);\n     */ setPublisher(input, options) {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * answer is sent by the client to the SFU after receiving a subscriber_offer.\n     *\n     * @generated from protobuf rpc: SendAnswer(stream.video.sfu.signal.SendAnswerRequest) returns (stream.video.sfu.signal.SendAnswerResponse);\n     */ sendAnswer(input, options) {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * SendICECandidate sends an ICE candidate to the client\n     *\n     * @generated from protobuf rpc: IceTrickle(stream.video.sfu.models.ICETrickle) returns (stream.video.sfu.signal.ICETrickleResponse);\n     */ iceTrickle(input, options) {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * UpdateSubscribers is used to notify the SFU about the list of video subscriptions\n     * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user\n     *\n     * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.signal.UpdateSubscriptionsRequest) returns (stream.video.sfu.signal.UpdateSubscriptionsResponse);\n     */ updateSubscriptions(input, options) {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: UpdateMuteStates(stream.video.sfu.signal.UpdateMuteStatesRequest) returns (stream.video.sfu.signal.UpdateMuteStatesResponse);\n     */ updateMuteStates(input, options) {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: IceRestart(stream.video.sfu.signal.ICERestartRequest) returns (stream.video.sfu.signal.ICERestartResponse);\n     */ iceRestart(input, options) {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: SendStats(stream.video.sfu.signal.SendStatsRequest) returns (stream.video.sfu.signal.SendStatsResponse);\n     */ sendStats(input, options) {\n        const method = this.methods[6], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_13__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n}\nconst defaultOptions = {\n    baseUrl: \"\",\n    sendJson: true,\n    timeout: 5 * 1000,\n    jsonOptions: {\n        ignoreUnknownFields: true\n    }\n};\nconst withHeaders = (headers)=>{\n    return {\n        interceptUnary (next, method, input, options) {\n            options.meta = {\n                ...options.meta,\n                ...headers\n            };\n            return next(method, input, options);\n        }\n    };\n};\n/**\n * Creates new SignalServerClient instance.\n *\n * @param options the twirp options.\n */ const createSignalClient = (options)=>{\n    const transport = new _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_14__.TwirpFetchTransport({\n        ...defaultOptions,\n        ...options\n    });\n    return new SignalServerClient(transport);\n};\n/**\n * Checks whether we are using React Native\n */ const isReactNative = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.product?.toLowerCase() === \"reactnative\";\n};\n// log levels, sorted by verbosity\nconst logLevels = Object.freeze({\n    trace: 0,\n    debug: 1,\n    info: 2,\n    warn: 3,\n    error: 4\n});\nlet logger$4;\nlet level = \"info\";\nconst logToConsole = (logLevel, message, ...args)=>{\n    let logMethod;\n    switch(logLevel){\n        case \"error\":\n            if (isReactNative()) {\n                message = `ERROR: ${message}`;\n                logMethod = console.info;\n                break;\n            }\n            logMethod = console.error;\n            break;\n        case \"warn\":\n            if (isReactNative()) {\n                message = `WARN: ${message}`;\n                logMethod = console.info;\n                break;\n            }\n            logMethod = console.warn;\n            break;\n        case \"info\":\n            logMethod = console.info;\n            break;\n        case \"trace\":\n            logMethod = console.trace;\n            break;\n        default:\n            logMethod = console.log;\n            break;\n    }\n    logMethod(message, ...args);\n};\nconst setLogger = (l, lvl)=>{\n    logger$4 = l;\n    if (lvl) {\n        setLogLevel(lvl);\n    }\n};\nconst setLogLevel = (l)=>{\n    level = l;\n};\nconst getLogger = (withTags)=>{\n    const loggerMethod = logger$4 || logToConsole;\n    const tags = (withTags || []).join(\":\");\n    const result = (logLevel, message, ...args)=>{\n        if (logLevels[logLevel] >= logLevels[level]) {\n            loggerMethod(logLevel, `[${tags}]: ${message}`, ...args);\n        }\n    };\n    return result;\n};\nconst getPreferredCodecs = (kind, preferredCodec, codecToRemove)=>{\n    const logger = getLogger([\n        \"codecs\"\n    ]);\n    if (!(\"getCapabilities\" in RTCRtpReceiver)) {\n        logger(\"warn\", \"RTCRtpReceiver.getCapabilities is not supported\");\n        return;\n    }\n    const cap = RTCRtpReceiver.getCapabilities(kind);\n    if (!cap) return;\n    const matched = [];\n    const partialMatched = [];\n    const unmatched = [];\n    cap.codecs.forEach((c)=>{\n        const codec = c.mimeType.toLowerCase();\n        logger(\"debug\", `Found supported codec: ${codec}`);\n        const shouldRemoveCodec = codecToRemove && codec === `${kind}/${codecToRemove.toLowerCase()}`;\n        if (shouldRemoveCodec) return;\n        const matchesCodec = codec === `${kind}/${preferredCodec.toLowerCase()}`;\n        if (!matchesCodec) {\n            unmatched.push(c);\n            return;\n        }\n        // for h264 codecs that have sdpFmtpLine available, use only if the\n        // profile-level-id is 42e01f for cross-browser compatibility\n        if (codec === \"h264\") {\n            if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n                matched.push(c);\n            } else {\n                partialMatched.push(c);\n            }\n            return;\n        }\n        matched.push(c);\n    });\n    return [\n        ...matched,\n        ...partialMatched,\n        ...unmatched\n    ];\n};\nconst getGenericSdp = async (direction)=>{\n    const tempPc = new RTCPeerConnection();\n    tempPc.addTransceiver(\"video\", {\n        direction\n    });\n    tempPc.addTransceiver(\"audio\", {\n        direction\n    });\n    const offer = await tempPc.createOffer();\n    let sdp = offer.sdp ?? \"\";\n    tempPc.getTransceivers().forEach((t)=>{\n        t.stop();\n    });\n    tempPc.close();\n    return sdp;\n};\nconst sfuEventKinds = {\n    subscriberOffer: undefined,\n    publisherAnswer: undefined,\n    connectionQualityChanged: undefined,\n    audioLevelChanged: undefined,\n    iceTrickle: undefined,\n    changePublishQuality: undefined,\n    participantJoined: undefined,\n    participantLeft: undefined,\n    dominantSpeakerChanged: undefined,\n    joinResponse: undefined,\n    healthCheckResponse: undefined,\n    trackPublished: undefined,\n    trackUnpublished: undefined,\n    error: undefined,\n    callGrantsUpdated: undefined,\n    goAway: undefined,\n    iceRestart: undefined,\n    pinsUpdated: undefined\n};\nconst isSfuEvent = (eventName)=>{\n    return Object.prototype.hasOwnProperty.call(sfuEventKinds, eventName);\n};\nclass Dispatcher {\n    constructor(){\n        this.logger = getLogger([\n            \"Dispatcher\"\n        ]);\n        this.subscribers = {};\n        this.dispatch = (message)=>{\n            const eventKind = message.eventPayload.oneofKind;\n            if (!eventKind) return;\n            const payload = message.eventPayload[eventKind];\n            this.logger(\"debug\", `Dispatching ${eventKind}`, payload);\n            const listeners = this.subscribers[eventKind];\n            if (!listeners) return;\n            for (const fn of listeners){\n                try {\n                    fn(payload);\n                } catch (e) {\n                    this.logger(\"warn\", \"Listener failed with error\", e);\n                }\n            }\n        };\n        this.on = (eventName, fn)=>{\n            var _a;\n            ((_a = this.subscribers)[eventName] ?? (_a[eventName] = [])).push(fn);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        this.off = (eventName, fn)=>{\n            this.subscribers[eventName] = (this.subscribers[eventName] || []).filter((f)=>f !== fn);\n        };\n        this.offAll = (eventName)=>{\n            if (eventName) {\n                this.subscribers[eventName] = [];\n            } else {\n                this.subscribers = {};\n            }\n        };\n    }\n}\n/**\n * A buffer for ICE Candidates. Used for ICE Trickle:\n * - https://bloggeek.me/webrtcglossary/trickle-ice/\n */ class IceTrickleBuffer {\n    constructor(){\n        this.subscriberCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_15__.ReplaySubject();\n        this.publisherCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_15__.ReplaySubject();\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        this.push = (iceTrickle)=>{\n            if (iceTrickle.peerType === PeerType.SUBSCRIBER) {\n                this.subscriberCandidates.next(iceTrickle);\n            } else if (iceTrickle.peerType === PeerType.PUBLISHER_UNSPECIFIED) {\n                this.publisherCandidates.next(iceTrickle);\n            } else {\n                this.logger(\"warn\", `ICETrickle, Unknown peer type`, iceTrickle);\n            }\n        };\n    }\n}\nfunction getIceCandidate(candidate) {\n    if (!candidate.usernameFragment) {\n        // react-native-webrtc doesn't include usernameFragment in the candidate\n        const splittedCandidate = candidate.candidate.split(\" \");\n        const ufragIndex = splittedCandidate.findIndex((s)=>s === \"ufrag\") + 1;\n        const usernameFragment = splittedCandidate[ufragIndex];\n        return JSON.stringify({\n            ...candidate,\n            usernameFragment\n        });\n    } else {\n        return JSON.stringify(candidate.toJSON());\n    }\n}\nlet sdkInfo;\nlet osInfo;\nlet deviceInfo;\nlet webRtcInfo;\nconst setSdkInfo = (info)=>{\n    sdkInfo = info;\n};\nconst getSdkInfo = ()=>{\n    return sdkInfo;\n};\nconst setOSInfo = (info)=>{\n    osInfo = info;\n};\nconst getOSInfo = ()=>{\n    return osInfo;\n};\nconst setDeviceInfo = (info)=>{\n    deviceInfo = info;\n};\nconst getDeviceInfo = ()=>{\n    return deviceInfo;\n};\nconst getWebRTCInfo = ()=>{\n    return webRtcInfo;\n};\nconst setWebRTCInfo = (info)=>{\n    webRtcInfo = info;\n};\nconst getClientDetails = ()=>{\n    if (isReactNative()) {\n        // Since RN doesn't support web, sharing browser info is not required\n        return {\n            sdk: getSdkInfo(),\n            os: getOSInfo(),\n            device: getDeviceInfo()\n        };\n    }\n    const userAgent = new ua_parser_js__WEBPACK_IMPORTED_MODULE_3__.UAParser(navigator.userAgent);\n    const { browser, os, device, cpu } = userAgent.getResult();\n    return {\n        sdk: getSdkInfo(),\n        browser: {\n            name: browser.name || navigator.userAgent,\n            version: browser.version || \"\"\n        },\n        os: {\n            name: os.name || \"\",\n            version: os.version || \"\",\n            architecture: cpu.architecture || \"\"\n        },\n        device: {\n            name: [\n                device.vendor,\n                device.model,\n                device.type\n            ].filter(Boolean).join(\" \"),\n            version: \"\"\n        }\n    };\n};\nconst DEFAULT_BITRATE = 1250000;\nconst defaultTargetResolution = {\n    bitrate: DEFAULT_BITRATE,\n    width: 1280,\n    height: 720\n};\n/**\n * Determines the most optimal video layers for simulcasting\n * for the given track.\n *\n * @param videoTrack the video track to find optimal layers for.\n * @param targetResolution the expected target resolution.\n */ const findOptimalVideoLayers = (videoTrack, targetResolution = defaultTargetResolution)=>{\n    const optimalVideoLayers = [];\n    const settings = videoTrack.getSettings();\n    const { width: w = 0, height: h = 0 } = settings;\n    const isRNIos = isReactNative() && getOSInfo()?.name.toLowerCase() === \"ios\";\n    const maxBitrate = getComputedMaxBitrate(targetResolution, w, h);\n    let downscaleFactor = 1;\n    [\n        \"f\",\n        \"h\",\n        \"q\"\n    ].forEach((rid)=>{\n        // Reversing the order [f, h, q] to [q, h, f] as Chrome uses encoding index\n        // when deciding which layer to disable when CPU or bandwidth is constrained.\n        // Encodings should be ordered in increasing spatial resolution order.\n        optimalVideoLayers.unshift({\n            active: true,\n            rid,\n            width: Math.round(w / downscaleFactor),\n            height: Math.round(h / downscaleFactor),\n            maxBitrate: Math.round(maxBitrate / downscaleFactor),\n            scaleResolutionDownBy: downscaleFactor,\n            // Simulcast on iOS React-Native requires all encodings to share the same framerate\n            maxFramerate: {\n                f: 30,\n                h: isRNIos ? 30 : 25,\n                q: isRNIos ? 30 : 20\n            }[rid]\n        });\n        downscaleFactor *= 2;\n    });\n    // for simplicity, we start with all layers enabled, then this function\n    // will clear/reassign the layers that are not needed\n    return withSimulcastConstraints(settings, optimalVideoLayers);\n};\n/**\n * Computes the maximum bitrate for a given resolution.\n * If the current resolution is lower than the target resolution,\n * we want to proportionally reduce the target bitrate.\n * If the current resolution is higher than the target resolution,\n * we want to use the target bitrate.\n *\n * @param targetResolution the target resolution.\n * @param currentWidth the current width of the track.\n * @param currentHeight the current height of the track.\n */ const getComputedMaxBitrate = (targetResolution, currentWidth, currentHeight)=>{\n    // if the current resolution is lower than the target resolution,\n    // we want to proportionally reduce the target bitrate\n    const { width: targetWidth, height: targetHeight } = targetResolution;\n    if (currentWidth < targetWidth || currentHeight < targetHeight) {\n        const currentPixels = currentWidth * currentHeight;\n        const targetPixels = targetWidth * targetHeight;\n        const reductionFactor = currentPixels / targetPixels;\n        return Math.round(targetResolution.bitrate * reductionFactor);\n    }\n    return targetResolution.bitrate;\n};\n/**\n * Browsers have different simulcast constraints for different video resolutions.\n *\n * This function modifies the provided list of video layers according to the\n * current implementation of simulcast constraints in the Chromium based browsers.\n *\n * https://chromium.googlesource.com/external/webrtc/+/refs/heads/main/media/engine/simulcast.cc#90\n */ const withSimulcastConstraints = (settings, optimalVideoLayers)=>{\n    let layers;\n    const size = Math.max(settings.width || 0, settings.height || 0);\n    if (size <= 320) {\n        // provide only one layer 320x240 (q), the one with the highest quality\n        layers = optimalVideoLayers.filter((layer)=>layer.rid === \"f\");\n    } else if (size <= 640) {\n        // provide two layers, 160x120 (q) and 640x480 (h)\n        layers = optimalVideoLayers.filter((layer)=>layer.rid !== \"h\");\n    } else {\n        // provide three layers for sizes > 640x480\n        layers = optimalVideoLayers;\n    }\n    const ridMapping = [\n        \"q\",\n        \"h\",\n        \"f\"\n    ];\n    return layers.map((layer, index)=>({\n            ...layer,\n            rid: ridMapping[index]\n        }));\n};\nconst findOptimalScreenSharingLayers = (videoTrack, preferences)=>{\n    const settings = videoTrack.getSettings();\n    return [\n        {\n            active: true,\n            rid: \"q\",\n            width: settings.width || 0,\n            height: settings.height || 0,\n            scaleResolutionDownBy: 1,\n            maxBitrate: preferences?.maxBitrate ?? 3000000,\n            maxFramerate: preferences?.maxFramerate ?? 30\n        }\n    ];\n};\nconst trackTypeToParticipantStreamKey = (trackType)=>{\n    switch(trackType){\n        case TrackType.SCREEN_SHARE:\n            return \"screenShareStream\";\n        case TrackType.SCREEN_SHARE_AUDIO:\n            return \"screenShareAudioStream\";\n        case TrackType.VIDEO:\n            return \"videoStream\";\n        case TrackType.AUDIO:\n            return \"audioStream\";\n        case TrackType.UNSPECIFIED:\n            throw new Error(\"Track type is unspecified\");\n        default:\n            const exhaustiveTrackTypeCheck = trackType;\n            throw new Error(`Unknown track type: ${exhaustiveTrackTypeCheck}`);\n    }\n};\nconst muteTypeToTrackType = (muteType)=>{\n    switch(muteType){\n        case \"audio\":\n            return TrackType.AUDIO;\n        case \"video\":\n            return TrackType.VIDEO;\n        case \"screenshare\":\n            return TrackType.SCREEN_SHARE;\n        case \"screenshare_audio\":\n            return TrackType.SCREEN_SHARE_AUDIO;\n        default:\n            const exhaustiveMuteTypeCheck = muteType;\n            throw new Error(`Unknown mute type: ${exhaustiveMuteTypeCheck}`);\n    }\n};\n/**\n * Checks if the provided update is a function patch.\n *\n * @param update the value to check.\n */ const isFunctionPatch = (update)=>typeof update === \"function\";\n/**\n * Gets the current value of an observable, or undefined if the observable has\n * not emitted a value yet.\n *\n * @param observable$ the observable to get the value from.\n */ const getCurrentValue = (observable$)=>{\n    let value;\n    let err = undefined;\n    (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__.combineLatest)([\n        observable$\n    ]).subscribe({\n        next: ([v])=>{\n            value = v;\n        },\n        error: (e)=>{\n            err = e;\n        }\n    }).unsubscribe();\n    if (err) throw err;\n    return value;\n};\n/**\n * Updates the value of the provided Subject.\n * An `update` can either be a new value or a function which takes\n * the current value and returns a new value.\n *\n * @param subject the subject to update.\n * @param update the update to apply to the subject.\n * @return the updated value.\n */ const setCurrentValue = (subject, update)=>{\n    const next = isFunctionPatch(update) ? update(getCurrentValue(subject)) : update;\n    subject.next(next);\n    return next;\n};\n/**\n * Creates a subscription and returns a function to unsubscribe.\n *\n * @param observable the observable to subscribe to.\n * @param handler the handler to call when the observable emits a value.\n */ const createSubscription = (observable, handler)=>{\n    const subscription = observable.subscribe(handler);\n    return ()=>{\n        subscription.unsubscribe();\n    };\n};\nvar rxUtils = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    createSubscription: createSubscription,\n    getCurrentValue: getCurrentValue,\n    setCurrentValue: setCurrentValue\n});\n/**\n * Creates a new combined {@link Comparator<T>} which sorts items by the given comparators.\n * The comparators are applied in the order they are given (left -> right).\n *\n * @param comparators the comparators to use for sorting.\n * @returns a combined {@link Comparator<T>}.\n */ const combineComparators = (...comparators)=>{\n    return (a, b)=>{\n        for (const comparator of comparators){\n            const result = comparator(a, b);\n            if (result !== 0) return result;\n        }\n        return 0;\n    };\n};\n/**\n * Creates a new comparator which sorts items in descending order.\n *\n * @example\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const byValueDesc = descending(byValue);\n *\n * @param comparator the comparator to wrap.\n */ const descending = (comparator)=>{\n    return (a, b)=>comparator(b, a);\n};\n/**\n * Creates a new comparator which conditionally applies the given comparator.\n *\n * @example\n * const shouldSortByValue = (a, b) => a % 2 === 0; // return false to turn it off\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const comparator = conditional(shouldSortByValue)(byValue);\n *\n * @param predicate the predicate to use for determining whether to apply the comparator.\n */ const conditional = (predicate)=>{\n    return (comparator)=>{\n        return (a, b)=>{\n            if (!predicate(a, b)) return 0;\n            return comparator(a, b);\n        };\n    };\n};\n/**\n * A no-op comparator which always returns 0.\n */ const noopComparator = ()=>{\n    return ()=>0;\n};\n/**\n * A comparator which sorts participants by the fact that they are the dominant speaker or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const dominantSpeaker = (a, b)=>{\n    if (a.isDominantSpeaker && !b.isDominantSpeaker) return -1;\n    if (!a.isDominantSpeaker && b.isDominantSpeaker) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by the fact that they are speaking or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const speaking = (a, b)=>{\n    if (a.isSpeaking && !b.isSpeaking) return -1;\n    if (!a.isSpeaking && b.isSpeaking) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by screen sharing status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const screenSharing = (a, b)=>{\n    if (hasScreenShare(a) && !hasScreenShare(b)) return -1;\n    if (!hasScreenShare(a) && hasScreenShare(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by video status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingVideo = (a, b)=>{\n    if (hasVideo(a) && !hasVideo(b)) return -1;\n    if (!hasVideo(a) && hasVideo(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by audio status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingAudio = (a, b)=>{\n    if (hasAudio(a) && !hasAudio(b)) return -1;\n    if (!hasAudio(a) && hasAudio(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which prioritizes participants who are pinned.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const pinned = (a, b)=>{\n    if (a.pin && b.pin) {\n        if (!a.pin.isLocalPin && b.pin.isLocalPin) return -1;\n        if (a.pin.isLocalPin && !b.pin.isLocalPin) return 1;\n        if (a.pin.pinnedAt > b.pin.pinnedAt) return -1;\n        if (a.pin.pinnedAt < b.pin.pinnedAt) return 1;\n    }\n    if (a.pin && !b.pin) return -1;\n    if (!a.pin && b.pin) return 1;\n    return 0;\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific reaction.\n *\n * @param type the reaction type.\n */ const reactionType = (type)=>{\n    return (a, b)=>{\n        if (a.reaction?.type === type && b.reaction?.type !== type) return -1;\n        if (a.reaction?.type !== type && b.reaction?.type === type) return 1;\n        return 0;\n    };\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific role.\n *\n * @param roles the roles to prioritize.\n */ const role = (...roles)=>(a, b)=>{\n        if (hasAnyRole(a, roles) && !hasAnyRole(b, roles)) return -1;\n        if (!hasAnyRole(a, roles) && hasAnyRole(b, roles)) return 1;\n        return 0;\n    };\n/**\n * A comparator which sorts participants by name.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const name = (a, b)=>{\n    if (a.name < b.name) return -1;\n    if (a.name > b.name) return 1;\n    return 0;\n};\nconst hasAnyRole = (p, roles)=>(p.roles || []).some((r)=>roles.includes(r));\nconst hasScreenShare = (p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE);\nconst hasVideo = (p)=>p.publishedTracks.includes(TrackType.VIDEO);\nconst hasAudio = (p)=>p.publishedTracks.includes(TrackType.AUDIO);\n// a comparator decorator which applies the decorated comparator only if the\n// participant is invisible.\n// This ensures stable sorting when all participants are visible.\nconst ifInvisibleBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE);\n/**\n * A comparator that applies the decorated comparator when a participant is\n * either invisible or its visibility state isn't known.\n * For visible participants, it ensures stable sorting.\n */ const ifInvisibleOrUnknownBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || a.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN);\n/**\n * The default sorting preset.\n */ const defaultSortPreset = combineComparators(pinned, screenSharing, ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for speaker layout.\n */ const speakerLayoutSortPreset = combineComparators(pinned, screenSharing, dominantSpeaker, ifInvisibleBy(combineComparators(speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for layouts that don't render all participants but\n * instead, render them in pages.\n */ const paginatedLayoutSortPreset = combineComparators(pinned, ifInvisibleOrUnknownBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for livestreams and audio rooms.\n */ const livestreamOrAudioRoomSortPreset = combineComparators(ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)), role(\"admin\", \"host\", \"speaker\"));\n/**\n * Represents the state of the current call.\n */ var CallingState;\n(function(CallingState) {\n    /**\n     * The call is in an unknown state.\n     */ CallingState[\"UNKNOWN\"] = \"unknown\";\n    /**\n     * The call is in an idle state.\n     */ CallingState[\"IDLE\"] = \"idle\";\n    /**\n     * The call is in the process of ringing.\n     * (User hasn't accepted nor rejected the call yet.)\n     */ CallingState[\"RINGING\"] = \"ringing\";\n    /**\n     * The call is in the process of joining.\n     */ CallingState[\"JOINING\"] = \"joining\";\n    /**\n     * The call is currently active.\n     */ CallingState[\"JOINED\"] = \"joined\";\n    /**\n     * The call has been left.\n     */ CallingState[\"LEFT\"] = \"left\";\n    /**\n     * The call is in the process of reconnecting.\n     */ CallingState[\"RECONNECTING\"] = \"reconnecting\";\n    /**\n     * The call is in the process of migrating from one node to another.\n     */ CallingState[\"MIGRATING\"] = \"migrating\";\n    /**\n     * The call has failed to reconnect.\n     */ CallingState[\"RECONNECTING_FAILED\"] = \"reconnecting-failed\";\n    /**\n     * The call is in offline mode.\n     */ CallingState[\"OFFLINE\"] = \"offline\";\n})(CallingState || (CallingState = {}));\n/**\n * Returns the default egress object - when no egress data is available.\n */ const defaultEgress = {\n    broadcasting: false,\n    hls: {\n        playlist_url: \"\"\n    },\n    rtmps: []\n};\n/**\n * Holds the state of the current call.\n * @react You don't have to use this class directly, as we are exposing the state through Hooks.\n */ class CallState {\n    /**\n     * Creates a new instance of the CallState class.\n     *\n     */ constructor(){\n        this.backstageSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(true);\n        this.blockedUserIdsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject([]);\n        this.createdAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(new Date());\n        this.endedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.startsAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.updatedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(new Date());\n        this.createdBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.customSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject({});\n        this.egressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.ingressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.recordingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(false);\n        this.sessionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.transcribingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(false);\n        this.endedBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.thumbnailsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.membersSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject([]);\n        this.ownCapabilitiesSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject([]);\n        this.callingStateSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(CallingState.UNKNOWN);\n        this.startedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.participantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(0);\n        this.anonymousParticipantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(0);\n        this.participantsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject([]);\n        this.callStatsReportSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        /**\n         * A list of comparators that are used to sort the participants.\n         *\n         * @private\n         */ this.sortParticipantsBy = defaultSortPreset;\n        /**\n         * Sets the list of criteria that are used to sort the participants.\n         * To disable sorting, you can pass `noopComparator()`.\n         *\n         * @param comparator the comparator to use to sort the participants.\n         */ this.setSortParticipantsBy = (comparator)=>{\n            this.sortParticipantsBy = comparator;\n            // trigger re-sorting of participants\n            this.setCurrentValue(this.participantsSubject, (ps)=>ps);\n        };\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the number of participants in the current call.\n         *\n         * @internal\n         * @param count the number of participants.\n         */ this.setParticipantCount = (count)=>{\n            return this.setCurrentValue(this.participantCountSubject, count);\n        };\n        /**\n         * Sets the time the call session actually started.\n         *\n         * @internal\n         * @param startedAt the time the call session actually started.\n         */ this.setStartedAt = (startedAt)=>{\n            return this.setCurrentValue(this.startedAtSubject, startedAt);\n        };\n        /**\n         * Sets the number of anonymous participants in the current call.\n         *\n         * @internal\n         * @param count the number of anonymous participants.\n         */ this.setAnonymousParticipantCount = (count)=>{\n            return this.setCurrentValue(this.anonymousParticipantCountSubject, count);\n        };\n        /**\n         * Sets the list of participants in the current call.\n         *\n         * @internal\n         *\n         * @param participants the list of participants.\n         */ this.setParticipants = (participants)=>{\n            return this.setCurrentValue(this.participantsSubject, participants);\n        };\n        /**\n         * Sets the calling state.\n         *\n         * @internal\n         * @param state the new calling state.\n         */ this.setCallingState = (state)=>{\n            return this.setCurrentValue(this.callingStateSubject, state);\n        };\n        /**\n         * Sets the call stats report.\n         *\n         * @internal\n         * @param report the report to set.\n         */ this.setCallStatsReport = (report)=>{\n            return this.setCurrentValue(this.callStatsReportSubject, report);\n        };\n        /**\n         * Sets the members of the current call.\n         *\n         * @internal\n         * @param members the members to set.\n         */ this.setMembers = (members)=>{\n            this.setCurrentValue(this.membersSubject, members);\n        };\n        /**\n         * Sets the own capabilities.\n         *\n         * @internal\n         * @param capabilities the capabilities to set.\n         */ this.setOwnCapabilities = (capabilities)=>{\n            return this.setCurrentValue(this.ownCapabilitiesSubject, capabilities);\n        };\n        /**\n         * Will try to find the participant with the given sessionId in the current call.\n         *\n         * @param sessionId the sessionId of the participant to find.\n         * @returns the participant with the given sessionId or undefined if not found.\n         */ this.findParticipantBySessionId = (sessionId)=>{\n            return this.participants.find((p)=>p.sessionId === sessionId);\n        };\n        /**\n         * Returns a new lookup table of participants indexed by their session ID.\n         */ this.getParticipantLookupBySessionId = ()=>{\n            return this.participants.reduce((lookupTable, participant)=>{\n                lookupTable[participant.sessionId] = participant;\n                return lookupTable;\n            }, {});\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If the participant can't be found, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param patch the patch to apply to the participant.\n         * @returns the updated participant or `undefined` if the participant couldn't be found.\n         */ this.updateParticipant = (sessionId, patch)=>{\n            const participant = this.findParticipantBySessionId(sessionId);\n            if (!participant) {\n                this.logger(\"warn\", `Participant with sessionId ${sessionId} not found`);\n                return;\n            }\n            const thePatch = typeof patch === \"function\" ? patch(participant) : patch;\n            const updatedParticipant = {\n                // FIXME OL: this is not a deep merge, we might want to revisit this\n                ...participant,\n                ...thePatch\n            };\n            return this.setParticipants((participants)=>participants.map((p)=>p.sessionId === sessionId ? updatedParticipant : p));\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If a participant with matching `sessionId` can't be found, the provided\n         * `participant` is added to the list of participants.\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param participant the participant to update or add.\n         */ this.updateOrAddParticipant = (sessionId, participant)=>{\n            if (!this.findParticipantBySessionId(sessionId)) {\n                return this.setParticipants((participants)=>[\n                        ...participants,\n                        participant\n                    ]);\n            }\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    if (p.sessionId === sessionId) {\n                        return {\n                            ...p,\n                            ...participant\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates all participants in the current call whose session ID is in the given `sessionIds`.\n         * If no patches are provided, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param patch the patch to apply to the participants.\n         * @returns all participants, with all patch applied.\n         */ this.updateParticipants = (patch)=>{\n            if (Object.keys(patch).length === 0) return;\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    const thePatch = patch[p.sessionId];\n                    if (thePatch) {\n                        return {\n                            ...p,\n                            ...thePatch\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param event the video event that our backend sent us.\n         */ this.updateFromEvent = (event)=>{\n            const update = this.eventHandlers[event.type];\n            if (update) {\n                update(event);\n            }\n        };\n        /**\n         * Updates the participant pinned state with server side pinning data.\n         *\n         * @param pins the latest pins from the server.\n         */ this.setServerSidePins = (pins)=>{\n            const pinsLookup = pins.reduce((lookup, pin)=>{\n                lookup[pin.sessionId] = Date.now();\n                return lookup;\n            }, {});\n            return this.setParticipants((participants)=>participants.map((participant)=>{\n                    const serverSidePinnedAt = pinsLookup[participant.sessionId];\n                    // the participant is newly pinned\n                    if (serverSidePinnedAt) {\n                        return {\n                            ...participant,\n                            pin: {\n                                isLocalPin: false,\n                                pinnedAt: serverSidePinnedAt\n                            }\n                        };\n                    }\n                    // the participant is no longer pinned server side\n                    // we need to reset the pin\n                    if (participant.pin && !participant.pin.isLocalPin) {\n                        return {\n                            ...participant,\n                            pin: undefined\n                        };\n                    }\n                    // no changes to be applied\n                    return participant;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param call the call response from the server.\n         */ this.updateFromCallResponse = (call)=>{\n            this.setCurrentValue(this.backstageSubject, call.backstage);\n            this.setCurrentValue(this.blockedUserIdsSubject, call.blocked_user_ids);\n            this.setCurrentValue(this.createdAtSubject, new Date(call.created_at));\n            this.setCurrentValue(this.updatedAtSubject, new Date(call.updated_at));\n            this.setCurrentValue(this.startsAtSubject, call.starts_at ? new Date(call.starts_at) : undefined);\n            this.setCurrentValue(this.endedAtSubject, call.ended_at ? new Date(call.ended_at) : undefined);\n            this.setCurrentValue(this.createdBySubject, call.created_by);\n            this.setCurrentValue(this.customSubject, call.custom);\n            this.setCurrentValue(this.egressSubject, call.egress);\n            this.setCurrentValue(this.ingressSubject, call.ingress);\n            this.setCurrentValue(this.recordingSubject, call.recording);\n            this.setCurrentValue(this.sessionSubject, call.session);\n            this.setCurrentValue(this.settingsSubject, call.settings);\n            this.setCurrentValue(this.transcribingSubject, call.transcribing);\n            this.setCurrentValue(this.thumbnailsSubject, call.thumbnails);\n        };\n        this.updateFromMemberRemoved = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.filter((m)=>event.members.indexOf(m.user_id) === -1));\n        };\n        this.updateFromMemberAdded = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>[\n                    ...members,\n                    ...event.members\n                ]);\n        };\n        this.updateFromHLSBroadcastStopped = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastingFailed = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastStarted = (event)=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: true,\n                    hls: {\n                        ...egress.hls,\n                        playlist_url: event.hls_playlist_url\n                    }\n                }));\n        };\n        this.updateFromSessionParticipantLeft = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_left event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                return {\n                    ...session,\n                    participants: participants.filter((p)=>p.user_session_id !== user_session_id),\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: Math.max(0, (participants_count_by_role[user.role] || 0) - 1)\n                    }\n                };\n            });\n        };\n        this.updateFromSessionParticipantJoined = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_joined event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                // It could happen that the backend delivers the same participant more than once.\n                // Once with the call.session_started event and once again with the\n                // call.session_participant_joined event. In this case,\n                // we should update the existing participant and prevent duplicating it.\n                let shouldInsertParticipant = true;\n                const updatedParticipants = participants.map((p)=>{\n                    if (p.user_session_id === user_session_id) {\n                        shouldInsertParticipant = false;\n                        return event.participant;\n                    }\n                    return p;\n                });\n                if (shouldInsertParticipant) {\n                    // this is a new array, we can safely push the new participant\n                    updatedParticipants.push(event.participant);\n                }\n                // If we are updating an existing participant, we don't want to increment\n                // the participant_by_role count.\n                const increment = shouldInsertParticipant ? 1 : 0;\n                return {\n                    ...session,\n                    participants: updatedParticipants,\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: (participants_count_by_role[user.role] || 0) + increment\n                    }\n                };\n            });\n        };\n        this.updateMembers = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.map((member)=>{\n                    const memberUpdate = event.members.find((m)=>m.user_id === member.user_id);\n                    return memberUpdate ? memberUpdate : member;\n                }));\n        };\n        this.updateParticipantReaction = (event)=>{\n            const { user, custom, type, emoji_code } = event.reaction;\n            this.setParticipants((participants)=>{\n                return participants.map((p)=>{\n                    // skip if the reaction is not for this participant\n                    if (p.userId !== user.id) return p;\n                    // update the participant with the new reaction\n                    return {\n                        ...p,\n                        reaction: {\n                            type,\n                            emoji_code,\n                            custom\n                        }\n                    };\n                });\n            });\n        };\n        this.unblockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>{\n                if (!current) return current;\n                return current.filter((id)=>id !== event.user.id);\n            });\n        };\n        this.blockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>[\n                    ...current || [],\n                    event.user.id\n                ]);\n        };\n        this.updateOwnCapabilities = (event)=>{\n            if (event.user.id === this.localParticipant?.userId) {\n                this.setCurrentValue(this.ownCapabilitiesSubject, event.own_capabilities);\n            }\n        };\n        this.logger = getLogger([\n            \"CallState\"\n        ]);\n        this.participants$ = this.participantsSubject.asObservable().pipe(// maintain stable-sort by mutating the participants stored\n        // in the original subject\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((ps)=>ps.sort(this.sortParticipantsBy)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.localParticipant$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((participants)=>participants.find((p)=>p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.remoteParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((participants)=>participants.filter((p)=>!p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.pinnedParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((participants)=>participants.filter((p)=>!!p.pin)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.dominantSpeaker$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((participants)=>participants.find((p)=>p.isDominantSpeaker)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.hasOngoingScreenShare$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((participants)=>participants.some((p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE))), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.startedAt$ = this.startedAtSubject.asObservable();\n        this.participantCount$ = this.participantCountSubject.asObservable();\n        this.anonymousParticipantCount$ = this.anonymousParticipantCountSubject.asObservable();\n        this.callStatsReport$ = this.callStatsReportSubject.asObservable();\n        this.members$ = this.membersSubject.asObservable();\n        this.ownCapabilities$ = this.ownCapabilitiesSubject.asObservable();\n        this.callingState$ = this.callingStateSubject.asObservable();\n        this.backstage$ = this.backstageSubject.asObservable();\n        this.blockedUserIds$ = this.blockedUserIdsSubject.asObservable();\n        this.createdAt$ = this.createdAtSubject.asObservable();\n        this.endedAt$ = this.endedAtSubject.asObservable();\n        this.startsAt$ = this.startsAtSubject.asObservable();\n        this.updatedAt$ = this.updatedAtSubject.asObservable();\n        this.createdBy$ = this.createdBySubject.asObservable();\n        this.custom$ = this.customSubject.asObservable();\n        this.egress$ = this.egressSubject.asObservable();\n        this.ingress$ = this.ingressSubject.asObservable();\n        this.recording$ = this.recordingSubject.asObservable();\n        this.session$ = this.sessionSubject.asObservable();\n        this.settings$ = this.settingsSubject.asObservable();\n        this.transcribing$ = this.transcribingSubject.asObservable();\n        this.endedBy$ = this.endedBySubject.asObservable();\n        this.thumbnails$ = this.thumbnailsSubject.asObservable();\n        this.eventHandlers = {\n            // these events are not updating the call state:\n            \"call.closed_caption\": undefined,\n            \"call.permission_request\": undefined,\n            \"call.recording_failed\": undefined,\n            \"call.recording_ready\": undefined,\n            \"call.transcription_started\": undefined,\n            \"call.transcription_stopped\": undefined,\n            \"call.transcription_ready\": undefined,\n            \"call.transcription_failed\": undefined,\n            \"call.user_muted\": undefined,\n            \"connection.error\": undefined,\n            \"connection.ok\": undefined,\n            \"health.check\": undefined,\n            custom: undefined,\n            // events that update call state:\n            \"call.accepted\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.blocked_user\": this.blockUser,\n            \"call.created\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ended\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setCurrentValue(this.endedBySubject, e.user);\n            },\n            \"call.hls_broadcasting_failed\": this.updateFromHLSBroadcastingFailed,\n            \"call.hls_broadcasting_started\": this.updateFromHLSBroadcastStarted,\n            \"call.hls_broadcasting_stopped\": this.updateFromHLSBroadcastStopped,\n            \"call.live_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.member_added\": this.updateFromMemberAdded,\n            \"call.member_removed\": this.updateFromMemberRemoved,\n            \"call.member_updated_permission\": this.updateMembers,\n            \"call.member_updated\": this.updateMembers,\n            \"call.notification\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setMembers(e.members);\n            },\n            \"call.permissions_updated\": this.updateOwnCapabilities,\n            \"call.reaction_new\": this.updateParticipantReaction,\n            \"call.recording_started\": ()=>this.setCurrentValue(this.recordingSubject, true),\n            \"call.recording_stopped\": ()=>this.setCurrentValue(this.recordingSubject, false),\n            \"call.rejected\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ring\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_ended\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_participant_joined\": this.updateFromSessionParticipantJoined,\n            \"call.session_participant_left\": this.updateFromSessionParticipantLeft,\n            \"call.session_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.unblocked_user\": this.unblockUser,\n            \"call.updated\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.deleted\": undefined\n        };\n    }\n    /**\n     * The server-side counted number of participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get participantCount() {\n        return this.getCurrentValue(this.participantCount$);\n    }\n    /**\n     * The time the call session actually started.\n     * Useful for displaying the call duration.\n     */ get startedAt() {\n        return this.getCurrentValue(this.startedAt$);\n    }\n    /**\n     * The server-side counted number of anonymous participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get anonymousParticipantCount() {\n        return this.getCurrentValue(this.anonymousParticipantCount$);\n    }\n    /**\n     * The list of participants in the current call.\n     */ get participants() {\n        return this.getCurrentValue(this.participants$);\n    }\n    /**\n     * The local participant in the current call.\n     */ get localParticipant() {\n        return this.getCurrentValue(this.localParticipant$);\n    }\n    /**\n     * The list of remote participants in the current call.\n     */ get remoteParticipants() {\n        return this.getCurrentValue(this.remoteParticipants$);\n    }\n    /**\n     * The dominant speaker in the current call.\n     */ get dominantSpeaker() {\n        return this.getCurrentValue(this.dominantSpeaker$);\n    }\n    /**\n     * The list of pinned participants in the current call.\n     */ get pinnedParticipants() {\n        return this.getCurrentValue(this.pinnedParticipants$);\n    }\n    /**\n     * Tell if there is an ongoing screen share in this call.\n     */ get hasOngoingScreenShare() {\n        return this.getCurrentValue(this.hasOngoingScreenShare$);\n    }\n    /**\n     * The calling state.\n     */ get callingState() {\n        return this.getCurrentValue(this.callingState$);\n    }\n    /**\n     * The call stats report.\n     */ get callStatsReport() {\n        return this.getCurrentValue(this.callStatsReport$);\n    }\n    /**\n     * The members of the current call.\n     */ get members() {\n        return this.getCurrentValue(this.members$);\n    }\n    /**\n     * The capabilities of the current user for the current call.\n     */ get ownCapabilities() {\n        return this.getCurrentValue(this.ownCapabilities$);\n    }\n    /**\n     * The backstage state.\n     */ get backstage() {\n        return this.getCurrentValue(this.backstage$);\n    }\n    /**\n     * Will provide the list of blocked user IDs.\n     */ get blockedUserIds() {\n        return this.getCurrentValue(this.blockedUserIds$);\n    }\n    /**\n     * Will provide the time when this call has been created.\n     */ get createdAt() {\n        return this.getCurrentValue(this.createdAt$);\n    }\n    /**\n     * Will provide the time when this call has been ended.\n     */ get endedAt() {\n        return this.getCurrentValue(this.endedAt$);\n    }\n    /**\n     * Will provide the time when this call has been scheduled to start.\n     */ get startsAt() {\n        return this.getCurrentValue(this.startsAt$);\n    }\n    /**\n     * Will provide the time when this call has been updated.\n     */ get updatedAt() {\n        return this.getCurrentValue(this.updatedAt$);\n    }\n    /**\n     * Will provide the user who created this call.\n     */ get createdBy() {\n        return this.getCurrentValue(this.createdBy$);\n    }\n    /**\n     * Will provide the custom data of this call.\n     */ get custom() {\n        return this.getCurrentValue(this.custom$);\n    }\n    /**\n     * Will provide the egress data of this call.\n     */ get egress() {\n        return this.getCurrentValue(this.egress$);\n    }\n    /**\n     * Will provide the ingress data of this call.\n     */ get ingress() {\n        return this.getCurrentValue(this.ingress$);\n    }\n    /**\n     * Will provide the recording state of this call.\n     */ get recording() {\n        return this.getCurrentValue(this.recording$);\n    }\n    /**\n     * Will provide the session data of this call.\n     */ get session() {\n        return this.getCurrentValue(this.session$);\n    }\n    /**\n     * Will provide the settings of this call.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Will provide the transcribing state of this call.\n     */ get transcribing() {\n        return this.getCurrentValue(this.transcribing$);\n    }\n    /**\n     * Will provide the user who ended this call.\n     */ get endedBy() {\n        return this.getCurrentValue(this.endedBy$);\n    }\n    /**\n     * Will provide the thumbnails of this call, if enabled in the call settings.\n     */ get thumbnails() {\n        return this.getCurrentValue(this.thumbnails$);\n    }\n}\nclass StreamVideoWriteableStateStore {\n    constructor(){\n        /**\n         * A store keeping data of a successfully connected user over WS to the coordinator server.\n         */ this.connectedUserSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        /**\n         * A list of {@link Call} objects created/tracked by this client.\n         */ this.callsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject([]);\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the currently connected user.\n         *\n         * @internal\n         * @param user the user to set as connected.\n         */ this.setConnectedUser = (user)=>{\n            return this.setCurrentValue(this.connectedUserSubject, user);\n        };\n        /**\n         * Sets the list of {@link Call} objects created/tracked by this client.\n         * @param calls\n         */ this.setCalls = (calls)=>{\n            return this.setCurrentValue(this.callsSubject, calls);\n        };\n        /**\n         * Adds a {@link Call} object to the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to add.\n         */ this.registerCall = (call)=>{\n            if (!this.calls.find((c)=>c.cid === call.cid)) {\n                this.setCalls((calls)=>[\n                        ...calls,\n                        call\n                    ]);\n            }\n        };\n        /**\n         * Removes a {@link Call} object from the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to remove\n         */ this.unregisterCall = (call)=>{\n            return this.setCalls((calls)=>calls.filter((c)=>c !== call));\n        };\n        /**\n         * Finds a {@link Call} object in the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param type the type of call to find.\n         * @param id the id of the call to find.\n         */ this.findCall = (type, id)=>{\n            return this.calls.find((c)=>c.type === type && c.id === id);\n        };\n        this.connectedUserSubject.subscribe(async (user)=>{\n            // leave all calls when the user disconnects.\n            if (!user) {\n                const logger = getLogger([\n                    \"client-state\"\n                ]);\n                for (const call of this.calls){\n                    if (call.state.callingState === CallingState.LEFT) continue;\n                    logger(\"info\", `User disconnected, leaving call: ${call.cid}`);\n                    await call.leave({\n                        reason: \"client.disconnectUser() called\"\n                    }).catch((err)=>{\n                        logger(\"error\", `Error leaving call: ${call.cid}`, err);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * The currently connected user.\n     */ get connectedUser() {\n        return this.getCurrentValue(this.connectedUserSubject);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return this.getCurrentValue(this.callsSubject);\n    }\n}\n/**\n * A reactive store that exposes state variables in a reactive manner.\n * You can subscribe to changes of the different state variables.\n * This central store contains all the state variables related to [`StreamVideoClient`](./StreamVideClient.md) and [`Call`](./Call.md).\n */ class StreamVideoReadOnlyStateStore {\n    constructor(store){\n        /**\n         * This method allows you the get the current value of a state variable.\n         *\n         * @param observable the observable to get the current value of.\n         * @returns the current value of the observable.\n         */ this.getCurrentValue = getCurrentValue;\n        // convert and expose subjects as observables\n        this.connectedUser$ = store.connectedUserSubject.asObservable();\n        this.calls$ = store.callsSubject.asObservable();\n    }\n    /**\n     * The current user connected over WS to the backend.\n     */ get connectedUser() {\n        return getCurrentValue(this.connectedUser$);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return getCurrentValue(this.calls$);\n    }\n}\nconst getRtpMap = (line)=>{\n    // Example: a=rtpmap:110 opus/48000/2\n    const rtpRegex = /^a=rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/;\n    // The first captured group is the payload type number, the second captured group is the encoding name, the third captured group is the clock rate, and the fourth captured group is any additional parameters.\n    const rtpMatch = rtpRegex.exec(line);\n    if (rtpMatch) {\n        return {\n            original: rtpMatch[0],\n            payload: rtpMatch[1],\n            codec: rtpMatch[2]\n        };\n    }\n};\nconst getFmtp = (line)=>{\n    // Example: a=fmtp:111 minptime=10; useinbandfec=1\n    const fmtpRegex = /^a=fmtp:(\\d*) (.*)/;\n    const fmtpMatch = fmtpRegex.exec(line);\n    // The first captured group is the payload type number, the second captured group is any additional parameters.\n    if (fmtpMatch) {\n        return {\n            original: fmtpMatch[0],\n            payload: fmtpMatch[1],\n            config: fmtpMatch[2]\n        };\n    }\n};\n/**\n * gets the media section for the specified media type.\n * The media section contains the media type, port, codec, and payload type.\n * Example: m=video 9 UDP/TLS/RTP/SAVPF 100 101 96 97 35 36 102 125 127\n */ const getMedia = (line, mediaType)=>{\n    const regex = new RegExp(`(m=${mediaType} \\\\d+ [\\\\w/]+) ([\\\\d\\\\s]+)`);\n    const match = regex.exec(line);\n    if (match) {\n        return {\n            original: match[0],\n            mediaWithPorts: match[1],\n            codecOrder: match[2]\n        };\n    }\n};\nconst getMediaSection = (sdp, mediaType)=>{\n    let media;\n    const rtpMap = [];\n    const fmtp = [];\n    let isTheRequiredMediaSection = false;\n    sdp.split(/(\\r\\n|\\r|\\n)/).forEach((line)=>{\n        const isValidLine = /^([a-z])=(.*)/.test(line);\n        if (!isValidLine) return;\n        /*\n          NOTE: according to https://www.rfc-editor.org/rfc/rfc8866.pdf\n          Each media description starts with an \"m=\" line and continues to the next media description or the end of the whole session description, whichever comes first\n        */ const type = line[0];\n        if (type === \"m\") {\n            const _media = getMedia(line, mediaType);\n            isTheRequiredMediaSection = !!_media;\n            if (_media) {\n                media = _media;\n            }\n        } else if (isTheRequiredMediaSection && type === \"a\") {\n            const rtpMapLine = getRtpMap(line);\n            const fmtpLine = getFmtp(line);\n            if (rtpMapLine) {\n                rtpMap.push(rtpMapLine);\n            } else if (fmtpLine) {\n                fmtp.push(fmtpLine);\n            }\n        }\n    });\n    if (media) {\n        return {\n            media,\n            rtpMap,\n            fmtp\n        };\n    }\n};\n/**\n * Gets the fmtp line corresponding to opus\n */ const getOpusFmtp = (sdp)=>{\n    const section = getMediaSection(sdp, \"audio\");\n    const rtpMap = section?.rtpMap.find((r)=>r.codec.toLowerCase() === \"opus\");\n    const codecId = rtpMap?.payload;\n    if (codecId) {\n        return section?.fmtp.find((f)=>f.payload === codecId);\n    }\n};\n/**\n * Returns an SDP with DTX enabled or disabled.\n */ const toggleDtx = (sdp, enable)=>{\n    const opusFmtp = getOpusFmtp(sdp);\n    if (opusFmtp) {\n        const matchDtx = /usedtx=(\\d)/.exec(opusFmtp.config);\n        const requiredDtxConfig = `usedtx=${enable ? \"1\" : \"0\"}`;\n        if (matchDtx) {\n            const newFmtp = opusFmtp.original.replace(/usedtx=(\\d)/, requiredDtxConfig);\n            return sdp.replace(opusFmtp.original, newFmtp);\n        } else {\n            const newFmtp = `${opusFmtp.original};${requiredDtxConfig}`;\n            return sdp.replace(opusFmtp.original, newFmtp);\n        }\n    }\n    return sdp;\n};\n/**\n * Enables high-quality audio through SDP munging for the given trackMid.\n *\n * @param sdp the SDP to munge.\n * @param trackMid the trackMid.\n * @param maxBitrate the max bitrate to set.\n */ const enableHighQualityAudio = (sdp, trackMid, maxBitrate = 510000)=>{\n    maxBitrate = Math.max(Math.min(maxBitrate, 510000), 96000);\n    const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n    const audioMedia = parsedSdp.media.find((m)=>m.type === \"audio\" && String(m.mid) === trackMid);\n    if (!audioMedia) return sdp;\n    const opusRtp = audioMedia.rtp.find((r)=>r.codec === \"opus\");\n    if (!opusRtp) return sdp;\n    const opusFmtp = audioMedia.fmtp.find((f)=>f.payload === opusRtp.payload);\n    if (!opusFmtp) return sdp;\n    // enable stereo, if not already enabled\n    if (opusFmtp.config.match(/stereo=(\\d)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/stereo=(\\d)/, \"stereo=1\");\n    } else {\n        opusFmtp.config = `${opusFmtp.config};stereo=1`;\n    }\n    // set maxaveragebitrate, to the given value\n    if (opusFmtp.config.match(/maxaveragebitrate=(\\d*)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/maxaveragebitrate=(\\d*)/, `maxaveragebitrate=${maxBitrate}`);\n    } else {\n        opusFmtp.config = `${opusFmtp.config};maxaveragebitrate=${maxBitrate}`;\n    }\n    return sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp);\n};\nconst logger$3 = getLogger([\n    \"Publisher\"\n]);\n/**\n * The `Publisher` is responsible for publishing/unpublishing media streams to/from the SFU\n * @internal\n */ class Publisher {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Publisher` instance.\n     *\n     * @param connectionConfig the connection configuration to use.\n     * @param sfuClient the SFU client to use.\n     * @param state the call state to use.\n     * @param dispatcher the dispatcher to use.\n     * @param isDtxEnabled whether DTX is enabled.\n     * @param isRedEnabled whether RED is enabled.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE once connection goes to `disconnected` state.\n     */ constructor({ connectionConfig, sfuClient, dispatcher, state, isDtxEnabled, isRedEnabled, iceRestartDelay = 2500 }){\n        this.transceiverRegistry = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.publishOptionsPerTrackType = new Map();\n        /**\n         * An array maintaining the order how transceivers were added to the peer connection.\n         * This is needed because some browsers (Firefox) don't reliably report\n         * trackId and `mid` parameters.\n         *\n         * @private\n         */ this.transceiverInitOrder = [];\n        this.trackKindMapping = {\n            [TrackType.AUDIO]: \"audio\",\n            [TrackType.VIDEO]: \"video\",\n            [TrackType.SCREEN_SHARE]: \"video\",\n            [TrackType.SCREEN_SHARE_AUDIO]: \"audio\",\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.trackLayersCache = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.isIceRestarting = false;\n        this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            pc.addEventListener(\"signalingstatechange\", this.onSignalingStateChange);\n            return pc;\n        };\n        /**\n         * Closes the publisher PeerConnection and cleans up the resources.\n         */ this.close = ({ stopTracks = true } = {})=>{\n            if (stopTracks) {\n                this.stopPublishing();\n                Object.keys(this.transceiverRegistry).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.transceiverRegistry[trackType] = undefined;\n                });\n                Object.keys(this.trackLayersCache).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.trackLayersCache[trackType] = undefined;\n                });\n            }\n            clearTimeout(this.iceRestartTimeout);\n            this.unsubscribeOnIceRestart();\n            this.pc.removeEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            this.pc.close();\n        };\n        /**\n         * Starts publishing the given track of the given media stream.\n         *\n         * Consecutive calls to this method will replace the stream.\n         * The previous stream will be stopped.\n         *\n         * @param mediaStream the media stream to publish.\n         * @param track the track to publish.\n         * @param trackType the track type to publish.\n         * @param opts the optional publish options to use.\n         */ this.publishStream = async (mediaStream, track, trackType, opts = {})=>{\n            if (track.readyState === \"ended\") {\n                throw new Error(`Can't publish a track that has ended already.`);\n            }\n            let transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track && t.sender.track?.kind === this.trackKindMapping[trackType]);\n            /**\n             * An event handler which listens for the 'ended' event on the track.\n             * Once the track has ended, it will notify the SFU and update the state.\n             */ const handleTrackEnded = async ()=>{\n                logger$3(\"info\", `Track ${TrackType[trackType]} has ended, notifying the SFU`);\n                await this.notifyTrackMuteStateChanged(mediaStream, trackType, true);\n                // clean-up, this event listener needs to run only once.\n                track.removeEventListener(\"ended\", handleTrackEnded);\n            };\n            if (!transceiver) {\n                const { settings } = this.state;\n                const targetResolution = settings?.video.target_resolution;\n                const videoEncodings = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, opts.screenShareSettings) : undefined;\n                let preferredCodec = opts.preferredCodec;\n                if (!preferredCodec && trackType === TrackType.VIDEO) {\n                    if (isReactNative()) {\n                        const osName = getOSInfo()?.name.toLowerCase();\n                        if (osName === \"ipados\") {\n                            // in ipads it was noticed that if vp8 codec is used\n                            // then the bytes sent is 0 in the outbound-rtp\n                            // so we are forcing h264 codec for ipads\n                            preferredCodec = \"H264\";\n                        } else if (osName === \"android\") {\n                            preferredCodec = \"VP8\";\n                        }\n                    }\n                }\n                const codecPreferences = this.getCodecPreferences(trackType, preferredCodec);\n                // listen for 'ended' event on the track as it might be ended abruptly\n                // by an external factor as permission revokes, device disconnected, etc.\n                // keep in mind that `track.stop()` doesn't trigger this event.\n                track.addEventListener(\"ended\", handleTrackEnded);\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                transceiver = this.pc.addTransceiver(track, {\n                    direction: \"sendonly\",\n                    streams: trackType === TrackType.VIDEO || trackType === TrackType.SCREEN_SHARE ? [\n                        mediaStream\n                    ] : undefined,\n                    sendEncodings: videoEncodings\n                });\n                logger$3(\"debug\", `Added ${TrackType[trackType]} transceiver`);\n                this.transceiverInitOrder.push(trackType);\n                this.transceiverRegistry[trackType] = transceiver;\n                this.publishOptionsPerTrackType.set(trackType, opts);\n                if (\"setCodecPreferences\" in transceiver && codecPreferences) {\n                    logger$3(\"info\", `Setting ${TrackType[trackType]} codec preferences`, codecPreferences);\n                    try {\n                        transceiver.setCodecPreferences(codecPreferences);\n                    } catch (err) {\n                        logger$3(\"warn\", `Couldn't set codec preferences`, err);\n                    }\n                }\n            } else {\n                const previousTrack = transceiver.sender.track;\n                // don't stop the track if we are re-publishing the same track\n                if (previousTrack && previousTrack !== track) {\n                    previousTrack.stop();\n                    previousTrack.removeEventListener(\"ended\", handleTrackEnded);\n                    track.addEventListener(\"ended\", handleTrackEnded);\n                }\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                await transceiver.sender.replaceTrack(track);\n            }\n            await this.notifyTrackMuteStateChanged(mediaStream, trackType, false);\n        };\n        /**\n         * Stops publishing the given track type to the SFU, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         * @param trackType the track type to unpublish.\n         * @param stopTrack specifies whether track should be stopped or just disabled\n         */ this.unpublishStream = async (trackType, stopTrack)=>{\n            const transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track);\n            if (transceiver && transceiver.sender.track && (stopTrack ? transceiver.sender.track.readyState === \"live\" : transceiver.sender.track.enabled)) {\n                stopTrack ? transceiver.sender.track.stop() : transceiver.sender.track.enabled = false;\n                // We don't need to notify SFU if unpublishing in response to remote soft mute\n                if (this.state.localParticipant?.publishedTracks.includes(trackType)) {\n                    await this.notifyTrackMuteStateChanged(undefined, trackType, true);\n                }\n            }\n        };\n        /**\n         * Returns true if the given track type is currently being published to the SFU.\n         *\n         * @param trackType the track type to check.\n         */ this.isPublishing = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\" && sender.track.enabled;\n            }\n            return false;\n        };\n        /**\n         * Returns true if the given track type is currently live\n         *\n         * @param trackType the track type to check.\n         */ this.isLive = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\";\n            }\n            return false;\n        };\n        this.notifyTrackMuteStateChanged = async (mediaStream, trackType, isMuted)=>{\n            await this.sfuClient.updateMuteState(trackType, isMuted);\n            const audioOrVideoOrScreenShareStream = trackTypeToParticipantStreamKey(trackType);\n            if (isMuted) {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>({\n                        publishedTracks: p.publishedTracks.filter((t)=>t !== trackType),\n                        [audioOrVideoOrScreenShareStream]: undefined\n                    }));\n            } else {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>{\n                    return {\n                        publishedTracks: p.publishedTracks.includes(trackType) ? p.publishedTracks : [\n                            ...p.publishedTracks,\n                            trackType\n                        ],\n                        [audioOrVideoOrScreenShareStream]: mediaStream\n                    };\n                });\n            }\n        };\n        /**\n         * Stops publishing all tracks and stop all tracks.\n         */ this.stopPublishing = ()=>{\n            logger$3(\"debug\", \"Stopping publishing all tracks\");\n            this.pc.getSenders().forEach((s)=>{\n                s.track?.stop();\n                if (this.pc.signalingState !== \"closed\") {\n                    this.pc.removeTrack(s);\n                }\n            });\n        };\n        this.updateVideoPublishQuality = async (enabledLayers)=>{\n            logger$3(\"info\", \"Update publish quality, requested layers by SFU:\", enabledLayers);\n            const videoSender = this.transceiverRegistry[TrackType.VIDEO]?.sender;\n            if (!videoSender) {\n                logger$3(\"warn\", \"Update publish quality, no video sender found.\");\n                return;\n            }\n            const params = videoSender.getParameters();\n            if (params.encodings.length === 0) {\n                logger$3(\"warn\", \"Update publish quality, No suitable video encoding quality found\");\n                return;\n            }\n            let changed = false;\n            let enabledRids = enabledLayers.filter((ly)=>ly.active).map((ly)=>ly.name);\n            params.encodings.forEach((enc)=>{\n                // flip 'active' flag only when necessary\n                const shouldEnable = enabledRids.includes(enc.rid);\n                if (shouldEnable !== enc.active) {\n                    enc.active = shouldEnable;\n                    changed = true;\n                }\n                if (shouldEnable) {\n                    let layer = enabledLayers.find((vls)=>vls.name === enc.rid);\n                    if (layer !== undefined) {\n                        if (layer.scaleResolutionDownBy >= 1 && layer.scaleResolutionDownBy !== enc.scaleResolutionDownBy) {\n                            logger$3(\"debug\", \"[dynascale]: setting scaleResolutionDownBy from server\", \"layer\", layer.name, \"scale-resolution-down-by\", layer.scaleResolutionDownBy);\n                            enc.scaleResolutionDownBy = layer.scaleResolutionDownBy;\n                            changed = true;\n                        }\n                        if (layer.maxBitrate > 0 && layer.maxBitrate !== enc.maxBitrate) {\n                            logger$3(\"debug\", \"[dynascale] setting max-bitrate from the server\", \"layer\", layer.name, \"max-bitrate\", layer.maxBitrate);\n                            enc.maxBitrate = layer.maxBitrate;\n                            changed = true;\n                        }\n                        if (layer.maxFramerate > 0 && layer.maxFramerate !== enc.maxFramerate) {\n                            logger$3(\"debug\", \"[dynascale]: setting maxFramerate from server\", \"layer\", layer.name, \"max-framerate\", layer.maxFramerate);\n                            enc.maxFramerate = layer.maxFramerate;\n                            changed = true;\n                        }\n                    }\n                }\n            });\n            const activeLayers = params.encodings.filter((e)=>e.active);\n            if (changed) {\n                await videoSender.setParameters(params);\n                logger$3(\"info\", `Update publish quality, enabled rids: `, activeLayers);\n            } else {\n                logger$3(\"info\", `Update publish quality, no change: `, activeLayers);\n            }\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        this.getCodecPreferences = (trackType, preferredCodec)=>{\n            if (trackType === TrackType.VIDEO) {\n                return getPreferredCodecs(\"video\", preferredCodec || \"vp8\");\n            }\n            if (trackType === TrackType.AUDIO) {\n                const defaultAudioCodec = this.isRedEnabled ? \"red\" : \"opus\";\n                const codecToRemove = !this.isRedEnabled ? \"red\" : undefined;\n                return getPreferredCodecs(\"audio\", preferredCodec ?? defaultAudioCodec, codecToRemove);\n            }\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$3(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.PUBLISHER_UNSPECIFIED\n            });\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Performs a migration of this publisher instance to a new SFU.\n         *\n         * Initiates a new `iceRestart` offer/answer exchange with the new SFU.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = async (sfuClient, connectionConfig)=>{\n            this.sfuClient = sfuClient;\n            this.pc.setConfiguration(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            const shouldRestartIce = this.pc.iceConnectionState === \"connected\";\n            if (shouldRestartIce) {\n                // negotiate only if there are tracks to publish\n                await this.negotiate({\n                    iceRestart: true\n                });\n            }\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$3(\"debug\", \"Restarting ICE connection\");\n            const signalingState = this.pc.signalingState;\n            if (this.isIceRestarting || signalingState === \"have-local-offer\") {\n                logger$3(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            await this.negotiate({\n                iceRestart: true\n            });\n        };\n        this.onNegotiationNeeded = async ()=>{\n            await this.negotiate();\n        };\n        /**\n         * Initiates a new offer/answer exchange with the currently connected SFU.\n         *\n         * @param options the optional offer options to use.\n         */ this.negotiate = async (options)=>{\n            this.isIceRestarting = options?.iceRestart ?? false;\n            const offer = await this.pc.createOffer(options);\n            let sdp = this.mungeCodecs(offer.sdp);\n            if (sdp && this.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n                const transceiver = this.transceiverRegistry[TrackType.SCREEN_SHARE_AUDIO];\n                if (transceiver && transceiver.sender.track) {\n                    const mid = transceiver.mid ?? this.extractMid(sdp, transceiver.sender.track, TrackType.SCREEN_SHARE_AUDIO);\n                    sdp = enableHighQualityAudio(sdp, mid);\n                }\n            }\n            // set the munged SDP back to the offer\n            offer.sdp = sdp;\n            const trackInfos = this.getCurrentTrackInfos(offer.sdp);\n            if (trackInfos.length === 0) {\n                throw new Error(`Can't initiate negotiation without announcing any tracks`);\n            }\n            await this.pc.setLocalDescription(offer);\n            const { response } = await this.sfuClient.setPublisher({\n                sdp: offer.sdp || \"\",\n                tracks: trackInfos\n            });\n            try {\n                await this.pc.setRemoteDescription({\n                    type: \"answer\",\n                    sdp: response.sdp\n                });\n            } catch (e) {\n                logger$3(\"error\", `setRemoteDescription error`, {\n                    sdp: response.sdp,\n                    error: e\n                });\n            }\n            this.isIceRestarting = false;\n            this.sfuClient.iceTrickleBuffer.publisherCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$3(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n        };\n        this.mungeCodecs = (sdp)=>{\n            if (sdp) {\n                sdp = toggleDtx(sdp, this.isDtxEnabled);\n            }\n            return sdp;\n        };\n        this.extractMid = (sdp, track, trackType)=>{\n            if (!sdp) {\n                logger$3(\"warn\", \"No SDP found. Returning empty mid\");\n                return \"\";\n            }\n            logger$3(\"debug\", `No 'mid' found for track. Trying to find it from the Offer SDP`);\n            const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n            const media = parsedSdp.media.find((m)=>{\n                return m.type === track.kind && // if `msid` is not present, we assume that the track is the first one\n                (m.msid?.includes(track.id) ?? true);\n            });\n            if (typeof media?.mid === \"undefined\") {\n                logger$3(\"debug\", `No mid found in SDP for track type ${track.kind} and id ${track.id}. Attempting to find a heuristic mid`);\n                const heuristicMid = this.transceiverInitOrder.indexOf(trackType);\n                if (heuristicMid !== -1) {\n                    return String(heuristicMid);\n                }\n                logger$3(\"debug\", \"No heuristic mid found. Returning empty mid\");\n                return \"\";\n            }\n            return String(media.mid);\n        };\n        this.getCurrentTrackInfos = (sdp)=>{\n            sdp = sdp || this.pc.localDescription?.sdp;\n            const { settings } = this.state;\n            const targetResolution = settings?.video.target_resolution;\n            return this.pc.getTransceivers().filter((t)=>t.direction === \"sendonly\" && t.sender.track).map((transceiver)=>{\n                const trackType = Number(Object.keys(this.transceiverRegistry).find((key)=>this.transceiverRegistry[key] === transceiver));\n                const track = transceiver.sender.track;\n                let optimalLayers;\n                if (track.readyState === \"live\") {\n                    const publishOpts = this.publishOptionsPerTrackType.get(trackType);\n                    optimalLayers = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, publishOpts?.screenShareSettings) : [];\n                    this.trackLayersCache[trackType] = optimalLayers;\n                } else {\n                    // we report the last known optimal layers for ended tracks\n                    optimalLayers = this.trackLayersCache[trackType] || [];\n                    logger$3(\"debug\", `Track ${TrackType[trackType]} is ended. Announcing last known optimal layers`, optimalLayers);\n                }\n                const layers = optimalLayers.map((optimalLayer)=>({\n                        rid: optimalLayer.rid || \"\",\n                        bitrate: optimalLayer.maxBitrate || 0,\n                        fps: optimalLayer.maxFramerate || 0,\n                        quality: this.ridToVideoQuality(optimalLayer.rid || \"\"),\n                        videoDimension: {\n                            width: optimalLayer.width,\n                            height: optimalLayer.height\n                        }\n                    }));\n                const isAudioTrack = [\n                    TrackType.AUDIO,\n                    TrackType.SCREEN_SHARE_AUDIO\n                ].includes(trackType);\n                const trackSettings = track.getSettings();\n                const isStereo = isAudioTrack && trackSettings.channelCount === 2;\n                return {\n                    trackId: track.id,\n                    layers: layers,\n                    trackType,\n                    mid: transceiver.mid ?? this.extractMid(sdp, track, trackType),\n                    stereo: isStereo,\n                    dtx: isAudioTrack && this.isDtxEnabled,\n                    red: isAudioTrack && this.isRedEnabled\n                };\n            });\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const iceState = this.pc.iceConnectionState;\n            const logLevel = iceState === \"connected\" || iceState === \"checking\" ? \"debug\" : \"warn\";\n            logger$3(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$3(\"debug\", `ICE Connection state changed to`, state);\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$3(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$3(\"error\", `ICE restart error`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$3(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$3(\"error\", `ICE restart error`, e);\n                        });\n                    } else {\n                        logger$3(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, this.iceRestartDelay);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$3(\"debug\", `ICE Gathering State`, this.pc.iceGatheringState);\n        };\n        this.onSignalingStateChange = ()=>{\n            logger$3(\"debug\", `Signaling state changed`, this.pc.signalingState);\n        };\n        this.ridToVideoQuality = (rid)=>{\n            return rid === \"q\" ? VideoQuality.LOW_UNSPECIFIED : rid === \"h\" ? VideoQuality.MID : VideoQuality.HIGH; // default to HIGH\n        };\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.isDtxEnabled = isDtxEnabled;\n        this.isRedEnabled = isRedEnabled;\n        this.iceRestartDelay = iceRestartDelay;\n        this.unsubscribeOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.PUBLISHER_UNSPECIFIED) return;\n            await this.restartIce();\n        });\n    }\n}\nconst logger$2 = getLogger([\n    \"Subscriber\"\n]);\n/**\n * A wrapper around the `RTCPeerConnection` that handles the incoming\n * media streams from the SFU.\n */ class Subscriber {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Subscriber` instance.\n     *\n     * @param sfuClient the SFU client to use.\n     * @param dispatcher the dispatcher to use.\n     * @param state the state of the call.\n     * @param connectionConfig the connection configuration to use.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE when connection goes to `disconnected` state.\n     */ constructor({ sfuClient, dispatcher, state, connectionConfig, iceRestartDelay = 2500 }){\n        this.isIceRestarting = false;\n        /**\n         * Creates a new `RTCPeerConnection` instance with the given configuration.\n         *\n         * @param connectionConfig the connection configuration to use.\n         */ this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"track\", this.handleOnTrack);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            return pc;\n        };\n        /**\n         * Closes the `RTCPeerConnection` and unsubscribes from the dispatcher.\n         */ this.close = ()=>{\n            clearTimeout(this.iceRestartTimeout);\n            this.unregisterOnSubscriberOffer();\n            this.unregisterOnIceRestart();\n            this.pc.close();\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Migrates the subscriber to a new SFU client.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = (sfuClient, connectionConfig)=>{\n            this.setSfuClient(sfuClient);\n            // when migrating, we want to keep the previous subscriber open\n            // until the new one is connected\n            const previousPC = this.pc;\n            // we keep a record of previously available video tracks\n            // so that we can monitor when they become available on the new\n            // subscriber and close the previous one.\n            const trackIdsToMigrate = new Set();\n            previousPC.getReceivers().forEach((r)=>{\n                if (r.track.kind === \"video\") {\n                    trackIdsToMigrate.add(r.track.id);\n                }\n            });\n            // set up a new subscriber peer connection, configured to connect\n            // to the new SFU node\n            const pc = this.createPeerConnection(connectionConfig);\n            let migrationTimeoutId;\n            const cleanupMigration = ()=>{\n                previousPC.close();\n                clearTimeout(migrationTimeoutId);\n            };\n            // When migrating, we want to keep track of the video tracks\n            // that are migrating to the new subscriber.\n            // Once all of them are available, we can close the previous subscriber.\n            const handleTrackMigration = (e)=>{\n                logger$2(\"debug\", `[Migration]: Migrated track: ${e.track.id}, ${e.track.kind}`);\n                trackIdsToMigrate.delete(e.track.id);\n                if (trackIdsToMigrate.size === 0) {\n                    logger$2(\"debug\", `[Migration]: Migration complete`);\n                    pc.removeEventListener(\"track\", handleTrackMigration);\n                    cleanupMigration();\n                }\n            };\n            // When migrating, we want to keep track of the connection state\n            // of the new subscriber.\n            // Once it is connected, we give it a 2-second grace period to receive\n            // all the video tracks that are migrating from the previous subscriber.\n            // After this threshold, we abruptly close the previous subscriber.\n            const handleConnectionStateChange = ()=>{\n                if (pc.connectionState === \"connected\") {\n                    migrationTimeoutId = setTimeout(()=>{\n                        pc.removeEventListener(\"track\", handleTrackMigration);\n                        cleanupMigration();\n                    }, 2000);\n                    pc.removeEventListener(\"connectionstatechange\", handleConnectionStateChange);\n                }\n            };\n            pc.addEventListener(\"track\", handleTrackMigration);\n            pc.addEventListener(\"connectionstatechange\", handleConnectionStateChange);\n            // replace the PeerConnection instance\n            this.pc = pc;\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$2(\"debug\", \"Restarting ICE connection\");\n            if (this.pc.signalingState === \"have-remote-offer\") {\n                logger$2(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            const previousIsIceRestarting = this.isIceRestarting;\n            try {\n                this.isIceRestarting = true;\n                await this.sfuClient.iceRestart({\n                    peerType: PeerType.SUBSCRIBER\n                });\n            } catch (e) {\n                // restore the previous state, as our intent for restarting ICE failed\n                this.isIceRestarting = previousIsIceRestarting;\n                throw e;\n            }\n        };\n        this.handleOnTrack = (e)=>{\n            const [primaryStream] = e.streams;\n            // example: `e3f6aaf8-b03d-4911-be36-83f47d37a76a:TRACK_TYPE_VIDEO`\n            const [trackId, trackType] = primaryStream.id.split(\":\");\n            const participantToUpdate = this.state.participants.find((p)=>p.trackLookupPrefix === trackId);\n            logger$2(\"debug\", `[onTrack]: Got remote ${trackType} track for userId: ${participantToUpdate?.userId}`, e.track.id, e.track);\n            if (!participantToUpdate) {\n                logger$2(\"error\", `[onTrack]: Received track for unknown participant: ${trackId}`, e);\n                return;\n            }\n            e.track.addEventListener(\"mute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track muted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"unmute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track unmuted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"ended\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track ended: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            const streamKindProp = {\n                TRACK_TYPE_AUDIO: \"audioStream\",\n                TRACK_TYPE_VIDEO: \"videoStream\",\n                TRACK_TYPE_SCREEN_SHARE: \"screenShareStream\",\n                TRACK_TYPE_SCREEN_SHARE_AUDIO: \"screenShareAudioStream\"\n            }[trackType];\n            if (!streamKindProp) {\n                logger$2(\"error\", `Unknown track type: ${trackType}`);\n                return;\n            }\n            const previousStream = participantToUpdate[streamKindProp];\n            if (previousStream) {\n                logger$2(\"info\", `[onTrack]: Cleaning up previous remote ${e.track.kind} tracks for userId: ${participantToUpdate.userId}`);\n                previousStream.getTracks().forEach((t)=>{\n                    t.stop();\n                    previousStream.removeTrack(t);\n                });\n            }\n            this.state.updateParticipant(participantToUpdate.sessionId, {\n                [streamKindProp]: primaryStream\n            });\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$2(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.SUBSCRIBER\n            });\n        };\n        this.negotiate = async (subscriberOffer)=>{\n            logger$2(\"info\", `Received subscriberOffer`, subscriberOffer);\n            await this.pc.setRemoteDescription({\n                type: \"offer\",\n                sdp: subscriberOffer.sdp\n            });\n            this.sfuClient.iceTrickleBuffer.subscriberCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$2(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n            const answer = await this.pc.createAnswer();\n            await this.pc.setLocalDescription(answer);\n            await this.sfuClient.sendAnswer({\n                peerType: PeerType.SUBSCRIBER,\n                sdp: answer.sdp || \"\"\n            });\n            this.isIceRestarting = false;\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$2(\"debug\", `ICE connection state changed`, state);\n            // do nothing when ICE is restarting\n            if (this.isIceRestarting) return;\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$2(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$2(\"error\", `ICE restart failed`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$2(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$2(\"error\", `ICE restart failed`, e);\n                        });\n                    } else {\n                        logger$2(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, 5000);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$2(\"debug\", `ICE gathering state changed`, this.pc.iceGatheringState);\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const iceState = this.pc.iceConnectionState;\n            const logLevel = iceState === \"connected\" || iceState === \"checking\" ? \"debug\" : \"warn\";\n            logger$2(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.iceRestartDelay = iceRestartDelay;\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.unregisterOnSubscriberOffer = dispatcher.on(\"subscriberOffer\", async (subscriberOffer)=>{\n            await this.negotiate(subscriberOffer);\n        });\n        this.unregisterOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.SUBSCRIBER) return;\n            await this.restartIce();\n        });\n    }\n}\nconst createWebSocketSignalChannel = (opts)=>{\n    const logger = getLogger([\n        \"sfu-client\"\n    ]);\n    const { endpoint, onMessage } = opts;\n    const ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(endpoint);\n    ws.binaryType = \"arraybuffer\"; // do we need this?\n    ws.addEventListener(\"error\", (e)=>{\n        logger(\"error\", \"Signaling WS channel error\", e);\n    });\n    ws.addEventListener(\"close\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is closed\", e);\n    });\n    ws.addEventListener(\"open\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is open\", e);\n    });\n    ws.addEventListener(\"message\", (e)=>{\n        try {\n            const message = e.data instanceof ArrayBuffer ? SfuEvent.fromBinary(new Uint8Array(e.data)) : SfuEvent.fromJsonString(e.data.toString());\n            onMessage(message);\n        } catch (err) {\n            logger(\"error\", \"Failed to decode a message. Check whether the Proto models match.\", {\n                event: e,\n                error: err\n            });\n        }\n    });\n    return ws;\n};\nconst sleep = (m)=>new Promise((r)=>setTimeout(r, m));\nfunction isFunction(value) {\n    return value && (Object.prototype.toString.call(value) === \"[object Function]\" || \"function\" === typeof value || value instanceof Function);\n}\n/**\n * A map of known error codes.\n */ const KnownCodes = {\n    TOKEN_EXPIRED: 40,\n    WS_CLOSED_SUCCESS: 1000,\n    WS_CLOSED_ABRUPTLY: 1006,\n    WS_POLICY_VIOLATION: 1008\n};\n/**\n * retryInterval - A retry interval which increases acc to number of failures\n *\n * @return {number} Duration to wait in milliseconds\n */ function retryInterval(numberOfFailures) {\n    // try to reconnect in 0.25-5 seconds (random to spread out the load from failures)\n    const max = Math.min(500 + numberOfFailures * 2000, 5000);\n    const min = Math.min(Math.max(250, (numberOfFailures - 1) * 2000), 5000);\n    return Math.floor(Math.random() * (max - min) + min);\n}\nfunction randomId() {\n    return generateUUIDv4();\n}\nfunction hex(bytes) {\n    let s = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        s += bytes[i].toString(16).padStart(2, \"0\");\n    }\n    return s;\n}\n// https://tools.ietf.org/html/rfc4122\nfunction generateUUIDv4() {\n    const bytes = getRandomBytes(16);\n    bytes[6] = bytes[6] & 0x0f | 0x40; // version\n    bytes[8] = bytes[8] & 0xbf | 0x80; // variant\n    return hex(bytes.subarray(0, 4)) + \"-\" + hex(bytes.subarray(4, 6)) + \"-\" + hex(bytes.subarray(6, 8)) + \"-\" + hex(bytes.subarray(8, 10)) + \"-\" + hex(bytes.subarray(10, 16));\n}\nfunction getRandomValuesWithMathRandom(bytes) {\n    const max = Math.pow(2, 8 * bytes.byteLength / bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Math.random() * max;\n    }\n}\nconst getRandomValues = (()=>{\n    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues !== \"undefined\") {\n        return crypto.getRandomValues.bind(crypto);\n    } else if (typeof msCrypto !== \"undefined\") {\n        return msCrypto.getRandomValues.bind(msCrypto);\n    } else {\n        return getRandomValuesWithMathRandom;\n    }\n})();\nfunction getRandomBytes(length) {\n    const bytes = new Uint8Array(length);\n    getRandomValues(bytes);\n    return bytes;\n}\nfunction convertErrorToJson(err) {\n    const jsonObj = {};\n    if (!err) return jsonObj;\n    try {\n        Object.getOwnPropertyNames(err).forEach((key)=>{\n            jsonObj[key] = Object.getOwnPropertyDescriptor(err, key);\n        });\n    } catch (_) {\n        return {\n            error: \"failed to serialize the error\"\n        };\n    }\n    return jsonObj;\n}\n/**\n * isOnline safely return the navigator.online value for browser env\n * if navigator is not in global object, it always return true\n */ function isOnline(logger) {\n    const nav = typeof navigator !== \"undefined\" ? navigator :  false ? 0 : undefined;\n    if (!nav) {\n        logger(\"warn\", \"isOnline failed to access window.navigator and assume browser is online\");\n        return true;\n    }\n    // RN navigator has undefined for onLine\n    if (typeof nav.onLine !== \"boolean\") {\n        return true;\n    }\n    return nav.onLine;\n}\n/**\n * listenForConnectionChanges - Adds an event listener fired on browser going online or offline\n */ function addConnectionEventListeners(cb) {\n    if (false) {}\n}\nfunction removeConnectionEventListeners(cb) {\n    if (false) {}\n}\n/**\n * The client used for exchanging information with the SFU.\n */ class StreamSfuClient {\n    /**\n     * Constructs a new SFU client.\n     *\n     * @param dispatcher the event dispatcher to use.\n     * @param sfuServer the SFU server to connect to.\n     * @param token the JWT token to use for authentication.\n     * @param sessionId the `sessionId` of the currently connected participant.\n     */ constructor({ dispatcher, sfuServer, token, sessionId }){\n        /**\n         * A buffer for ICE Candidates that are received before\n         * the PeerConnections are ready to handle them.\n         */ this.iceTrickleBuffer = new IceTrickleBuffer();\n        /**\n         * A flag indicating whether the client is currently migrating away\n         * from this SFU.\n         */ this.isMigratingAway = false;\n        /**\n         * A flag indicating that the client connection is broken for the current\n         * client and that a fast-reconnect with a new client should be attempted.\n         */ this.isFastReconnecting = false;\n        this.pingIntervalInMs = 10 * 1000;\n        this.unhealthyTimeoutInMs = this.pingIntervalInMs + 5 * 1000;\n        this.close = (code, reason)=>{\n            this.logger(\"debug\", `Closing SFU WS connection: ${code} - ${reason}`);\n            if (this.signalWs.readyState !== this.signalWs.CLOSED) {\n                this.signalWs.close(code, `js-client: ${reason}`);\n            }\n            this.unsubscribeIceTrickle();\n            clearInterval(this.keepAliveInterval);\n            clearTimeout(this.connectionCheckTimeout);\n        };\n        this.updateSubscriptions = async (subscriptions)=>{\n            return retryable(()=>this.rpc.updateSubscriptions({\n                    sessionId: this.sessionId,\n                    tracks: subscriptions\n                }), this.logger);\n        };\n        this.setPublisher = async (data)=>{\n            return retryable(()=>this.rpc.setPublisher({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.sendAnswer = async (data)=>{\n            return retryable(()=>this.rpc.sendAnswer({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceTrickle = async (data)=>{\n            return retryable(()=>this.rpc.iceTrickle({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceRestart = async (data)=>{\n            return retryable(()=>this.rpc.iceRestart({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.updateMuteState = async (trackType, muted)=>{\n            return this.updateMuteStates({\n                muteStates: [\n                    {\n                        trackType,\n                        muted\n                    }\n                ]\n            });\n        };\n        this.updateMuteStates = async (data)=>{\n            return retryable(()=>this.rpc.updateMuteStates({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.sendStats = async (stats)=>{\n            return retryable(()=>this.rpc.sendStats({\n                    ...stats,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.join = async (data)=>{\n            const joinRequest = JoinRequest.create({\n                ...data,\n                sessionId: this.sessionId,\n                token: this.token\n            });\n            return this.send(SfuRequest.create({\n                requestPayload: {\n                    oneofKind: \"joinRequest\",\n                    joinRequest\n                }\n            }));\n        };\n        this.send = async (message)=>{\n            return this.signalReady.then((signal)=>{\n                if (signal.readyState !== signal.OPEN) return;\n                this.logger(\"debug\", `Sending message to: ${this.edgeName}`, SfuRequest.toJson(message));\n                signal.send(SfuRequest.toBinary(message));\n            });\n        };\n        this.keepAlive = ()=>{\n            clearInterval(this.keepAliveInterval);\n            this.keepAliveInterval = setInterval(()=>{\n                this.logger(\"trace\", \"Sending healthCheckRequest to SFU\");\n                const message = SfuRequest.create({\n                    requestPayload: {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: {}\n                    }\n                });\n                this.send(message).catch((e)=>{\n                    this.logger(\"error\", \"Error sending healthCheckRequest to SFU\", e);\n                });\n            }, this.pingIntervalInMs);\n        };\n        this.scheduleConnectionCheck = ()=>{\n            clearTimeout(this.connectionCheckTimeout);\n            this.connectionCheckTimeout = setTimeout(()=>{\n                if (this.lastMessageTimestamp) {\n                    const timeSinceLastMessage = new Date().getTime() - this.lastMessageTimestamp.getTime();\n                    if (timeSinceLastMessage > this.unhealthyTimeoutInMs) {\n                        this.close(StreamSfuClient.ERROR_CONNECTION_UNHEALTHY, `SFU connection unhealthy. Didn't receive any message for ${this.unhealthyTimeoutInMs}ms`);\n                    }\n                }\n            }, this.unhealthyTimeoutInMs);\n        };\n        this.sessionId = sessionId || generateUUIDv4();\n        this.sfuServer = sfuServer;\n        this.edgeName = sfuServer.edge_name;\n        this.token = token;\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        const logInterceptor = {\n            interceptUnary: (next, method, input, options)=>{\n                this.logger(\"trace\", `Calling SFU RPC method ${method.name}`, {\n                    input,\n                    options\n                });\n                return next(method, input, options);\n            }\n        };\n        this.rpc = createSignalClient({\n            baseUrl: sfuServer.url,\n            interceptors: [\n                withHeaders({\n                    Authorization: `Bearer ${token}`\n                }),\n                logInterceptor\n            ]\n        });\n        // Special handling for the ICETrickle kind of events.\n        // These events might be triggered by the SFU before the initial RTC\n        // connection is established. In that case, those events (ICE candidates)\n        // need to be buffered and later added to the appropriate PeerConnection\n        // once the remoteDescription is known and set.\n        this.unsubscribeIceTrickle = dispatcher.on(\"iceTrickle\", (iceTrickle)=>{\n            this.iceTrickleBuffer.push(iceTrickle);\n        });\n        this.signalWs = createWebSocketSignalChannel({\n            endpoint: sfuServer.ws_endpoint,\n            onMessage: (message)=>{\n                this.lastMessageTimestamp = new Date();\n                this.scheduleConnectionCheck();\n                dispatcher.dispatch(message);\n            }\n        });\n        this.signalReady = new Promise((resolve)=>{\n            const onOpen = ()=>{\n                this.signalWs.removeEventListener(\"open\", onOpen);\n                this.keepAlive();\n                resolve(this.signalWs);\n            };\n            this.signalWs.addEventListener(\"open\", onOpen);\n        });\n    }\n}\n/**\n * The normal closure code. Used for controlled shutdowns.\n */ StreamSfuClient.NORMAL_CLOSURE = 1000;\n/**\n * The error code used when the SFU connection is unhealthy.\n * Usually, this means that no message has been received from the SFU for\n * a certain amount of time (`connectionCheckTimeout`).\n */ StreamSfuClient.ERROR_CONNECTION_UNHEALTHY = 4001;\n/**\n * The error code used when the SFU connection is broken.\n * Usually, this means that the WS connection has been closed unexpectedly.\n * This error code is used to announce a fast-reconnect.\n */ StreamSfuClient.ERROR_CONNECTION_BROKEN = 4002; // used in fast-reconnects\nconst MAX_RETRIES = 5;\n/**\n * Creates a closure which wraps the given RPC call and retries invoking\n * the RPC until it succeeds or the maximum number of retries is reached.\n *\n * Between each retry, there would be a random delay in order to avoid\n * request bursts towards the SFU.\n *\n * @param rpc the closure around the RPC call to execute.\n * @param logger a logger instance to use.\n * @param <I> the type of the request object.\n * @param <O> the type of the response object.\n */ const retryable = async (rpc, logger)=>{\n    let retryAttempt = 0;\n    let rpcCallResult;\n    do {\n        // don't delay the first invocation\n        if (retryAttempt > 0) {\n            await sleep(retryInterval(retryAttempt));\n        }\n        rpcCallResult = await rpc();\n        logger(\"trace\", `SFU RPC response received for ${rpcCallResult.method.name}`, rpcCallResult);\n        // if the RPC call failed, log the error and retry\n        if (rpcCallResult.response.error) {\n            logger(\"error\", `SFU RPC Error (${rpcCallResult.method.name}):`, rpcCallResult.response.error);\n        }\n        retryAttempt++;\n    }while (rpcCallResult.response.error?.shouldRetry && retryAttempt < MAX_RETRIES);\n    if (rpcCallResult.response.error) {\n        throw rpcCallResult.response.error;\n    }\n    return rpcCallResult;\n};\n/**\n * Event handler that watched the delivery of `call.accepted`.\n * Once the event is received, the call is joined.\n */ const watchCallAccepted = (call)=>{\n    return async function onCallAccepted(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { state } = call;\n        if (event.call.created_by.id === call.currentUserId && state.callingState === CallingState.RINGING) {\n            await call.join();\n        }\n    };\n};\n/**\n * Event handler that watches delivery of `call.rejected` Websocket event.\n * Once the event is received, the call is left.\n */ const watchCallRejected = (call)=>{\n    return async function onCallRejected(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { call: eventCall } = event;\n        const { session: callSession } = eventCall;\n        if (!callSession) {\n            call.logger(\"warn\", \"No call session provided. Ignoring call.rejected event.\", event);\n            return;\n        }\n        const rejectedBy = callSession.rejected_by;\n        const { members, callingState } = call.state;\n        if (callingState !== CallingState.RINGING) {\n            call.logger(\"info\", \"Call is not in ringing mode (it is either accepted or rejected already). Ignoring call.rejected event.\", event);\n            return;\n        }\n        if (call.isCreatedByMe) {\n            const everyoneElseRejected = members.filter((m)=>m.user_id !== call.currentUserId).every((m)=>rejectedBy[m.user_id]);\n            if (everyoneElseRejected) {\n                call.logger(\"info\", \"everyone rejected, leaving the call\");\n                await call.leave({\n                    reason: \"ring: everyone rejected\"\n                });\n            }\n        } else {\n            if (rejectedBy[eventCall.created_by.id]) {\n                call.logger(\"info\", \"call creator rejected, leaving call\");\n                await call.leave({\n                    reason: \"ring: creator rejected\"\n                });\n            }\n        }\n    };\n};\n/**\n * Event handler that watches the delivery of `call.ended` Websocket event.\n */ const watchCallEnded = (call)=>{\n    return async function onCallEnded() {\n        const { callingState } = call.state;\n        if (callingState === CallingState.RINGING || callingState === CallingState.JOINED || callingState === CallingState.JOINING) {\n            await call.leave({\n                reason: \"call.ended event received\"\n            });\n        }\n    };\n};\n/**\n * Event handler that watches for `callGrantsUpdated` events.\n *\n * @param state the call state to update.\n */ const watchCallGrantsUpdated = (state)=>{\n    return function onCallGrantsUpdated(event) {\n        const { currentGrants } = event;\n        if (currentGrants) {\n            const { canPublishAudio, canPublishVideo, canScreenshare } = currentGrants;\n            const update = {\n                [OwnCapability.SEND_AUDIO]: canPublishAudio,\n                [OwnCapability.SEND_VIDEO]: canPublishVideo,\n                [OwnCapability.SCREENSHARE]: canScreenshare\n            };\n            const nextCapabilities = state.ownCapabilities.filter((capability)=>update[capability] !== false);\n            Object.entries(update).forEach(([capability, value])=>{\n                if (value && !nextCapabilities.includes(capability)) {\n                    nextCapabilities.push(capability);\n                }\n            });\n            state.setOwnCapabilities(nextCapabilities);\n        }\n    };\n};\nconst logger$1 = getLogger([\n    \"events\"\n]);\n/**\n * An event responder which handles the `changePublishQuality` event.\n */ const watchChangePublishQuality = (dispatcher, call)=>{\n    return dispatcher.on(\"changePublishQuality\", (e)=>{\n        const { videoSenders } = e;\n        videoSenders.forEach((videoSender)=>{\n            const { layers } = videoSender;\n            call.updatePublishQuality(layers.filter((l)=>l.active));\n        });\n    });\n};\nconst watchConnectionQualityChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"connectionQualityChanged\", (e)=>{\n        const { connectionQualityUpdates } = e;\n        if (!connectionQualityUpdates) return;\n        state.updateParticipants(connectionQualityUpdates.reduce((patches, update)=>{\n            const { sessionId, connectionQuality } = update;\n            patches[sessionId] = {\n                connectionQuality\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Updates the approximate number of participants in the call by peeking at the\n * health check events that our SFU sends.\n */ const watchParticipantCountChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"healthCheckResponse\", (e)=>{\n        const { participantCount } = e;\n        if (participantCount) {\n            state.setParticipantCount(participantCount.total);\n            state.setAnonymousParticipantCount(participantCount.anonymous);\n        }\n    });\n};\nconst watchLiveEnded = (dispatcher, call)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (e.error && e.error.code !== ErrorCode.LIVE_ENDED) return;\n        if (!call.permissionsContext.hasPermission(OwnCapability.JOIN_BACKSTAGE)) {\n            call.leave({\n                reason: \"live ended\"\n            }).catch((err)=>{\n                logger$1(\"error\", \"Failed to leave call after live ended\", err);\n            });\n        }\n    });\n};\n/**\n * Watches and logs the errors reported by the currently connected SFU.\n */ const watchSfuErrorReports = (dispatcher)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (!e.error) return;\n        const { error } = e;\n        logger$1(\"error\", \"SFU reported error\", {\n            code: ErrorCode[error.code],\n            message: error.message,\n            shouldRetry: error.shouldRetry\n        });\n    });\n};\n/**\n * Watches for `pinsUpdated` events and updates the pinned state of participants\n * in the call.\n */ const watchPinsUpdated = (state)=>{\n    return function onPinsUpdated(e) {\n        const { pins } = e;\n        state.setServerSidePins(pins);\n    };\n};\n/**\n * An event handler that handles soft mutes.\n *\n * @param call the call.\n */ const handleRemoteSoftMute = (call)=>{\n    return call.on(\"trackUnpublished\", async (event)=>{\n        const { cause, type, sessionId } = event;\n        const { localParticipant } = call.state;\n        if (cause === TrackUnpublishReason.MODERATION && sessionId === localParticipant?.sessionId) {\n            const logger = call.logger;\n            logger(\"info\", `Local participant's ${TrackType[type]} track is muted remotely`);\n            try {\n                if (type === TrackType.VIDEO) {\n                    await call.camera.disable();\n                } else if (type === TrackType.AUDIO) {\n                    await call.microphone.disable();\n                } else {\n                    logger(\"warn\", \"Unsupported track type to soft mute\", TrackType[type]);\n                }\n                if (call.publisher?.isPublishing(type)) {\n                    await call.stopPublish(type);\n                }\n            } catch (error) {\n                logger(\"error\", \"Failed to stop publishing\", error);\n            }\n        }\n    });\n};\n/**\n * An event responder which handles the `participantJoined` event.\n */ const watchParticipantJoined = (state)=>{\n    return function onParticipantJoined(e) {\n        const { participant } = e;\n        if (!participant) return;\n        // `state.updateOrAddParticipant` acts as a safeguard against\n        // potential duplicate events from the SFU.\n        //\n        // Although the SFU should not send duplicate events, we have seen\n        // some race conditions in the past during the `join-flow` where\n        // the SFU would send participant info as part of the `join`\n        // response and then follow up with a `participantJoined` event for\n        // already announced participants.\n        state.updateOrAddParticipant(participant.sessionId, Object.assign(participant, {\n            viewportVisibilityState: {\n                videoTrack: VisibilityState.UNKNOWN,\n                screenShareTrack: VisibilityState.UNKNOWN\n            }\n        }));\n    };\n};\n/**\n * An event responder which handles the `participantLeft` event.\n */ const watchParticipantLeft = (state)=>{\n    return function onParticipantLeft(e) {\n        const { participant } = e;\n        if (!participant) return;\n        state.setParticipants((participants)=>participants.filter((p)=>p.sessionId !== participant.sessionId));\n    };\n};\n/**\n * An event responder which handles the `trackPublished` event.\n * The SFU will send this event when a participant publishes a track.\n */ const watchTrackPublished = (state)=>{\n    return function onTrackPublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls.\n        // After a certain threshold, the SFU would stop emitting `participantJoined`\n        // events, and instead, it would only provide the participant's information\n        // once they start publishing a track.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: [\n                        ...p.publishedTracks,\n                        type\n                    ].filter(unique)\n                }));\n        }\n    };\n};\n/**\n * An event responder which handles the `trackUnpublished` event.\n * The SFU will send this event when a participant unpublishes a track.\n */ const watchTrackUnpublished = (state)=>{\n    return function onTrackUnpublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls. See `watchTrackPublished`.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: p.publishedTracks.filter((t)=>t !== type)\n                }));\n        }\n    };\n};\nconst unique = (v, i, arr)=>arr.indexOf(v) === i;\n/**\n * Watches for `dominantSpeakerChanged` events.\n */ const watchDominantSpeakerChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"dominantSpeakerChanged\", (e)=>{\n        const { sessionId } = e;\n        if (sessionId === state.dominantSpeaker?.sessionId) return;\n        state.setParticipants((participants)=>participants.map((participant)=>{\n                // mark the new dominant speaker\n                if (participant.sessionId === sessionId) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: true\n                    };\n                }\n                // unmark the old dominant speaker\n                if (participant.isDominantSpeaker) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: false\n                    };\n                }\n                return participant; // no change\n            }));\n    });\n};\n/**\n * Watches for `audioLevelChanged` events.\n */ const watchAudioLevelChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"audioLevelChanged\", (e)=>{\n        const { audioLevels } = e;\n        state.updateParticipants(audioLevels.reduce((patches, current)=>{\n            patches[current.sessionId] = {\n                audioLevel: current.level,\n                isSpeaking: current.isSpeaking\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Registers the default event handlers for a call during its lifecycle.\n *\n * @param call the call to register event handlers for.\n * @param state the call state.\n * @param dispatcher the dispatcher.\n */ const registerEventHandlers = (call, state, dispatcher)=>{\n    const eventHandlers = [\n        call.on(\"call.ended\", watchCallEnded(call)),\n        watchLiveEnded(dispatcher, call),\n        watchSfuErrorReports(dispatcher),\n        watchChangePublishQuality(dispatcher, call),\n        watchConnectionQualityChanged(dispatcher, state),\n        watchParticipantCountChanged(dispatcher, state),\n        call.on(\"participantJoined\", watchParticipantJoined(state)),\n        call.on(\"participantLeft\", watchParticipantLeft(state)),\n        call.on(\"trackPublished\", watchTrackPublished(state)),\n        call.on(\"trackUnpublished\", watchTrackUnpublished(state)),\n        watchAudioLevelChanged(dispatcher, state),\n        watchDominantSpeakerChanged(dispatcher, state),\n        call.on(\"callGrantsUpdated\", watchCallGrantsUpdated(state)),\n        call.on(\"pinsUpdated\", watchPinsUpdated(state)),\n        handleRemoteSoftMute(call)\n    ];\n    if (call.ringing) {\n        // these events are only relevant when the call is ringing\n        eventHandlers.push(registerRingingCallEventHandlers(call));\n    }\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Registers event handlers for a call that is of ringing type.\n *\n * @param call the call to register event handlers for.\n */ const registerRingingCallEventHandlers = (call)=>{\n    const coordinatorRingEvents = {\n        \"call.accepted\": watchCallAccepted(call),\n        \"call.rejected\": watchCallRejected(call)\n    };\n    const eventHandlers = Object.keys(coordinatorRingEvents).map((event)=>{\n        const eventName = event;\n        return call.on(eventName, coordinatorRingEvents[eventName]);\n    });\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Collects all necessary information to join a call, talks to the coordinator\n * and returns the necessary information to join the call.\n *\n * @param httpClient the http client to use.\n * @param type the type of the call.\n * @param id the id of the call.\n * @param data the data for the call.\n */ const join = async (httpClient, type, id, data)=>{\n    const { call, credentials, members, own_capabilities, stats_options } = await doJoin(httpClient, type, id, data);\n    return {\n        connectionConfig: toRtcConfiguration(credentials.ice_servers),\n        sfuServer: credentials.server,\n        token: credentials.token,\n        metadata: call,\n        members,\n        ownCapabilities: own_capabilities,\n        statsOptions: stats_options\n    };\n};\nconst doJoin = async (httpClient, type, id, data)=>{\n    const location = await httpClient.getLocationHint();\n    const request = {\n        ...data,\n        location\n    };\n    return httpClient.post(`/call/${type}/${id}/join`, request);\n};\nconst toRtcConfiguration = (config)=>{\n    if (!config || config.length === 0) return undefined;\n    const rtcConfig = {\n        iceServers: config.map((ice)=>({\n                urls: ice.urls,\n                username: ice.username,\n                credential: ice.password\n            }))\n    };\n    return rtcConfig;\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten$1 = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\nconst getSdkSignature = (clientDetails)=>{\n    const { sdk, ...platform } = clientDetails;\n    const sdkName = sdk && sdk.type === SdkType.REACT ? \"stream-react\" : sdk && sdk.type === SdkType.REACT_NATIVE ? \"stream-react-native\" : \"stream-js\";\n    const sdkVersion = sdk ? `${sdk.major}.${sdk.minor}.${sdk.patch}` : \"0.0.0-development\";\n    return {\n        sdkName,\n        sdkVersion,\n        ...platform\n    };\n};\n/**\n * Creates a new StatsReporter instance that collects metrics about the ongoing call and reports them to the state store\n */ const createStatsReporter = ({ subscriber, publisher, state, pollingIntervalInMs = 2000 })=>{\n    const logger = getLogger([\n        \"stats\"\n    ]);\n    const getRawStatsForTrack = async (kind, selector)=>{\n        if (kind === \"subscriber\" && subscriber) {\n            return subscriber.getStats(selector);\n        } else if (kind === \"publisher\" && publisher) {\n            return publisher.getStats(selector);\n        } else {\n            logger(\"warn\", `Can't retrieve RTC stats for ${kind}`);\n            return undefined;\n        }\n    };\n    const getStatsForStream = async (kind, mediaStream)=>{\n        const pc = kind === \"subscriber\" ? subscriber : publisher;\n        const statsForStream = [];\n        for (let track of mediaStream.getTracks()){\n            const report = await pc.getStats(track);\n            const stats = transform(report, {\n                // @ts-ignore\n                trackKind: track.kind,\n                kind\n            });\n            statsForStream.push(stats);\n        }\n        return statsForStream;\n    };\n    const startReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.add(sessionId);\n        void run();\n    };\n    const stopReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.delete(sessionId);\n        void run();\n    };\n    const sessionIdsToTrack = new Set();\n    /**\n     * The main stats reporting loop.\n     */ const run = async ()=>{\n        const participantStats = {};\n        const sessionIds = new Set(sessionIdsToTrack);\n        if (sessionIds.size > 0) {\n            for (let participant of state.participants){\n                if (!sessionIds.has(participant.sessionId)) continue;\n                const kind = participant.isLocalParticipant ? \"publisher\" : \"subscriber\";\n                try {\n                    const mergedStream = new MediaStream([\n                        ...participant.videoStream?.getVideoTracks() || [],\n                        ...participant.audioStream?.getAudioTracks() || []\n                    ]);\n                    participantStats[participant.sessionId] = await getStatsForStream(kind, mergedStream);\n                    mergedStream.getTracks().forEach((t)=>{\n                        mergedStream.removeTrack(t);\n                    });\n                } catch (e) {\n                    logger(\"error\", `Failed to collect stats for ${kind} if ${participant.userId}`, e);\n                }\n            }\n        }\n        const [subscriberStats, publisherStats] = await Promise.all([\n            subscriber.getStats().then((report)=>transform(report, {\n                    kind: \"subscriber\",\n                    trackKind: \"video\"\n                })).then(aggregate),\n            publisher.getStats().then((report)=>transform(report, {\n                    kind: \"publisher\",\n                    trackKind: \"video\"\n                })).then(aggregate)\n        ]);\n        const [subscriberRawStats, publisherRawStats] = await Promise.all([\n            getRawStatsForTrack(\"subscriber\"),\n            getRawStatsForTrack(\"publisher\")\n        ]);\n        state.setCallStatsReport({\n            datacenter: publisher.sfuClient.edgeName,\n            publisherStats,\n            subscriberStats,\n            subscriberRawStats,\n            publisherRawStats,\n            participants: participantStats,\n            timestamp: Date.now()\n        });\n    };\n    let timeoutId;\n    if (pollingIntervalInMs > 0) {\n        const loop = async ()=>{\n            await run().catch((e)=>{\n                logger(\"debug\", \"Failed to collect stats\", e);\n            });\n            timeoutId = setTimeout(loop, pollingIntervalInMs);\n        };\n        void loop();\n    }\n    const stop = ()=>{\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n    };\n    return {\n        getRawStatsForTrack,\n        getStatsForStream,\n        startReportingStatsFor,\n        stopReportingStatsFor,\n        stop\n    };\n};\n/**\n * Transforms raw RTC stats into a slimmer and uniform across browsers format.\n *\n * @param report the report to transform.\n * @param opts the transform options.\n */ const transform = (report, opts)=>{\n    const { trackKind, kind } = opts;\n    const direction = kind === \"subscriber\" ? \"inbound-rtp\" : \"outbound-rtp\";\n    const stats = flatten$1(report);\n    const streams = stats.filter((stat)=>stat.type === direction && stat.kind === trackKind).map((stat)=>{\n        const rtcStreamStats = stat;\n        const codec = stats.find((s)=>s.type === \"codec\" && s.id === rtcStreamStats.codecId); // FIXME OL: incorrect type!\n        const transport = stats.find((s)=>s.type === \"transport\" && s.id === rtcStreamStats.transportId);\n        let roundTripTime;\n        if (transport && transport.dtlsState === \"connected\") {\n            const candidatePair = stats.find((s)=>s.type === \"candidate-pair\" && s.id === transport.selectedCandidatePairId);\n            roundTripTime = candidatePair?.currentRoundTripTime;\n        }\n        return {\n            bytesSent: rtcStreamStats.bytesSent,\n            bytesReceived: rtcStreamStats.bytesReceived,\n            codec: codec?.mimeType,\n            currentRoundTripTime: roundTripTime,\n            frameHeight: rtcStreamStats.frameHeight,\n            frameWidth: rtcStreamStats.frameWidth,\n            framesPerSecond: rtcStreamStats.framesPerSecond,\n            jitter: rtcStreamStats.jitter,\n            kind: rtcStreamStats.kind,\n            // @ts-ignore: available in Chrome only, TS doesn't recognize this\n            qualityLimitationReason: rtcStreamStats.qualityLimitationReason,\n            rid: rtcStreamStats.rid,\n            ssrc: rtcStreamStats.ssrc\n        };\n    });\n    return {\n        rawStats: report,\n        streams,\n        timestamp: Date.now()\n    };\n};\n/**\n * Aggregates generic stats.\n *\n * @param stats the stats to aggregate.\n */ const aggregate = (stats)=>{\n    const aggregatedStats = {\n        rawReport: stats,\n        totalBytesSent: 0,\n        totalBytesReceived: 0,\n        averageJitterInMs: 0,\n        averageRoundTripTimeInMs: 0,\n        qualityLimitationReasons: \"none\",\n        highestFrameWidth: 0,\n        highestFrameHeight: 0,\n        highestFramesPerSecond: 0,\n        timestamp: Date.now()\n    };\n    let maxArea = -1;\n    const area = (w, h)=>w * h;\n    const qualityLimitationReasons = new Set();\n    const streams = stats.streams;\n    const report = streams.reduce((acc, stream)=>{\n        acc.totalBytesSent += stream.bytesSent || 0;\n        acc.totalBytesReceived += stream.bytesReceived || 0;\n        acc.averageJitterInMs += stream.jitter || 0;\n        acc.averageRoundTripTimeInMs += stream.currentRoundTripTime || 0;\n        // naive calculation of the highest resolution\n        const streamArea = area(stream.frameWidth || 0, stream.frameHeight || 0);\n        if (streamArea > maxArea) {\n            acc.highestFrameWidth = stream.frameWidth || 0;\n            acc.highestFrameHeight = stream.frameHeight || 0;\n            acc.highestFramesPerSecond = stream.framesPerSecond || 0;\n            maxArea = streamArea;\n        }\n        qualityLimitationReasons.add(stream.qualityLimitationReason || \"\");\n        return acc;\n    }, aggregatedStats);\n    if (streams.length > 0) {\n        report.averageJitterInMs = Math.round(report.averageJitterInMs / streams.length * 1000);\n        report.averageRoundTripTimeInMs = Math.round(report.averageRoundTripTimeInMs / streams.length * 1000);\n    }\n    const qualityLimitationReason = [\n        qualityLimitationReasons.has(\"cpu\") && \"cpu\",\n        qualityLimitationReasons.has(\"bandwidth\") && \"bandwidth\",\n        qualityLimitationReasons.has(\"other\") && \"other\"\n    ].filter(Boolean).join(\", \");\n    if (qualityLimitationReason) {\n        report.qualityLimitationReasons = qualityLimitationReason;\n    }\n    return report;\n};\nclass SfuStatsReporter {\n    constructor(sfuClient, { options, clientDetails, subscriber, publisher }){\n        this.logger = getLogger([\n            \"SfuStatsReporter\"\n        ]);\n        this.run = async ()=>{\n            const [subscriberStats, publisherStats] = await Promise.all([\n                this.subscriber.getStats().then(flatten$1).then(JSON.stringify),\n                this.publisher.getStats().then(flatten$1).then(JSON.stringify)\n            ]);\n            await this.sfuClient.sendStats({\n                sdk: this.sdkName,\n                sdkVersion: this.sdkVersion,\n                webrtcVersion: this.webRTCVersion,\n                subscriberStats,\n                publisherStats\n            });\n        };\n        this.start = ()=>{\n            if (this.options.reporting_interval_ms <= 0) return;\n            this.intervalId = setInterval(()=>{\n                this.run().catch((err)=>{\n                    this.logger(\"warn\", \"Failed to report stats\", err);\n                });\n            }, this.options.reporting_interval_ms);\n        };\n        this.stop = ()=>{\n            clearInterval(this.intervalId);\n            this.intervalId = undefined;\n        };\n        this.sfuClient = sfuClient;\n        this.options = options;\n        this.subscriber = subscriber;\n        this.publisher = publisher;\n        const webRTCInfo = getWebRTCInfo();\n        const { sdk, browser } = clientDetails;\n        this.sdkName = sdk && sdk.type === SdkType.REACT ? \"stream-react\" : sdk && sdk.type === SdkType.REACT_NATIVE ? \"stream-react-native\" : \"stream-js\";\n        this.sdkVersion = sdk ? `${sdk.major}.${sdk.minor}.${sdk.patch}` : \"0.0.0-development\";\n        // The WebRTC version if passed from the SDK, it is taken else the browser info is sent.\n        this.webRTCVersion = webRTCInfo?.version || `${browser?.name || \"\"}-${browser?.version || \"\"}` || \"N/A\";\n    }\n}\nconst DEFAULT_THRESHOLD = 0.35;\nclass ViewportTracker {\n    constructor(){\n        /**\n         * @private\n         */ this.elementHandlerMap = new Map();\n        /**\n         * @private\n         */ this.observer = null;\n        // in React children render before viewport is set, add\n        // them to the queue and observe them once the observer is ready\n        /**\n         * @private\n         */ this.queueSet = new Set();\n        /**\n         * Method to set scrollable viewport as root for the IntersectionObserver, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param viewportElement\n         * @param options\n         * @returns Unobserve\n         */ this.setViewport = (viewportElement, options)=>{\n            const cleanup = ()=>{\n                this.observer?.disconnect();\n                this.observer = null;\n                this.elementHandlerMap.clear();\n            };\n            this.observer = new IntersectionObserver((entries)=>{\n                entries.forEach((entry)=>{\n                    const handler = this.elementHandlerMap.get(entry.target);\n                    handler?.(entry);\n                });\n            }, {\n                root: viewportElement,\n                ...options,\n                threshold: options?.threshold ?? DEFAULT_THRESHOLD\n            });\n            if (this.queueSet.size) {\n                this.queueSet.forEach(([queueElement, queueHandler])=>{\n                    // check if element which requested observation is\n                    // a child of a viewport element, skip if isn't\n                    if (!viewportElement.contains(queueElement)) return;\n                    this.observer.observe(queueElement);\n                    this.elementHandlerMap.set(queueElement, queueHandler);\n                });\n                this.queueSet.clear();\n            }\n            return cleanup;\n        };\n        /**\n         * Method to set element to observe and handler to be triggered whenever IntersectionObserver\n         * detects a possible change in element's visibility within specified viewport, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param element\n         * @param handler\n         * @returns Unobserve\n         */ this.observe = (element, handler)=>{\n            const queueItem = [\n                element,\n                handler\n            ];\n            const cleanup = ()=>{\n                this.elementHandlerMap.delete(element);\n                this.observer?.unobserve(element);\n                this.queueSet.delete(queueItem);\n            };\n            if (this.elementHandlerMap.has(element)) return cleanup;\n            if (!this.observer) {\n                this.queueSet.add(queueItem);\n                return cleanup;\n            }\n            if (this.observer.root.contains(element)) {\n                this.elementHandlerMap.set(element, handler);\n                this.observer.observe(element);\n            }\n            return cleanup;\n        };\n    }\n}\n/**\n * Checks whether the current browser is Safari.\n */ const isSafari = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent || \"\");\n};\n/**\n * Checks whether the current browser is Firefox.\n */ const isFirefox = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Firefox\");\n};\n/**\n * Checks whether the current browser is Google Chrome.\n */ const isChrome = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Chrome\");\n};\nvar browsers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    isChrome: isChrome,\n    isFirefox: isFirefox,\n    isSafari: isSafari\n});\nconst DEFAULT_VIEWPORT_VISIBILITY_STATE = {\n    videoTrack: VisibilityState.UNKNOWN,\n    screenShareTrack: VisibilityState.UNKNOWN\n};\n/**\n * A manager class that handles dynascale related tasks like:\n *\n * - binding video elements to session ids\n * - binding audio elements to session ids\n * - tracking element visibility\n * - updating subscriptions based on viewport visibility\n * - updating subscriptions based on video element dimensions\n * - updating subscriptions based on published tracks\n */ class DynascaleManager {\n    /**\n     * Creates a new DynascaleManager instance.\n     *\n     * @param call the call to manage.\n     */ constructor(call){\n        /**\n         * The viewport tracker instance.\n         */ this.viewportTracker = new ViewportTracker();\n        this.logger = getLogger([\n            \"DynascaleManager\"\n        ]);\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         * @returns Untrack.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            const cleanup = this.viewportTracker.observe(element, (entry)=>{\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    // observer triggers when the element is \"moved\" to be a fullscreen element\n                    // keep it VISIBLE if that happens to prevent fullscreen with placeholder\n                    const isVisible = entry.isIntersecting || document.fullscreenElement === element ? VisibilityState.VISIBLE : VisibilityState.INVISIBLE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: isVisible\n                        }\n                    };\n                });\n            });\n            return ()=>{\n                cleanup();\n                // reset visibility state to UNKNOWN upon cleanup\n                // so that the layouts that are not actively observed\n                // can still function normally (runtime layout switching)\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: VisibilityState.UNKNOWN\n                        }\n                    };\n                });\n            };\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.viewportTracker.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const boundParticipant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!boundParticipant) return;\n            const requestTrackWithDimensions = (debounceType, dimension)=>{\n                if (dimension && (dimension.width === 0 || dimension.height === 0)) {\n                    // ignore 0x0 dimensions. this can happen when the video element\n                    // is not visible (e.g., has display: none).\n                    // we treat this as \"unsubscription\" as we don't want to keep\n                    // consuming bandwidth for a video that is not visible on the screen.\n                    this.logger(\"debug\", `Ignoring 0x0 dimension`, boundParticipant);\n                    dimension = undefined;\n                }\n                this.call.updateSubscriptionsPartial(trackType, {\n                    [sessionId]: {\n                        dimension\n                    }\n                }, debounceType);\n            };\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((participants)=>participants.find((participant)=>participant.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.takeWhile)((participant)=>!!participant), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            /**\n             * Since the video elements are now being removed from the DOM (React SDK) upon\n             * visibility change, this subscription is not in use an stays here only for the\n             * plain JS integrations where integrators might choose not to remove the video\n             * elements from the DOM.\n             */ // keep copy for resize observer handler\n            let viewportVisibilityState;\n            const viewportVisibilityStateSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((p)=>p.viewportVisibilityState?.[trackType]), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)()).subscribe((nextViewportVisibilityState)=>{\n                // skip initial trigger\n                if (!viewportVisibilityState) {\n                    viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                    return;\n                }\n                viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                if (nextViewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return requestTrackWithDimensions(DebounceType.MEDIUM, undefined);\n                }\n                requestTrackWithDimensions(DebounceType.MEDIUM, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n            });\n            let lastDimensions;\n            const resizeObserver = boundParticipant.isLocalParticipant ? null : new ResizeObserver(()=>{\n                const currentDimensions = `${videoElement.clientWidth},${videoElement.clientHeight}`;\n                // skip initial trigger\n                if (!lastDimensions) {\n                    lastDimensions = currentDimensions;\n                    return;\n                }\n                if (lastDimensions === currentDimensions || viewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return;\n                }\n                requestTrackWithDimensions(DebounceType.SLOW, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n                lastDimensions = currentDimensions;\n            });\n            resizeObserver?.observe(videoElement);\n            // element renders and gets bound - track subscription gets\n            // triggered first other ones get skipped on initial subscriptions\n            const publishedTracksSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilKeyChanged)(\"publishedTracks\"), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((p)=>p.publishedTracks.includes(trackType === \"videoTrack\" ? TrackType.VIDEO : TrackType.SCREEN_SHARE)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)()).subscribe((isPublishing)=>{\n                if (isPublishing) {\n                    // the participant just started to publish a track\n                    requestTrackWithDimensions(DebounceType.FAST, {\n                        width: videoElement.clientWidth,\n                        height: videoElement.clientHeight\n                    });\n                } else {\n                    // the participant just stopped publishing a track\n                    requestTrackWithDimensions(DebounceType.FAST, undefined);\n                }\n            });\n            videoElement.autoplay = true;\n            videoElement.playsInline = true;\n            // explicitly marking the element as muted will allow autoplay to work\n            // without prior user interaction:\n            // https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\n            videoElement.muted = true;\n            const streamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilKeyChanged)(trackType === \"videoTrack\" ? \"videoStream\" : \"screenShareStream\")).subscribe((p)=>{\n                const source = trackType === \"videoTrack\" ? p.videoStream : p.screenShareStream;\n                if (videoElement.srcObject === source) return;\n                videoElement.srcObject = source ?? null;\n                if (isSafari() || isFirefox()) {\n                    setTimeout(()=>{\n                        videoElement.srcObject = source ?? null;\n                        videoElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                    // we add extra delay until we attempt to force-play\n                    // the participant's media stream in Firefox and Safari,\n                    // as they seem to have some timing issues\n                    }, 25);\n                }\n            });\n            return ()=>{\n                requestTrackWithDimensions(DebounceType.FAST, undefined);\n                viewportVisibilityStateSubscription?.unsubscribe();\n                publishedTracksSubscription?.unsubscribe();\n                streamSubscription.unsubscribe();\n                resizeObserver?.disconnect();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         * @returns a cleanup function that will unbind the audio element.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType)=>{\n            const participant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!participant || participant.isLocalParticipant) return;\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((participants)=>participants.find((p)=>p.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.takeWhile)((p)=>!!p), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            const updateMediaStreamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilKeyChanged)(trackType === \"screenShareAudioTrack\" ? \"screenShareAudioStream\" : \"audioStream\")).subscribe((p)=>{\n                const source = trackType === \"screenShareAudioTrack\" ? p.screenShareAudioStream : p.audioStream;\n                if (audioElement.srcObject === source) return;\n                setTimeout(()=>{\n                    audioElement.srcObject = source ?? null;\n                    if (audioElement.srcObject) {\n                        audioElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                        // audio output device shall be set after the audio element is played\n                        // otherwise, the browser will not pick it up, and will always\n                        // play audio through the system's default device\n                        const { selectedDevice } = this.call.speaker.state;\n                        if (selectedDevice && \"setSinkId\" in audioElement) {\n                            audioElement.setSinkId(selectedDevice);\n                        }\n                    }\n                });\n            });\n            const sinkIdSubscription = !(\"setSinkId\" in audioElement) ? null : this.call.speaker.state.selectedDevice$.subscribe((deviceId)=>{\n                if (deviceId) {\n                    audioElement.setSinkId(deviceId);\n                }\n            });\n            const volumeSubscription = (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__.combineLatest)([\n                this.call.speaker.state.volume$,\n                participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilKeyChanged)(\"audioVolume\"))\n            ]).subscribe(([volume, p])=>{\n                audioElement.volume = p.audioVolume ?? volume;\n            });\n            audioElement.autoplay = true;\n            return ()=>{\n                sinkIdSubscription?.unsubscribe();\n                volumeSubscription.unsubscribe();\n                updateMediaStreamSubscription.unsubscribe();\n            };\n        };\n        this.call = call;\n    }\n}\n/**\n * Stores the permissions for the current user and exposes\n * a few helper methods which make it easier to work with permissions.\n *\n * This is an internal class meant to be used in combination with\n * a {@link Call} instance.\n *\n * @internal\n */ class PermissionsContext {\n    constructor(){\n        this.permissions = [];\n        /**\n         * Sets the permissions for the current user.\n         *\n         * @param permissions the permissions to set.\n         */ this.setPermissions = (permissions)=>{\n            this.permissions = permissions || [];\n        };\n        /**\n         * Sets the settings for the bound call.\n         * @param settings\n         */ this.setCallSettings = (settings)=>{\n            this.settings = settings;\n        };\n        /**\n         * Checks if the current user has a specific permission.\n         *\n         * @param permission the permission to check for.\n         */ this.hasPermission = (permission)=>{\n            return this.permissions.includes(permission);\n        };\n        /**\n         * Checks if the current user can request a specific permission\n         * within the call.\n         *\n         * @param permission the permission to check for.\n         * @param settings the call settings to check against (optional).\n         */ this.canRequest = (permission, settings = this.settings)=>{\n            if (!settings) return false;\n            const { audio, video, screensharing } = settings;\n            switch(permission){\n                case OwnCapability.SEND_AUDIO:\n                    return audio.access_request_enabled;\n                case OwnCapability.SEND_VIDEO:\n                    return video.access_request_enabled;\n                case OwnCapability.SCREENSHARE:\n                    return screensharing.access_request_enabled;\n                default:\n                    return false;\n            }\n        };\n    }\n}\n/**\n * Represents a call type.\n */ class CallType {\n    /**\n     * Constructs a new CallType.\n     *\n     * @param name the name of the call type.\n     * @param options the options for the call type.\n     */ constructor(name, options = {\n        sortParticipantsBy: defaultSortPreset\n    }){\n        this.name = name;\n        this.options = options;\n    }\n}\n/**\n * A registry of {@link CallType}s.\n * You can register and unregister call types.\n */ class CallTypesRegistry {\n    /**\n     * Constructs a new CallTypesRegistry.\n     *\n     * @param callTypes the initial call types to register.\n     */ constructor(callTypes){\n        /**\n         * Registers a new call type.\n         *\n         * @param callType the call type to register.\n         */ this.register = (callType)=>{\n            this.callTypes[callType.name] = callType;\n        };\n        /**\n         * Unregisters a call type.\n         *\n         * @param name the name of the call type to unregister.\n         */ this.unregister = (name)=>{\n            delete this.callTypes[name];\n        };\n        /**\n         * Gets a call type by name.\n         *\n         * @param name the name of the call type to get.\n         */ this.get = (name)=>{\n            if (!this.callTypes[name]) {\n                this.register(new CallType(name));\n            }\n            return this.callTypes[name];\n        };\n        this.callTypes = callTypes.reduce((acc, callType)=>{\n            acc[callType.name] = callType;\n            return acc;\n        }, {});\n    }\n}\n/**\n * The default call types registry.\n * You can use this instance to dynamically register and unregister call types.\n */ const CallTypes = new CallTypesRegistry([\n    new CallType(\"default\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"development\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"livestream\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    }),\n    new CallType(\"audio_room\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    })\n]);\n/**\n * Returns an Observable that emits the list of available devices\n * that meet the given constraints.\n *\n * @param constraints the constraints to use when requesting the devices.\n * @param kind the kind of devices to enumerate.\n */ const getDevices = (constraints, kind)=>{\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.Observable((subscriber)=>{\n        const enumerate = async ()=>{\n            let devices = await navigator.mediaDevices.enumerateDevices();\n            // some browsers report empty device labels (Firefox).\n            // in that case, we need to request permissions (via getUserMedia)\n            // to be able to get the device labels\n            const needsGetUserMedia = devices.some((device)=>device.kind === kind && device.label === \"\");\n            if (needsGetUserMedia) {\n                let mediaStream;\n                try {\n                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n                    devices = await navigator.mediaDevices.enumerateDevices();\n                } finally{\n                    if (mediaStream) disposeOfMediaStream(mediaStream);\n                }\n            }\n            return devices;\n        };\n        enumerate().then((devices)=>{\n            // notify subscribers and complete\n            subscriber.next(devices);\n            subscriber.complete();\n        }).catch((error)=>{\n            const logger = getLogger([\n                \"devices\"\n            ]);\n            logger(\"error\", \"Failed to enumerate devices\", error);\n            subscriber.error(error);\n        });\n    });\n};\n/**\n * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n *\n *  */ const checkIfAudioOutputChangeSupported = ()=>{\n    if (typeof document === \"undefined\") return false;\n    const element = document.createElement(\"audio\");\n    return \"setSinkId\" in element;\n};\n/**\n * The default constraints used to request audio devices.\n */ const audioDeviceConstraints = {\n    audio: {\n        autoGainControl: true,\n        noiseSuppression: true,\n        echoCancellation: true\n    }\n};\n/**\n * The default constraints used to request video devices.\n */ const videoDeviceConstraints = {\n    video: {\n        width: 1280,\n        height: 720\n    }\n};\n/**\n * Creates a memoized observable instance\n * that will be created only once and shared between all callers.\n *\n * @param create a function that creates an Observable.\n */ const memoizedObservable = (create)=>{\n    let memoized;\n    return ()=>{\n        if (!memoized) memoized = create();\n        return memoized;\n    };\n};\nconst getDeviceChangeObserver = memoizedObservable(()=>{\n    // Audio and video devices are requested in two separate requests.\n    // That way, users will be presented with two separate prompts\n    // -> they can give access to just camera, or just microphone\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.Observable((subscriber)=>{\n        // 'addEventListener' is not available in React Native\n        if (!navigator.mediaDevices.addEventListener) return;\n        const notify = ()=>subscriber.next();\n        navigator.mediaDevices.addEventListener(\"devicechange\", notify);\n        return ()=>{\n            navigator.mediaDevices.removeEventListener(\"devicechange\", notify);\n        };\n    }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.debounceTime)(500), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.concatMap)(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__.from)(navigator.mediaDevices.enumerateDevices())), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)(1));\n});\nconst getAudioDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(getDevices(audioDeviceConstraints, \"audioinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)(1));\n});\nconst getAudioOutputDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(getDevices(audioDeviceConstraints, \"audiooutput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)(1));\n});\nconst getVideoDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(getDevices(videoDeviceConstraints, \"videoinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)(1));\n});\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audioinput' devices, if devices are added/removed the list is updated.\n */ const getAudioDevices = ()=>{\n    return getAudioDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((values)=>values.filter((d)=>d.kind === \"audioinput\")));\n};\n/**\n * Prompts the user for a permission to use video devices (if not already granted) and lists the available 'videoinput' devices, if devices are added/removed the list is updated.\n */ const getVideoDevices = ()=>{\n    return getVideoDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((values)=>values.filter((d)=>d.kind === \"videoinput\")));\n};\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audiooutput' devices, if devices are added/removed the list is updated. Selecting 'audiooutput' device only makes sense if [the browser has support for changing audio output on 'audio' elements](#checkifaudiooutputchangesupported)\n */ const getAudioOutputDevices = ()=>{\n    return getAudioOutputDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((values)=>values.filter((d)=>d.kind === \"audiooutput\")));\n};\nconst getStream = async (constraints)=>{\n    try {\n        return await navigator.mediaDevices.getUserMedia(constraints);\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", `Failed get user media`, {\n            error: e,\n            constraints: constraints\n        });\n        throw e;\n    }\n};\n/**\n * Returns an audio media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns the new `MediaStream` fulfilling the given constraints.\n */ const getAudioStream = async (trackConstraints)=>{\n    const constraints = {\n        audio: {\n            ...audioDeviceConstraints.audio,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Returns a video media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns a new `MediaStream` fulfilling the given constraints.\n */ const getVideoStream = async (trackConstraints)=>{\n    const constraints = {\n        video: {\n            ...videoDeviceConstraints.video,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Prompts the user for a permission to share a screen.\n * If the user grants the permission, a screen sharing stream is returned. Throws otherwise.\n *\n * The callers of this API are responsible to handle the possible errors.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n *\n * @param options any additional options to pass to the [`getDisplayMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia) API.\n */ const getScreenShareStream = async (options)=>{\n    try {\n        return await navigator.mediaDevices.getDisplayMedia({\n            video: true,\n            audio: {\n                channelCount: {\n                    ideal: 2\n                },\n                echoCancellation: false,\n                autoGainControl: false,\n                noiseSuppression: false\n            },\n            // @ts-expect-error - not present in types yet\n            systemAudio: \"include\",\n            ...options\n        });\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", \"Failed to get screen share stream\", e);\n        throw e;\n    }\n};\nconst deviceIds$ = typeof navigator !== \"undefined\" && typeof navigator.mediaDevices !== \"undefined\" ? memoizedObservable(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__.from)(navigator.mediaDevices.enumerateDevices()), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)(1)))() : undefined;\n/**\n * Deactivates MediaStream (stops and removes tracks) to be later garbage collected\n *\n * @param stream MediaStream\n * @returns void\n */ const disposeOfMediaStream = (stream)=>{\n    if (!stream.active) return;\n    stream.getTracks().forEach((track)=>{\n        track.stop();\n        stream.removeTrack(track);\n    });\n    // @ts-expect-error release() is present in react-native-webrtc and must be called to dispose the stream\n    if (typeof stream.release === \"function\") {\n        // @ts-expect-error\n        stream.release();\n    }\n};\nclass InputMediaDeviceManager {\n    constructor(call, state, trackType){\n        this.call = call;\n        this.state = state;\n        this.trackType = trackType;\n        /**\n         * if true, stops the media stream when call is left\n         */ this.stopOnLeave = true;\n        this.subscriptions = [];\n        this.isTrackStoppedDueToTrackEnd = false;\n        this.filters = [];\n        /**\n         * Disposes the manager.\n         *\n         * @internal\n         */ this.dispose = ()=>{\n            this.subscriptions.forEach((s)=>s());\n        };\n        this.logger = getLogger([\n            `${TrackType[trackType].toLowerCase()} manager`\n        ]);\n        if (deviceIds$ && !isReactNative() && (this.trackType === TrackType.AUDIO || this.trackType === TrackType.VIDEO)) {\n            this.handleDisconnectedOrReplacedDevices();\n        }\n    }\n    /**\n     * Lists the available audio/video devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        return this.getDevices();\n    }\n    /**\n     * Starts stream.\n     */ async enable() {\n        if (this.state.status === \"enabled\") return;\n        this.enablePromise = this.unmuteStream();\n        try {\n            await this.enablePromise;\n            this.state.setStatus(\"enabled\");\n            this.enablePromise = undefined;\n        } catch (error) {\n            this.enablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * Stops or pauses the stream based on state.disableMode\n     * @param {boolean} [forceStop=false] when true, stops the tracks regardless of the state.disableMode\n     */ async disable(forceStop = false) {\n        this.state.prevStatus = this.state.status;\n        if (!forceStop && this.state.status === \"disabled\") return;\n        const stopTracks = forceStop || this.state.disableMode === \"stop-tracks\";\n        this.disablePromise = this.muteStream(stopTracks);\n        try {\n            await this.disablePromise;\n            this.state.setStatus(\"disabled\");\n            this.disablePromise = undefined;\n        } catch (error) {\n            this.disablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * If status was previously enabled, it will re-enable the device.\n     */ async resume() {\n        if (this.state.prevStatus === \"enabled\" && this.state.status === \"disabled\") {\n            await this.enable();\n        }\n    }\n    /**\n     * If the current device status is disabled, it will enable the device,\n     * else it will disable it.\n     */ async toggle() {\n        if (this.state.status === \"enabled\") {\n            return this.disable();\n        } else {\n            return this.enable();\n        }\n    }\n    /**\n     * Registers a filter that will be applied to the stream.\n     *\n     * The registered filter will get the existing stream, and it should return\n     * a new stream with the applied filter.\n     *\n     * @param filter the filter to register.\n     * @returns a function that will unregister the filter.\n     */ async registerFilter(filter) {\n        this.filters.push(filter);\n        await this.applySettingsToStream();\n        return async ()=>{\n            this.filters = this.filters.filter((f)=>f !== filter);\n            await this.applySettingsToStream();\n        };\n    }\n    /**\n     * Will set the default constraints for the device.\n     *\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.state.setDefaultConstraints(constraints);\n    }\n    /**\n     * Selects a device.\n     *\n     * Note: This method is not supported in React Native\n     * @param deviceId the device id to select.\n     */ async select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This method is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for reference.\");\n        }\n        if (deviceId === this.state.selectedDevice) {\n            return;\n        }\n        this.state.setDevice(deviceId);\n        await this.applySettingsToStream();\n    }\n    async applySettingsToStream() {\n        if (this.state.status === \"enabled\") {\n            await this.muteStream();\n            await this.unmuteStream();\n        }\n    }\n    getTracks() {\n        return this.state.mediaStream?.getTracks() ?? [];\n    }\n    async muteStream(stopTracks = true) {\n        if (!this.state.mediaStream) return;\n        this.logger(\"debug\", `${stopTracks ? \"Stopping\" : \"Disabling\"} stream`);\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.stopPublishStream(stopTracks);\n        }\n        this.muteLocalStream(stopTracks);\n        const allEnded = this.getTracks().every((t)=>t.readyState === \"ended\");\n        if (allEnded) {\n            if (this.state.mediaStream && // @ts-expect-error release() is present in react-native-webrtc\n            typeof this.state.mediaStream.release === \"function\") {\n                // @ts-expect-error called to dispose the stream in RN\n                this.state.mediaStream.release();\n            }\n            this.state.setMediaStream(undefined);\n        }\n    }\n    muteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.enabled) track.enabled = false;\n        });\n    }\n    unmuteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (!track.enabled) track.enabled = true;\n        });\n    }\n    stopTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.readyState === \"live\") track.stop();\n        });\n    }\n    muteLocalStream(stopTracks) {\n        if (!this.state.mediaStream) {\n            return;\n        }\n        if (stopTracks) {\n            this.stopTracks();\n        } else {\n            this.muteTracks();\n        }\n    }\n    async unmuteStream() {\n        this.logger(\"debug\", \"Starting stream\");\n        let stream;\n        if (this.state.mediaStream && this.getTracks().every((t)=>t.readyState === \"live\")) {\n            stream = this.state.mediaStream;\n            this.unmuteTracks();\n        } else {\n            const defaultConstraints = this.state.defaultConstraints;\n            const constraints = {\n                ...defaultConstraints,\n                deviceId: this.state.selectedDevice\n            };\n            /**\n             * Chains two media streams together.\n             *\n             * In our case, filters MediaStreams are derived from their parent MediaStream.\n             * However, once a child filter's track is stopped,\n             * the tracks of the parent MediaStream aren't automatically stopped.\n             * This leads to a situation where the camera indicator light is still on\n             * even though the user stopped publishing video.\n             *\n             * This function works around this issue by stopping the parent MediaStream's tracks\n             * as well once the child filter's tracks are stopped.\n             *\n             * It works by patching the stop() method of the child filter's tracks to also stop\n             * the parent MediaStream's tracks of the same type. Here we assume that\n             * the parent MediaStream has only one track of each type.\n             *\n             * @param parentStream the parent MediaStream. Omit for the root stream.\n             */ const chainWith = (parentStream)=>async (filterStream)=>{\n                    if (!parentStream) return filterStream;\n                    // TODO OL: take care of track.enabled property as well\n                    const parent = await parentStream;\n                    filterStream.getTracks().forEach((track)=>{\n                        const originalStop = track.stop;\n                        track.stop = function stop() {\n                            originalStop.call(track);\n                            parent.getTracks().forEach((parentTrack)=>{\n                                if (parentTrack.kind === track.kind) {\n                                    parentTrack.stop();\n                                }\n                            });\n                        };\n                    });\n                    parent.getTracks().forEach((parentTrack)=>{\n                        // When the parent stream abruptly ends, we propagate the event\n                        // to the filter stream.\n                        // This usually happens when the camera/microphone permissions\n                        // are revoked or when the device is disconnected.\n                        const handleParentTrackEnded = ()=>{\n                            filterStream.getTracks().forEach((track)=>{\n                                if (parentTrack.kind !== track.kind) return;\n                                track.stop();\n                                track.dispatchEvent(new Event(\"ended\")); // propagate the event\n                            });\n                        };\n                        parentTrack.addEventListener(\"ended\", handleParentTrackEnded);\n                        this.subscriptions.push(()=>{\n                            parentTrack.removeEventListener(\"ended\", handleParentTrackEnded);\n                        });\n                    });\n                    return filterStream;\n                };\n            // we publish the last MediaStream of the chain\n            stream = await this.filters.reduce((parent, filter)=>parent.then(filter).then(chainWith(parent)), this.getStream(constraints));\n        }\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.publishStream(stream);\n        }\n        if (this.state.mediaStream !== stream) {\n            this.state.setMediaStream(stream);\n            this.getTracks().forEach((track)=>{\n                track.addEventListener(\"ended\", async ()=>{\n                    if (this.enablePromise) {\n                        await this.enablePromise;\n                    }\n                    if (this.disablePromise) {\n                        await this.disablePromise;\n                    }\n                    if (this.state.status === \"enabled\") {\n                        this.isTrackStoppedDueToTrackEnd = true;\n                        setTimeout(()=>{\n                            this.isTrackStoppedDueToTrackEnd = false;\n                        }, 2000);\n                        await this.disable();\n                    }\n                });\n            });\n        }\n    }\n    get mediaDeviceKind() {\n        if (this.trackType === TrackType.AUDIO) {\n            return \"audioinput\";\n        }\n        if (this.trackType === TrackType.VIDEO) {\n            return \"videoinput\";\n        }\n        return \"\";\n    }\n    handleDisconnectedOrReplacedDevices() {\n        this.subscriptions.push(createSubscription((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__.combineLatest)([\n            deviceIds$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__.pairwise)()),\n            this.state.selectedDevice$\n        ]), async ([[prevDevices, currentDevices], deviceId])=>{\n            if (!deviceId) {\n                return;\n            }\n            if (this.enablePromise) {\n                await this.enablePromise;\n            }\n            if (this.disablePromise) {\n                await this.disablePromise;\n            }\n            let isDeviceDisconnected = false;\n            let isDeviceReplaced = false;\n            const currentDevice = this.findDeviceInList(currentDevices, deviceId);\n            const prevDevice = this.findDeviceInList(prevDevices, deviceId);\n            if (!currentDevice && prevDevice) {\n                isDeviceDisconnected = true;\n            } else if (currentDevice && prevDevice && currentDevice.deviceId === prevDevice.deviceId && currentDevice.groupId !== prevDevice.groupId) {\n                isDeviceReplaced = true;\n            }\n            if (isDeviceDisconnected) {\n                await this.disable();\n                this.select(undefined);\n            }\n            if (isDeviceReplaced) {\n                if (this.isTrackStoppedDueToTrackEnd && this.state.status === \"disabled\") {\n                    await this.enable();\n                    this.isTrackStoppedDueToTrackEnd = false;\n                } else {\n                    await this.applySettingsToStream();\n                }\n            }\n        }));\n    }\n    findDeviceInList(devices, deviceId) {\n        return devices.find((d)=>d.deviceId === deviceId && d.kind === this.mediaDeviceKind);\n    }\n}\nclass InputMediaDeviceManagerState {\n    /**\n     * Constructs new InputMediaDeviceManagerState instance.\n     *\n     * @param disableMode the disable mode to use.\n     * @param permissionName the permission name to use for querying.\n     * `undefined` means no permission is required.\n     */ constructor(disableMode = \"stop-tracks\", permissionName = undefined){\n        this.disableMode = disableMode;\n        this.permissionName = permissionName;\n        this.statusSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.mediaStreamSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.defaultConstraintsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current media stream, or `undefined` if the device is currently disabled.\n         *\n         */ this.mediaStream$ = this.mediaStreamSubject.asObservable();\n        /**\n         * An Observable that emits the currently selected device\n         */ this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the device status\n         */ this.status$ = this.statusSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)());\n        /**\n         * The default constraints for the device.\n         */ this.defaultConstraints$ = this.defaultConstraintsSubject.asObservable();\n        /**\n         * An observable that will emit `true` if browser/system permission\n         * is granted, `false` otherwise.\n         */ this.hasBrowserPermission$ = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.Observable((subscriber)=>{\n            const notifyGranted = ()=>subscriber.next(true);\n            const permissionsAPIAvailable = !!navigator?.permissions?.query;\n            if (isReactNative() || !this.permissionName || !permissionsAPIAvailable) {\n                getLogger([\n                    \"devices\"\n                ])(\"warn\", `Permissions can't be queried. Assuming granted.`);\n                return notifyGranted();\n            }\n            let permissionState;\n            const notify = ()=>{\n                subscriber.next(// In some browsers, the 'change' event doesn't reliably emit and hence,\n                // permissionState stays in 'prompt' state forever.\n                // Typically, this happens when a user grants one-time permission.\n                // Instead of checking if a permission is granted, we check if it isn't denied\n                permissionState.state !== \"denied\");\n            };\n            navigator.permissions.query({\n                name: this.permissionName\n            }).then((permissionStatus)=>{\n                permissionState = permissionStatus;\n                permissionState.addEventListener(\"change\", notify);\n                notify();\n            }).catch(()=>{\n                // permission doesn't exist or can't be queried -> assume it's granted\n                // an example would be Firefox,\n                // where neither camera microphone permission can be queried\n                notifyGranted();\n            });\n            return ()=>{\n                permissionState?.removeEventListener(\"change\", notify);\n            };\n        }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.shareReplay)(1));\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n    }\n    /**\n     * The device status\n     */ get status() {\n        return this.getCurrentValue(this.status$);\n    }\n    /**\n     * The currently selected device\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The current media stream, or `undefined` if the device is currently disabled.\n     */ get mediaStream() {\n        return this.getCurrentValue(this.mediaStream$);\n    }\n    /**\n     * @internal\n     * @param status\n     */ setStatus(status) {\n        this.setCurrentValue(this.statusSubject, status);\n    }\n    /**\n     * @internal\n     * @param stream the stream to set.\n     */ setMediaStream(stream) {\n        this.setCurrentValue(this.mediaStreamSubject, stream);\n        if (stream) {\n            this.setDevice(this.getDeviceIdFromStream(stream));\n        }\n    }\n    /**\n     * @internal\n     * @param deviceId the device id to set.\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * Gets the default constraints for the device.\n     */ get defaultConstraints() {\n        return this.getCurrentValue(this.defaultConstraints$);\n    }\n    /**\n     * Sets the default constraints for the device.\n     *\n     * @internal\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.setCurrentValue(this.defaultConstraintsSubject, constraints);\n    }\n}\nclass CameraManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"stop-tracks\", // `camera` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"camera\");\n        this.directionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        this.direction$ = this.directionSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)());\n    }\n    /**\n     * The preferred camera direction\n     * front - means the camera facing the user\n     * back - means the camera facing the environment\n     */ get direction() {\n        return this.getCurrentValue(this.direction$);\n    }\n    /**\n     * @internal\n     */ setDirection(direction) {\n        this.setCurrentValue(this.directionSubject, direction);\n    }\n    /**\n     * @internal\n     */ setMediaStream(stream) {\n        super.setMediaStream(stream);\n        if (stream) {\n            // RN getSettings() doesn't return facingMode, so we don't verify camera direction\n            const direction = isReactNative() ? this.direction : stream.getVideoTracks()[0]?.getSettings().facingMode === \"environment\" ? \"back\" : \"front\";\n            this.setDirection(direction);\n        }\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getVideoTracks()[0]?.getSettings().deviceId;\n    }\n}\nclass CameraManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new CameraManagerState(), TrackType.VIDEO);\n        this.targetResolution = {\n            width: 1280,\n            height: 720\n        };\n    }\n    /**\n     * Select the camera direction.\n     *\n     * @param direction the direction of the camera to select.\n     */ async selectDirection(direction) {\n        this.state.setDirection(direction);\n        // Providing both device id and direction doesn't work, so we deselect the device\n        this.state.setDevice(undefined);\n        await this.applySettingsToStream();\n    }\n    /**\n     * Flips the camera direction: if it's front it will change to back, if it's back, it will change to front.\n     *\n     * Note: if there is no available camera with the desired direction, this method will do nothing.\n     * @returns\n     */ async flip() {\n        const newDirection = this.state.direction === \"front\" ? \"back\" : \"front\";\n        await this.selectDirection(newDirection);\n    }\n    /**\n     * @internal\n     */ async selectTargetResolution(resolution) {\n        this.targetResolution.height = resolution.height;\n        this.targetResolution.width = resolution.width;\n        if (this.enablePromise) {\n            try {\n                await this.enablePromise;\n            } catch (error) {\n                // couldn't enable device, target resolution will be applied the next time user attempts to start the device\n                this.logger(\"warn\", \"could not apply target resolution\", error);\n            }\n        }\n        if (this.state.status === \"enabled\") {\n            const { width, height } = this.state.mediaStream.getVideoTracks()[0]?.getSettings();\n            if (width !== this.targetResolution.width || height !== this.targetResolution.height) {\n                await this.applySettingsToStream();\n                this.logger(\"debug\", `${width}x${height} target resolution applied to media stream`);\n            }\n        }\n    }\n    /**\n     * Sets the preferred codec for encoding the video.\n     *\n     * @internal internal use only, not part of the public API.\n     * @param codec the codec to use for encoding the video.\n     */ setPreferredCodec(codec) {\n        this.preferredCodec = codec;\n    }\n    getDevices() {\n        return getVideoDevices();\n    }\n    getStream(constraints) {\n        constraints.width = this.targetResolution.width;\n        constraints.height = this.targetResolution.height;\n        // We can't set both device id and facing mode\n        // Device id has higher priority\n        if (!constraints.deviceId && this.state.direction) {\n            constraints.facingMode = this.state.direction === \"front\" ? \"user\" : \"environment\";\n        }\n        return getVideoStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishVideoStream(stream, {\n            preferredCodec: this.preferredCodec\n        });\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.VIDEO, stopTracks);\n    }\n}\nclass MicrophoneManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"disable-tracks\", // `microphone` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"microphone\");\n        this.speakingWhileMutedSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(false);\n        this.speakingWhileMuted$ = this.speakingWhileMutedSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)());\n    }\n    /**\n     * `true` if the user's microphone is muted but they'are speaking.\n     *\n     * This feature is not available in the React Native SDK.\n     */ get speakingWhileMuted() {\n        return this.getCurrentValue(this.speakingWhileMuted$);\n    }\n    /**\n     * @internal\n     */ setSpeakingWhileMuted(isSpeaking) {\n        this.setCurrentValue(this.speakingWhileMutedSubject, isSpeaking);\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getAudioTracks()[0]?.getSettings().deviceId;\n    }\n}\nconst DETECTION_FREQUENCY_IN_MS = 500;\nconst AUDIO_LEVEL_THRESHOLD$1 = 150;\nconst FFT_SIZE = 128;\n/**\n * Creates a new sound detector.\n *\n * @param audioStream the audio stream to observe. Depending on the provided configuration, this stream might be destroyed when the sound detector is stopped.\n * @param onSoundDetectedStateChanged a callback which is called when the sound state changes.\n * @param options custom options for the sound detector.\n * @returns a clean-up function which once invoked stops the sound detector.\n */ const createSoundDetector = (audioStream, onSoundDetectedStateChanged, options = {})=>{\n    const { detectionFrequencyInMs = DETECTION_FREQUENCY_IN_MS, audioLevelThreshold = AUDIO_LEVEL_THRESHOLD$1, fftSize = FFT_SIZE, destroyStreamOnStop = true } = options;\n    const audioContext = new AudioContext();\n    const analyser = audioContext.createAnalyser();\n    analyser.fftSize = fftSize;\n    const microphone = audioContext.createMediaStreamSource(audioStream);\n    microphone.connect(analyser);\n    const intervalId = setInterval(()=>{\n        const data = new Uint8Array(analyser.frequencyBinCount);\n        analyser.getByteFrequencyData(data);\n        const isSoundDetected = data.some((value)=>value >= audioLevelThreshold);\n        const averagedDataValue = data.reduce((pv, cv)=>pv + cv, 0) / data.length;\n        const percentage = averagedDataValue > audioLevelThreshold ? 100 : Math.round(averagedDataValue / audioLevelThreshold * 100);\n        // When the track is disabled, it takes time for the buffer to empty\n        // This check will ensure that we don't send anything if the track is disabled\n        if (audioStream.getAudioTracks()[0]?.enabled) {\n            onSoundDetectedStateChanged({\n                isSoundDetected,\n                audioLevel: percentage\n            });\n        } else {\n            onSoundDetectedStateChanged({\n                isSoundDetected: false,\n                audioLevel: 0\n            });\n        }\n    }, detectionFrequencyInMs);\n    return async function stop() {\n        clearInterval(intervalId);\n        // clean-up the AudioContext elements\n        microphone.disconnect();\n        analyser.disconnect();\n        await audioContext.close();\n        // stop the stream\n        if (destroyStreamOnStop) {\n            audioStream.getTracks().forEach((track)=>{\n                track.stop();\n                audioStream.removeTrack(track);\n            });\n        }\n    };\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\nconst AUDIO_LEVEL_THRESHOLD = 0.2;\nclass RNSpeechDetector {\n    constructor(){\n        this.pc1 = new RTCPeerConnection({});\n        this.pc2 = new RTCPeerConnection({});\n    }\n    /**\n     * Starts the speech detection.\n     */ async start() {\n        try {\n            const audioStream = await navigator.mediaDevices.getUserMedia({\n                audio: true\n            });\n            this.pc1.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc2.addIceCandidate(e.candidate);\n            });\n            this.pc2.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc1.addIceCandidate(e.candidate);\n            });\n            audioStream.getTracks().forEach((track)=>this.pc1.addTrack(track, audioStream));\n            const offer = await this.pc1.createOffer({});\n            await this.pc2.setRemoteDescription(offer);\n            await this.pc1.setLocalDescription(offer);\n            const answer = await this.pc2.createAnswer();\n            await this.pc1.setRemoteDescription(answer);\n            await this.pc2.setLocalDescription(answer);\n            const audioTracks = audioStream.getAudioTracks();\n            // We need to mute the audio track for this temporary stream, or else you will hear yourself twice while in the call.\n            audioTracks.forEach((track)=>track.enabled = false);\n        } catch (error) {\n            console.error(\"Error connecting and negotiating between PeerConnections:\", error);\n        }\n    }\n    /**\n     * Stops the speech detection and releases all allocated resources.\n     */ stop() {\n        this.pc1.close();\n        this.pc2.close();\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    /**\n     * Public method that detects the audio levels and returns the status.\n     */ onSpeakingDetectedStateChange(onSoundDetectedStateChanged) {\n        this.intervalId = setInterval(async ()=>{\n            const stats = await this.pc1.getStats();\n            const report = flatten(stats);\n            // Audio levels are present inside stats of type `media-source` and of kind `audio`\n            const audioMediaSourceStats = report.find((stat)=>stat.type === \"media-source\" && stat.kind === \"audio\");\n            if (audioMediaSourceStats) {\n                const { audioLevel } = audioMediaSourceStats;\n                if (audioLevel) {\n                    if (audioLevel >= AUDIO_LEVEL_THRESHOLD) {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: true,\n                            audioLevel\n                        });\n                    } else {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: false,\n                            audioLevel: 0\n                        });\n                    }\n                }\n            }\n        }, 1000);\n        return ()=>{\n            clearInterval(this.intervalId);\n        };\n    }\n}\nclass MicrophoneManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new MicrophoneManagerState(), TrackType.AUDIO);\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__.combineLatest)([\n            this.call.state.callingState$,\n            this.call.state.ownCapabilities$,\n            this.state.selectedDevice$,\n            this.state.status$\n        ]).subscribe(async ([callingState, ownCapabilities, deviceId, status])=>{\n            if (callingState !== CallingState.JOINED) {\n                if (callingState === CallingState.LEFT) {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n                return;\n            }\n            if (ownCapabilities.includes(OwnCapability.SEND_AUDIO)) {\n                if (status === \"disabled\") {\n                    await this.startSpeakingWhileMutedDetection(deviceId);\n                } else {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n            } else {\n                await this.stopSpeakingWhileMutedDetection();\n            }\n        });\n    }\n    getDevices() {\n        return getAudioDevices();\n    }\n    getStream(constraints) {\n        return getAudioStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishAudioStream(stream);\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.AUDIO, stopTracks);\n    }\n    async startSpeakingWhileMutedDetection(deviceId) {\n        await this.stopSpeakingWhileMutedDetection();\n        if (isReactNative()) {\n            this.rnSpeechDetector = new RNSpeechDetector();\n            await this.rnSpeechDetector.start();\n            const unsubscribe = this.rnSpeechDetector?.onSpeakingDetectedStateChange((event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n            this.soundDetectorCleanup = ()=>{\n                unsubscribe();\n                this.rnSpeechDetector?.stop();\n                this.rnSpeechDetector = undefined;\n            };\n        } else {\n            // Need to start a new stream that's not connected to publisher\n            const stream = await this.getStream({\n                deviceId\n            });\n            this.soundDetectorCleanup = createSoundDetector(stream, (event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n        }\n    }\n    async stopSpeakingWhileMutedDetection() {\n        if (!this.soundDetectorCleanup) {\n            return;\n        }\n        this.state.setSpeakingWhileMuted(false);\n        try {\n            await this.soundDetectorCleanup();\n        } finally{\n            this.soundDetectorCleanup = undefined;\n        }\n    }\n}\nclass ScreenShareState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(...arguments);\n        this.audioEnabledSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(true);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current screen share audio status.\n         */ this.audioEnabled$ = this.audioEnabledSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the current screen share settings.\n         */ this.settings$ = this.settingsSubject.asObservable();\n        /**\n         * @internal\n         */ this.getDeviceIdFromStream = (stream)=>{\n            const [track] = stream.getTracks();\n            return track?.getSettings().deviceId;\n        };\n    }\n    /**\n     * The current screen share audio status.\n     */ get audioEnabled() {\n        return this.getCurrentValue(this.audioEnabled$);\n    }\n    /**\n     * Set the current screen share audio status.\n     */ setAudioEnabled(isEnabled) {\n        this.setCurrentValue(this.audioEnabledSubject, isEnabled);\n    }\n    /**\n     * The current screen share settings.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Set the current screen share settings.\n     *\n     * @param settings the screen share settings to set.\n     */ setSettings(settings) {\n        this.setCurrentValue(this.settingsSubject, settings);\n    }\n}\nclass ScreenShareManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new ScreenShareState(), TrackType.SCREEN_SHARE);\n    }\n    /**\n     * Will enable screen share audio options on supported platforms.\n     *\n     * Note: for ongoing screen share, audio won't be enabled until you\n     * re-publish the screen share stream.\n     */ enableScreenShareAudio() {\n        this.state.setAudioEnabled(true);\n    }\n    /**\n     * Will disable screen share audio options on supported platforms.\n     */ async disableScreenShareAudio() {\n        this.state.setAudioEnabled(false);\n        if (this.call.publisher?.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n            await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, true);\n        }\n    }\n    /**\n     * Returns the current screen share settings.\n     */ getSettings() {\n        return this.state.settings;\n    }\n    /**\n     * Sets the current screen share settings.\n     *\n     * @param settings the settings to set.\n     */ setSettings(settings) {\n        this.state.setSettings(settings);\n    }\n    getDevices() {\n        return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.of)([]); // there are no devices to be listed for Screen Share\n    }\n    getStream(constraints) {\n        if (!this.state.audioEnabled) {\n            constraints.audio = false;\n        }\n        return getScreenShareStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishScreenShareStream(stream, {\n            screenShareSettings: this.state.settings\n        });\n    }\n    async stopPublishStream(stopTracks) {\n        await this.call.stopPublish(TrackType.SCREEN_SHARE, stopTracks);\n        await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, stopTracks);\n    }\n    /**\n     * Overrides the default `select` method to throw an error.\n     *\n     * @param deviceId ignored.\n     */ async select(deviceId) {\n        throw new Error(\"This method is not supported in for Screen Share\");\n    }\n}\nclass SpeakerState {\n    constructor(){\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(\"\");\n        this.volumeSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(1);\n        /**\n         * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n         */ this.isDeviceSelectionSupported = checkIfAudioOutputChangeSupported();\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)());\n        this.volume$ = this.volumeSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.distinctUntilChanged)());\n    }\n    /**\n     * The currently selected device\n     *\n     * Note: this feature is not supported in React Native\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The currently selected volume\n     *\n     * Note: this feature is not supported in React Native\n     */ get volume() {\n        return this.getCurrentValue(this.volume$);\n    }\n    /**\n     * @internal\n     * @param deviceId\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * @internal\n     * @param volume\n     */ setVolume(volume) {\n        this.setCurrentValue(this.volumeSubject, volume);\n    }\n}\nclass SpeakerManager {\n    constructor(call){\n        this.state = new SpeakerState();\n        this.subscriptions = [];\n        /**\n         * Disposes the manager.\n         *\n         * @internal\n         */ this.dispose = ()=>{\n            this.subscriptions.forEach((s)=>s.unsubscribe());\n        };\n        this.call = call;\n        if (deviceIds$ && !isReactNative()) {\n            this.subscriptions.push((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__.combineLatest)([\n                deviceIds$,\n                this.state.selectedDevice$\n            ]).subscribe(([devices, deviceId])=>{\n                if (!deviceId) {\n                    return;\n                }\n                const device = devices.find((d)=>d.deviceId === deviceId && d.kind === \"audiooutput\");\n                if (!device) {\n                    this.select(\"\");\n                }\n            }));\n        }\n    }\n    /**\n     * Lists the available audio output devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     * Note: This method is not supported in React Native\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        return getAudioOutputDevices();\n    }\n    /**\n     * Select a device.\n     *\n     * Note: This method is not supported in React Native\n     *\n     * @param deviceId empty string means the system default\n     */ select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        this.state.setDevice(deviceId);\n    }\n    /**\n     * Set the volume of the audio elements\n     * @param volume a number between 0 and 1.\n     *\n     * Note: This method is not supported in React Native\n     */ setVolume(volume) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        if (volume && (volume < 0 || volume > 1)) {\n            throw new Error(\"Volume must be between 0 and 1\");\n        }\n        this.state.setVolume(volume);\n    }\n    /**\n     * Set the volume of a participant.\n     *\n     * Note: This method is not supported in React Native.\n     *\n     * @param sessionId the participant's session id.\n     * @param volume a number between 0 and 1. Set it to `undefined` to use the default volume.\n     */ setParticipantVolume(sessionId, volume) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        if (volume && (volume < 0 || volume > 1)) {\n            throw new Error(\"Volume must be between 0 and 1, or undefined\");\n        }\n        this.call.state.updateParticipant(sessionId, {\n            audioVolume: volume\n        });\n    }\n}\n/**\n * An object representation of a `Call`.\n */ class Call {\n    /**\n     * Constructs a new `Call` instance.\n     *\n     * NOTE: Don't call the constructor directly, instead\n     * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)\n     * method to construct a `Call` instance.\n     */ constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing = false, watching = false }){\n        /**\n         * The state of this call.\n         */ this.state = new CallState();\n        /**\n         * The DynascaleManager instance.\n         */ this.dynascaleManager = new DynascaleManager(this);\n        /**\n         * The permissions context of this call.\n         */ this.permissionsContext = new PermissionsContext();\n        /**\n         * The event dispatcher instance dedicated to this Call instance.\n         * @private\n         */ this.dispatcher = new Dispatcher();\n        this.trackSubscriptionsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject({\n            type: DebounceType.MEDIUM,\n            data: []\n        });\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        /**\n         * A list hooks/functions to invoke when the call is left.\n         * A typical use case is to clean up some global event handlers.\n         * @private\n         */ this.leaveCallHooks = new Set();\n        this.streamClientEventHandlers = new Map();\n        /**\n         * You can subscribe to WebSocket events provided by the API. To remove a subscription, call the `off` method.\n         * Please note that subscribing to WebSocket events is an advanced use-case.\n         * For most use-cases, it should be enough to watch for state changes.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.on = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.on(eventName, fn);\n            }\n            const offHandler = this.streamClient.on(eventName, (e)=>{\n                const event = e;\n                if (event.call_cid && event.call_cid === this.cid) {\n                    fn(event);\n                }\n            });\n            // keep the 'off' reference returned by the stream client\n            this.streamClientEventHandlers.set(fn, offHandler);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.off = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.off(eventName, fn);\n            }\n            // unsubscribe from the stream client event by using the 'off' reference\n            const registeredOffHandler = this.streamClientEventHandlers.get(fn);\n            if (registeredOffHandler) {\n                registeredOffHandler();\n            }\n        };\n        /**\n         * Leave the call and stop the media streams that were published by the call.\n         */ this.leave = async ({ reject = false, reason = \"user is leaving the call\" } = {})=>{\n            const callingState = this.state.callingState;\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Cannot leave call that has already been left.\");\n            }\n            if (callingState === CallingState.JOINING) {\n                await this.assertCallJoined();\n            }\n            if (this.ringing) {\n                // I'm the one who started the call, so I should cancel it.\n                const hasOtherParticipants = this.state.remoteParticipants.length > 0;\n                if (this.isCreatedByMe && !hasOtherParticipants) {\n                    // Signals other users that I have cancelled my call to them\n                    // before they accepted it.\n                    await this.reject();\n                } else if (reject && callingState === CallingState.RINGING) {\n                    // Signals other users that I have rejected the incoming call.\n                    await this.reject();\n                }\n            }\n            this.statsReporter?.stop();\n            this.statsReporter = undefined;\n            this.sfuStatsReporter?.stop();\n            this.sfuStatsReporter = undefined;\n            this.subscriber?.close();\n            this.subscriber = undefined;\n            this.publisher?.close();\n            this.publisher = undefined;\n            this.sfuClient?.close(StreamSfuClient.NORMAL_CLOSURE, reason);\n            this.sfuClient = undefined;\n            this.dispatcher.offAll();\n            this.state.setCallingState(CallingState.LEFT);\n            // Call all leave call hooks, e.g. to clean up global event handlers\n            this.leaveCallHooks.forEach((hook)=>hook());\n            this.clientStore.unregisterCall(this);\n            this.camera.dispose();\n            this.microphone.dispose();\n            this.screenShare.dispose();\n            this.speaker.dispose();\n            const stopOnLeavePromises = [];\n            if (this.camera.stopOnLeave) {\n                stopOnLeavePromises.push(this.camera.disable(true));\n            }\n            if (this.microphone.stopOnLeave) {\n                stopOnLeavePromises.push(this.microphone.disable(true));\n            }\n            if (this.screenShare.stopOnLeave) {\n                stopOnLeavePromises.push(this.screenShare.disable(true));\n            }\n            await Promise.all(stopOnLeavePromises);\n        };\n        /**\n         * Loads the information about the call.\n         *\n         * @param params.ring if set to true, a `call.ring` event will be sent to the call members.\n         * @param params.notify if set to true, a `call.notification` event will be sent to the call members.\n         * @param params.members_limit the total number of members to return as part of the response.\n         */ this.get = async (params)=>{\n            const response = await this.streamClient.get(this.streamClientBasePath, params);\n            if (params?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Loads the information about the call and creates it if it doesn't exist.\n         *\n         * @param data the data to create the call with.\n         */ this.getOrCreate = async (data)=>{\n            const response = await this.streamClient.post(this.streamClientBasePath, data);\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Creates a call\n         *\n         * @param data the data to create the call with.\n         */ this.create = async (data)=>{\n            return this.getOrCreate(data);\n        };\n        /**\n         * A shortcut for {@link Call.get} with `ring` parameter set to `true`.\n         * Will send a `call.ring` event to the call members.\n         */ this.ring = async ()=>{\n            return await this.get({\n                ring: true\n            });\n        };\n        /**\n         * A shortcut for {@link Call.get} with `notify` parameter set to `true`.\n         * Will send a `call.notification` event to the call members.\n         */ this.notify = async ()=>{\n            return await this.get({\n                notify: true\n            });\n        };\n        /**\n         * Marks the incoming call as accepted.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.join} invokes this method automatically for you when joining a call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.accept = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/accept`);\n        };\n        /**\n         * Marks the incoming call as rejected.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.leave} invokes this method automatically for you when you leave or reject this call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.reject = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reject`);\n        };\n        /**\n         * Will start to watch for call related WebSocket events and initiate a call session with the server.\n         *\n         * @returns a promise which resolves once the call join-flow has finished.\n         */ this.join = async (data)=>{\n            const callingState = this.state.callingState;\n            if ([\n                CallingState.JOINED,\n                CallingState.JOINING\n            ].includes(callingState)) {\n                this.logger(\"warn\", \"Join method called twice, you should only call this once\");\n                throw new Error(`Illegal State: Already joined.`);\n            }\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Illegal State: Cannot join already left call. Create a new Call instance to join a call.\");\n            }\n            const isMigrating = callingState === CallingState.MIGRATING;\n            const isReconnecting = callingState === CallingState.RECONNECTING;\n            this.state.setCallingState(CallingState.JOINING);\n            this.logger(\"debug\", \"Starting join flow\");\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            if (this.ringing && !this.isCreatedByMe) {\n                // signals other users that I have accepted the incoming call.\n                await this.accept();\n            }\n            let sfuServer;\n            let sfuToken;\n            let connectionConfig;\n            let statsOptions;\n            try {\n                if (this.sfuClient?.isFastReconnecting) {\n                    // use previous SFU configuration and values\n                    connectionConfig = this.publisher?.connectionConfiguration;\n                    sfuServer = this.sfuClient.sfuServer;\n                    sfuToken = this.sfuClient.token;\n                    statsOptions = this.sfuStatsReporter?.options;\n                } else {\n                    // full join flow - let the Coordinator pick a new SFU for us\n                    const call = await join(this.streamClient, this.type, this.id, data);\n                    this.state.updateFromCallResponse(call.metadata);\n                    this.state.setMembers(call.members);\n                    this.state.setOwnCapabilities(call.ownCapabilities);\n                    connectionConfig = call.connectionConfig;\n                    sfuServer = call.sfuServer;\n                    sfuToken = call.token;\n                    statsOptions = call.statsOptions;\n                }\n                if (this.streamClient._hasConnectionID()) {\n                    this.watching = true;\n                    this.clientStore.registerCall(this);\n                }\n            } catch (error) {\n                // restore the previous call state if the join-flow fails\n                this.state.setCallingState(callingState);\n                throw error;\n            }\n            const previousSfuClient = this.sfuClient;\n            const sfuClient = this.sfuClient = new StreamSfuClient({\n                dispatcher: this.dispatcher,\n                sfuServer,\n                token: sfuToken,\n                sessionId: previousSfuClient?.sessionId\n            });\n            /**\n             * A closure which hides away the re-connection logic.\n             */ const reconnect = async (strategy, reason)=>{\n                const currentState = this.state.callingState;\n                if (currentState === CallingState.MIGRATING || currentState === CallingState.RECONNECTING) {\n                    // prevent parallel reconnection attempts\n                    return;\n                }\n                this.reconnectAttempts++;\n                this.state.setCallingState(strategy === \"migrate\" ? CallingState.MIGRATING : CallingState.RECONNECTING);\n                if (strategy === \"migrate\") {\n                    this.logger(\"debug\", `[Migration]: migrating call ${this.cid} away from ${sfuServer.edge_name}`);\n                    sfuClient.isMigratingAway = true;\n                } else {\n                    this.logger(\"debug\", `[Rejoin]: ${strategy} rejoin call ${this.cid} (${this.reconnectAttempts})...`);\n                }\n                // take a snapshot of the current \"local participant\" state\n                // we'll need it for restoring the previous publishing state later\n                const localParticipant = this.state.localParticipant;\n                if (strategy === \"fast\") {\n                    sfuClient.close(StreamSfuClient.ERROR_CONNECTION_BROKEN, `attempting fast reconnect: ${reason}`);\n                } else if (strategy === \"full\") {\n                    // in migration or recovery scenarios, we don't want to\n                    // wait before attempting to reconnect to an SFU server\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    // in full-reconnect, we need to dispose all Peer Connections\n                    this.subscriber?.close();\n                    this.subscriber = undefined;\n                    this.publisher?.close({\n                        stopTracks: false\n                    });\n                    this.publisher = undefined;\n                    this.statsReporter?.stop();\n                    this.statsReporter = undefined;\n                    this.sfuStatsReporter?.stop();\n                    this.sfuStatsReporter = undefined;\n                    // clean up current connection\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, `attempting full reconnect: ${reason}`);\n                }\n                await this.join({\n                    ...data,\n                    ...strategy === \"migrate\" && {\n                        migrating_from: sfuServer.edge_name\n                    }\n                });\n                // clean up previous connection\n                if (strategy === \"migrate\") {\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, \"attempting migration\");\n                }\n                this.logger(\"info\", `[Rejoin]: Attempt ${this.reconnectAttempts} successful!`);\n                // we shouldn't be republishing the streams if we're migrating\n                // as the underlying peer connection will take care of it as part\n                // of the ice-restart process\n                if (localParticipant && strategy === \"full\") {\n                    const { audioStream, videoStream, screenShareStream, screenShareAudioStream } = localParticipant;\n                    let screenShare;\n                    if (screenShareStream || screenShareAudioStream) {\n                        screenShare = new MediaStream();\n                        screenShareStream?.getVideoTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                        screenShareAudioStream?.getAudioTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                    }\n                    // restore previous publishing state\n                    if (audioStream) await this.publishAudioStream(audioStream);\n                    if (videoStream) {\n                        await this.publishVideoStream(videoStream, {\n                            preferredCodec: this.camera.preferredCodec\n                        });\n                    }\n                    if (screenShare) await this.publishScreenShareStream(screenShare);\n                    this.logger(\"info\", `[Rejoin]: State restored. Attempt: ${this.reconnectAttempts}`);\n                }\n            };\n            // reconnect if the connection was closed unexpectedly. example:\n            // - SFU crash or restart\n            // - network change\n            sfuClient.signalReady.then(()=>{\n                // register a handler for the \"goAway\" event\n                const unregisterGoAway = this.dispatcher.on(\"goAway\", (event)=>{\n                    const { reason } = event;\n                    this.logger(\"info\", `[Migration]: Going away from SFU... Reason: ${GoAwayReason[reason]}`);\n                    reconnect(\"migrate\", GoAwayReason[reason]).catch((err)=>{\n                        this.logger(\"warn\", `[Migration]: Failed to migrate to another SFU.`, err);\n                    });\n                });\n                sfuClient.signalWs.addEventListener(\"close\", (e)=>{\n                    // unregister the \"goAway\" handler, as we won't need it anymore for this connection.\n                    // the upcoming re-join will register a new handler anyway\n                    unregisterGoAway();\n                    // do nothing if the connection was closed on purpose\n                    if (e.code === StreamSfuClient.NORMAL_CLOSURE) return;\n                    // do nothing if the connection was closed because of a policy violation\n                    // e.g., the user has been blocked by an admin or moderator\n                    if (e.code === KnownCodes.WS_POLICY_VIOLATION) return;\n                    // When the SFU is being shut down, it sends a goAway message.\n                    // While we migrate to another SFU, we might have the WS connection\n                    // to the old SFU closed abruptly. In this case, we don't want\n                    // to reconnect to the old SFU, but rather to the new one.\n                    const isMigratingAway = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isMigratingAway;\n                    const isFastReconnecting = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isFastReconnecting;\n                    if (isMigratingAway || isFastReconnecting) return;\n                    // do nothing if the connection was closed because of a fast reconnect\n                    if (e.code === StreamSfuClient.ERROR_CONNECTION_BROKEN) return;\n                    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                        sfuClient.isFastReconnecting = this.reconnectAttempts === 0;\n                        const strategy = sfuClient.isFastReconnecting ? \"fast\" : \"full\";\n                        reconnect(strategy, `SFU closed the WS with code: ${e.code}`).catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: ${strategy} rejoin failed for ${this.reconnectAttempts} times. Giving up.`, err);\n                            this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                        });\n                    } else {\n                        this.logger(\"error\", \"[Rejoin]: Reconnect attempts exceeded. Giving up...\");\n                        this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    }\n                });\n            });\n            // handlers for connection online/offline events\n            const unsubscribeOnlineEvent = this.streamClient.on(\"connection.changed\", async (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (!e.online) return;\n                unsubscribeOnlineEvent();\n                const currentCallingState = this.state.callingState;\n                const shouldReconnect = currentCallingState === CallingState.OFFLINE || currentCallingState === CallingState.RECONNECTING_FAILED;\n                if (!shouldReconnect) return;\n                this.logger(\"info\", \"[Rejoin]: Going online...\");\n                let isFirstReconnectAttempt = true;\n                do {\n                    try {\n                        sfuClient.isFastReconnecting = isFirstReconnectAttempt;\n                        await reconnect(isFirstReconnectAttempt ? \"fast\" : \"full\", \"Network: online\");\n                        return; // break the loop if rejoin is successful\n                    } catch (err) {\n                        this.logger(\"error\", `[Rejoin][Network]: Rejoin failed for attempt ${this.reconnectAttempts}`, err);\n                    }\n                    // wait for a bit before trying to reconnect again\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    isFirstReconnectAttempt = false;\n                }while (this.reconnectAttempts < this.maxReconnectAttempts);\n                // if we're here, it means that we've exhausted all the reconnect attempts\n                this.logger(\"error\", `[Rejoin][Network]: Rejoin failed. Giving up.`);\n                this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n            });\n            const unsubscribeOfflineEvent = this.streamClient.on(\"connection.changed\", (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (e.online) return;\n                unsubscribeOfflineEvent();\n                this.state.setCallingState(CallingState.OFFLINE);\n            });\n            this.leaveCallHooks.add(()=>{\n                unsubscribeOnlineEvent();\n                unsubscribeOfflineEvent();\n            });\n            if (!this.subscriber) {\n                this.subscriber = new Subscriber({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig\n                });\n            }\n            if (!this.publisher) {\n                const audioSettings = this.state.settings?.audio;\n                const isDtxEnabled = !!audioSettings?.opus_dtx_enabled;\n                const isRedEnabled = !!audioSettings?.redundant_coding_enabled;\n                this.publisher = new Publisher({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig,\n                    isDtxEnabled,\n                    isRedEnabled\n                });\n            }\n            if (!this.statsReporter) {\n                this.statsReporter = createStatsReporter({\n                    subscriber: this.subscriber,\n                    publisher: this.publisher,\n                    state: this.state\n                });\n            }\n            const clientDetails = getClientDetails();\n            if (!this.sfuStatsReporter && statsOptions) {\n                this.sfuStatsReporter = new SfuStatsReporter(sfuClient, {\n                    clientDetails,\n                    options: statsOptions,\n                    subscriber: this.subscriber,\n                    publisher: this.publisher\n                });\n                this.sfuStatsReporter.start();\n            }\n            try {\n                // 1. wait for the signal server to be ready before sending \"joinRequest\"\n                sfuClient.signalReady.catch((err)=>this.logger(\"error\", \"Signal ready failed\", err))// prepare a generic SDP and send it to the SFU.\n                // this is a throw-away SDP that the SFU will use to determine\n                // the capabilities of the client (codec support, etc.)\n                .then(()=>getGenericSdp(\"recvonly\")).then((sdp)=>{\n                    const subscriptions = getCurrentValue(this.trackSubscriptionsSubject);\n                    const migration = isMigrating ? {\n                        fromSfuId: data?.migrating_from || \"\",\n                        subscriptions: subscriptions.data || [],\n                        announcedTracks: this.publisher?.getCurrentTrackInfos() || []\n                    } : undefined;\n                    return sfuClient.join({\n                        subscriberSdp: sdp || \"\",\n                        clientDetails,\n                        migration,\n                        fastReconnect: previousSfuClient?.isFastReconnecting ?? false\n                    });\n                });\n                // 2. in parallel, wait for the SFU to send us the \"joinResponse\"\n                // this will throw an error if the SFU rejects the join request or\n                // fails to respond in time\n                const { callState, reconnected } = await this.waitForJoinResponse();\n                if (isReconnecting) {\n                    this.logger(\"debug\", \"[Rejoin] fast reconnected:\", reconnected);\n                }\n                if (isMigrating) {\n                    await this.subscriber.migrateTo(sfuClient, connectionConfig);\n                    await this.publisher.migrateTo(sfuClient, connectionConfig);\n                } else if (isReconnecting) {\n                    if (reconnected) {\n                        // update the SFU client instance on the subscriber and publisher\n                        this.subscriber.setSfuClient(sfuClient);\n                        this.publisher.setSfuClient(sfuClient);\n                        // and perform a full ICE restart on the publisher\n                        await this.publisher.restartIce();\n                    } else if (previousSfuClient?.isFastReconnecting) {\n                        // reconnection wasn't possible, so we need to do a full rejoin\n                        return await reconnect(\"full\", \"re-attempting\").catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: Rejoin failed forced full rejoin.`, err);\n                        });\n                    }\n                }\n                const currentParticipants = callState?.participants || [];\n                const participantCount = callState?.participantCount;\n                const startedAt = callState?.startedAt ? Timestamp.toDate(callState.startedAt) : new Date();\n                const pins = callState?.pins ?? [];\n                this.state.setParticipants(()=>{\n                    const participantLookup = this.state.getParticipantLookupBySessionId();\n                    return currentParticipants.map((p)=>{\n                        // We need to preserve the local state of the participant\n                        // (e.g. videoDimension, visibilityState, pinnedAt, etc.)\n                        // as it doesn't exist on the server.\n                        const existingParticipant = participantLookup[p.sessionId];\n                        return Object.assign(p, existingParticipant, {\n                            isLocalParticipant: p.sessionId === sfuClient.sessionId,\n                            viewportVisibilityState: existingParticipant?.viewportVisibilityState ?? {\n                                videoTrack: VisibilityState.UNKNOWN,\n                                screenShareTrack: VisibilityState.UNKNOWN\n                            }\n                        });\n                    });\n                });\n                this.state.setParticipantCount(participantCount?.total || 0);\n                this.state.setAnonymousParticipantCount(participantCount?.anonymous || 0);\n                this.state.setStartedAt(startedAt);\n                this.state.setServerSidePins(pins);\n                this.reconnectAttempts = 0; // reset the reconnect attempts counter\n                this.state.setCallingState(CallingState.JOINED);\n                try {\n                    await this.initCamera({\n                        setStatus: true\n                    });\n                    await this.initMic({\n                        setStatus: true\n                    });\n                } catch (error) {\n                    this.logger(\"warn\", \"Camera and/or mic init failed during join call\", error);\n                }\n                // 3. once we have the \"joinResponse\", and possibly reconciled the local state\n                // we schedule a fast subscription update for all remote participants\n                // that were visible before we reconnected or migrated to a new SFU.\n                const { remoteParticipants } = this.state;\n                if (remoteParticipants.length > 0) {\n                    this.updateSubscriptions(remoteParticipants, DebounceType.FAST);\n                }\n                this.logger(\"info\", `Joined call ${this.cid}`);\n            } catch (err) {\n                // join failed, try to rejoin\n                if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                    this.logger(\"error\", `[Rejoin]: Rejoin ${this.reconnectAttempts} failed.`, err);\n                    await reconnect(\"full\", \"previous attempt failed\");\n                    this.logger(\"info\", `[Rejoin]: Rejoin ${this.reconnectAttempts} successful!`);\n                } else {\n                    this.logger(\"error\", `[Rejoin]: Rejoin failed for ${this.reconnectAttempts} times. Giving up.`);\n                    this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    throw new Error(\"Join failed\");\n                }\n            }\n        };\n        this.waitForJoinResponse = (timeout = 5000)=>{\n            return new Promise((resolve, reject)=>{\n                const unsubscribe = this.on(\"joinResponse\", (event)=>{\n                    clearTimeout(timeoutId);\n                    unsubscribe();\n                    resolve(event);\n                });\n                const timeoutId = setTimeout(()=>{\n                    unsubscribe();\n                    reject(new Error('Waiting for \"joinResponse\" has timed out'));\n                }, timeout);\n            });\n        };\n        /**\n         * Starts publishing the given video stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the previously published stream.\n         * The previous video stream will be stopped.\n         *\n         * @param videoStream the video stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishVideoStream = async (videoStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish video before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [videoTrack] = videoStream.getVideoTracks();\n            if (!videoTrack) {\n                this.logger(\"error\", `There is no video track to publish in the stream.`);\n                return;\n            }\n            await this.publisher.publishStream(videoStream, videoTrack, TrackType.VIDEO, opts);\n        };\n        /**\n         * Starts publishing the given audio stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the audio stream that is currently being published.\n         * The previous audio stream will be stopped.\n         *\n         * @param audioStream the audio stream to publish.\n         */ this.publishAudioStream = async (audioStream)=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish audio before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [audioTrack] = audioStream.getAudioTracks();\n            if (!audioTrack) {\n                this.logger(\"error\", `There is no audio track in the stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(audioStream, audioTrack, TrackType.AUDIO);\n        };\n        /**\n         * Starts publishing the given screen-share stream to the call.\n         *\n         * Consecutive calls to this method will replace the previous screen-share stream.\n         * The previous screen-share stream will be stopped.\n         *\n         * @param screenShareStream the screen-share stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishScreenShareStream = async (screenShareStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish screen share before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [screenShareTrack] = screenShareStream.getVideoTracks();\n            if (!screenShareTrack) {\n                this.logger(\"error\", `There is no video track in the screen share stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(screenShareStream, screenShareTrack, TrackType.SCREEN_SHARE, opts);\n            const [screenShareAudioTrack] = screenShareStream.getAudioTracks();\n            if (screenShareAudioTrack) {\n                await this.publisher.publishStream(screenShareStream, screenShareAudioTrack, TrackType.SCREEN_SHARE_AUDIO, opts);\n            }\n        };\n        /**\n         * Stops publishing the given track type to the call, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         *\n         * @param trackType the track type to stop publishing.\n         * @param stopTrack if `true` the track will be stopped, else it will be just disabled\n         */ this.stopPublish = async (trackType, stopTrack = true)=>{\n            this.logger(\"info\", `stopPublish ${TrackType[trackType]}, stop tracks: ${stopTrack}`);\n            await this.publisher?.unpublishStream(trackType, stopTrack);\n        };\n        /**\n         * Update track subscription configuration for one or more participants.\n         * You have to create a subscription for each participant for all the different kinds of tracks you want to receive.\n         * You can only subscribe for tracks after the participant started publishing the given kind of track.\n         *\n         * @param trackType the kind of subscription to update.\n         * @param changes the list of subscription changes to do.\n         * @param type the debounce type to use for the update.\n         */ this.updateSubscriptionsPartial = (trackType, changes, type = DebounceType.SLOW)=>{\n            if (trackType === \"video\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'videoTrack'`);\n                trackType = \"videoTrack\";\n            } else if (trackType === \"screen\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'screenShareTrack'`);\n                trackType = \"screenShareTrack\";\n            }\n            const participants = this.state.updateParticipants(Object.entries(changes).reduce((acc, [sessionId, change])=>{\n                if (change.dimension?.height) {\n                    change.dimension.height = Math.ceil(change.dimension.height);\n                }\n                if (change.dimension?.width) {\n                    change.dimension.width = Math.ceil(change.dimension.width);\n                }\n                const prop = trackType === \"videoTrack\" ? \"videoDimension\" : trackType === \"screenShareTrack\" ? \"screenShareDimension\" : undefined;\n                if (prop) {\n                    acc[sessionId] = {\n                        [prop]: change.dimension\n                    };\n                }\n                return acc;\n            }, {}));\n            if (participants) {\n                this.updateSubscriptions(participants, type);\n            }\n        };\n        this.updateSubscriptions = (participants, type = DebounceType.SLOW)=>{\n            const subscriptions = [];\n            for (const p of participants){\n                // we don't want to subscribe to our own tracks\n                if (p.isLocalParticipant) continue;\n                // NOTE: audio tracks don't have to be requested explicitly\n                // as the SFU will implicitly subscribe us to all of them,\n                // once they become available.\n                if (p.videoDimension && p.publishedTracks.includes(TrackType.VIDEO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.VIDEO,\n                        dimension: p.videoDimension\n                    });\n                }\n                if (p.screenShareDimension && p.publishedTracks.includes(TrackType.SCREEN_SHARE)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE,\n                        dimension: p.screenShareDimension\n                    });\n                }\n                if (p.publishedTracks.includes(TrackType.SCREEN_SHARE_AUDIO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE_AUDIO\n                    });\n                }\n            }\n            // schedule update\n            this.trackSubscriptionsSubject.next({\n                type,\n                data: subscriptions\n            });\n        };\n        /**\n         * Will enhance the reported stats with additional participant-specific information (`callStatsReport$` state [store variable](./StreamVideoClient.md/#readonlystatestore)).\n         * This is usually helpful when detailed stats for a specific participant are needed.\n         *\n         * @param sessionId the sessionId to start reporting for.\n         */ this.startReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.startReportingStatsFor(sessionId);\n        };\n        /**\n         * Opposite of `startReportingStatsFor`.\n         * Will turn off stats reporting for a specific participant.\n         *\n         * @param sessionId the sessionId to stop reporting for.\n         */ this.stopReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.stopReportingStatsFor(sessionId);\n        };\n        /**\n         * Resets the last sent reaction for the user holding the given `sessionId`. This is a local action, it won't reset the reaction on the backend.\n         *\n         * @param sessionId the session id.\n         */ this.resetReaction = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                reaction: undefined\n            });\n        };\n        /**\n         * Sets the list of criteria to sort the participants by.\n         *\n         * @param criteria the list of criteria to sort the participants by.\n         */ this.setSortParticipantsBy = (criteria)=>{\n            return this.state.setSortParticipantsBy(criteria);\n        };\n        /**\n         * Updates the list of video layers to publish.\n         *\n         * @internal\n         * @param enabledLayers the list of layers to enable.\n         */ this.updatePublishQuality = async (enabledLayers)=>{\n            return this.publisher?.updateVideoPublishQuality(enabledLayers);\n        };\n        this.assertCallJoined = ()=>{\n            return new Promise((resolve)=>{\n                this.state.callingState$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.takeWhile)((state)=>state !== CallingState.JOINED, true), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__.filter)((s)=>s === CallingState.JOINED)).subscribe(()=>resolve());\n            });\n        };\n        /**\n         * Sends a reaction to the other call participants.\n         *\n         * @param reaction the reaction to send.\n         */ this.sendReaction = async (reaction)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reaction`, reaction);\n        };\n        /**\n         * Blocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to block.\n         */ this.blockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/block`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Unblocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to unblock.\n         */ this.unblockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unblock`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Mutes the current user.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteSelf = (type)=>{\n            const myUserId = this.currentUserId;\n            if (myUserId) {\n                return this.muteUser(myUserId, type);\n            }\n        };\n        /**\n         * Mutes all the other participants.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteOthers = (type)=>{\n            const trackType = muteTypeToTrackType(type);\n            if (!trackType) return;\n            const userIdsToMute = [];\n            for (const participant of this.state.remoteParticipants){\n                if (participant.publishedTracks.includes(trackType)) {\n                    userIdsToMute.push(participant.userId);\n                }\n            }\n            return this.muteUser(userIdsToMute, type);\n        };\n        /**\n         * Mutes the user with the given `userId`.\n         *\n         * @param userId the id of the user to mute.\n         * @param type the type of the mute operation.\n         */ this.muteUser = (userId, type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                user_ids: Array.isArray(userId) ? userId : [\n                    userId\n                ],\n                [type]: true\n            });\n        };\n        /**\n         * Will mute all users in the call.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteAllUsers = (type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                mute_all_users: true,\n                [type]: true\n            });\n        };\n        /**\n         * Starts recording the call\n         */ this.startRecording = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_recording`, request ? request : {});\n        };\n        /**\n         * Stops recording the call\n         */ this.stopRecording = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_recording`, {});\n        };\n        /**\n         * Starts the transcription of the call.\n         *\n         * @param request the request data.\n         */ this.startTranscription = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_transcription`, request);\n        };\n        /**\n         * Stops the transcription of the call.\n         */ this.stopTranscription = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_transcription`);\n        };\n        /**\n         * Sends a `call.permission_request` event to all users connected to the call. The call settings object contains infomration about which permissions can be requested during a call (for example a user might be allowed to request permission to publish audio, but not video).\n         */ this.requestPermissions = async (data)=>{\n            const { permissions } = data;\n            const canRequestPermissions = permissions.every((permission)=>this.permissionsContext.canRequest(permission));\n            if (!canRequestPermissions) {\n                throw new Error(`You are not allowed to request permissions: ${permissions.join(\", \")}`);\n            }\n            return this.streamClient.post(`${this.streamClientBasePath}/request_permission`, data);\n        };\n        /**\n         * Allows you to grant certain permissions to a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be granted are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to grant permissions to.\n         * @param permissions the permissions to grant.\n         */ this.grantPermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                grant_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to revoke certain permissions from a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be revoked are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to revoke permissions from.\n         * @param permissions the permissions to revoke.\n         */ this.revokePermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                revoke_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to grant or revoke a specific permission to a user in a call. The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * When revoking a permission, this endpoint will also mute the relevant track from the user. This is similar to muting a user with the difference that the user will not be able to unmute afterwards.\n         *\n         * Supported permissions that can be granted or revoked: `send-audio`, `send-video` and `screenshare`.\n         *\n         * `call.permissions_updated` event is sent to all members of the call.\n         *\n         */ this.updateUserPermissions = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/user_permissions`, data);\n        };\n        /**\n         * Starts the livestreaming of the call.\n         *\n         * @param data the request data.\n         * @param params the request params.\n         */ this.goLive = async (data = {}, params)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/go_live`, data, params);\n        };\n        /**\n         * Stops the livestreaming of the call.\n         */ this.stopLive = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_live`, {});\n        };\n        /**\n         * Starts the broadcasting of the call.\n         */ this.startHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_broadcasting`, {});\n        };\n        /**\n         * Stops the broadcasting of the call.\n         */ this.stopHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_broadcasting`, {});\n        };\n        /**\n         * Updates the call settings or custom data.\n         *\n         * @param updates the updates to apply to the call.\n         */ this.update = async (updates)=>{\n            const response = await this.streamClient.patch(`${this.streamClientBasePath}`, updates);\n            const { call, members, own_capabilities } = response;\n            this.state.updateFromCallResponse(call);\n            this.state.setMembers(members);\n            this.state.setOwnCapabilities(own_capabilities);\n            return response;\n        };\n        /**\n         * Ends the call. Once the call is ended, it cannot be re-joined.\n         */ this.endCall = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mark_ended`);\n        };\n        /**\n         * Pins the given session to the top of the participants list.\n         *\n         * @param sessionId the sessionId to pin.\n         */ this.pin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: {\n                    isLocalPin: true,\n                    pinnedAt: Date.now()\n                }\n            });\n        };\n        /**\n         * Unpins the given session from the top of the participants list.\n         *\n         * @param sessionId the sessionId to unpin.\n         */ this.unpin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: undefined\n            });\n        };\n        /**\n         * Pins the given session to the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.pinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/pin`, request);\n        };\n        /**\n         * Unpins the given session from the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.unpinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unpin`, request);\n        };\n        /**\n         * Query call members with filter query. The result won't be stored in call state.\n         * @param request\n         * @returns\n         */ this.queryMembers = (request)=>{\n            return this.streamClient.post(\"/call/members\", {\n                ...request || {},\n                id: this.id,\n                type: this.type\n            });\n        };\n        /**\n         * Will update the call members.\n         *\n         * @param data the request data.\n         */ this.updateCallMembers = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/members`, data);\n        };\n        /**\n         * Schedules an auto-drop timeout based on the call settings.\n         * Applicable only for ringing calls.\n         */ this.scheduleAutoDrop = ()=>{\n            clearTimeout(this.dropTimeout);\n            this.leaveCallHooks.add(createSubscription(this.state.settings$, (settings)=>{\n                if (!settings) return;\n                // ignore if the call is not ringing\n                if (this.state.callingState !== CallingState.RINGING) return;\n                const timeoutInMs = settings.ring.auto_cancel_timeout_ms;\n                // 0 means no auto-drop\n                if (timeoutInMs <= 0) return;\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = setTimeout(()=>{\n                    this.leave({\n                        reason: \"ring: timeout\"\n                    }).catch((err)=>{\n                        this.logger(\"error\", \"Failed to drop call\", err);\n                    });\n                }, timeoutInMs);\n            }));\n        };\n        /**\n         * Retrieves the list of recordings for the current call or call session.\n         *\n         * If `callSessionId` is provided, it will return the recordings for that call session.\n         * Otherwise, all recordings for the current call will be returned.\n         *\n         * @param callSessionId the call session id to retrieve recordings for.\n         */ this.queryRecordings = async (callSessionId)=>{\n            let endpoint = this.streamClientBasePath;\n            if (callSessionId) {\n                endpoint = `${endpoint}/${callSessionId}`;\n            }\n            return this.streamClient.get(`${endpoint}/recordings`);\n        };\n        /**\n         * Retrieves the list of transcriptions for the current call.\n         *\n         * @returns the list of transcriptions.\n         */ this.queryTranscriptions = async ()=>{\n            return this.streamClient.get(`${this.streamClientBasePath}/transcriptions`);\n        };\n        /**\n         * Retrieve call statistics for a particular call session (historical).\n         * Here `callSessionID` is mandatory.\n         *\n         * @param callSessionID the call session ID to retrieve statistics for.\n         * @returns The call stats.\n         */ this.getCallStats = async (callSessionID)=>{\n            const endpoint = `${this.streamClientBasePath}/stats/${callSessionID}`;\n            return this.streamClient.get(endpoint);\n        };\n        /**\n         * Submit user feedback for the call\n         *\n         * @param rating Rating between 1 and 5 denoting the experience of the user in the call\n         * @param reason The reason/description for the rating\n         * @param custom Custom data\n         * @returns\n         */ this.submitFeedback = async (rating, { reason, custom } = {})=>{\n            if (rating < 1 || rating > 5) {\n                throw new Error(\"Rating must be between 1 and 5\");\n            }\n            const userSessionId = this.sfuClient?.sessionId;\n            const callSessionId = this.state.session?.id;\n            if (!callSessionId || !userSessionId) {\n                throw new Error(\"Feedback can be submitted only in the context of a call session\");\n            }\n            const { sdkName, sdkVersion, ...platform } = getSdkSignature(getClientDetails());\n            const endpoint = `${this.streamClientBasePath}/feedback/${callSessionId}`;\n            return this.streamClient.post(endpoint, {\n                rating,\n                reason,\n                user_session_id: userSessionId,\n                sdk: sdkName,\n                sdk_version: sdkVersion,\n                custom: {\n                    ...custom,\n                    \"x-stream-platform-data\": platform\n                }\n            });\n        };\n        /**\n         * Sends a custom event to all call participants.\n         *\n         * @param payload the payload to send.\n         */ this.sendCustomEvent = async (payload)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/event`, {\n                custom: payload\n            });\n        };\n        this.applyDeviceConfig = ()=>{\n            this.initCamera({\n                setStatus: false\n            });\n            this.initMic({\n                setStatus: false\n            });\n        };\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the video mode.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            return this.dynascaleManager.trackElementVisibility(element, sessionId, trackType);\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.dynascaleManager.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const unbind = this.dynascaleManager.bindVideoElement(videoElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType = \"audioTrack\")=>{\n            const unbind = this.dynascaleManager.bindAudioElement(audioElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <img> element to this call's thumbnail (if enabled in settings).\n         *\n         * @param imageElement the image element to bind to.\n         * @param opts options for the binding.\n         */ this.bindCallThumbnailElement = (imageElement, opts = {})=>{\n            const handleError = ()=>{\n                imageElement.src = opts.fallbackImageSource || \"https://getstream.io/random_svg/?name=x&id=x\";\n            };\n            const unsubscribe = createSubscription(this.state.thumbnails$, (thumbnails)=>{\n                if (!thumbnails) return;\n                imageElement.addEventListener(\"error\", handleError);\n                const thumbnailUrl = new URL(thumbnails.image_url);\n                thumbnailUrl.searchParams.set(\"w\", String(imageElement.clientWidth));\n                thumbnailUrl.searchParams.set(\"h\", String(imageElement.clientHeight));\n                imageElement.src = thumbnailUrl.toString();\n            });\n            return ()=>{\n                unsubscribe();\n                imageElement.removeEventListener(\"error\", handleError);\n            };\n        };\n        this.type = type;\n        this.id = id;\n        this.cid = `${type}:${id}`;\n        this.ringingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.BehaviorSubject(ringing);\n        this.watching = watching;\n        this.streamClient = streamClient;\n        this.clientStore = clientStore;\n        this.streamClientBasePath = `/call/${this.type}/${this.id}`;\n        this.logger = getLogger([\n            \"Call\"\n        ]);\n        const callTypeConfig = CallTypes.get(type);\n        const participantSorter = sortParticipantsBy || callTypeConfig.options.sortParticipantsBy;\n        if (participantSorter) {\n            this.state.setSortParticipantsBy(participantSorter);\n        }\n        this.state.setMembers(members || []);\n        this.state.setOwnCapabilities(ownCapabilities || []);\n        this.state.setCallingState(ringing ? CallingState.RINGING : CallingState.IDLE);\n        this.on(\"all\", (event)=>{\n            // update state with the latest event data\n            this.state.updateFromEvent(event);\n        });\n        this.leaveCallHooks.add(registerEventHandlers(this, this.state, this.dispatcher));\n        this.registerEffects();\n        this.leaveCallHooks.add(createSubscription(this.trackSubscriptionsSubject.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__.debounce)((v)=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__.timer)(v.type)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.map)((v)=>v.data)), (subscriptions)=>this.sfuClient?.updateSubscriptions(subscriptions)));\n        this.camera = new CameraManager(this);\n        this.microphone = new MicrophoneManager(this);\n        this.speaker = new SpeakerManager(this);\n        this.screenShare = new ScreenShareManager(this);\n    }\n    registerEffects() {\n        this.leaveCallHooks.add(// handles updating the permissions context when the settings change.\n        createSubscription(this.state.settings$, (settings)=>{\n            if (!settings) return;\n            this.permissionsContext.setCallSettings(settings);\n        }));\n        this.leaveCallHooks.add(// handle the case when the user permissions are modified.\n        createSubscription(this.state.ownCapabilities$, (ownCapabilities)=>{\n            // update the permission context.\n            this.permissionsContext.setPermissions(ownCapabilities);\n            if (!this.publisher) return;\n            // check if the user still has publishing permissions and stop publishing if not.\n            const permissionToTrackType = {\n                [OwnCapability.SEND_AUDIO]: TrackType.AUDIO,\n                [OwnCapability.SEND_VIDEO]: TrackType.VIDEO,\n                [OwnCapability.SCREENSHARE]: TrackType.SCREEN_SHARE\n            };\n            for (const [permission, trackType] of Object.entries(permissionToTrackType)){\n                const hasPermission = this.permissionsContext.hasPermission(permission);\n                if (!hasPermission && (this.publisher.isPublishing(trackType) || this.publisher.isLive(trackType))) {\n                    // Stop tracks, then notify device manager\n                    this.stopPublish(trackType).catch((err)=>{\n                        this.logger(\"error\", `Error stopping publish ${trackType}`, err);\n                    }).then(()=>{\n                        if (trackType === TrackType.VIDEO && this.camera.state.status === \"enabled\") {\n                            this.camera.disable().catch((err)=>this.logger(\"error\", `Error disabling camera after permission revoked`, err));\n                        }\n                        if (trackType === TrackType.AUDIO && this.microphone.state.status === \"enabled\") {\n                            this.microphone.disable().catch((err)=>this.logger(\"error\", `Error disabling microphone after permission revoked`, err));\n                        }\n                    });\n                }\n            }\n        }));\n        this.leaveCallHooks.add(// handles the case when the user is blocked by the call owner.\n        createSubscription(this.state.blockedUserIds$, async (blockedUserIds)=>{\n            if (!blockedUserIds || blockedUserIds.length === 0) return;\n            const currentUserId = this.currentUserId;\n            if (currentUserId && blockedUserIds.includes(currentUserId)) {\n                this.logger(\"info\", \"Leaving call because of being blocked\");\n                await this.leave({\n                    reason: \"user blocked\"\n                });\n            }\n        }));\n        this.leaveCallHooks.add(// watch for auto drop cancellation\n        createSubscription(this.state.callingState$, (callingState)=>{\n            if (!this.ringing) return;\n            if (callingState === CallingState.JOINED || callingState === CallingState.JOINING || callingState === CallingState.LEFT) {\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = undefined;\n            }\n        }));\n        this.leaveCallHooks.add(// \"ringing\" mode effects and event handlers\n        createSubscription(this.ringingSubject, (isRinging)=>{\n            if (!isRinging) return;\n            this.scheduleAutoDrop();\n            if (this.state.callingState === CallingState.IDLE) {\n                this.state.setCallingState(CallingState.RINGING);\n            }\n            this.leaveCallHooks.add(registerRingingCallEventHandlers(this));\n        }));\n    }\n    /**\n     * A flag indicating whether the call is \"ringing\" type of call.\n     */ get ringing() {\n        return getCurrentValue(this.ringingSubject);\n    }\n    /**\n     * Retrieves the current user ID.\n     */ get currentUserId() {\n        return this.clientStore.connectedUser?.id;\n    }\n    /**\n     * A flag indicating whether the call was created by the current user.\n     */ get isCreatedByMe() {\n        return this.state.createdBy?.id === this.currentUserId;\n    }\n    async initCamera(options) {\n        // Wait for any in progress camera operation\n        if (this.camera.enablePromise) {\n            await this.camera.enablePromise;\n        }\n        if (this.camera.disablePromise) {\n            await this.camera.disablePromise;\n        }\n        if (this.state.localParticipant?.videoStream || !this.permissionsContext.hasPermission(\"send-video\")) {\n            return;\n        }\n        // Set camera direction if it's not yet set\n        if (!this.camera.state.direction && !this.camera.state.selectedDevice) {\n            let defaultDirection = \"front\";\n            const backendSetting = this.state.settings?.video.camera_facing;\n            if (backendSetting) {\n                defaultDirection = backendSetting === \"front\" ? \"front\" : \"back\";\n            }\n            this.camera.state.setDirection(defaultDirection);\n        }\n        // Set target resolution\n        const targetResolution = this.state.settings?.video.target_resolution;\n        if (targetResolution) {\n            await this.camera.selectTargetResolution(targetResolution);\n        }\n        if (options.setStatus) {\n            // Publish already that was set before we joined\n            if (this.camera.state.status === \"enabled\" && this.camera.state.mediaStream && !this.publisher?.isPublishing(TrackType.VIDEO)) {\n                await this.publishVideoStream(this.camera.state.mediaStream, {\n                    preferredCodec: this.camera.preferredCodec\n                });\n            }\n            // Start camera if backend config specifies, and there is no local setting\n            if (this.camera.state.status === undefined && this.state.settings?.video.camera_default_on) {\n                await this.camera.enable();\n            }\n        }\n    }\n    async initMic(options) {\n        // Wait for any in progress mic operation\n        if (this.microphone.enablePromise) {\n            await this.microphone.enablePromise;\n        }\n        if (this.microphone.disablePromise) {\n            await this.microphone.disablePromise;\n        }\n        if (this.state.localParticipant?.audioStream || !this.permissionsContext.hasPermission(\"send-audio\")) {\n            return;\n        }\n        if (options.setStatus) {\n            // Publish media stream that was set before we joined\n            if (this.microphone.state.status === \"enabled\" && this.microphone.state.mediaStream && !this.publisher?.isPublishing(TrackType.AUDIO)) {\n                await this.publishAudioStream(this.microphone.state.mediaStream);\n            }\n            // Start mic if backend config specifies, and there is no local setting\n            if (this.microphone.state.status === undefined && this.state.settings?.audio.mic_default_on) {\n                await this.microphone.enable();\n            }\n        }\n    }\n}\nclass InsightMetrics {\n    constructor(){\n        this.connectionStartTimestamp = null;\n        this.wsTotalFailures = 0;\n        this.wsConsecutiveFailures = 0;\n        this.instanceClientId = randomId();\n    }\n}\n/**\n * postInsights is not supposed to be used by end users directly within chat application, and thus is kept isolated\n * from all the client/connection code/logic.\n *\n * @param insightType\n * @param insights\n */ const postInsights = async (insightType, insights)=>{\n    const maxAttempts = 3;\n    for(let i = 0; i < maxAttempts; i++){\n        try {\n            await axios__WEBPACK_IMPORTED_MODULE_33__[\"default\"].post(`https://chat-insights.getstream.io/insights/${insightType}`, insights);\n        } catch (e) {\n            await sleep((i + 1) * 3000);\n            continue;\n        }\n        break;\n    }\n};\nfunction buildWsFatalInsight(connection, event) {\n    return {\n        ...event,\n        ...buildWsBaseInsight(connection)\n    };\n}\nfunction buildWsBaseInsight(connection) {\n    const { client } = connection;\n    return {\n        ready_state: connection.ws?.readyState,\n        url: connection._buildUrl(),\n        api_key: client.key,\n        start_ts: client.insightMetrics.connectionStartTimestamp,\n        end_ts: new Date().getTime(),\n        auth_type: client.getAuthType(),\n        token: client.tokenManager.token,\n        user_id: client.userID,\n        user_details: client._user,\n        // device: client.options.device,\n        device: \"browser\",\n        client_id: connection.connectionID,\n        ws_details: connection.ws,\n        ws_consecutive_failures: client.insightMetrics.wsConsecutiveFailures,\n        ws_total_failures: client.insightMetrics.wsTotalFailures,\n        request_id: connection.requestID,\n        online: typeof navigator !== \"undefined\" ? navigator?.onLine : null,\n        user_agent: typeof navigator !== \"undefined\" ? navigator?.userAgent : null,\n        instance_client_id: client.insightMetrics.instanceClientId\n    };\n}\nfunction buildWsSuccessAfterFailureInsight(connection) {\n    return buildWsBaseInsight(connection);\n}\n// Type guards to check WebSocket error type\nconst isCloseEvent = (res)=>res.code !== undefined;\nconst isErrorEvent = (res)=>res.error !== undefined;\n/**\n * StableWSConnection - A WS connection that reconnects upon failure.\n * - the browser will sometimes report that you're online or offline\n * - the WS connection can break and fail (there is a 30s health check)\n * - sometimes your WS connection will seem to work while the user is in fact offline\n * - to speed up online/offline detection you can use the window.addEventListener('offline');\n *\n * There are 4 ways in which a connection can become unhealthy:\n * - websocket.onerror is called\n * - websocket.onclose is called\n * - the health check fails and no event is received for ~40 seconds\n * - the browser indicates the connection is now offline\n *\n * There are 2 assumptions we make about the server:\n * - state can be recovered by querying the channel again\n * - if the servers fails to publish a message to the client, the WS connection is destroyed\n */ class StableWSConnection {\n    constructor(client){\n        this._log = (msg, extra = {}, level = \"info\")=>{\n            this.client.logger(level, \"connection:\" + msg, {\n                ...extra\n            });\n        };\n        this.setClient = (client)=>{\n            this.client = client;\n        };\n        /**\n         * Builds and returns the url for websocket.\n         * @private\n         * @returns url string\n         */ this._buildUrl = ()=>{\n            const params = new URLSearchParams();\n            // const qs = encodeURIComponent(this.client._buildWSPayload(this.requestID));\n            // params.set('json', qs);\n            params.set(\"api_key\", this.client.key);\n            params.set(\"stream-auth-type\", this.client.getAuthType());\n            params.set(\"X-Stream-Client\", this.client.getUserAgent());\n            // params.append('authorization', this.client._getToken()!);\n            return `${this.client.wsBaseURL}/connect?${params.toString()}`;\n        };\n        /**\n         * onlineStatusChanged - this function is called when the browser connects or disconnects from the internet.\n         *\n         * @param {Event} event Event with type online or offline\n         *\n         */ this.onlineStatusChanged = (event)=>{\n            if (event.type === \"offline\") {\n                // mark the connection as down\n                this._log(\"onlineStatusChanged() - Status changing to offline\");\n                // we know that the app is offline so dispatch the unhealthy connection event immediately\n                this._setHealth(false, true);\n            } else if (event.type === \"online\") {\n                // retry right now...\n                // We check this.isHealthy, not sure if it's always\n                // smart to create a new WS connection if the old one is still up and running.\n                // it's possible we didn't miss any messages, so this process is just expensive and not needed.\n                this._log(`onlineStatusChanged() - Status changing to online. isHealthy: ${this.isHealthy}`);\n                if (!this.isHealthy) {\n                    this._reconnect({\n                        interval: 10\n                    });\n                }\n            }\n        };\n        this.onopen = (wsID)=>{\n            if (this.wsID !== wsID) return;\n            const user = this.client.user;\n            if (!user) {\n                this.client.logger(\"error\", `User not set, can't connect to WS`);\n                return;\n            }\n            const token = this.client._getToken();\n            if (!token) {\n                this.client.logger(\"error\", `Token not set, can't connect authenticate`);\n                return;\n            }\n            const authMessage = {\n                token,\n                user_details: {\n                    id: user.id,\n                    name: user.name,\n                    image: user.image,\n                    custom: user.custom\n                }\n            };\n            this.authenticationSent = true;\n            this.ws?.send(JSON.stringify(authMessage));\n            this._log(\"onopen() - onopen callback\", {\n                wsID\n            });\n        };\n        this.onmessage = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onmessage() - onmessage callback\", {\n                event,\n                wsID\n            });\n            const data = typeof event.data === \"string\" ? JSON.parse(event.data) : null;\n            // we wait till the first message before we consider the connection open.\n            // the reason for this is that auth errors and similar errors trigger a ws.onopen and immediately\n            // after that a ws.onclose.\n            if (!this.isResolved && data && data.type === \"connection.error\") {\n                this.isResolved = true;\n                if (data.error) {\n                    // @ts-expect-error - the types of _errorFromWSEvent are incorrect\n                    this.rejectPromise?.(this._errorFromWSEvent(data, false));\n                    return;\n                }\n            }\n            // trigger the event..\n            this.lastEvent = new Date();\n            if (data && (data.type === \"health.check\" || data.type === \"connection.ok\")) {\n                // the initial health-check should come from the client\n                this.scheduleNextPing();\n            }\n            if (data && data.type === \"connection.ok\") {\n                this.resolvePromise?.(data);\n                this._setHealth(true);\n            }\n            if (data && data.type === \"connection.error\" && data.error) {\n                const { code } = data.error;\n                this.isHealthy = false;\n                this.isConnecting = false;\n                this.consecutiveFailures += 1;\n                if (code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                    clearTimeout(this.connectionCheckTimeoutRef);\n                    this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                    this._reconnect({\n                        refreshToken: true\n                    });\n                }\n            }\n            if (data) {\n                this.client.dispatchEvent(data);\n            }\n            this.scheduleConnectionCheck();\n        };\n        this.onclose = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onclose() - onclose callback - \" + event.code, {\n                event,\n                wsID\n            });\n            if (event.code === KnownCodes.WS_CLOSED_SUCCESS) {\n                // this is a permanent error raised by stream..\n                // usually caused by invalid auth details\n                const error = new Error(`WS connection reject with error ${event.reason}`);\n                error.reason = event.reason;\n                error.code = event.code;\n                error.wasClean = event.wasClean;\n                error.target = event.target;\n                this.rejectPromise?.(error);\n                this._log(`onclose() - WS connection reject with error ${event.reason}`, {\n                    event\n                });\n            } else {\n                this.consecutiveFailures += 1;\n                this.totalFailures += 1;\n                this._setHealth(false);\n                this.isConnecting = false;\n                this.rejectPromise?.(this._errorFromWSEvent(event));\n                this._log(`onclose() - WS connection closed. Calling reconnect ...`, {\n                    event\n                });\n                // reconnect if its an abnormal failure\n                this._reconnect();\n            }\n        };\n        this.onerror = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this.consecutiveFailures += 1;\n            this.totalFailures += 1;\n            this._setHealth(false);\n            this.isConnecting = false;\n            this.rejectPromise?.(this._errorFromWSEvent(event));\n            this._log(`onerror() - WS connection resulted into error`, {\n                event\n            });\n            this._reconnect();\n        };\n        /**\n         * _setHealth - Sets the connection to healthy or unhealthy.\n         * Broadcasts an event in case the connection status changed.\n         *\n         * @param {boolean} healthy boolean indicating if the connection is healthy or not\n         * @param {boolean} dispatchImmediately boolean indicating to dispatch event immediately even if the connection is unhealthy\n         *\n         */ this._setHealth = (healthy, dispatchImmediately = false)=>{\n            if (healthy === this.isHealthy) return;\n            this.isHealthy = healthy;\n            if (this.isHealthy || dispatchImmediately) {\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n                return;\n            }\n            // we're offline, wait few seconds and fire and event if still offline\n            setTimeout(()=>{\n                if (this.isHealthy) return;\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n            }, 5000);\n        };\n        /**\n         * _errorFromWSEvent - Creates an error object for the WS event\n         *\n         */ this._errorFromWSEvent = (event, isWSFailure = true)=>{\n            let code;\n            let statusCode;\n            let message;\n            if (isCloseEvent(event)) {\n                code = event.code;\n                statusCode = \"unknown\";\n                message = event.reason;\n            }\n            if (isErrorEvent(event)) {\n                code = event.error.code;\n                statusCode = event.error.StatusCode;\n                message = event.error.message;\n            }\n            // Keeping this `warn` level log, to avoid cluttering of error logs from ws failures.\n            this._log(`_errorFromWSEvent() - WS failed with code ${code}`, {\n                event\n            }, \"warn\");\n            const error = new Error(`WS failed with code ${code} and reason - ${message}`);\n            error.code = code;\n            /**\n             * StatusCode does not exist on any event types but has been left\n             * as is to preserve JS functionality during the TS implementation\n             */ error.StatusCode = statusCode;\n            error.isWSFailure = isWSFailure;\n            return error;\n        };\n        /**\n         * _setupPromise - sets up the this.connectOpen promise\n         */ this._setupConnectionPromise = ()=>{\n            this.isResolved = false;\n            /** a promise that is resolved once ws.open is called */ this.connectionOpen = new Promise((resolve, reject)=>{\n                this.resolvePromise = resolve;\n                this.rejectPromise = reject;\n            });\n        };\n        /**\n         * Schedules a next health check ping for websocket.\n         */ this.scheduleNextPing = ()=>{\n            if (this.healthCheckTimeoutRef) {\n                clearTimeout(this.healthCheckTimeoutRef);\n            }\n            // 30 seconds is the recommended interval (messenger uses this)\n            this.healthCheckTimeoutRef = setTimeout(()=>{\n                // send the healthcheck..., server replies with a health check event\n                const data = [\n                    {\n                        type: \"health.check\",\n                        client_id: this.client.clientID\n                    }\n                ];\n                // try to send on the connection\n                try {\n                    this.ws?.send(JSON.stringify(data));\n                } catch (e) {\n                // error will already be detected elsewhere\n                }\n            }, this.pingInterval);\n        };\n        /**\n         * scheduleConnectionCheck - schedules a check for time difference between last received event and now.\n         * If the difference is more than 35 seconds, it means our health check logic has failed and websocket needs\n         * to be reconnected.\n         */ this.scheduleConnectionCheck = ()=>{\n            if (this.connectionCheckTimeoutRef) {\n                clearTimeout(this.connectionCheckTimeoutRef);\n            }\n            this.connectionCheckTimeoutRef = setTimeout(()=>{\n                const now = new Date();\n                if (this.lastEvent && now.getTime() - this.lastEvent.getTime() > this.connectionCheckTimeout) {\n                    this._log(\"scheduleConnectionCheck - going to reconnect\");\n                    this._setHealth(false);\n                    this._reconnect();\n                }\n            }, this.connectionCheckTimeout);\n        };\n        this.client = client;\n        /** consecutive failures influence the duration of the timeout */ this.consecutiveFailures = 0;\n        /** keep track of the total number of failures */ this.totalFailures = 0;\n        /** We only make 1 attempt to reconnect at the same time.. */ this.isConnecting = false;\n        /** True after the auth payload is sent to the server */ this.authenticationSent = false;\n        /** To avoid reconnect if client is disconnected */ this.isDisconnected = false;\n        /** Boolean that indicates if the connection promise is resolved */ this.isResolved = false;\n        /** Boolean that indicates if we have a working connection to the server */ this.isHealthy = false;\n        /** Incremented when a new WS connection is made */ this.wsID = 1;\n        /** Store the last event time for health checks */ this.lastEvent = null;\n        /** Send a health check message every 25 seconds */ this.pingInterval = 25 * 1000;\n        this.connectionCheckTimeout = this.pingInterval + 10 * 1000;\n        addConnectionEventListeners(this.onlineStatusChanged);\n    }\n    /**\n     * connect - Connect to the WS URL\n     * the default 15s timeout allows between 2~3 tries\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async connect(timeout = 15000) {\n        if (this.isConnecting) {\n            throw Error(`You've called connect twice, can only attempt 1 connection at the time`);\n        }\n        this.isDisconnected = false;\n        try {\n            const healthCheck = await this._connect();\n            this.consecutiveFailures = 0;\n            this._log(`connect() - Established ws connection with healthcheck: ${healthCheck}`);\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (// @ts-ignore\n            error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                this._reconnect({\n                    refreshToken: true\n                });\n            } else {\n                // @ts-ignore\n                if (!error.isWSFailure) {\n                    // API rejected the connection and we should not retry\n                    throw new Error(JSON.stringify({\n                        // @ts-ignore\n                        code: error.code,\n                        // @ts-ignore\n                        StatusCode: error.StatusCode,\n                        // @ts-ignore\n                        message: error.message,\n                        // @ts-ignore\n                        isWSFailure: error.isWSFailure\n                    }));\n                }\n            }\n        }\n        return await this._waitForHealthy(timeout);\n    }\n    /**\n     * _waitForHealthy polls the promise connection to see if its resolved until it times out\n     * the default 15s timeout allows between 2~3 tries\n     * @param timeout duration(ms)\n     */ async _waitForHealthy(timeout = 15000) {\n        return Promise.race([\n            (async ()=>{\n                const interval = 50; // ms\n                for(let i = 0; i <= timeout; i += interval){\n                    try {\n                        return await this.connectionOpen;\n                    } catch (error) {\n                        if (i === timeout) {\n                            throw new Error(JSON.stringify({\n                                code: error.code,\n                                StatusCode: error.StatusCode,\n                                message: error.message,\n                                isWSFailure: error.isWSFailure\n                            }));\n                        }\n                        await sleep(interval);\n                    }\n                }\n            })(),\n            (async ()=>{\n                await sleep(timeout);\n                this.isConnecting = false;\n                throw new Error(JSON.stringify({\n                    code: \"\",\n                    StatusCode: \"\",\n                    message: \"initial WS connection could not be established\",\n                    isWSFailure: true\n                }));\n            })()\n        ]);\n    }\n    /**\n     * disconnect - Disconnect the connection and doesn't recover...\n     *\n     */ disconnect(timeout) {\n        this._log(`disconnect() - Closing the websocket connection for wsID ${this.wsID}`);\n        this.wsID += 1;\n        this.isConnecting = false;\n        this.isDisconnected = true;\n        // start by removing all the listeners\n        if (this.healthCheckTimeoutRef) {\n            clearInterval(this.healthCheckTimeoutRef);\n        }\n        if (this.connectionCheckTimeoutRef) {\n            clearInterval(this.connectionCheckTimeoutRef);\n        }\n        removeConnectionEventListeners(this.onlineStatusChanged);\n        this.isHealthy = false;\n        // remove ws handlers...\n        if (this.ws && this.ws.removeAllListeners) {\n            this.ws.removeAllListeners();\n        }\n        let isClosedPromise;\n        // and finally close...\n        // Assigning to local here because we will remove it from this before the\n        // promise resolves.\n        const { ws } = this;\n        if (ws && ws.close && ws.readyState === ws.OPEN) {\n            isClosedPromise = new Promise((resolve)=>{\n                const onclose = (event)=>{\n                    this._log(`disconnect() - resolving isClosedPromise ${event ? \"with\" : \"without\"} close frame`, {\n                        event\n                    });\n                    resolve();\n                };\n                ws.onclose = onclose;\n                // In case we don't receive close frame websocket server in time,\n                // lets not wait for more than 1 second.\n                setTimeout(onclose, timeout != null ? timeout : 1000);\n            });\n            this._log(`disconnect() - Manually closed connection by calling client.disconnect()`);\n            ws.close(KnownCodes.WS_CLOSED_SUCCESS, \"Manually closed connection by calling client.disconnect()\");\n        } else {\n            this._log(`disconnect() - ws connection doesn't exist or it is already closed.`);\n            isClosedPromise = Promise.resolve();\n        }\n        delete this.ws;\n        return isClosedPromise;\n    }\n    /**\n     * _connect - Connect to the WS endpoint\n     *\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async _connect() {\n        if (this.isConnecting || this.isDisconnected && this.client.options.enableWSFallback) return; // simply ignore _connect if it's currently trying to connect\n        this.isConnecting = true;\n        this.requestID = randomId();\n        this.client.insightMetrics.connectionStartTimestamp = new Date().getTime();\n        let isTokenReady = false;\n        try {\n            this._log(`_connect() - waiting for token`);\n            await this.client.tokenManager.tokenReady();\n            isTokenReady = true;\n        } catch (e) {\n        // token provider has failed before, so try again\n        }\n        try {\n            if (!isTokenReady) {\n                this._log(`_connect() - tokenProvider failed before, so going to retry`);\n                await this.client.tokenManager.loadToken();\n            }\n            this._setupConnectionPromise();\n            const wsURL = this._buildUrl();\n            this._log(`_connect() - Connecting to ${wsURL}`, {\n                wsURL,\n                requestID: this.requestID\n            });\n            this.ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(wsURL);\n            this.ws.onopen = this.onopen.bind(this, this.wsID);\n            this.ws.onclose = this.onclose.bind(this, this.wsID);\n            this.ws.onerror = this.onerror.bind(this, this.wsID);\n            this.ws.onmessage = this.onmessage.bind(this, this.wsID);\n            const response = await this.connectionOpen;\n            this.isConnecting = false;\n            if (response) {\n                this.connectionID = response.connection_id;\n                this.client.resolveConnectionId?.(this.connectionID);\n                if (this.client.insightMetrics.wsConsecutiveFailures > 0 && this.client.options.enableInsights) {\n                    postInsights(\"ws_success_after_failure\", buildWsSuccessAfterFailureInsight(this));\n                    this.client.insightMetrics.wsConsecutiveFailures = 0;\n                }\n                return response;\n            }\n        } catch (err) {\n            this.isConnecting = false;\n            // @ts-ignore\n            this._log(`_connect() - Error - `, err);\n            if (this.client.options.enableInsights) {\n                this.client.insightMetrics.wsConsecutiveFailures++;\n                this.client.insightMetrics.wsTotalFailures++;\n                const insights = buildWsFatalInsight(this, convertErrorToJson(err));\n                postInsights?.(\"ws_fatal\", insights);\n            }\n            this.client.rejectConnectionId?.();\n            throw err;\n        }\n    }\n    /**\n     * _reconnect - Retry the connection to WS endpoint\n     *\n     * @param {{ interval?: number; refreshToken?: boolean }} options Following options are available\n     *\n     * - `interval`\t{int}\t\t\tnumber of ms that function should wait before reconnecting\n     * - `refreshToken` {boolean}\treload/refresh user token be refreshed before attempting reconnection.\n     */ async _reconnect(options = {}) {\n        this._log(\"_reconnect() - Initiating the reconnect\");\n        // only allow 1 connection at the time\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (1) since already connecting or healthy\");\n            return;\n        }\n        // reconnect in case of on error or on close\n        // also reconnect if the health check cycle fails\n        let interval = options.interval;\n        if (!interval) {\n            interval = retryInterval(this.consecutiveFailures);\n        }\n        // reconnect, or try again after a little while...\n        await sleep(interval);\n        // Check once again if by some other call to _reconnect is active or connection is\n        // already restored, then no need to proceed.\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (2) since already connecting or healthy\");\n            return;\n        }\n        if (this.isDisconnected && this.client.options.enableWSFallback) {\n            this._log(\"_reconnect() - Abort (3) since disconnect() is called\");\n            return;\n        }\n        this._log(\"_reconnect() - Destroying current WS connection\");\n        // cleanup the old connection\n        this._destroyCurrentWSConnection();\n        if (options.refreshToken) {\n            await this.client.tokenManager.loadToken();\n        }\n        try {\n            await this._connect();\n            this._log(\"_reconnect() - Waiting for recoverCallBack\");\n            // await this.client.recoverState();\n            this._log(\"_reconnect() - Finished recoverCallBack\");\n            this.consecutiveFailures = 0;\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"_reconnect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                return this._reconnect({\n                    refreshToken: true\n                });\n            }\n            // reconnect on WS failures, don't reconnect if there is a code bug\n            if (error.isWSFailure) {\n                this._log(\"_reconnect() - WS failure, so going to try to reconnect\");\n                this._reconnect();\n            }\n        }\n        this._log(\"_reconnect() - == END ==\");\n    }\n    /**\n     * _destroyCurrentWSConnection - Removes the current WS connection\n     *\n     */ _destroyCurrentWSConnection() {\n        // increment the ID, meaning we will ignore all messages from the old\n        // ws connection from now on.\n        this.wsID += 1;\n        try {\n            this?.ws?.removeAllListeners();\n            this?.ws?.close();\n        } catch (e) {\n        // we don't care\n        }\n    }\n}\nfunction isString(arrayOrString) {\n    return typeof arrayOrString === \"string\";\n}\nfunction isMapStringCallback(arrayOrString, callback) {\n    return !!callback && isString(arrayOrString);\n}\nfunction map(arrayOrString, callback) {\n    const res = [];\n    if (isString(arrayOrString) && isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (arrayOrString.charAt(k)) {\n                const kValue = arrayOrString.charAt(k);\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    } else if (!isString(arrayOrString) && !isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (k in arrayOrString) {\n                const kValue = arrayOrString[k];\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    }\n    return res;\n}\nconst encodeBase64 = (data)=>(0,base64_js__WEBPACK_IMPORTED_MODULE_6__.fromByteArray)(new Uint8Array(map(data, (char)=>char.charCodeAt(0))));\n// base-64 decoder throws exception if encoded string is not padded by '=' to make string length\n// in multiples of 4. So gonna use our own method for this purpose to keep backwards compatibility\n// https://github.com/beatgammit/base64-js/blob/master/index.js#L26\nconst decodeBase64 = (s)=>{\n    const e = {}, w = String.fromCharCode, L = s.length;\n    let i, b = 0, c, x, l = 0, a, r = \"\";\n    const A = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(i = 0; i < 64; i++){\n        e[A.charAt(i)] = i;\n    }\n    for(x = 0; x < L; x++){\n        c = e[s.charAt(x)];\n        b = (b << 6) + c;\n        l += 6;\n        while(l >= 8){\n            ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));\n        }\n    }\n    return r;\n};\n/**\n *\n * @param {string} userId the id of the user\n * @return {string}\n */ function DevToken(userId) {\n    return [\n        \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n        encodeBase64(JSON.stringify({\n            user_id: userId\n        })),\n        \"devtoken\"\n    ].join(\".\");\n}\nfunction UserFromToken(token) {\n    const fragments = token.split(\".\");\n    if (fragments.length !== 3) {\n        return \"\";\n    }\n    const b64Payload = fragments[1];\n    const payload = decodeBase64(b64Payload);\n    const data = JSON.parse(payload);\n    return data.user_id;\n}\n/**\n * TokenManager\n *\n * Handles all the operations around user token.\n */ class TokenManager {\n    /**\n     * Constructor\n     *\n     * @param {Secret} secret\n     */ constructor(secret){\n        /**\n         * Set the static string token or token provider.\n         * Token provider should return a token string or a promise which resolves to string token.\n         *\n         * @param {TokenOrProvider} tokenOrProvider - the token or token provider.\n         * @param {UserResponse} user - the user object.\n         * @param {boolean} isAnonymous - whether the user is anonymous or not.\n         */ this.setTokenOrProvider = async (tokenOrProvider, user, isAnonymous)=>{\n            this.validateToken(tokenOrProvider, user, isAnonymous);\n            this.user = user;\n            if (isFunction(tokenOrProvider)) {\n                this.tokenProvider = tokenOrProvider;\n                this.type = \"provider\";\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                this.token = tokenOrProvider;\n                this.type = \"static\";\n            }\n            await this.loadToken();\n        };\n        /**\n         * Resets the token manager.\n         * Useful for client disconnection or switching user.\n         */ this.reset = ()=>{\n            this.token = undefined;\n            this.user = undefined;\n            this.loadTokenPromise = null;\n        };\n        // Validates the user token.\n        this.validateToken = (tokenOrProvider, user, isAnonymous)=>{\n            // allow empty token for anon user\n            if (user && isAnonymous && !tokenOrProvider) return;\n            // Don't allow empty token for non-server side client.\n            if (!this.secret && !tokenOrProvider) {\n                throw new Error(\"UserWithId token can not be empty\");\n            }\n            if (tokenOrProvider && typeof tokenOrProvider !== \"string\" && !isFunction(tokenOrProvider)) {\n                throw new Error(\"user token should either be a string or a function\");\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                // Allow empty token for anonymous users\n                if (isAnonymous && tokenOrProvider === \"\") return;\n                const tokenUserId = UserFromToken(tokenOrProvider);\n                if (tokenOrProvider != null && (tokenUserId == null || tokenUserId === \"\" || !isAnonymous && tokenUserId !== user.id)) {\n                    throw new Error(\"userToken does not have a user_id or is not matching with user.id\");\n                }\n            }\n        };\n        // Resolves when token is ready. This function is simply to check if loadToken is in progress, in which\n        // case a function should wait.\n        this.tokenReady = ()=>this.loadTokenPromise;\n        // Fetches a token from tokenProvider function and sets in tokenManager.\n        // In case of static token, it will simply resolve to static token.\n        this.loadToken = ()=>{\n            // eslint-disable-next-line no-async-promise-executor\n            this.loadTokenPromise = new Promise(async (resolve, reject)=>{\n                if (this.type === \"static\") {\n                    return resolve(this.token);\n                }\n                if (this.tokenProvider && typeof this.tokenProvider !== \"string\") {\n                    try {\n                        this.token = await this.tokenProvider();\n                    } catch (e) {\n                        return reject(new Error(`Call to tokenProvider failed with message: ${e}`));\n                    }\n                    resolve(this.token);\n                }\n            });\n            return this.loadTokenPromise;\n        };\n        // Returns a current token\n        this.getToken = ()=>{\n            if (this.token) {\n                return this.token;\n            }\n            if (this.user && !this.token) {\n                return this.token;\n            }\n            throw new Error(`Both secret and user tokens are not set. Either client.connectUser wasn't called or client.disconnect was called`);\n        };\n        this.isStatic = ()=>this.type === \"static\";\n        this.loadTokenPromise = null;\n        if (secret) {\n            this.secret = secret;\n        }\n        this.type = \"static\";\n    }\n}\nconst APIErrorCodes = {\n    \"-1\": {\n        name: \"InternalSystemError\",\n        retryable: true\n    },\n    \"2\": {\n        name: \"AccessKeyError\",\n        retryable: false\n    },\n    \"3\": {\n        name: \"AuthenticationFailedError\",\n        retryable: true\n    },\n    \"4\": {\n        name: \"InputError\",\n        retryable: false\n    },\n    \"6\": {\n        name: \"DuplicateUsernameError\",\n        retryable: false\n    },\n    \"9\": {\n        name: \"RateLimitError\",\n        retryable: true\n    },\n    \"16\": {\n        name: \"DoesNotExistError\",\n        retryable: false\n    },\n    \"17\": {\n        name: \"NotAllowedError\",\n        retryable: false\n    },\n    \"18\": {\n        name: \"EventNotSupportedError\",\n        retryable: false\n    },\n    \"19\": {\n        name: \"ChannelFeatureNotSupportedError\",\n        retryable: false\n    },\n    \"20\": {\n        name: \"MessageTooLongError\",\n        retryable: false\n    },\n    \"21\": {\n        name: \"MultipleNestingLevelError\",\n        retryable: false\n    },\n    \"22\": {\n        name: \"PayloadTooBigError\",\n        retryable: false\n    },\n    \"23\": {\n        name: \"RequestTimeoutError\",\n        retryable: true\n    },\n    \"24\": {\n        name: \"MaxHeaderSizeExceededError\",\n        retryable: false\n    },\n    \"40\": {\n        name: \"AuthErrorTokenExpired\",\n        retryable: false\n    },\n    \"41\": {\n        name: \"AuthErrorTokenNotValidYet\",\n        retryable: false\n    },\n    \"42\": {\n        name: \"AuthErrorTokenUsedBeforeIssuedAt\",\n        retryable: false\n    },\n    \"43\": {\n        name: \"AuthErrorTokenSignatureInvalid\",\n        retryable: false\n    },\n    \"44\": {\n        name: \"CustomCommandEndpointMissingError\",\n        retryable: false\n    },\n    \"45\": {\n        name: \"CustomCommandEndpointCallError\",\n        retryable: true\n    },\n    \"46\": {\n        name: \"ConnectionIDNotFoundError\",\n        retryable: false\n    },\n    \"60\": {\n        name: \"CoolDownError\",\n        retryable: true\n    },\n    \"69\": {\n        name: \"ErrWrongRegion\",\n        retryable: false\n    },\n    \"70\": {\n        name: \"ErrQueryChannelPermissions\",\n        retryable: false\n    },\n    \"71\": {\n        name: \"ErrTooManyConnections\",\n        retryable: true\n    },\n    \"99\": {\n        name: \"AppSuspendedError\",\n        retryable: false\n    }\n};\nfunction isAPIError(error) {\n    return error.code !== undefined;\n}\nfunction isErrorRetryable(error) {\n    if (!error.code) return false;\n    const err = APIErrorCodes[`${error.code}`];\n    if (!err) return false;\n    return err.retryable;\n}\nfunction isConnectionIDError(error) {\n    return error.code === 46; // ConnectionIDNotFoundError\n}\nfunction isWSFailure(err) {\n    if (typeof err.isWSFailure === \"boolean\") {\n        return err.isWSFailure;\n    }\n    try {\n        return JSON.parse(err.message).isWSFailure;\n    } catch (_) {\n        return false;\n    }\n}\nfunction isErrorResponse(res) {\n    return !res.status || res.status < 200 || 300 <= res.status;\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Closed\"] = \"CLOSED\";\n    ConnectionState[\"Connected\"] = \"CONNECTED\";\n    ConnectionState[\"Connecting\"] = \"CONNECTING\";\n    ConnectionState[\"Disconnected\"] = \"DISCONNECTED\";\n    ConnectionState[\"Init\"] = \"INIT\";\n})(ConnectionState || (ConnectionState = {}));\nclass WSConnectionFallback {\n    constructor(client){\n        /** @private */ this._onlineStatusChanged = (event)=>{\n            this._log(`_onlineStatusChanged() - ${event.type}`);\n            if (event.type === \"offline\") {\n                this._setState(ConnectionState.Closed);\n                this.cancelToken?.cancel(\"disconnect() is called\");\n                this.cancelToken = undefined;\n                return;\n            }\n            if (event.type === \"online\" && this.state === ConnectionState.Closed) {\n                this.connect(true);\n            }\n        };\n        /** @private */ this._req = async (params, config, retry)=>{\n            if (!this.cancelToken && !params.close) {\n                this.cancelToken = axios__WEBPACK_IMPORTED_MODULE_33__[\"default\"].CancelToken.source();\n            }\n            try {\n                const res = await this.client.doAxiosRequest(\"get\", this.client.baseURL.replace(\":3030\", \":8900\") + \"/longpoll\", undefined, {\n                    config: {\n                        ...config,\n                        cancelToken: this.cancelToken?.token\n                    },\n                    params,\n                    publicEndpoint: true\n                });\n                this.consecutiveFailures = 0; // always reset in case of no error\n                return res;\n            } catch (err) {\n                this.consecutiveFailures += 1;\n                // @ts-ignore\n                if (retry && isErrorRetryable(err)) {\n                    this._log(`_req() - Retryable error, retrying request`);\n                    await sleep(retryInterval(this.consecutiveFailures));\n                    return this._req(params, config, retry);\n                }\n                throw err;\n            }\n        };\n        /** @private */ this._poll = async ()=>{\n            while(this.state === ConnectionState.Connected){\n                try {\n                    const data = await this._req({}, {\n                        timeout: 30000\n                    }, true); // 30s => API responds in 20s if there is no event\n                    if (data.events?.length) {\n                        for(let i = 0; i < data.events.length; i++){\n                            this.client.dispatchEvent(data.events[i]);\n                        }\n                    }\n                } catch (err) {\n                    if (axios__WEBPACK_IMPORTED_MODULE_33__[\"default\"].isCancel(err)) {\n                        this._log(`_poll() - axios canceled request`);\n                        return;\n                    }\n                    /** client.doAxiosRequest will take care of TOKEN_EXPIRED error */ // @ts-ignore\n                    if (isConnectionIDError(err)) {\n                        this._log(`_poll() - ConnectionID error, connecting without ID...`);\n                        this._setState(ConnectionState.Disconnected);\n                        this.connect(true);\n                        return;\n                    }\n                    // @ts-ignore\n                    if (isAPIError(err) && !isErrorRetryable(err)) {\n                        this._setState(ConnectionState.Closed);\n                        return;\n                    }\n                    await sleep(retryInterval(this.consecutiveFailures));\n                }\n            }\n        };\n        /**\n         * connect try to open a longpoll request\n         * @param reconnect should be false for first call and true for subsequent calls to keep the connection alive and call recoverState\n         */ this.connect = async (reconnect = false)=>{\n            if (this.state === ConnectionState.Connecting) {\n                this._log(\"connect() - connecting already in progress\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            if (this.state === ConnectionState.Connected) {\n                this._log(\"connect() - already connected and polling\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            this._setState(ConnectionState.Connecting);\n            this.connectionID = undefined; // connect should be sent with empty connection_id so API creates one\n            try {\n                const { event } = await this._req({\n                    json: this.client._buildWSPayload()\n                }, {\n                    timeout: 8000\n                }, reconnect);\n                this._setState(ConnectionState.Connected);\n                this.connectionID = event.connection_id;\n                this.client.resolveConnectionId?.();\n                // @ts-expect-error\n                this.client.dispatchEvent(event);\n                this._poll();\n                return event;\n            } catch (err) {\n                this._setState(ConnectionState.Closed);\n                this.client.rejectConnectionId?.();\n                throw err;\n            }\n        };\n        /**\n         * isHealthy checks if there is a connectionID and connection is in Connected state\n         */ this.isHealthy = ()=>{\n            return !!this.connectionID && this.state === ConnectionState.Connected;\n        };\n        this.disconnect = async (timeout = 2000)=>{\n            removeConnectionEventListeners(this._onlineStatusChanged);\n            this._setState(ConnectionState.Disconnected);\n            this.cancelToken?.cancel(\"disconnect() is called\");\n            this.cancelToken = undefined;\n            const connection_id = this.connectionID;\n            this.connectionID = undefined;\n            try {\n                await this._req({\n                    close: true,\n                    connection_id\n                }, {\n                    timeout\n                }, false);\n                this._log(`disconnect() - Closed connectionID`);\n            } catch (err) {\n                this._log(`disconnect() - Failed`, {\n                    err\n                }, \"error\");\n            }\n        };\n        this.client = client;\n        this.state = ConnectionState.Init;\n        this.consecutiveFailures = 0;\n        addConnectionEventListeners(this._onlineStatusChanged);\n    }\n    _log(msg, extra = {}, level = \"info\") {\n        this.client.logger(level, \"WSConnectionFallback:\" + msg, {\n            ...extra\n        });\n    }\n    _setState(state) {\n        this._log(`_setState() - ${state}`);\n        // transition from connecting => connected\n        if (this.state === ConnectionState.Connecting && state === ConnectionState.Connected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: true\n            });\n        }\n        if (state === ConnectionState.Closed || state === ConnectionState.Disconnected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: false\n            });\n        }\n        this.state = state;\n    }\n}\nconst logger = getLogger([\n    \"location\"\n]);\nconst HINT_URL = `https://hint.stream-io-video.com/`;\nconst getLocationHint = async (hintUrl = HINT_URL, timeout = 2000)=>{\n    const abortController = new AbortController();\n    const timeoutId = setTimeout(()=>abortController.abort(), timeout);\n    try {\n        const response = await fetch(hintUrl, {\n            method: \"HEAD\",\n            signal: abortController.signal\n        });\n        const awsPop = response.headers.get(\"x-amz-cf-pop\") || \"ERR\";\n        logger(\"debug\", `Location header: ${awsPop}`);\n        return awsPop.substring(0, 3); // AMS1-P2 -> AMS\n    } catch (e) {\n        logger(\"warn\", `Failed to get location hint from ${hintUrl}`, e);\n        return \"ERR\";\n    } finally{\n        clearTimeout(timeoutId);\n    }\n};\nclass StreamClient {\n    /**\n     * Initialize a client.\n     *\n     * @param {string} key - the api key\n     * @param {StreamClientOptions} [options] - additional options, here you can pass custom options to axios instance\n     * @param {string} [options.secret] - the api secret\n     * @param {boolean} [options.browser] - enforce the client to be in browser mode\n     * @param {boolean} [options.warmUp] - default to false, if true, client will open a connection as soon as possible to speed up following requests\n     * @param {Logger} [options.Logger] - custom logger\n     * @param {number} [options.timeout] - default to 3000\n     * @param {httpsAgent} [options.httpsAgent] - custom httpsAgent, in node it's default to https.agent()\n     */ constructor(key, options){\n        this.listeners = {};\n        this.nextRequestAbortController = null;\n        this.devToken = (userID)=>{\n            return DevToken(userID);\n        };\n        this.getAuthType = ()=>{\n            return this.anonymous ? \"anonymous\" : \"jwt\";\n        };\n        this.setBaseURL = (baseURL)=>{\n            this.baseURL = baseURL;\n            this.wsBaseURL = this.baseURL.replace(\"http\", \"ws\").replace(\":3030\", \":8800\");\n        };\n        this.getLocationHint = async (hintUrl, timeout)=>{\n            const hint = await this.locationHint;\n            if (!hint || hint === \"ERR\") {\n                this.locationHint = getLocationHint(hintUrl ?? this.options.locationHintUrl, timeout ?? this.options.locationHintTimeout);\n                return this.locationHint;\n            }\n            return hint;\n        };\n        this._getConnectionID = ()=>this.wsConnection?.connectionID || this.wsFallback?.connectionID;\n        this._hasConnectionID = ()=>Boolean(this._getConnectionID());\n        /**\n         * connectUser - Set the current user and open a WebSocket connection\n         *\n         * @param user Data about this user. IE {name: \"john\"}\n         * @param {TokenOrProvider} userTokenOrProvider Token or provider\n         *\n         * @return {ConnectAPIResponse} Returns a promise that resolves when the connection is setup\n         */ this.connectUser = async (user, userTokenOrProvider)=>{\n            if (!user.id) {\n                throw new Error('The \"id\" field on the user is missing');\n            }\n            /**\n             * Calling connectUser multiple times is potentially the result of a  bad integration, however,\n             * If the user id remains the same we don't throw error\n             */ if (this.userID === user.id && this.setUserPromise) {\n                this.logger(\"warn\", \"Consecutive calls to connectUser is detected, ideally you should only call this function once in your app.\");\n                return this.setUserPromise;\n            }\n            if (this.userID) {\n                throw new Error(\"Use client.disconnect() before trying to connect as a different user. connectUser was called twice.\");\n            }\n            if ((this._isUsingServerAuth() || this.node) && !this.options.allowServerSideConnect) {\n                this.logger(\"warn\", 'Please do not use connectUser server side. connectUser impacts MAU and concurrent connection usage and thus your bill. If you have a valid use-case, add \"allowServerSideConnect: true\" to the client options to disable this warning.');\n            }\n            // we generate the client id client side\n            this.userID = user.id;\n            this.anonymous = false;\n            const setTokenPromise = this._setToken(user, userTokenOrProvider, this.anonymous);\n            this._setUser(user);\n            const wsPromise = this.openConnection();\n            this.setUserPromise = Promise.all([\n                setTokenPromise,\n                wsPromise\n            ]).then((result)=>result[1]);\n            try {\n                return await this.setUserPromise;\n            } catch (err) {\n                if (this.persistUserOnConnectionFailure) {\n                    // cleanup client to allow the user to retry connectUser again\n                    this.closeConnection();\n                } else {\n                    this.disconnectUser();\n                }\n                throw err;\n            }\n        };\n        this._setToken = (user, userTokenOrProvider, isAnonymous)=>this.tokenManager.setTokenOrProvider(userTokenOrProvider, user, isAnonymous);\n        this._setUser = (user)=>{\n            /**\n             * This one is used by the frontend. This is a copy of the current user object stored on backend.\n             * It contains reserved properties and own user properties which are not present in `this._user`.\n             */ this.user = user;\n            this.userID = user.id;\n            // this one is actually used for requests. This is a copy of current user provided to `connectUser` function.\n            this._user = {\n                ...user\n            };\n        };\n        /**\n         * Disconnects the websocket connection, without removing the user set on client.\n         * client.closeConnection will not trigger default auto-retry mechanism for reconnection. You need\n         * to call client.openConnection to reconnect to websocket.\n         *\n         * This is mainly useful on mobile side. You can only receive push notifications\n         * if you don't have active websocket connection.\n         * So when your app goes to background, you can call `client.closeConnection`.\n         * And when app comes back to foreground, call `client.openConnection`.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming succesful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.closeConnection = async (timeout)=>{\n            if (this.cleaningIntervalRef != null) {\n                clearInterval(this.cleaningIntervalRef);\n                this.cleaningIntervalRef = undefined;\n            }\n            await Promise.all([\n                this.wsConnection?.disconnect(timeout),\n                this.wsFallback?.disconnect(timeout)\n            ]);\n            return Promise.resolve();\n        };\n        /**\n         * Creates a new WebSocket connection with the current user. Returns empty promise, if there is an active connection\n         */ this.openConnection = async ()=>{\n            if (!this.userID) {\n                throw Error(\"UserWithId is not set on client, use client.connectUser or client.connectAnonymousUser instead\");\n            }\n            if (this.wsConnection?.isConnecting && this.wsPromise) {\n                this.logger(\"info\", \"client:openConnection() - connection already in progress\");\n                return this.wsPromise;\n            }\n            if ((this.wsConnection?.isHealthy || this.wsFallback?.isHealthy()) && this._hasConnectionID()) {\n                this.logger(\"info\", \"client:openConnection() - openConnection called twice, healthy connection already exists\");\n                return Promise.resolve();\n            }\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.clientID = `${this.userID}--${randomId()}`;\n            this.wsPromise = this.connect();\n            return this.wsPromise;\n        };\n        this._normalizeDate = (before)=>{\n            if (before instanceof Date) {\n                before = before.toISOString();\n            }\n            if (before === \"\") {\n                throw new Error(\"Don't pass blank string for since, use null instead if resetting the token revoke\");\n            }\n            return before;\n        };\n        /**\n         * Disconnects the websocket and removes the user from client.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            this.logger(\"info\", \"client:disconnect() - Disconnecting the client\");\n            // remove the user specific fields\n            delete this.user;\n            delete this._user;\n            delete this.userID;\n            this.anonymous = false;\n            await this.closeConnection(timeout);\n            this.tokenManager.reset();\n            this.connectionIdPromise = undefined;\n            this.rejectConnectionId = undefined;\n            this.resolveConnectionId = undefined;\n        };\n        this.connectGuestUser = async (user)=>{\n            this.guestUserCreatePromise = this.doAxiosRequest(\"post\", \"/guest\", {\n                user: {\n                    ...user\n                }\n            }, {\n                publicEndpoint: true\n            });\n            const response = await this.guestUserCreatePromise;\n            this.guestUserCreatePromise.finally(()=>this.guestUserCreatePromise = undefined);\n            return this.connectUser(response.user, response.access_token);\n        };\n        /**\n         * connectAnonymousUser - Set an anonymous user and open a WebSocket connection\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.anonymous = true;\n            await this._setToken(user, tokenOrProvider, this.anonymous);\n            this._setUser(user);\n            // some endpoints require a connection_id to be resolved.\n            // as anonymous users aren't allowed to open WS connections, we just\n            // resolve the connection_id here.\n            this.resolveConnectionId?.();\n        };\n        /**\n         * on - Listen to events on all channels and users your watching\n         *\n         * client.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n         *\n         * @param eventName The event type to listen for (optional)\n         * @param callback The callback to call\n         *\n         * @return  Returns a function which, when called, unsubscribes the event handler.\n         */ this.on = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Adding listener for ${eventName} event`);\n            this.listeners[eventName]?.push(callback);\n            return ()=>{\n                this.off(eventName, callback);\n            };\n        };\n        /**\n         * off - Remove the event handler\n         */ this.off = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Removing listener for ${eventName} event`);\n            this.listeners[eventName] = this.listeners[eventName]?.filter((value)=>value !== callback);\n        };\n        this._logApiRequest = (type, url, data, config)=>{\n            this.logger(\"trace\", `client: ${type} - Request - ${url}`, {\n                payload: data,\n                config\n            });\n        };\n        this._logApiResponse = (type, url, response)=>{\n            this.logger(\"trace\", `client:${type} - Response - url: ${url} > status ${response.status}`, {\n                response\n            });\n        };\n        this._logApiError = (type, url, error)=>{\n            this.logger(\"error\", `client:${type} - Error - url: ${url}`, {\n                url,\n                error\n            });\n        };\n        this.doAxiosRequest = async (type, url, data, options = {})=>{\n            if (!options.publicEndpoint) {\n                await Promise.all([\n                    this.tokenManager.tokenReady(),\n                    this.guestUserCreatePromise,\n                    this.connectionIdPromise\n                ]);\n            }\n            const requestConfig = this._enrichAxiosOptions(options);\n            try {\n                let response;\n                this._logApiRequest(type, url, data, requestConfig);\n                switch(type){\n                    case \"get\":\n                        response = await this.axiosInstance.get(url, requestConfig);\n                        break;\n                    case \"delete\":\n                        response = await this.axiosInstance.delete(url, requestConfig);\n                        break;\n                    case \"post\":\n                        response = await this.axiosInstance.post(url, data, requestConfig);\n                        break;\n                    case \"put\":\n                        response = await this.axiosInstance.put(url, data, requestConfig);\n                        break;\n                    case \"patch\":\n                        response = await this.axiosInstance.patch(url, data, requestConfig);\n                        break;\n                    case \"options\":\n                        response = await this.axiosInstance.options(url, requestConfig);\n                        break;\n                    default:\n                        throw new Error(\"Invalid request type\");\n                }\n                this._logApiResponse(type, url, response);\n                this.consecutiveFailures = 0;\n                return this.handleResponse(response);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            } catch (e /**TODO: generalize error types  */ ) {\n                e.client_request_id = requestConfig.headers?.[\"x-client-request-id\"];\n                this.consecutiveFailures += 1;\n                if (e.response) {\n                    this._logApiError(type, url, e.response);\n                    /** connection_fallback depends on this token expiration logic */ if (e.response.data.code === KnownCodes.TOKEN_EXPIRED && !this.tokenManager.isStatic()) {\n                        if (this.consecutiveFailures > 1) {\n                            await sleep(retryInterval(this.consecutiveFailures));\n                        }\n                        await this.tokenManager.loadToken();\n                        return await this.doAxiosRequest(type, url, data, options);\n                    }\n                    return this.handleResponse(e.response);\n                } else {\n                    this._logApiError(type, url, e);\n                    // eslint-disable-next-line no-throw-literal\n                    throw e;\n                }\n            }\n        };\n        this.get = (url, params)=>{\n            return this.doAxiosRequest(\"get\", url, null, {\n                params\n            });\n        };\n        this.put = (url, data, params)=>{\n            return this.doAxiosRequest(\"put\", url, data, {\n                params\n            });\n        };\n        this.post = (url, data, params)=>{\n            return this.doAxiosRequest(\"post\", url, data, {\n                params\n            });\n        };\n        this.patch = (url, data, params)=>{\n            return this.doAxiosRequest(\"patch\", url, data, {\n                params\n            });\n        };\n        this.delete = (url, params)=>{\n            return this.doAxiosRequest(\"delete\", url, null, {\n                params\n            });\n        };\n        this.errorFromResponse = (response)=>{\n            let err;\n            err = new ErrorFromResponse(`Stream error HTTP code: ${response.status}`);\n            if (response.data && response.data.code) {\n                err = new Error(`Stream error code ${response.data.code}: ${response.data.message}`);\n                err.code = response.data.code;\n            }\n            err.response = response;\n            err.status = response.status;\n            return err;\n        };\n        this.handleResponse = (response)=>{\n            const data = response.data;\n            if (isErrorResponse(response)) {\n                throw this.errorFromResponse(response);\n            }\n            return data;\n        };\n        this.dispatchEvent = (event)=>{\n            if (!event.received_at) event.received_at = new Date();\n            this.logger(\"debug\", `Dispatching event: ${event.type}`, event);\n            if (!this.listeners) return;\n            // call generic listeners\n            for (const listener of this.listeners.all || []){\n                listener(event);\n            }\n            // call type specific listeners\n            for (const listener of this.listeners[event.type] || []){\n                listener(event);\n            }\n        };\n        /**\n         * @private\n         */ this.connect = async ()=>{\n            if (!this.userID || !this._user) {\n                throw Error(\"Call connectUser or connectAnonymousUser before starting the connection\");\n            }\n            if (!this.wsBaseURL) {\n                throw Error(\"Websocket base url not set\");\n            }\n            if (!this.clientID) {\n                throw Error(\"clientID is not set\");\n            }\n            if (!this.wsConnection && (this.options.warmUp || this.options.enableInsights)) {\n                this._sayHi();\n            }\n            // The StableWSConnection handles all the reconnection logic.\n            if (this.options.wsConnection && this.node) {\n                // Intentionally avoiding adding ts generics on wsConnection in options since its only useful for unit test purpose.\n                this.options.wsConnection.setClient(this);\n                this.wsConnection = this.options.wsConnection;\n            } else {\n                this.wsConnection = new StableWSConnection(this);\n            }\n            try {\n                // if fallback is used before, continue using it instead of waiting for WS to fail\n                if (this.wsFallback) {\n                    return await this.wsFallback.connect();\n                }\n                this.logger(\"info\", \"StreamClient.connect: this.wsConnection.connect()\");\n                // if WSFallback is enabled, ws connect should timeout faster so fallback can try\n                return await this.wsConnection.connect(this.options.enableWSFallback ? this.defaultWSTimeoutWithFallback : this.defaultWSTimeout);\n            } catch (err) {\n                // run fallback only if it's WS/Network error and not a normal API error\n                // make sure browser is online before even trying the longpoll\n                if (this.options.enableWSFallback && // @ts-ignore\n                isWSFailure(err) && isOnline(this.logger)) {\n                    this.logger(\"warn\", \"client:connect() - WS failed, fallback to longpoll\");\n                    this.dispatchEvent({\n                        type: \"transport.changed\",\n                        mode: \"longpoll\"\n                    });\n                    this.wsConnection._destroyCurrentWSConnection();\n                    this.wsConnection.disconnect().then(); // close WS so no retry\n                    this.wsFallback = new WSConnectionFallback(this);\n                    return await this.wsFallback.connect();\n                }\n                throw err;\n            }\n        };\n        /**\n         * Check the connectivity with server for warmup purpose.\n         *\n         * @private\n         */ this._sayHi = ()=>{\n            const client_request_id = randomId();\n            const opts = {\n                headers: axios__WEBPACK_IMPORTED_MODULE_1__.AxiosHeaders.from({\n                    \"x-client-request-id\": client_request_id\n                })\n            };\n            this.doAxiosRequest(\"get\", this.baseURL + \"/hi\", null, opts).catch((e)=>{\n                if (this.options.enableInsights) {\n                    postInsights(\"http_hi_failed\", {\n                        api_key: this.key,\n                        err: e,\n                        client_request_id\n                    });\n                }\n            });\n        };\n        this.getUserAgent = ()=>{\n            const version = \"0.7.4\";\n            return this.userAgent || `stream-video-javascript-client-${this.node ? \"node\" : \"browser\"}-${version}`;\n        };\n        this.setUserAgent = (userAgent)=>{\n            this.userAgent = userAgent;\n        };\n        /**\n         * _isUsingServerAuth - Returns true if we're using server side auth\n         */ this._isUsingServerAuth = ()=>!!this.secret;\n        this._enrichAxiosOptions = (options = {\n            params: {},\n            headers: {},\n            config: {}\n        })=>{\n            const token = options.publicEndpoint && !this.user ? undefined : this._getToken();\n            const authorization = token ? {\n                Authorization: token\n            } : undefined;\n            let signal = null;\n            if (this.nextRequestAbortController !== null) {\n                signal = this.nextRequestAbortController.signal;\n                this.nextRequestAbortController = null;\n            }\n            if (!options.headers?.[\"x-client-request-id\"]) {\n                options.headers = {\n                    ...options.headers,\n                    \"x-client-request-id\": randomId()\n                };\n            }\n            return {\n                params: {\n                    user_id: this.userID,\n                    connection_id: this._getConnectionID(),\n                    api_key: this.key,\n                    ...options.params\n                },\n                headers: {\n                    ...authorization,\n                    \"stream-auth-type\": options.publicEndpoint && !this.user ? \"anonymous\" : this.getAuthType(),\n                    \"X-Stream-Client\": this.getUserAgent(),\n                    ...options.headers\n                },\n                ...signal ? {\n                    signal\n                } : {},\n                ...options.config,\n                ...this.options.axiosRequestConfig\n            };\n        };\n        this._getToken = ()=>{\n            if (!this.tokenManager) return null;\n            return this.tokenManager.getToken();\n        };\n        /**\n         * encode ws url payload\n         * @private\n         * @returns json string\n         */ this._buildWSPayload = (client_request_id)=>{\n            return JSON.stringify({\n                user_id: this.userID,\n                user_details: this._user,\n                client_request_id\n            });\n        };\n        /**\n         * creates an abort controller that will be used by the next HTTP Request.\n         */ this.createAbortControllerForNextRequest = ()=>{\n            return this.nextRequestAbortController = new AbortController();\n        };\n        // set the key\n        this.key = key;\n        // set the secret\n        this.secret = options?.secret;\n        // set the options... and figure out defaults...\n        const inputOptions = options ? options : {\n            browser: \"undefined\" !== \"undefined\"\n        };\n        this.browser = inputOptions.browser || \"undefined\" !== \"undefined\";\n        this.node = !this.browser;\n        if (this.browser) {\n            this.locationHint = getLocationHint(options?.locationHintUrl, options?.locationHintTimeout);\n        }\n        this.options = {\n            timeout: 5000,\n            withCredentials: false,\n            warmUp: false,\n            ...inputOptions\n        };\n        if (this.node && !this.options.httpsAgent) {\n            this.options.httpsAgent = new (https__WEBPACK_IMPORTED_MODULE_5___default().Agent)({\n                keepAlive: true,\n                keepAliveMsecs: 3000\n            });\n        }\n        this.setBaseURL(this.options.baseURL || \"https://video.stream-io-api.com/video\");\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_RUN) {\n            this.setBaseURL(\"http://localhost:3030/video\");\n        }\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_HOST) {\n            this.setBaseURL(`http://${process.env.STREAM_LOCAL_TEST_HOST}/video`);\n        }\n        this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_33__[\"default\"].create({\n            ...this.options,\n            baseURL: this.baseURL\n        });\n        // WS connection is initialized when setUser is called\n        this.wsConnection = null;\n        this.wsPromise = null;\n        this.setUserPromise = null;\n        // mapping between channel groups and configs\n        this.anonymous = false;\n        this.persistUserOnConnectionFailure = this.options?.persistUserOnConnectionFailure;\n        // If it is a server-side client, then lets initialize the tokenManager, since token will be\n        // generated from secret.\n        this.tokenManager = new TokenManager(this.secret);\n        this.consecutiveFailures = 0;\n        this.insightMetrics = new InsightMetrics();\n        this.defaultWSTimeoutWithFallback = 6000;\n        this.defaultWSTimeout = 15000;\n        this.logger = isFunction(inputOptions.logger) ? inputOptions.logger : ()=>null;\n    }\n}\n/**\n * A `StreamVideoClient` instance lets you communicate with our API, and authenticate users.\n */ class StreamVideoClient {\n    constructor(apiKeyOrArgs, opts){\n        this.logLevel = \"warn\";\n        this.eventHandlersToUnregister = [];\n        /**\n         * Disconnects the currently connected user from the client.\n         *\n         * If the connection is successfully disconnected, the connected user [state variable](#readonlystatestore) will be updated accordingly\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            if (!this.streamClient.user && !this.connectionPromise) {\n                return;\n            }\n            const disconnectUser = ()=>this.streamClient.disconnectUser(timeout);\n            this.disconnectionPromise = this.connectionPromise ? this.connectionPromise.then(()=>disconnectUser()) : disconnectUser();\n            this.disconnectionPromise.finally(()=>this.disconnectionPromise = undefined);\n            await this.disconnectionPromise;\n            this.eventHandlersToUnregister.forEach((unregister)=>unregister());\n            this.eventHandlersToUnregister = [];\n            this.writeableStateStore.setConnectedUser(undefined);\n        };\n        /**\n         * You can subscribe to WebSocket events provided by the API.\n         * To remove a subscription, call the `off` method or, execute the returned unsubscribe function.\n         * Please note that subscribing to WebSocket events is an advanced use-case, for most use-cases it should be enough to watch for changes in the reactive [state store](#readonlystatestore).\n         *\n         * @param eventName the event name or 'all'.\n         * @param callback the callback which will be called when the event is emitted.\n         * @returns an unsubscribe function.\n         */ this.on = (eventName, callback)=>{\n            return this.streamClient.on(eventName, callback);\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param callback the callback which was passed to the `on` method.\n         */ this.off = (eventName, callback)=>{\n            return this.streamClient.off(eventName, callback);\n        };\n        /**\n         * Creates a new call.\n         *\n         * @param type the type of the call.\n         * @param id the id of the call.\n         */ this.call = (type, id)=>{\n            return new Call({\n                streamClient: this.streamClient,\n                id: id,\n                type: type,\n                clientStore: this.writeableStateStore\n            });\n        };\n        /**\n         * Creates a new guest user with the given data.\n         *\n         * @param data the data for the guest user.\n         */ this.createGuestUser = async (data)=>{\n            return this.streamClient.doAxiosRequest(\"post\", \"/guest\", data, {\n                publicEndpoint: true\n            });\n        };\n        /**\n         * Will query the API for calls matching the given filters.\n         *\n         * @param data the query data.\n         */ this.queryCalls = async (data = {})=>{\n            const response = await this.streamClient.post(\"/calls\", data);\n            const calls = response.calls.map((c)=>{\n                const call = new Call({\n                    streamClient: this.streamClient,\n                    id: c.call.id,\n                    type: c.call.type,\n                    members: c.members,\n                    ownCapabilities: c.own_capabilities,\n                    watching: data.watch,\n                    clientStore: this.writeableStateStore\n                });\n                call.state.updateFromCallResponse(c.call);\n                call.applyDeviceConfig();\n                if (data.watch) {\n                    this.writeableStateStore.registerCall(call);\n                }\n                return call;\n            });\n            return {\n                ...response,\n                calls: calls\n            };\n        };\n        /**\n         * Retrieve the list of available call statistics reports matching a particular condition.\n         *\n         * @param data Filter and sort conditions for retrieving available call report summaries.\n         * @returns List with summary of available call reports matching the condition.\n         */ this.queryCallStats = async (data = {})=>{\n            return this.streamClient.post(`/call/stats`, data);\n        };\n        /**\n         * Returns a list of available data centers available for hosting calls.\n         */ this.edges = async ()=>{\n            return this.streamClient.get(`/edges`);\n        };\n        /**\n         * addDevice - Adds a push device for a user.\n         *\n         * @param {string} id the device id\n         * @param {string} push_provider the push provider name (eg. apn, firebase)\n         * @param {string} push_provider_name user provided push provider name\n         * @param {string} [userID] the user id (defaults to current user)\n         * @param {boolean} [voip_token] enables use of VoIP token for push notifications on iOS platform\n         */ this.addDevice = async (id, push_provider, push_provider_name, userID, voip_token)=>{\n            return await this.streamClient.post(\"/devices\", {\n                id,\n                push_provider,\n                voip_token,\n                ...userID != null ? {\n                    user_id: userID\n                } : {},\n                ...push_provider_name != null ? {\n                    push_provider_name\n                } : {}\n            });\n        };\n        /**\n         * getDevices - Returns the devices associated with a current user\n         * @param {string} [userID] User ID. Only works on serverside\n         */ this.getDevices = async (userID)=>{\n            return await this.streamClient.get(\"/devices\", userID ? {\n                user_id: userID\n            } : {});\n        };\n        /**\n         * removeDevice - Removes the device with the given id.\n         *\n         * @param {string} id The device id\n         * @param {string} [userID] The user id. Only specify this for serverside requests\n         */ this.removeDevice = async (id, userID)=>{\n            return await this.streamClient.delete(\"/devices\", {\n                id,\n                ...userID ? {\n                    user_id: userID\n                } : {}\n            });\n        };\n        /**\n         * A callback that can be used to create ringing calls from push notifications. If the call already exists, it will do nothing.\n         * @param call_cid\n         * @returns\n         */ this.onRingingCall = async (call_cid)=>{\n            // if we find the call and is already ringing, we don't need to create a new call\n            // as client would have received the call.ring state because the app had WS alive when receiving push notifications\n            let call = this.readOnlyStateStore.calls.find((c)=>c.cid === call_cid && c.ringing);\n            if (!call) {\n                // if not it means that WS is not alive when receiving the push notifications and we need to fetch the call\n                const [callType, callId] = call_cid.split(\":\");\n                call = new Call({\n                    streamClient: this.streamClient,\n                    type: callType,\n                    id: callId,\n                    clientStore: this.writeableStateStore,\n                    ringing: true\n                });\n                await call.get();\n            }\n            return call;\n        };\n        /**\n         * Connects the given anonymous user to the client.\n         *\n         * @param user the user to connect.\n         * @param tokenOrProvider a token or a function that returns a token.\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            const connectAnonymousUser = ()=>this.streamClient.connectAnonymousUser(user, tokenOrProvider);\n            this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectAnonymousUser()) : connectAnonymousUser();\n            this.connectionPromise.finally(()=>this.connectionPromise = undefined);\n            return this.connectionPromise;\n        };\n        let logger = logToConsole;\n        let logLevel = \"warn\";\n        if (typeof apiKeyOrArgs === \"string\") {\n            logLevel = opts?.logLevel || logLevel;\n            logger = opts?.logger || logger;\n        } else {\n            logLevel = apiKeyOrArgs.options?.logLevel || logLevel;\n            logger = apiKeyOrArgs.options?.logger || logger;\n        }\n        setLogger(logger, logLevel);\n        this.logger = getLogger([\n            \"client\"\n        ]);\n        if (typeof apiKeyOrArgs === \"string\") {\n            this.streamClient = new StreamClient(apiKeyOrArgs, {\n                persistUserOnConnectionFailure: true,\n                ...opts,\n                logLevel,\n                logger: this.logger\n            });\n        } else {\n            this.streamClient = new StreamClient(apiKeyOrArgs.apiKey, {\n                persistUserOnConnectionFailure: true,\n                ...apiKeyOrArgs.options,\n                logLevel,\n                logger: this.logger\n            });\n            const sdkInfo = getSdkInfo();\n            if (sdkInfo) {\n                this.streamClient.setUserAgent(this.streamClient.getUserAgent() + `-video-${SdkType[sdkInfo.type].toLowerCase()}-sdk-${sdkInfo.major}.${sdkInfo.minor}.${sdkInfo.patch}`);\n            }\n        }\n        this.writeableStateStore = new StreamVideoWriteableStateStore();\n        this.readOnlyStateStore = new StreamVideoReadOnlyStateStore(this.writeableStateStore);\n        if (typeof apiKeyOrArgs !== \"string\") {\n            const user = apiKeyOrArgs.user;\n            const token = apiKeyOrArgs.token || apiKeyOrArgs.tokenProvider;\n            if (user) {\n                this.connectUser(user, token);\n            }\n        }\n    }\n    /**\n     * Return the reactive state store, use this if you want to be notified about changes to the client state\n     */ get state() {\n        return this.readOnlyStateStore;\n    }\n    /**\n     * Connects the given user to the client.\n     * Only one user can connect at a time, if you want to change users, call `disconnectUser` before connecting a new user.\n     * If the connection is successful, the connected user [state variable](#readonlystatestore) will be updated accordingly.\n     *\n     * @param user the user to connect.\n     * @param token a token or a function that returns a token.\n     */ async connectUser(user, token) {\n        if (user.type === \"anonymous\") {\n            user.id = \"!anon\";\n            return this.connectAnonymousUser(user, token);\n        }\n        let connectUser = ()=>{\n            return this.streamClient.connectUser(user, token);\n        };\n        if (user.type === \"guest\") {\n            connectUser = async ()=>{\n                return this.streamClient.connectGuestUser(user);\n            };\n        }\n        this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectUser()) : connectUser();\n        this.connectionPromise?.finally(()=>this.connectionPromise = undefined);\n        const connectUserResponse = await this.connectionPromise;\n        // connectUserResponse will be void if connectUser called twice for the same user\n        if (connectUserResponse?.me) {\n            this.writeableStateStore.setConnectedUser(connectUserResponse.me);\n        }\n        this.eventHandlersToUnregister.push(this.on(\"connection.changed\", (event)=>{\n            if (event.online) {\n                const callsToReWatch = this.writeableStateStore.calls.filter((call)=>call.watching).map((call)=>call.cid);\n                this.logger(\"info\", `Rewatching calls after connection changed ${callsToReWatch.join(\", \")}`);\n                if (callsToReWatch.length > 0) {\n                    this.queryCalls({\n                        watch: true,\n                        filter_conditions: {\n                            cid: {\n                                $in: callsToReWatch\n                            }\n                        },\n                        sort: [\n                            {\n                                field: \"cid\",\n                                direction: 1\n                            }\n                        ]\n                    }).catch((err)=>{\n                        this.logger(\"error\", \"Failed to re-watch calls\", err);\n                    });\n                }\n            }\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.created\", (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"warn\", \"Received `call.created` sent by the current user\");\n                return;\n            }\n            this.logger(\"info\", `New call created and registered: ${call.cid}`);\n            const newCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore\n            });\n            newCall.state.updateFromCallResponse(call);\n            this.writeableStateStore.registerCall(newCall);\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.ring\", async (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"debug\", \"Received `call.ring` sent by the current user so ignoring the event\");\n                return;\n            }\n            // The call might already be tracked by the client,\n            // if `call.created` was received before `call.ring`.\n            // In that case, we cleanup the already tracked call.\n            const prevCall = this.writeableStateStore.findCall(call.type, call.id);\n            await prevCall?.leave({\n                reason: \"cleaning-up in call.ring\"\n            });\n            // we create a new call\n            const theCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore,\n                ringing: true\n            });\n            theCall.state.updateFromCallResponse(call);\n            // we fetch the latest metadata for the call from the server\n            await theCall.get();\n            this.writeableStateStore.registerCall(theCall);\n        }));\n        return connectUserResponse;\n    }\n    /**\n     * addDevice - Adds a push device for a user.\n     *\n     * @param {string} id the device id\n     * @param {string} push_provider the push provider name (eg. apn, firebase)\n     * @param {string} push_provider_name user provided push provider name\n     * @param {string} [userID] the user id (defaults to current user)\n     */ async addVoipDevice(id, push_provider, push_provider_name, userID) {\n        return await this.addDevice(id, push_provider, push_provider_name, userID, true);\n    }\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1jbGllbnQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0R0E7O0NBRUcsR0FDVSxNQUFBQSxpQ0FBaUM7SUFDNUNDLFNBQVM7SUFDVEMsVUFBVTs7QUFpRFo7O0NBRUcsR0FDVSxNQUFBQyx3Q0FBd0M7SUFDbkRGLFNBQVM7SUFDVEMsVUFBVTs7QUErbEVaOztDQUVHLEdBQ1UsTUFBQUUsc0NBQXNDO0lBQ2pEQyxVQUFVO0lBQ1ZDLEtBQUs7SUFDTEMsUUFBUTtJQUNSQyxRQUFROztBQWtpQ1Y7OztDQUdHLEdBQ1UsTUFBQUMsZ0JBQWdCO0lBQzNCQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYkMsaUJBQWlCO0lBQ2pCQyxVQUFVO0lBQ1ZDLGdCQUFnQjtJQUNoQkMsV0FBVztJQUNYQyxpQkFBaUI7SUFDakJDLFlBQVk7SUFDWkMsa0JBQWtCO0lBQ2xCQyxXQUFXO0lBQ1hDLG9CQUFvQjtJQUNwQkMsYUFBYTtJQUNiQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsc0JBQXNCO0lBQ3RCQyxtQkFBbUI7SUFDbkJDLDBCQUEwQjtJQUMxQkMscUJBQXFCO0lBQ3JCQyxrQkFBa0I7SUFDbEJDLHlCQUF5QjtJQUN6QkMsYUFBYTtJQUNiQyxvQkFBb0I7SUFDcEJDLHlCQUF5QjtJQUN6QkMsc0JBQXNCOztBQXVieEI7O0NBRUcsR0FDVSxNQUFBQyxnQ0FBZ0M7SUFDM0NDLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxTQUFTOztBQUtYOztDQUVHLEdBQ1UsTUFBQUMsbUNBQW1DO0lBQzlDQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFB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WTtJQUN0Qjs7S0FFRyxHQUNIQSxZQUFBLENBQUFBLFlBQUE7SUFDQTs7S0FFRyxHQUNIQSxZQUFBLENBQUFBLFlBQUE7SUFDQTs7S0FFRyxHQUNIQSxZQUFBLENBQUFBLFlBQUE7SUFDQTs7S0FFRyxHQUNIQSxZQUFBLENBQUFBLFlBQUE7QUFDRixHQWpCWUEsZ0JBQUFBLENBQUFBLGVBaUJYO0FBQ0Q7O0NBRUcsR0FDSCxJQUFZQztBQUFaLFVBQVlBLFNBQVM7SUFDbkI7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0FBQ0YsR0FyQllBLGFBQUFBLENBQUFBLFlBcUJYO0FBQ0Q7O0NBRUcsR0FDSCxJQUFZQztBQUFaLFVBQVlBLFNBQVM7SUFDbkI7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFBO0lBQ0E7O0tBRUcsR0FDSEEsU0FBQSxDQUFBQSxTQUFB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QUF5QixDQUFDcnVELElBQUksQ0FDakMsSUFBSSxDQUFDdVksRUFBRSxDQUFDLGFBQWEsT0FBT2tNO1lBQzFCLE1BQU0sRUFBRTFNLElBQUksRUFBRTZMLE9BQU8sRUFBRSxHQUFHYTtZQUMxQixJQUFJK0IsS0FBSy9mLEVBQUUsS0FBS3NSLEtBQUt1TixVQUFVLENBQUM3ZSxFQUFFLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQ3FPLE1BQU0sQ0FDVCxTQUNBO2dCQUVGOzs7OztZQU1GLE1BQU1nN0MsV0FBVyxJQUFJLENBQUN0QixtQkFBbUIsQ0FBQ3JqQyxRQUFRLENBQUNwVCxLQUFLdlIsSUFBSSxFQUFFdVIsS0FBS3RSLEVBQUU7WUFDckUsTUFBTXFwRCxVQUFVemtDLE1BQU07Z0JBQUUvWSxRQUFRO1lBQTBCOztZQUUxRCxNQUFNeTlDLFVBQVUsSUFBSWpwRCxLQUFLO2dCQUN2Qjh3QyxjQUFjLElBQUksQ0FBQ0EsWUFBWTtnQkFDL0JweEMsTUFBTXVSLEtBQUt2UixJQUFJO2dCQUNmQyxJQUFJc1IsS0FBS3RSLEVBQUU7Z0JBQ1htZDtnQkFDQWkwQixhQUFhLElBQUksQ0FBQzJXLG1CQUFtQjtnQkFDckMxdEIsU0FBUztZQUNWO1lBQ0RpdkIsUUFBUXZzQyxLQUFLLENBQUN1QixzQkFBc0IsQ0FBQ2hOOztZQUVyQyxNQUFNZzRDLFFBQVEvNkIsR0FBRztZQUNqQixJQUFJLENBQUN3NUIsbUJBQW1CLENBQUN4akMsWUFBWSxDQUFDK2tDOztRQUkxQyxPQUFPUjs7SUFrS1Q7Ozs7Ozs7S0FPRyxHQUNILE1BQU1TLGNBQ0p2cEQsRUFBVSxFQUNWc29ELGFBQXFCLEVBQ3JCQyxrQkFBMEIsRUFDMUIzTixNQUFlO1FBRWYsT0FBTyxNQUFNLElBQUksQ0FBQ3lOLFNBQVMsQ0FDekJyb0QsSUFDQXNvRCxlQUNBQyxvQkFDQTNOLFFBQ0E7O0FBeUVMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9nZW4vY29vcmRpbmF0b3IvaW5kZXgudHM/N2NlYSIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vdHlwZXMudHM/N2MyNyIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2dlbi9nb29nbGUvcHJvdG9idWYvc3RydWN0LnRzP2RmNjciLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9nZW4vZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC50cz8yZTFjIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzLnRzPzJkZGUiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9nZW4vdmlkZW8vc2Z1L3NpZ25hbF9ycGMvc2lnbmFsLnRzP2NjOTYiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9nZW4vdmlkZW8vc2Z1L2V2ZW50L2V2ZW50cy50cz83YzdhIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvdHlwZXMudHM/NDc5ZCIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2dlbi92aWRlby9zZnUvc2lnbmFsX3JwYy9zaWduYWwuY2xpZW50LnRzP2FmZWQiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9ycGMvY3JlYXRlQ2xpZW50LnRzP2M2YTgiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9oZWxwZXJzL3BsYXRmb3Jtcy50cz8zZDMwIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvbG9nZ2VyLnRzPzg3NDYiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9ydGMvY29kZWNzLnRzP2RlYjUiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9ydGMvRGlzcGF0Y2hlci50cz9kMDFlIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvcnRjL0ljZVRyaWNrbGVCdWZmZXIudHM/ZmY2ZSIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL3J0Yy9oZWxwZXJzL2ljZUNhbmRpZGF0ZS50cz8xMWIzIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvY2xpZW50LWRldGFpbHMudHM/Mzc4ZSIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL3J0Yy92aWRlb0xheWVycy50cz9iYjcwIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvcnRjL2hlbHBlcnMvdHJhY2tzLnRzP2U2OTgiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9zdG9yZS9yeFV0aWxzLnRzPzc5NDEiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9zb3J0aW5nL2NvbXBhcmF0b3IudHM/OGE3MiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL3NvcnRpbmcvcGFydGljaXBhbnRzLnRzPzU4NWIiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9zb3J0aW5nL3ByZXNldHMudHM/YmM0OCIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL3N0b3JlL0NhbGxTdGF0ZS50cz81N2I4Iiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvc3RvcmUvc3RhdGVTdG9yZS50cz8wMThhIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvaGVscGVycy9zZHAtbXVuZ2luZy50cz9mZGNmIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvcnRjL1B1Ymxpc2hlci50cz80MGJkIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvcnRjL1N1YnNjcmliZXIudHM/NjhkMyIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL3J0Yy9zaWduYWwudHM/ZDcxYiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vdXRpbHMudHM/Njg2NiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL1N0cmVhbVNmdUNsaWVudC50cz81ZDIzIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvZXZlbnRzL2NhbGwudHM/NzRmMyIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2V2ZW50cy9jYWxsLXBlcm1pc3Npb25zLnRzPzk5ZjAiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9ldmVudHMvaW50ZXJuYWwudHM/YWU3YiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2V2ZW50cy9tdXRlcy50cz8yMDhmIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvZXZlbnRzL3BhcnRpY2lwYW50LnRzPzlmNWMiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9ldmVudHMvc3BlYWtlci50cz82NjAzIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvZXZlbnRzL2NhbGxFdmVudEhhbmRsZXJzLnRzPzI1OWIiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9ydGMvZmxvd3Mvam9pbi50cz9lNmE3Iiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvc3RhdHMvdXRpbHMudHM/NDA3ZSIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL3N0YXRzL3N0YXRlU3RvcmVTdGF0c1JlcG9ydGVyLnRzP2YzYTAiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9zdGF0cy9TZnVTdGF0c1JlcG9ydGVyLnRzPzIxYzUiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9oZWxwZXJzL1ZpZXdwb3J0VHJhY2tlci50cz83ODRjIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvaGVscGVycy9icm93c2Vycy50cz9hODQ2Iiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvaGVscGVycy9EeW5hc2NhbGVNYW5hZ2VyLnRzPzQxNzgiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9wZXJtaXNzaW9ucy9QZXJtaXNzaW9uc0NvbnRleHQudHM/OGE4ZSIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL0NhbGxUeXBlLnRzP2FiOTciLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9kZXZpY2VzL2RldmljZXMudHM/YjQ3ZiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2RldmljZXMvSW5wdXRNZWRpYURldmljZU1hbmFnZXIudHM/ZTYxMCIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2RldmljZXMvSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZS50cz9lYTc3Iiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvZGV2aWNlcy9DYW1lcmFNYW5hZ2VyU3RhdGUudHM/MmM2MiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2RldmljZXMvQ2FtZXJhTWFuYWdlci50cz9lOGEyIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvZGV2aWNlcy9NaWNyb3Bob25lTWFuYWdlclN0YXRlLnRzPzNmMTMiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9oZWxwZXJzL3NvdW5kLWRldGVjdG9yLnRzP2NiMmYiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9oZWxwZXJzL1JOU3BlZWNoRGV0ZWN0b3IudHM/NmViNSIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2RldmljZXMvTWljcm9waG9uZU1hbmFnZXIudHM/Zjc2ZiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2RldmljZXMvU2NyZWVuU2hhcmVTdGF0ZS50cz83OWRmIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvZGV2aWNlcy9TY3JlZW5TaGFyZU1hbmFnZXIudHM/MTA4MyIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2RldmljZXMvU3BlYWtlclN0YXRlLnRzPzI5NjgiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9kZXZpY2VzL1NwZWFrZXJNYW5hZ2VyLnRzPzIxNDUiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9DYWxsLnRzPzdiNWUiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9jb29yZGluYXRvci9jb25uZWN0aW9uL2luc2lnaHRzLnRzPzVlOWMiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9jb29yZGluYXRvci9jb25uZWN0aW9uL2Nvbm5lY3Rpb24udHM/NjA2ZiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vYmFzZTY0LnRzPzA1ZjYiLCJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4uLy4uL3NyYy9jb29yZGluYXRvci9jb25uZWN0aW9uL3NpZ25pbmcudHM/OWVjMyIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vdG9rZW5fbWFuYWdlci50cz8wM2UyIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvY29vcmRpbmF0b3IvY29ubmVjdGlvbi9lcnJvcnMudHM/MjEyNiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9mYWxsYmFjay50cz81NGMwIiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvY29vcmRpbmF0b3IvY29ubmVjdGlvbi9sb2NhdGlvbi50cz9jZjA5Iiwid2VicGFjazovL3RlYW1zcGFjZS8uLi8uLi9zcmMvY29vcmRpbmF0b3IvY29ubmVjdGlvbi9jbGllbnQudHM/M2YxZiIsIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi4vLi4vc3JjL1N0cmVhbVZpZGVvQ2xpZW50LnRzPzE0NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEFQSUVycm9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQVBJRXJyb3Ige1xuICAvKipcbiAgICogUmVzcG9uc2UgSFRUUCBzdGF0dXMgY29kZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgQVBJRXJyb3JcbiAgICovXG4gIFN0YXR1c0NvZGU6IG51bWJlcjtcbiAgLyoqXG4gICAqIEFQSSBlcnJvciBjb2RlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBBUElFcnJvclxuICAgKi9cbiAgY29kZTogbnVtYmVyO1xuICAvKipcbiAgICogQWRkaXRpb25hbCBlcnJvci1zcGVjaWZpYyBpbmZvcm1hdGlvblxuICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICogQG1lbWJlcm9mIEFQSUVycm9yXG4gICAqL1xuICBkZXRhaWxzOiBBcnJheTxudW1iZXI+O1xuICAvKipcbiAgICogUmVxdWVzdCBkdXJhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQVBJRXJyb3JcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGVycm9yIGluZm9cbiAgICogQHR5cGUge3sgW2tleTogc3RyaW5nXTogc3RyaW5nOyB9fVxuICAgKiBAbWVtYmVyb2YgQVBJRXJyb3JcbiAgICovXG4gIGV4Y2VwdGlvbl9maWVsZHM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICAvKipcbiAgICogTWVzc2FnZSBkZXNjcmliaW5nIGFuIGVycm9yXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBBUElFcnJvclxuICAgKi9cbiAgbWVzc2FnZTogc3RyaW5nO1xuICAvKipcbiAgICogVVJMIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQVBJRXJyb3JcbiAgICovXG4gIG1vcmVfaW5mbzogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBBY2NlcHRDYWxsUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY2NlcHRDYWxsUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEFjY2VwdENhbGxSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQXVkaW9TZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvU2V0dGluZ3Mge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBBdWRpb1NldHRpbmdzXG4gICAqL1xuICBhY2Nlc3NfcmVxdWVzdF9lbmFibGVkOiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEF1ZGlvU2V0dGluZ3NcbiAgICovXG4gIGRlZmF1bHRfZGV2aWNlOiBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEF1ZGlvU2V0dGluZ3NcbiAgICovXG4gIG1pY19kZWZhdWx0X29uOiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBBdWRpb1NldHRpbmdzXG4gICAqL1xuICBvcHVzX2R0eF9lbmFibGVkOiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBBdWRpb1NldHRpbmdzXG4gICAqL1xuICByZWR1bmRhbnRfY29kaW5nX2VuYWJsZWQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEF1ZGlvU2V0dGluZ3NcbiAgICovXG4gIHNwZWFrZXJfZGVmYXVsdF9vbjogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0gPSB7XG4gIFNQRUFLRVI6ICdzcGVha2VyJyxcbiAgRUFSUElFQ0U6ICdlYXJwaWVjZScsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtID1cbiAgKHR5cGVvZiBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0pW2tleW9mIHR5cGVvZiBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW1dO1xuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEF1ZGlvU2V0dGluZ3NSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9TZXR0aW5nc1JlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBBdWRpb1NldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgYWNjZXNzX3JlcXVlc3RfZW5hYmxlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQXVkaW9TZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGRlZmF1bHRfZGV2aWNlOiBBdWRpb1NldHRpbmdzUmVxdWVzdERlZmF1bHREZXZpY2VFbnVtO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBBdWRpb1NldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgbWljX2RlZmF1bHRfb24/OiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBBdWRpb1NldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgb3B1c19kdHhfZW5hYmxlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEF1ZGlvU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICByZWR1bmRhbnRfY29kaW5nX2VuYWJsZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBBdWRpb1NldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgc3BlYWtlcl9kZWZhdWx0X29uPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBBdWRpb1NldHRpbmdzUmVxdWVzdERlZmF1bHREZXZpY2VFbnVtID0ge1xuICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gIEVBUlBJRUNFOiAnZWFycGllY2UnLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIEF1ZGlvU2V0dGluZ3NSZXF1ZXN0RGVmYXVsdERldmljZUVudW0gPVxuICAodHlwZW9mIEF1ZGlvU2V0dGluZ3NSZXF1ZXN0RGVmYXVsdERldmljZUVudW0pW2tleW9mIHR5cGVvZiBBdWRpb1NldHRpbmdzUmVxdWVzdERlZmF1bHREZXZpY2VFbnVtXTtcblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBCYWNrc3RhZ2VTZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tzdGFnZVNldHRpbmdzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgQmFja3N0YWdlU2V0dGluZ3NcbiAgICovXG4gIGVuYWJsZWQ6IGJvb2xlYW47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEJhY2tzdGFnZVNldHRpbmdzUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tzdGFnZVNldHRpbmdzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEJhY2tzdGFnZVNldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgZW5hYmxlZD86IGJvb2xlYW47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEJsb2NrVXNlclJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja1VzZXJSZXF1ZXN0IHtcbiAgLyoqXG4gICAqIHRoZSB1c2VyIHRvIGJsb2NrXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBCbG9ja1VzZXJSZXF1ZXN0XG4gICAqL1xuICB1c2VyX2lkOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEJsb2NrVXNlclJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tVc2VyUmVzcG9uc2Uge1xuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIHJlcXVlc3QgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBCbG9ja1VzZXJSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHRvIGNhbGwgcGFydGljaXBhbnRzIHRvIG5vdGlmeSB3aGVuIGEgdXNlciBpcyBibG9ja2VkIG9uIGEgY2FsbCwgY2xpZW50cyBjYW4gdXNlIHRoaXMgZXZlbnQgdG8gc2hvdyBhIG5vdGlmaWNhdGlvbi5cbiAqIElmIHRoZSB1c2VyIGlzIHRoZSBjdXJyZW50IHVzZXIsIHRoZSBjbGllbnQgc2hvdWxkIGxlYXZlIHRoZSBjYWxsIHNjcmVlbiBhcyB3ZWxsXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEJsb2NrZWRVc2VyRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2VkVXNlckV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtVc2VyUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBCbG9ja2VkVXNlckV2ZW50XG4gICAqL1xuICBibG9ja2VkX2J5X3VzZXI/OiBVc2VyUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQmxvY2tlZFVzZXJFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBCbG9ja2VkVXNlckV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLmJsb2NrZWRfdXNlclwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQmxvY2tlZFVzZXJFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1VzZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIEJsb2NrZWRVc2VyRXZlbnRcbiAgICovXG4gIHVzZXI6IFVzZXJSZXNwb25zZTtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQnJvYWRjYXN0U2V0dGluZ3NSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnJvYWRjYXN0U2V0dGluZ3NSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgQnJvYWRjYXN0U2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtITFNTZXR0aW5nc1JlcXVlc3R9XG4gICAqIEBtZW1iZXJvZiBCcm9hZGNhc3RTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGhscz86IEhMU1NldHRpbmdzUmVxdWVzdDtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQnJvYWRjYXN0U2V0dGluZ3NSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJyb2FkY2FzdFNldHRpbmdzUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBCcm9hZGNhc3RTZXR0aW5nc1Jlc3BvbnNlXG4gICAqL1xuICBlbmFibGVkOiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0hMU1NldHRpbmdzUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBCcm9hZGNhc3RTZXR0aW5nc1Jlc3BvbnNlXG4gICAqL1xuICBobHM6IEhMU1NldHRpbmdzUmVzcG9uc2U7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGEgdXNlciBhY2NlcHRzIGEgbm90aWZpY2F0aW9uIHRvIGpvaW4gYSBjYWxsLlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsQWNjZXB0ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxBY2NlcHRlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsQWNjZXB0ZWRFdmVudFxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxBY2NlcHRlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxBY2NlcHRlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLmFjY2VwdGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsQWNjZXB0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1VzZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxBY2NlcHRlZEV2ZW50XG4gICAqL1xuICB1c2VyOiBVc2VyUmVzcG9uc2U7XG59XG4vKipcbiAqIENhbGxDbG9zZWRDYXB0aW9uIHJlcHJlc2VudHMgYSBjbG9zZWQgY2FwdGlvbiBvZiBhIGNhbGwuXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxDbG9zZWRDYXB0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbENsb3NlZENhcHRpb24ge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxDbG9zZWRDYXB0aW9uXG4gICAqL1xuICBlbmRfdGltZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxDbG9zZWRDYXB0aW9uXG4gICAqL1xuICBzcGVha2VyX2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbENsb3NlZENhcHRpb25cbiAgICovXG4gIHN0YXJ0X3RpbWU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsQ2xvc2VkQ2FwdGlvblxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBhIGNhbGwgaXMgY3JlYXRlZC4gQ2xpZW50cyByZWNlaXZpbmcgdGhpcyBldmVudCBzaG91bGQgY2hlY2sgaWYgdGhlIHJpbmdpbmdcbiAqIGZpZWxkIGlzIHNldCB0byB0cnVlIGFuZCBpZiBzbywgc2hvdyB0aGUgY2FsbCBzY3JlZW5cbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbENyZWF0ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxDcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxDcmVhdGVkRXZlbnRcbiAgICovXG4gIGNhbGw6IENhbGxSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsQ3JlYXRlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxDcmVhdGVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIHRoZSBtZW1iZXJzIGFkZGVkIHRvIHRoaXMgY2FsbFxuICAgKiBAdHlwZSB7QXJyYXk8TWVtYmVyUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgQ2FsbENyZWF0ZWRFdmVudFxuICAgKi9cbiAgbWVtYmVyczogQXJyYXk8TWVtYmVyUmVzcG9uc2U+O1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5jcmVhdGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsQ3JlYXRlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGEgY2FsbCBpcyBkZWxldGVkLiBDbGllbnRzIHJlY2VpdmluZyB0aGlzIGV2ZW50IHNob3VsZCBsZWF2ZSB0aGUgY2FsbCBzY3JlZW5cbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbERlbGV0ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxEZWxldGVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxEZWxldGVkRXZlbnRcbiAgICovXG4gIGNhbGw6IENhbGxSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsRGVsZXRlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxEZWxldGVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwuZGVsZXRlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbERlbGV0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBhIGNhbGwgaXMgbWFyayBhcyBlbmRlZCBmb3IgYWxsIGl0cyBwYXJ0aWNpcGFudHMuIENsaWVudHMgcmVjZWl2aW5nIHRoaXMgZXZlbnQgc2hvdWxkIGxlYXZlIHRoZSBjYWxsIHNjcmVlblxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsRW5kZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxFbmRlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsRW5kZWRFdmVudFxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxFbmRlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxFbmRlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLmVuZGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsRW5kZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1VzZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxFbmRlZEV2ZW50XG4gICAqL1xuICB1c2VyPzogVXNlclJlc3BvbnNlO1xufVxuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbEV2ZW50XG4gICAqL1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIENhbGxFdmVudFxuICAgKi9cbiAgZW5kX3RpbWVzdGFtcDogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIENhbGxFdmVudFxuICAgKi9cbiAgc2V2ZXJpdHk6IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBDYWxsRXZlbnRcbiAgICovXG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIEhMUyBicm9hZGNhc3RpbmcgaGFzIGZhaWxlZFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsSExTQnJvYWRjYXN0aW5nRmFpbGVkRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsSExTQnJvYWRjYXN0aW5nRmFpbGVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxITFNCcm9hZGNhc3RpbmdGYWlsZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsSExTQnJvYWRjYXN0aW5nRmFpbGVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwuaGxzX2Jyb2FkY2FzdGluZ19mYWlsZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxITFNCcm9hZGNhc3RpbmdGYWlsZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBITFMgYnJvYWRjYXN0aW5nIGhhcyBzdGFydGVkXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxITFNCcm9hZGNhc3RpbmdTdGFydGVkRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsSExTQnJvYWRjYXN0aW5nU3RhcnRlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsSExTQnJvYWRjYXN0aW5nU3RhcnRlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxITFNCcm9hZGNhc3RpbmdTdGFydGVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsSExTQnJvYWRjYXN0aW5nU3RhcnRlZEV2ZW50XG4gICAqL1xuICBobHNfcGxheWxpc3RfdXJsOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLmhsc19icm9hZGNhc3Rpbmdfc3RhcnRlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbEhMU0Jyb2FkY2FzdGluZ1N0YXJ0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBITFMgYnJvYWRjYXN0aW5nIGhhcyBzdG9wcGVkXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxITFNCcm9hZGNhc3RpbmdTdG9wcGVkRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsSExTQnJvYWRjYXN0aW5nU3RvcHBlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsSExTQnJvYWRjYXN0aW5nU3RvcHBlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxITFNCcm9hZGNhc3RpbmdTdG9wcGVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwuaGxzX2Jyb2FkY2FzdGluZ19zdG9wcGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsSExTQnJvYWRjYXN0aW5nU3RvcHBlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxJbmdyZXNzUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsSW5ncmVzc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtSVE1QSW5ncmVzc31cbiAgICogQG1lbWJlcm9mIENhbGxJbmdyZXNzUmVzcG9uc2VcbiAgICovXG4gIHJ0bXA6IFJUTVBJbmdyZXNzO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBhIGNhbGwgaXMgc3RhcnRlZC4gQ2xpZW50cyByZWNlaXZpbmcgdGhpcyBldmVudCBzaG91bGQgc3RhcnQgdGhlIGNhbGwuXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxMaXZlU3RhcnRlZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbExpdmVTdGFydGVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxMaXZlU3RhcnRlZEV2ZW50XG4gICAqL1xuICBjYWxsOiBDYWxsUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbExpdmVTdGFydGVkRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbExpdmVTdGFydGVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwubGl2ZV9zdGFydGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTGl2ZVN0YXJ0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBvbmUgb3IgbW9yZSBtZW1iZXJzIGFyZSBhZGRlZCB0byBhIGNhbGxcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbE1lbWJlckFkZGVkRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsTWVtYmVyQWRkZWRFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlckFkZGVkRXZlbnRcbiAgICovXG4gIGNhbGw6IENhbGxSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTWVtYmVyQWRkZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTWVtYmVyQWRkZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogdGhlIG1lbWJlcnMgYWRkZWQgdG8gdGhpcyBjYWxsXG4gICAqIEB0eXBlIHtBcnJheTxNZW1iZXJSZXNwb25zZT59XG4gICAqIEBtZW1iZXJvZiBDYWxsTWVtYmVyQWRkZWRFdmVudFxuICAgKi9cbiAgbWVtYmVyczogQXJyYXk8TWVtYmVyUmVzcG9uc2U+O1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5tZW1iZXJfYWRkZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxNZW1iZXJBZGRlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIG9uZSBvciBtb3JlIG1lbWJlcnMgYXJlIHJlbW92ZWQgZnJvbSBhIGNhbGxcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbE1lbWJlclJlbW92ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxNZW1iZXJSZW1vdmVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxNZW1iZXJSZW1vdmVkRXZlbnRcbiAgICovXG4gIGNhbGw6IENhbGxSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTWVtYmVyUmVtb3ZlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxNZW1iZXJSZW1vdmVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIHRoZSBsaXN0IG9mIG1lbWJlciBJRHMgcmVtb3ZlZCBmcm9tIHRoZSBjYWxsXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclJlbW92ZWRFdmVudFxuICAgKi9cbiAgbWVtYmVyczogQXJyYXk8c3RyaW5nPjtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwubWVtYmVyX3JlbW92ZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxNZW1iZXJSZW1vdmVkRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gb25lIG9yIG1vcmUgbWVtYmVycyBhcmUgdXBkYXRlZFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsTWVtYmVyVXBkYXRlZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbE1lbWJlclVwZGF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclVwZGF0ZWRFdmVudFxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxNZW1iZXJVcGRhdGVkRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclVwZGF0ZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgbWVtYmVycyB0aGF0IHdlcmUgdXBkYXRlZFxuICAgKiBAdHlwZSB7QXJyYXk8TWVtYmVyUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclVwZGF0ZWRFdmVudFxuICAgKi9cbiAgbWVtYmVyczogQXJyYXk8TWVtYmVyUmVzcG9uc2U+O1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5tZW1iZXJfdXBkYXRlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclVwZGF0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBvbmUgb3IgbW9yZSBtZW1iZXJzIGdldCBpdHMgcm9sZSB1cGRhdGVkXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxNZW1iZXJVcGRhdGVkUGVybWlzc2lvbkV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbE1lbWJlclVwZGF0ZWRQZXJtaXNzaW9uRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxNZW1iZXJVcGRhdGVkUGVybWlzc2lvbkV2ZW50XG4gICAqL1xuICBjYWxsOiBDYWxsUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclVwZGF0ZWRQZXJtaXNzaW9uRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgY2FwYWJpbGl0aWVzIGJ5IHJvbGUgZm9yIHRoaXMgY2FsbFxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBBcnJheTxzdHJpbmc+OyB9fVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclVwZGF0ZWRQZXJtaXNzaW9uRXZlbnRcbiAgICovXG4gIGNhcGFiaWxpdGllc19ieV9yb2xlOiB7IFtrZXk6IHN0cmluZ106IEFycmF5PHN0cmluZz4gfTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTWVtYmVyVXBkYXRlZFBlcm1pc3Npb25FdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgbWVtYmVycyB0aGF0IHdlcmUgdXBkYXRlZFxuICAgKiBAdHlwZSB7QXJyYXk8TWVtYmVyUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgQ2FsbE1lbWJlclVwZGF0ZWRQZXJtaXNzaW9uRXZlbnRcbiAgICovXG4gIG1lbWJlcnM6IEFycmF5PE1lbWJlclJlc3BvbnNlPjtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwubWVtYmVyX2FkZGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTWVtYmVyVXBkYXRlZFBlcm1pc3Npb25FdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgdG8gYWxsIGNhbGwgbWVtYmVycyB0byBub3RpZnkgdGhleSBhcmUgZ2V0dGluZyBjYWxsZWRcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbE5vdGlmaWNhdGlvbkV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbE5vdGlmaWNhdGlvbkV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsTm90aWZpY2F0aW9uRXZlbnRcbiAgICovXG4gIGNhbGw6IENhbGxSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTm90aWZpY2F0aW9uRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbE5vdGlmaWNhdGlvbkV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDYWxsIG1lbWJlcnNcbiAgICogQHR5cGUge0FycmF5PE1lbWJlclJlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIENhbGxOb3RpZmljYXRpb25FdmVudFxuICAgKi9cbiAgbWVtYmVyczogQXJyYXk8TWVtYmVyUmVzcG9uc2U+O1xuICAvKipcbiAgICogQ2FsbCBzZXNzaW9uIElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTm90aWZpY2F0aW9uRXZlbnRcbiAgICovXG4gIHNlc3Npb25faWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwubm90aWZpY2F0aW9uXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsTm90aWZpY2F0aW9uRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtVc2VyUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsTm90aWZpY2F0aW9uRXZlbnRcbiAgICovXG4gIHVzZXI6IFVzZXJSZXNwb25zZTtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFBhcnRpY2lwYW50UmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsUGFydGljaXBhbnRSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFBhcnRpY2lwYW50UmVzcG9uc2VcbiAgICovXG4gIGpvaW5lZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxQYXJ0aWNpcGFudFJlc3BvbnNlXG4gICAqL1xuICByb2xlOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VXNlclJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFBhcnRpY2lwYW50UmVzcG9uc2VcbiAgICovXG4gIHVzZXI6IFVzZXJSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUGFydGljaXBhbnRSZXNwb25zZVxuICAgKi9cbiAgdXNlcl9zZXNzaW9uX2lkOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGEgcmVhY3Rpb24gaXMgc2VudCBpbiBhIGNhbGwsIGNsaWVudHMgc2hvdWxkIHVzZSB0aGlzIHRvIHNob3cgdGhlIHJlYWN0aW9uIGluIHRoZSBjYWxsIHNjcmVlblxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsUmVhY3Rpb25FdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxSZWFjdGlvbkV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVhY3Rpb25FdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVhY3Rpb25FdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1JlYWN0aW9uUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVhY3Rpb25FdmVudFxuICAgKi9cbiAgcmVhY3Rpb246IFJlYWN0aW9uUmVzcG9uc2U7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnJlYWN0aW9uX25ld1wiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlYWN0aW9uRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogQ2FsbFJlY29yZGluZyByZXByZXNlbnRzIGEgcmVjb3JkaW5nIG9mIGEgY2FsbC5cbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFJlY29yZGluZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxSZWNvcmRpbmcge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZWNvcmRpbmdcbiAgICovXG4gIGVuZF90aW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ1xuICAgKi9cbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVjb3JkaW5nXG4gICAqL1xuICBzdGFydF90aW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ1xuICAgKi9cbiAgdXJsOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGNhbGwgcmVjb3JkaW5nIGhhcyBmYWlsZWRcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFJlY29yZGluZ0ZhaWxlZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFJlY29yZGluZ0ZhaWxlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVjb3JkaW5nRmFpbGVkRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ0ZhaWxlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnJlY29yZGluZ19mYWlsZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZWNvcmRpbmdGYWlsZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBjYWxsIHJlY29yZGluZyBpcyByZWFkeVxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsUmVjb3JkaW5nUmVhZHlFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxSZWNvcmRpbmdSZWFkeUV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVjb3JkaW5nUmVhZHlFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVjb3JkaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ1JlYWR5RXZlbnRcbiAgICovXG4gIGNhbGxfcmVjb3JkaW5nOiBDYWxsUmVjb3JkaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZWNvcmRpbmdSZWFkeUV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnJlY29yZGluZ19yZWFkeVwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ1JlYWR5RXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gY2FsbCByZWNvcmRpbmcgaGFzIHN0YXJ0ZWRcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFJlY29yZGluZ1N0YXJ0ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxSZWNvcmRpbmdTdGFydGVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZWNvcmRpbmdTdGFydGVkRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ1N0YXJ0ZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5yZWNvcmRpbmdfc3RhcnRlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ1N0YXJ0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBjYWxsIHJlY29yZGluZyBoYXMgc3RvcHBlZFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsUmVjb3JkaW5nU3RvcHBlZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFJlY29yZGluZ1N0b3BwZWRFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlY29yZGluZ1N0b3BwZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVjb3JkaW5nU3RvcHBlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnJlY29yZGluZ19zdG9wcGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVjb3JkaW5nU3RvcHBlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGEgdXNlciByZWplY3RzIGEgbm90aWZpY2F0aW9uIHRvIGpvaW4gYSBjYWxsLlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsUmVqZWN0ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxSZWplY3RlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVqZWN0ZWRFdmVudFxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZWplY3RlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZWplY3RlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnJlamVjdGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVqZWN0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1VzZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxSZWplY3RlZEV2ZW50XG4gICAqL1xuICB1c2VyOiBVc2VyUmVzcG9uc2U7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFJlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3sgW2tleTogc3RyaW5nXTogYW55OyB9fVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlcXVlc3RcbiAgICovXG4gIGN1c3RvbT86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8TWVtYmVyUmVxdWVzdD59XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVxdWVzdFxuICAgKi9cbiAgbWVtYmVycz86IEFycmF5PE1lbWJlclJlcXVlc3Q+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxTZXR0aW5nc1JlcXVlc3R9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVxdWVzdFxuICAgKi9cbiAgc2V0dGluZ3Nfb3ZlcnJpZGU/OiBDYWxsU2V0dGluZ3NSZXF1ZXN0O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZXF1ZXN0XG4gICAqL1xuICBzdGFydHNfYXQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlcXVlc3RcbiAgICovXG4gIHRlYW0/OiBzdHJpbmc7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjYWxsXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgYmFja3N0YWdlOiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIGJsb2NrZWRfdXNlcl9pZHM6IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGEgY2FsbCAoPHR5cGU+OjxpZD4pXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIGNpZDogc3RyaW5nO1xuICAvKipcbiAgICogRGF0ZS90aW1lIG9mIGNyZWF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtVc2VyUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIGNyZWF0ZWRfYnk6IFVzZXJSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIGN1cnJlbnRfc2Vzc2lvbl9pZDogc3RyaW5nO1xuICAvKipcbiAgICogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgb2JqZWN0XG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IGFueTsgfX1cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgY3VzdG9tOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0VncmVzc1Jlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlc3BvbnNlXG4gICAqL1xuICBlZ3Jlc3M6IEVncmVzc1Jlc3BvbnNlO1xuICAvKipcbiAgICogRGF0ZS90aW1lIHdoZW4gdGhlIGNhbGwgZW5kZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgZW5kZWRfYXQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDYWxsIElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIGlkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbEluZ3Jlc3NSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgaW5ncmVzczogQ2FsbEluZ3Jlc3NSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlc3BvbnNlXG4gICAqL1xuICByZWNvcmRpbmc6IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFNlc3Npb25SZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgc2Vzc2lvbj86IENhbGxTZXNzaW9uUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFNldHRpbmdzUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIHNldHRpbmdzOiBDYWxsU2V0dGluZ3NSZXNwb25zZTtcbiAgLyoqXG4gICAqIERhdGUvdGltZSB3aGVuIHRoZSBjYWxsIHdpbGwgc3RhcnRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgc3RhcnRzX2F0Pzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgdGVhbT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtUaHVtYm5haWxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgdGh1bWJuYWlscz86IFRodW1ibmFpbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBDYWxsUmVzcG9uc2VcbiAgICovXG4gIHRyYW5zY3JpYmluZzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGNhbGxcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSZXNwb25zZVxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICogRGF0ZS90aW1lIG9mIHRoZSBsYXN0IHVwZGF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJlc3BvbnNlXG4gICAqL1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB0byBhbGwgY2FsbCBtZW1iZXJzIHRvIG5vdGlmeSB0aGV5IGFyZSBnZXR0aW5nIGNhbGxlZFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsUmluZ0V2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFJpbmdFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJpbmdFdmVudFxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSaW5nRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJpbmdFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogQ2FsbCBtZW1iZXJzXG4gICAqIEB0eXBlIHtBcnJheTxNZW1iZXJSZXNwb25zZT59XG4gICAqIEBtZW1iZXJvZiBDYWxsUmluZ0V2ZW50XG4gICAqL1xuICBtZW1iZXJzOiBBcnJheTxNZW1iZXJSZXNwb25zZT47XG4gIC8qKlxuICAgKiBDYWxsIHNlc3Npb24gSURcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxSaW5nRXZlbnRcbiAgICovXG4gIHNlc3Npb25faWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwubm90aWZpY2F0aW9uXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsUmluZ0V2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VXNlclJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFJpbmdFdmVudFxuICAgKi9cbiAgdXNlcjogVXNlclJlc3BvbnNlO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBhIGNhbGwgc2Vzc2lvbiBlbmRzXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxTZXNzaW9uRW5kZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxTZXNzaW9uRW5kZWRFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25FbmRlZEV2ZW50XG4gICAqL1xuICBjYWxsOiBDYWxsUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25FbmRlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxTZXNzaW9uRW5kZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogQ2FsbCBzZXNzaW9uIElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvbkVuZGVkRXZlbnRcbiAgICovXG4gIHNlc3Npb25faWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwuc2Vzc2lvbl9lbmRlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25FbmRlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGEgcGFydGljaXBhbnQgam9pbnMgYSBjYWxsIHNlc3Npb25cbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFBhcnRpY2lwYW50UmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkRXZlbnRcbiAgICovXG4gIHBhcnRpY2lwYW50OiBDYWxsUGFydGljaXBhbnRSZXNwb25zZTtcbiAgLyoqXG4gICAqIENhbGwgc2Vzc2lvbiBJRFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZEV2ZW50XG4gICAqL1xuICBzZXNzaW9uX2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnNlc3Npb25fcGFydGljaXBhbnRfam9pbmVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gYSBwYXJ0aWNpcGFudCBsZWF2ZXMgYSBjYWxsIHNlc3Npb25cbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudExlZnRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxTZXNzaW9uUGFydGljaXBhbnRMZWZ0RXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxTZXNzaW9uUGFydGljaXBhbnRMZWZ0RXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudExlZnRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxQYXJ0aWNpcGFudFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudExlZnRFdmVudFxuICAgKi9cbiAgcGFydGljaXBhbnQ6IENhbGxQYXJ0aWNpcGFudFJlc3BvbnNlO1xuICAvKipcbiAgICogQ2FsbCBzZXNzaW9uIElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblBhcnRpY2lwYW50TGVmdEV2ZW50XG4gICAqL1xuICBzZXNzaW9uX2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnNlc3Npb25fcGFydGljaXBhbnRfbGVmdFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudExlZnRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsU2Vzc2lvblJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFNlc3Npb25SZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH19XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblJlc3BvbnNlXG4gICAqL1xuICBhY2NlcHRlZF9ieTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblJlc3BvbnNlXG4gICAqL1xuICBlbmRlZF9hdD86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblJlc3BvbnNlXG4gICAqL1xuICBpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxTZXNzaW9uUmVzcG9uc2VcbiAgICovXG4gIGxpdmVfZW5kZWRfYXQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25SZXNwb25zZVxuICAgKi9cbiAgbGl2ZV9zdGFydGVkX2F0Pzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PENhbGxQYXJ0aWNpcGFudFJlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIENhbGxTZXNzaW9uUmVzcG9uc2VcbiAgICovXG4gIHBhcnRpY2lwYW50czogQXJyYXk8Q2FsbFBhcnRpY2lwYW50UmVzcG9uc2U+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3sgW2tleTogc3RyaW5nXTogbnVtYmVyOyB9fVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25SZXNwb25zZVxuICAgKi9cbiAgcGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGU6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH19XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblJlc3BvbnNlXG4gICAqL1xuICByZWplY3RlZF9ieTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblJlc3BvbnNlXG4gICAqL1xuICBzdGFydGVkX2F0Pzogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBhIGNhbGwgc2Vzc2lvbiBzdGFydHNcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFNlc3Npb25TdGFydGVkRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsU2Vzc2lvblN0YXJ0ZWRFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNlc3Npb25TdGFydGVkRXZlbnRcbiAgICovXG4gIGNhbGw6IENhbGxSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblN0YXJ0ZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblN0YXJ0ZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogQ2FsbCBzZXNzaW9uIElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2Vzc2lvblN0YXJ0ZWRFdmVudFxuICAgKi9cbiAgc2Vzc2lvbl9pZDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5zZXNzaW9uX3N0YXJ0ZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxTZXNzaW9uU3RhcnRlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxTZXR0aW5nc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsU2V0dGluZ3NSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBdWRpb1NldHRpbmdzUmVxdWVzdH1cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGF1ZGlvPzogQXVkaW9TZXR0aW5nc1JlcXVlc3Q7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QmFja3N0YWdlU2V0dGluZ3NSZXF1ZXN0fVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgYmFja3N0YWdlPzogQmFja3N0YWdlU2V0dGluZ3NSZXF1ZXN0O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0Jyb2FkY2FzdFNldHRpbmdzUmVxdWVzdH1cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGJyb2FkY2FzdGluZz86IEJyb2FkY2FzdFNldHRpbmdzUmVxdWVzdDtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtHZW9mZW5jZVNldHRpbmdzUmVxdWVzdH1cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGdlb2ZlbmNpbmc/OiBHZW9mZW5jZVNldHRpbmdzUmVxdWVzdDtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtSZWNvcmRTZXR0aW5nc1JlcXVlc3R9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICByZWNvcmRpbmc/OiBSZWNvcmRTZXR0aW5nc1JlcXVlc3Q7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7UmluZ1NldHRpbmdzUmVxdWVzdH1cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIHJpbmc/OiBSaW5nU2V0dGluZ3NSZXF1ZXN0O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1NjcmVlbnNoYXJpbmdTZXR0aW5nc1JlcXVlc3R9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBzY3JlZW5zaGFyaW5nPzogU2NyZWVuc2hhcmluZ1NldHRpbmdzUmVxdWVzdDtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtUaHVtYm5haWxzU2V0dGluZ3NSZXF1ZXN0fVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgdGh1bWJuYWlscz86IFRodW1ibmFpbHNTZXR0aW5nc1JlcXVlc3Q7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdH1cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIHRyYW5zY3JpcHRpb24/OiBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1ZpZGVvU2V0dGluZ3NSZXF1ZXN0fVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgdmlkZW8/OiBWaWRlb1NldHRpbmdzUmVxdWVzdDtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ2FsbFNldHRpbmdzUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsU2V0dGluZ3NSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXVkaW9TZXR0aW5nc31cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1Jlc3BvbnNlXG4gICAqL1xuICBhdWRpbzogQXVkaW9TZXR0aW5ncztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtCYWNrc3RhZ2VTZXR0aW5nc31cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1Jlc3BvbnNlXG4gICAqL1xuICBiYWNrc3RhZ2U6IEJhY2tzdGFnZVNldHRpbmdzO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0Jyb2FkY2FzdFNldHRpbmdzUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgYnJvYWRjYXN0aW5nOiBCcm9hZGNhc3RTZXR0aW5nc1Jlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0dlb2ZlbmNlU2V0dGluZ3N9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgZ2VvZmVuY2luZzogR2VvZmVuY2VTZXR0aW5ncztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtSZWNvcmRTZXR0aW5nc1Jlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNldHRpbmdzUmVzcG9uc2VcbiAgICovXG4gIHJlY29yZGluZzogUmVjb3JkU2V0dGluZ3NSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtSaW5nU2V0dGluZ3N9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgcmluZzogUmluZ1NldHRpbmdzO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1NjcmVlbnNoYXJpbmdTZXR0aW5nc31cbiAgICogQG1lbWJlcm9mIENhbGxTZXR0aW5nc1Jlc3BvbnNlXG4gICAqL1xuICBzY3JlZW5zaGFyaW5nOiBTY3JlZW5zaGFyaW5nU2V0dGluZ3M7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VGh1bWJuYWlsc1NldHRpbmdzfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFNldHRpbmdzUmVzcG9uc2VcbiAgICovXG4gIHRodW1ibmFpbHM6IFRodW1ibmFpbHNTZXR0aW5ncztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtUcmFuc2NyaXB0aW9uU2V0dGluZ3N9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgdHJhbnNjcmlwdGlvbjogVHJhbnNjcmlwdGlvblNldHRpbmdzO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1ZpZGVvU2V0dGluZ3N9XG4gICAqIEBtZW1iZXJvZiBDYWxsU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgdmlkZW86IFZpZGVvU2V0dGluZ3M7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxTdGF0ZVJlc3BvbnNlRmllbGRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFN0YXRlUmVzcG9uc2VGaWVsZHMge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxTdGF0ZVJlc3BvbnNlRmllbGRzXG4gICAqL1xuICBjYWxsOiBDYWxsUmVzcG9uc2U7XG4gIC8qKlxuICAgKiBMaXN0IG9mIGNhbGwgbWVtYmVyc1xuICAgKiBAdHlwZSB7QXJyYXk8TWVtYmVyUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgQ2FsbFN0YXRlUmVzcG9uc2VGaWVsZHNcbiAgICovXG4gIG1lbWJlcnM6IEFycmF5PE1lbWJlclJlc3BvbnNlPjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtNZW1iZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENhbGxTdGF0ZVJlc3BvbnNlRmllbGRzXG4gICAqL1xuICBtZW1iZXJzaGlwPzogTWVtYmVyUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8T3duQ2FwYWJpbGl0eT59XG4gICAqIEBtZW1iZXJvZiBDYWxsU3RhdGVSZXNwb25zZUZpZWxkc1xuICAgKi9cbiAgb3duX2NhcGFiaWxpdGllczogQXJyYXk8T3duQ2FwYWJpbGl0eT47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxTdGF0c1JlcG9ydFN1bW1hcnlSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxTdGF0c1JlcG9ydFN1bW1hcnlSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFN0YXRzUmVwb3J0U3VtbWFyeVJlc3BvbnNlXG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxTdGF0c1JlcG9ydFN1bW1hcnlSZXNwb25zZVxuICAgKi9cbiAgY2FsbF9zZXNzaW9uX2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFN0YXRzUmVwb3J0U3VtbWFyeVJlc3BvbnNlXG4gICAqL1xuICBjYWxsX3N0YXR1czogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxTdGF0c1JlcG9ydFN1bW1hcnlSZXNwb25zZVxuICAgKi9cbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsU3RhdHNSZXBvcnRTdW1tYXJ5UmVzcG9uc2VcbiAgICovXG4gIGZpcnN0X3N0YXRzX3RpbWU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBDYWxsU3RhdHNSZXBvcnRTdW1tYXJ5UmVzcG9uc2VcbiAgICovXG4gIHF1YWxpdHlfc2NvcmU/OiBudW1iZXI7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxUaW1lbGluZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxUaW1lbGluZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8Q2FsbEV2ZW50Pn1cbiAgICogQG1lbWJlcm9mIENhbGxUaW1lbGluZVxuICAgKi9cbiAgZXZlbnRzOiBBcnJheTxDYWxsRXZlbnQ+O1xufVxuLyoqXG4gKiBDYWxsVHJhbnNjcmlwdGlvbiByZXByZXNlbnRzIGEgdHJhbnNjcmlwdGlvbiBvZiBhIGNhbGwuXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFRyYW5zY3JpcHRpb24ge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uXG4gICAqL1xuICBlbmRfdGltZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uXG4gICAqL1xuICBzdGFydF90aW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25cbiAgICovXG4gIHVybDogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBjYWxsIHRyYW5zY3JpcHRpb24gaGFzIGZhaWxlZFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFRyYW5zY3JpcHRpb25GYWlsZWRFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25GYWlsZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnRyYW5zY3JpcHRpb25fZmFpbGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGNhbGwgdHJhbnNjcmlwdGlvbiBpcyByZWFkeVxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsVHJhbnNjcmlwdGlvblJlYWR5RXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsVHJhbnNjcmlwdGlvblJlYWR5RXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uUmVhZHlFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsVHJhbnNjcmlwdGlvbn1cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uUmVhZHlFdmVudFxuICAgKi9cbiAgY2FsbF90cmFuc2NyaXB0aW9uOiBDYWxsVHJhbnNjcmlwdGlvbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvblJlYWR5RXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwudHJhbnNjcmlwdGlvbl9yZWFkeVwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25SZWFkeUV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGNhbGwgdHJhbnNjcmlwdGlvbiBoYXMgc3RhcnRlZFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsVHJhbnNjcmlwdGlvblN0YXJ0ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uU3RhcnRlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvblN0YXJ0ZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvblN0YXJ0ZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC50cmFuc2NyaXB0aW9uX3N0YXJ0ZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uU3RhcnRlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGNhbGwgdHJhbnNjcmlwdGlvbiBoYXMgc3RvcHBlZFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDYWxsVHJhbnNjcmlwdGlvblN0b3BwZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uU3RvcHBlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvblN0b3BwZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvblN0b3BwZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC50cmFuc2NyaXB0aW9uX3N0b3BwZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uU3RvcHBlZEV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxUeXBlUmVzcG9uc2VcbiAqIEBpbnRlcmZhY2UgQ2FsbFRyYW5zY3JpcHRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsVHJhbnNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25cbiAgICovXG4gIGVuZF90aW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25cbiAgICovXG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25cbiAgICovXG4gIHN0YXJ0X3RpbWU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvblxuICAgKi9cbiAgdXJsOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGNhbGwgdHJhbnNjcmlwdGlvbiBoYXMgZmFpbGVkXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNhbGwudHJhbnNjcmlwdGlvbl9mYWlsZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gY2FsbCB0cmFuc2NyaXB0aW9uIGlzIHJlYWR5XG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uUmVhZHlFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uUmVhZHlFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25SZWFkeUV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxUcmFuc2NyaXB0aW9ufVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25SZWFkeUV2ZW50XG4gICAqL1xuICBjYWxsX3RyYW5zY3JpcHRpb246IENhbGxUcmFuc2NyaXB0aW9uO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uUmVhZHlFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC50cmFuc2NyaXB0aW9uX3JlYWR5XCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVHJhbnNjcmlwdGlvblJlYWR5RXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gY2FsbCB0cmFuc2NyaXB0aW9uIGhhcyBzdGFydGVkXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uU3RhcnRlZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFRyYW5zY3JpcHRpb25TdGFydGVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uU3RhcnRlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uU3RhcnRlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnRyYW5zY3JpcHRpb25fc3RhcnRlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25TdGFydGVkRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gY2FsbCB0cmFuc2NyaXB0aW9uIGhhcyBzdG9wcGVkXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxUcmFuc2NyaXB0aW9uU3RvcHBlZEV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbFRyYW5zY3JpcHRpb25TdG9wcGVkRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uU3RvcHBlZEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxUcmFuc2NyaXB0aW9uU3RvcHBlZEV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnRyYW5zY3JpcHRpb25fc3RvcHBlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFRyYW5zY3JpcHRpb25TdG9wcGVkRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gYSBjYWxsIGlzIHVwZGF0ZWQsIGNsaWVudHMgc2hvdWxkIHVzZSB0aGlzIHVwZGF0ZSB0aGUgbG9jYWwgc3RhdGUgb2YgdGhlIGNhbGwuXG4gKiBUaGlzIGV2ZW50IGFsc28gY29udGFpbnMgdGhlIGNhcGFiaWxpdGllcyBieSByb2xlIGZvciB0aGUgY2FsbCwgY2xpZW50cyBzaG91bGQgdXBkYXRlIHRoZSBvd25fY2FwYWJpbGl0eSBmb3IgdGhlIGN1cnJlbnQuXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxVcGRhdGVkRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsVXBkYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBDYWxsVXBkYXRlZEV2ZW50XG4gICAqL1xuICBjYWxsOiBDYWxsUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFVwZGF0ZWRFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBjYXBhYmlsaXRpZXMgYnkgcm9sZSBmb3IgdGhpcyBjYWxsXG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IEFycmF5PHN0cmluZz47IH19XG4gICAqIEBtZW1iZXJvZiBDYWxsVXBkYXRlZEV2ZW50XG4gICAqL1xuICBjYXBhYmlsaXRpZXNfYnlfcm9sZTogeyBba2V5OiBzdHJpbmddOiBBcnJheTxzdHJpbmc+IH07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFVwZGF0ZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5lbmRlZFwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2FsbFVwZGF0ZWRFdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBhIGNhbGwgbWVtYmVyIGlzIG11dGVkXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENhbGxVc2VyTXV0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsVXNlck11dGVkIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVXNlck11dGVkXG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxVc2VyTXV0ZWRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDYWxsVXNlck11dGVkXG4gICAqL1xuICBmcm9tX3VzZXJfaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKiBAbWVtYmVyb2YgQ2FsbFVzZXJNdXRlZFxuICAgKi9cbiAgbXV0ZWRfdXNlcl9pZHM6IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnVzZXJfbXV0ZWRcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENhbGxVc2VyTXV0ZWRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gY2xvc2VkIGNhcHRpb25zIGFyZSBiZWluZyBzZW50IGluIGEgY2FsbCwgY2xpZW50cyBzaG91bGQgdXNlIHRoaXMgdG8gc2hvdyB0aGUgY2xvc2VkIGNhcHRpb25zIGluIHRoZSBjYWxsIHNjcmVlblxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDbG9zZWRDYXB0aW9uRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDbG9zZWRDYXB0aW9uRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENsb3NlZENhcHRpb25FdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsQ2xvc2VkQ2FwdGlvbn1cbiAgICogQG1lbWJlcm9mIENsb3NlZENhcHRpb25FdmVudFxuICAgKi9cbiAgY2xvc2VkX2NhcHRpb246IENhbGxDbG9zZWRDYXB0aW9uO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENsb3NlZENhcHRpb25FdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5jbG9zZWRfY2FwdGlvblwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ2xvc2VkQ2FwdGlvbkV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ29sbGVjdFVzZXJGZWVkYmFja1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2xsZWN0VXNlckZlZWRiYWNrUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAbWVtYmVyb2YgQ29sbGVjdFVzZXJGZWVkYmFja1JlcXVlc3RcbiAgICovXG4gIGN1c3RvbT86IHsgW2tleTpzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBDb2xsZWN0VXNlckZlZWRiYWNrUmVxdWVzdFxuICAgKi9cbiAgcmF0aW5nPzogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENvbGxlY3RVc2VyRmVlZGJhY2tSZXF1ZXN0XG4gICAqL1xuICByZWFzb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ29sbGVjdFVzZXJGZWVkYmFja1JlcXVlc3RcbiAgICovXG4gIHNkazogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENvbGxlY3RVc2VyRmVlZGJhY2tSZXF1ZXN0XG4gICAqL1xuICBzZGtfdmVyc2lvbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENvbGxlY3RVc2VyRmVlZGJhY2tSZXF1ZXN0XG4gICAqL1xuICB1c2VyX3Nlc3Npb25faWQ6IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ29sbGVjdFVzZXJGZWVkYmFja1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGVjdFVzZXJGZWVkYmFja1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ29sbGVjdFVzZXJGZWVkYmFja1Jlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENvbm5lY3RVc2VyRGV0YWlsc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0VXNlckRldGFpbHNSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IGFueTsgfX1cbiAgICogQG1lbWJlcm9mIENvbm5lY3RVc2VyRGV0YWlsc1JlcXVlc3RcbiAgICovXG4gIGN1c3RvbT86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ29ubmVjdFVzZXJEZXRhaWxzUmVxdWVzdFxuICAgKi9cbiAgaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDb25uZWN0VXNlckRldGFpbHNSZXF1ZXN0XG4gICAqL1xuICBpbWFnZT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDb25uZWN0VXNlckRldGFpbHNSZXF1ZXN0XG4gICAqL1xuICBsYW5ndWFnZT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDb25uZWN0VXNlckRldGFpbHNSZXF1ZXN0XG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiB0aGUgV1MgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCBhbmQgYXV0aGVudGljYXRlZCwgdGhpcyBldmVudCBjb250YWlucyB0aGUgZnVsbCB1c2VyIG9iamVjdCBhcyBpdCBpcyBzdG9yZWQgb24gdGhlIHNlcnZlclxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDb25uZWN0ZWRFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3RlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBjb25uZWN0aW9uX2lkIGZvciB0aGlzIGNsaWVudFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ29ubmVjdGVkRXZlbnRcbiAgICovXG4gIGNvbm5lY3Rpb25faWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDb25uZWN0ZWRFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge093blVzZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIENvbm5lY3RlZEV2ZW50XG4gICAqL1xuICBtZTogT3duVXNlclJlc3BvbnNlO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY29ubmVjdGlvbi5va1wiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ29ubmVjdGVkRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gdGhlIFdTIGNvbm5lY3Rpb24gZmFpbHNcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ29ubmVjdGlvbkVycm9yRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uRXJyb3JFdmVudCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ29ubmVjdGlvbkVycm9yRXZlbnRcbiAgICovXG4gIGNvbm5lY3Rpb25faWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBDb25uZWN0aW9uRXJyb3JFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FQSUVycm9yfVxuICAgKiBAbWVtYmVyb2YgQ29ubmVjdGlvbkVycm9yRXZlbnRcbiAgICovXG4gIGVycm9yOiBBUElFcnJvcjtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50OiBcImNvbm5lY3Rpb24ub2tcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENvbm5lY3Rpb25FcnJvckV2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIENvb3JkaW5hdGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29vcmRpbmF0ZXMge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIENvb3JkaW5hdGVzXG4gICAqL1xuICBsYXRpdHVkZTogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIENvb3JkaW5hdGVzXG4gICAqL1xuICBsb25naXR1ZGU6IG51bWJlcjtcbn1cblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDcmVhdGVEZXZpY2VSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlRGV2aWNlUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ3JlYXRlRGV2aWNlUmVxdWVzdFxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ3JlYXRlRGV2aWNlUmVxdWVzdFxuICAgKi9cbiAgcHVzaF9wcm92aWRlcj86IENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENyZWF0ZURldmljZVJlcXVlc3RcbiAgICovXG4gIHB1c2hfcHJvdmlkZXJfbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgQ3JlYXRlRGV2aWNlUmVxdWVzdFxuICAgKi9cbiAgdm9pcF90b2tlbj86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgQ3JlYXRlRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0gPSB7XG4gIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICBBUE46ICdhcG4nLFxuICBIVUFXRUk6ICdodWF3ZWknLFxuICBYSUFPTUk6ICd4aWFvbWknLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID1cbiAgKHR5cGVvZiBDcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSlba2V5b2YgdHlwZW9mIENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtXTtcblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDcmVhdGVHdWVzdFJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVHdWVzdFJlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1VzZXJSZXF1ZXN0fVxuICAgKiBAbWVtYmVyb2YgQ3JlYXRlR3Vlc3RSZXF1ZXN0XG4gICAqL1xuICB1c2VyOiBVc2VyUmVxdWVzdDtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgQ3JlYXRlR3Vlc3RSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUd1ZXN0UmVzcG9uc2Uge1xuICAvKipcbiAgICogdGhlIGFjY2VzcyB0b2tlbiB0byBhdXRoZW50aWNhdGUgdGhlIHVzZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENyZWF0ZUd1ZXN0UmVzcG9uc2VcbiAgICovXG4gIGFjY2Vzc190b2tlbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIENyZWF0ZUd1ZXN0UmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VXNlclJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ3JlYXRlR3Vlc3RSZXNwb25zZVxuICAgKi9cbiAgdXNlcjogVXNlclJlc3BvbnNlO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBDcmVkZW50aWFsc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWRlbnRpYWxzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxJQ0VTZXJ2ZXI+fVxuICAgKiBAbWVtYmVyb2YgQ3JlZGVudGlhbHNcbiAgICovXG4gIGljZV9zZXJ2ZXJzOiBBcnJheTxJQ0VTZXJ2ZXI+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1NGVVJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgQ3JlZGVudGlhbHNcbiAgICovXG4gIHNlcnZlcjogU0ZVUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ3JlZGVudGlhbHNcbiAgICovXG4gIHRva2VuOiBzdHJpbmc7XG59XG5cbi8vIE1hbnVhbGx5IGFkZGVkIGJlY2F1c2UgQVBJIHNwZWMgaXMgZmF1bHR5XG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVZpZGVvRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEN1c3RvbVZpZGVvRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tVmlkZW9FdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgb2JqZWN0XG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IGFueTsgfX1cbiAgICogQG1lbWJlcm9mIEN1c3RvbVZpZGVvRXZlbnRcbiAgICovXG4gIGN1c3RvbTogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50LCBcImN1c3RvbVwiIGluIHRoaXMgY2FzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tVmlkZW9FdmVudFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1VzZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIEN1c3RvbVZpZGVvRXZlbnRcbiAgICovXG4gIHVzZXI6IFVzZXJSZXNwb25zZTtcbn1cblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBEZXZpY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXZpY2Uge1xuICAvKipcbiAgICogRGF0ZS90aW1lIG9mIGNyZWF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBEZXZpY2VcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgZGV2aWNlIGlzIGRpc2FibGVkIG9yIG5vdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIERldmljZVxuICAgKi9cbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogUmVhc29uIGV4cGxhaW5pbmcgd2h5IGRldmljZSBoYWQgYmVlbiBkaXNhYmxlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRGV2aWNlXG4gICAqL1xuICBkaXNhYmxlZF9yZWFzb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRGV2aWNlXG4gICAqL1xuICBpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIERldmljZVxuICAgKi9cbiAgcHVzaF9wcm92aWRlcjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIERldmljZVxuICAgKi9cbiAgcHVzaF9wcm92aWRlcl9uYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hlbiB0cnVlIHRoZSB0b2tlbiBpcyBmb3IgQXBwbGUgVm9JUCBwdXNoIG5vdGlmaWNhdGlvbnNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBEZXZpY2VcbiAgICovXG4gIHZvaXA/OiBib29sZWFuO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBFZGdlUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFZGdlUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEVkZ2VSZXNwb25zZVxuICAgKi9cbiAgY29udGluZW50X2NvZGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBFZGdlUmVzcG9uc2VcbiAgICovXG4gIGNvdW50cnlfaXNvX2NvZGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBFZGdlUmVzcG9uc2VcbiAgICovXG4gIGdyZWVuOiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRWRnZVJlc3BvbnNlXG4gICAqL1xuICBpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEVkZ2VSZXNwb25zZVxuICAgKi9cbiAgbGF0ZW5jeV90ZXN0X3VybDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEVkZ2VSZXNwb25zZVxuICAgKi9cbiAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBFZGdlUmVzcG9uc2VcbiAgICovXG4gIGxvbmdpdHVkZTogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEVkZ2VSZXNwb25zZVxuICAgKi9cbiAgcmVkOiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRWRnZVJlc3BvbnNlXG4gICAqL1xuICBzdWJkaXZpc2lvbl9pc29fY29kZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEVkZ2VSZXNwb25zZVxuICAgKi9cbiAgeWVsbG93OiBudW1iZXI7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEVncmVzc0hMU1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWdyZXNzSExTUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEVncmVzc0hMU1Jlc3BvbnNlXG4gICAqL1xuICBwbGF5bGlzdF91cmw6IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgRWdyZXNzUlRNUFJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWdyZXNzUlRNUFJlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBFZ3Jlc3NSVE1QUmVzcG9uc2VcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBFZ3Jlc3NSVE1QUmVzcG9uc2VcbiAgICovXG4gIHN0cmVhbV9rZXk6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBFZ3Jlc3NSVE1QUmVzcG9uc2VcbiAgICovXG4gIHVybDogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBFZ3Jlc3NSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVncmVzc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgRWdyZXNzUmVzcG9uc2VcbiAgICovXG4gIGJyb2FkY2FzdGluZzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtFZ3Jlc3NITFNSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIEVncmVzc1Jlc3BvbnNlXG4gICAqL1xuICBobHM/OiBFZ3Jlc3NITFNSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxFZ3Jlc3NSVE1QUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgRWdyZXNzUmVzcG9uc2VcbiAgICovXG4gIHJ0bXBzOiBBcnJheTxFZ3Jlc3NSVE1QUmVzcG9uc2U+O1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBFbmRDYWxsUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbmRDYWxsUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEVuZENhbGxSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgR2VvZmVuY2VTZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEdlb2ZlbmNlU2V0dGluZ3Mge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBHZW9mZW5jZVNldHRpbmdzXG4gICAqL1xuICBuYW1lczogQXJyYXk8c3RyaW5nPjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgR2VvZmVuY2VTZXR0aW5nc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZW9mZW5jZVNldHRpbmdzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICogQG1lbWJlcm9mIEdlb2ZlbmNlU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBuYW1lcz86IEFycmF5PHN0cmluZz47XG59XG5cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgR2VvbG9jYXRpb25SZXN1bHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZW9sb2NhdGlvblJlc3VsdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgR2VvbG9jYXRpb25SZXN1bHRcbiAgICovXG4gIGFjY3VyYWN5X3JhZGl1czogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEdlb2xvY2F0aW9uUmVzdWx0XG4gICAqL1xuICBjb250aW5lbnRfY29kZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEdlb2xvY2F0aW9uUmVzdWx0XG4gICAqL1xuICBjb3VudHJ5X2lzb19jb2RlOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgR2VvbG9jYXRpb25SZXN1bHRcbiAgICovXG4gIGxhdGl0dWRlOiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgR2VvbG9jYXRpb25SZXN1bHRcbiAgICovXG4gIGxvbmdpdHVkZTogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEdlb2xvY2F0aW9uUmVzdWx0XG4gICAqL1xuICBzdWJkaXZpc2lvbl9pc29fY29kZTogc3RyaW5nO1xufVxuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEdldENhbGxSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldENhbGxSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFJlc3BvbnNlXG4gICAqL1xuICBjYWxsOiBDYWxsUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFJlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PE1lbWJlclJlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIEdldENhbGxSZXNwb25zZVxuICAgKi9cbiAgbWVtYmVyczogQXJyYXk8TWVtYmVyUmVzcG9uc2U+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge01lbWJlclJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFJlc3BvbnNlXG4gICAqL1xuICBtZW1iZXJzaGlwPzogTWVtYmVyUmVzcG9uc2U7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8T3duQ2FwYWJpbGl0eT59XG4gICAqIEBtZW1iZXJvZiBHZXRDYWxsUmVzcG9uc2VcbiAgICovXG4gIG93bl9jYXBhYmlsaXRpZXM6IEFycmF5PE93bkNhcGFiaWxpdHk+O1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBHZXRDYWxsU3RhdHNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldENhbGxTdGF0c1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBHZXRDYWxsU3RhdHNSZXNwb25zZVxuICAgKi9cbiAgY2FsbF9kdXJhdGlvbl9zZWNvbmRzOiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFRpbWVsaW5lfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFN0YXRzUmVzcG9uc2VcbiAgICovXG4gIGNhbGxfdGltZWxpbmU/OiBDYWxsVGltZWxpbmU7XG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmVxdWVzdCBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEdldENhbGxTdGF0c1Jlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1N0YXRzfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFN0YXRzUmVzcG9uc2VcbiAgICovXG4gIGppdHRlcj86IFN0YXRzO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1N0YXRzfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFN0YXRzUmVzcG9uc2VcbiAgICovXG4gIGxhdGVuY3k/OiBTdGF0cztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBHZXRDYWxsU3RhdHNSZXNwb25zZVxuICAgKi9cbiAgbWF4X2ZyZWV6ZXNfZHVyYXRpb25fc2Vjb25kczogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEdldENhbGxTdGF0c1Jlc3BvbnNlXG4gICAqL1xuICBtYXhfcGFydGljaXBhbnRzOiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFN0YXRzUmVzcG9uc2VcbiAgICovXG4gIG1heF90b3RhbF9xdWFsaXR5X2xpbWl0YXRpb25fZHVyYXRpb25fc2Vjb25kczogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PFVzZXJTdGF0cz59XG4gICAqIEBtZW1iZXJvZiBHZXRDYWxsU3RhdHNSZXNwb25zZVxuICAgKi9cbiAgcGFydGljaXBhbnRfcmVwb3J0OiBBcnJheTxVc2VyU3RhdHM+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEdldENhbGxTdGF0c1Jlc3BvbnNlXG4gICAqL1xuICBwdWJsaXNoaW5nX3BhcnRpY2lwYW50czogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIEdldENhbGxTdGF0c1Jlc3BvbnNlXG4gICAqL1xuICBxdWFsaXR5X3Njb3JlOiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFN0YXRzUmVzcG9uc2VcbiAgICovXG4gIHNmdV9jb3VudDogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PFNGVUxvY2F0aW9uUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgR2V0Q2FsbFN0YXRzUmVzcG9uc2VcbiAgICovXG4gIHNmdXM6IEFycmF5PFNGVUxvY2F0aW9uUmVzcG9uc2U+O1xufVxuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEdldEVkZ2VzUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZXRFZGdlc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgR2V0RWRnZXNSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxFZGdlUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgR2V0RWRnZXNSZXNwb25zZVxuICAgKi9cbiAgZWRnZXM6IEFycmF5PEVkZ2VSZXNwb25zZT47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZXRPckNyZWF0ZUNhbGxSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVxdWVzdH1cbiAgICogQG1lbWJlcm9mIEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3RcbiAgICovXG4gIGRhdGE/OiBDYWxsUmVxdWVzdDtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBHZXRPckNyZWF0ZUNhbGxSZXF1ZXN0XG4gICAqL1xuICBtZW1iZXJzX2xpbWl0PzogbnVtYmVyO1xuICAvKipcbiAgICogaWYgcHJvdmlkZWQgaXQgc2VuZHMgYSBub3RpZmljYXRpb24gZXZlbnQgdG8gdGhlIG1lbWJlcnMgZm9yIHRoaXMgY2FsbFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3RcbiAgICovXG4gIG5vdGlmeT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBpZiBwcm92aWRlZCBpdCBzZW5kcyBhIHJpbmcgZXZlbnQgdG8gdGhlIG1lbWJlcnMgZm9yIHRoaXMgY2FsbFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3RcbiAgICovXG4gIHJpbmc/OiBib29sZWFuO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBHZXRPckNyZWF0ZUNhbGxSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldE9yQ3JlYXRlQ2FsbFJlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBHZXRPckNyZWF0ZUNhbGxSZXNwb25zZVxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBHZXRPckNyZWF0ZUNhbGxSZXNwb25zZVxuICAgKi9cbiAgY3JlYXRlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBHZXRPckNyZWF0ZUNhbGxSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxNZW1iZXJSZXNwb25zZT59XG4gICAqIEBtZW1iZXJvZiBHZXRPckNyZWF0ZUNhbGxSZXNwb25zZVxuICAgKi9cbiAgbWVtYmVyczogQXJyYXk8TWVtYmVyUmVzcG9uc2U+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge01lbWJlclJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgR2V0T3JDcmVhdGVDYWxsUmVzcG9uc2VcbiAgICovXG4gIG1lbWJlcnNoaXA/OiBNZW1iZXJSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxPd25DYXBhYmlsaXR5Pn1cbiAgICogQG1lbWJlcm9mIEdldE9yQ3JlYXRlQ2FsbFJlc3BvbnNlXG4gICAqL1xuICBvd25fY2FwYWJpbGl0aWVzOiBBcnJheTxPd25DYXBhYmlsaXR5Pjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgR29MaXZlUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdvTGl2ZVJlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEdvTGl2ZVJlcXVlc3RcbiAgICovXG4gIHJlY29yZGluZ19zdG9yYWdlX25hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEdvTGl2ZVJlcXVlc3RcbiAgICovXG4gIHN0YXJ0X2hscz86IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEdvTGl2ZVJlcXVlc3RcbiAgICovXG4gIHN0YXJ0X3JlY29yZGluZz86IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEdvTGl2ZVJlcXVlc3RcbiAgICovXG4gIHN0YXJ0X3RyYW5zY3JpcHRpb24/OiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEdvTGl2ZVJlcXVlc3RcbiAgICovXG4gIHRyYW5zY3JpcHRpb25fc3RvcmFnZV9uYW1lPzogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBHb0xpdmVSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdvTGl2ZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBHb0xpdmVSZXNwb25zZVxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIHJlcXVlc3QgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBHb0xpdmVSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cblxuLy8gTWFudWFsbHkgYWRkZWQgYmVjYXVzZSBBUEkgc3BlYyBpcyBmYXVsdHlcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgSGVhbHRoQ2hlY2tFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbm5lY3Rpb25faWQgZm9yIHRoaXMgY2xpZW50XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBIZWFsdGhDaGVja0V2ZW50XG4gICAqL1xuICBjb25uZWN0aW9uX2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgSGVhbHRoQ2hlY2tFdmVudFxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiaGVhbHRoLmNoZWNrXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBIZWFsdGhDaGVja0V2ZW50XG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgSExTU2V0dGluZ3NSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSExTU2V0dGluZ3NSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgSExTU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBhdXRvX29uPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgSExTU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKiBAbWVtYmVyb2YgSExTU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBxdWFsaXR5X3RyYWNrcz86IEFycmF5PHN0cmluZz47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIEhMU1NldHRpbmdzUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBITFNTZXR0aW5nc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgSExTU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgYXV0b19vbjogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgSExTU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgZW5hYmxlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKiBAbWVtYmVyb2YgSExTU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgcXVhbGl0eV90cmFja3M6IEFycmF5PHN0cmluZz47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIElDRVNlcnZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDRVNlcnZlciB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgSUNFU2VydmVyXG4gICAqL1xuICBwYXNzd29yZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBJQ0VTZXJ2ZXJcbiAgICovXG4gIHVybHM6IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgSUNFU2VydmVyXG4gICAqL1xuICB1c2VybmFtZTogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBKb2luQ2FsbFJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBKb2luQ2FsbFJlcXVlc3Qge1xuICAvKipcbiAgICogaWYgdHJ1ZSB0aGUgY2FsbCB3aWxsIGJlIGNyZWF0ZWQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVxdWVzdFxuICAgKi9cbiAgY3JlYXRlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsUmVxdWVzdH1cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVxdWVzdFxuICAgKi9cbiAgZGF0YT86IENhbGxSZXF1ZXN0O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVxdWVzdFxuICAgKi9cbiAgbG9jYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBKb2luQ2FsbFJlcXVlc3RcbiAgICovXG4gIG1lbWJlcnNfbGltaXQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJZiB0aGUgcGFydGljaXBhbnQgaXMgbWlncmF0aW5nIGZyb20gYW5vdGhlciBTRlUsIHRoZW4gdGhpcyBpcyB0aGUgSUQgb2YgdGhlIHByZXZpb3VzIFNGVVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgSm9pbkNhbGxSZXF1ZXN0XG4gICAqL1xuICBtaWdyYXRpbmdfZnJvbT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgSm9pbkNhbGxSZXF1ZXN0XG4gICAqL1xuICBub3RpZnk/OiBib29sZWFuO1xuICAvKipcbiAgICogaWYgdHJ1ZSBhbmQgdGhlIGNhbGwgaXMgY3JlYXRlZCwgdGhlIG5vdGlmaWNhdGlvbiB3aWxsIGluY2x1ZGUgcmluZz10cnVlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgSm9pbkNhbGxSZXF1ZXN0XG4gICAqL1xuICByaW5nPzogYm9vbGVhbjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgSm9pbkNhbGxSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEpvaW5DYWxsUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVzcG9uc2VcbiAgICovXG4gIGNhbGw6IENhbGxSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgSm9pbkNhbGxSZXNwb25zZVxuICAgKi9cbiAgY3JlYXRlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDcmVkZW50aWFsc31cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVzcG9uc2VcbiAgICovXG4gIGNyZWRlbnRpYWxzOiBDcmVkZW50aWFscztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBKb2luQ2FsbFJlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PE1lbWJlclJlc3BvbnNlPn1cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVzcG9uc2VcbiAgICovXG4gIG1lbWJlcnM6IEFycmF5PE1lbWJlclJlc3BvbnNlPjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtNZW1iZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVzcG9uc2VcbiAgICovXG4gIG1lbWJlcnNoaXA/OiBNZW1iZXJSZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxPd25DYXBhYmlsaXR5Pn1cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVzcG9uc2VcbiAgICovXG4gIG93bl9jYXBhYmlsaXRpZXM6IEFycmF5PE93bkNhcGFiaWxpdHk+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1N0YXRzT3B0aW9uc31cbiAgICogQG1lbWJlcm9mIEpvaW5DYWxsUmVzcG9uc2VcbiAgICovXG4gIHN0YXRzX29wdGlvbnM6IFN0YXRzT3B0aW9ucztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgTGlzdERldmljZXNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExpc3REZXZpY2VzUmVzcG9uc2Uge1xuICAvKipcbiAgICogTGlzdCBvZiBkZXZpY2VzXG4gICAqIEB0eXBlIHtBcnJheTxEZXZpY2U+fVxuICAgKiBAbWVtYmVyb2YgTGlzdERldmljZXNSZXNwb25zZVxuICAgKi9cbiAgZGV2aWNlczogQXJyYXk8RGV2aWNlPjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBMaXN0RGV2aWNlc1Jlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBMaXN0UmVjb3JkaW5nc1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFJlY29yZGluZ3NSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgTGlzdFJlY29yZGluZ3NSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxDYWxsUmVjb3JkaW5nPn1cbiAgICogQG1lbWJlcm9mIExpc3RSZWNvcmRpbmdzUmVzcG9uc2VcbiAgICovXG4gIHJlY29yZGluZ3M6IEFycmF5PENhbGxSZWNvcmRpbmc+O1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBMaXN0VHJhbnNjcmlwdGlvbnNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExpc3RUcmFuc2NyaXB0aW9uc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBMaXN0VHJhbnNjcmlwdGlvbnNSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxDYWxsVHJhbnNjcmlwdGlvbj59XG4gICAqIEBtZW1iZXJvZiBMaXN0VHJhbnNjcmlwdGlvbnNSZXNwb25zZVxuICAgKi9cbiAgdHJhbnNjcmlwdGlvbnM6IEFycmF5PENhbGxUcmFuc2NyaXB0aW9uPjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgTG9jYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2NhdGlvbiB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgTG9jYXRpb25cbiAgICovXG4gIGNvbnRpbmVudF9jb2RlOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgTG9jYXRpb25cbiAgICovXG4gIGNvdW50cnlfaXNvX2NvZGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBMb2NhdGlvblxuICAgKi9cbiAgc3ViZGl2aXNpb25faXNvX2NvZGU6IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgTWVtYmVyUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lbWJlclJlcXVlc3Qge1xuICAvKipcbiAgICogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgb2JqZWN0XG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IGFueTsgfX1cbiAgICogQG1lbWJlcm9mIE1lbWJlclJlcXVlc3RcbiAgICovXG4gIGN1c3RvbT86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgTWVtYmVyUmVxdWVzdFxuICAgKi9cbiAgcm9sZT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBNZW1iZXJSZXF1ZXN0XG4gICAqL1xuICB1c2VyX2lkOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIE1lbWJlclJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVtYmVyUmVzcG9uc2Uge1xuICAvKipcbiAgICogRGF0ZS90aW1lIG9mIGNyZWF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBNZW1iZXJSZXNwb25zZVxuICAgKi9cbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAvKipcbiAgICogQ3VzdG9tIG1lbWJlciByZXNwb25zZSBkYXRhXG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IGFueTsgfX1cbiAgICogQG1lbWJlcm9mIE1lbWJlclJlc3BvbnNlXG4gICAqL1xuICBjdXN0b206IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIC8qKlxuICAgKiBEYXRlL3RpbWUgb2YgZGVsZXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIE1lbWJlclJlc3BvbnNlXG4gICAqL1xuICBkZWxldGVkX2F0Pzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIE1lbWJlclJlc3BvbnNlXG4gICAqL1xuICByb2xlPzogc3RyaW5nO1xuICAvKipcbiAgICogRGF0ZS90aW1lIG9mIHRoZSBsYXN0IHVwZGF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgTWVtYmVyUmVzcG9uc2VcbiAgICovXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtVc2VyUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBNZW1iZXJSZXNwb25zZVxuICAgKi9cbiAgdXNlcjogVXNlclJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIE1lbWJlclJlc3BvbnNlXG4gICAqL1xuICB1c2VyX2lkOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIE11dGVVc2Vyc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNdXRlVXNlcnNSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgTXV0ZVVzZXJzUmVxdWVzdFxuICAgKi9cbiAgYXVkaW8/OiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBNdXRlVXNlcnNSZXF1ZXN0XG4gICAqL1xuICBtdXRlX2FsbF91c2Vycz86IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIE11dGVVc2Vyc1JlcXVlc3RcbiAgICovXG4gIHNjcmVlbnNoYXJlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgTXV0ZVVzZXJzUmVxdWVzdFxuICAgKi9cbiAgc2NyZWVuc2hhcmVfYXVkaW8/OiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBNdXRlVXNlcnNSZXF1ZXN0XG4gICAqL1xuICB1c2VyX2lkcz86IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIE11dGVVc2Vyc1JlcXVlc3RcbiAgICovXG4gIHZpZGVvPzogYm9vbGVhbjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgTXV0ZVVzZXJzUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNdXRlVXNlcnNSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmVxdWVzdCBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIE11dGVVc2Vyc1Jlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFsbCBwb3NzaWJpbGl0eSBvZiBzdHJpbmcgdG8gdXNlXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBPd25DYXBhYmlsaXR5ID0ge1xuICBCTE9DS19VU0VSUzogJ2Jsb2NrLXVzZXJzJyxcbiAgQ1JFQVRFX0NBTEw6ICdjcmVhdGUtY2FsbCcsXG4gIENSRUFURV9SRUFDVElPTjogJ2NyZWF0ZS1yZWFjdGlvbicsXG4gIEVORF9DQUxMOiAnZW5kLWNhbGwnLFxuICBKT0lOX0JBQ0tTVEFHRTogJ2pvaW4tYmFja3N0YWdlJyxcbiAgSk9JTl9DQUxMOiAnam9pbi1jYWxsJyxcbiAgSk9JTl9FTkRFRF9DQUxMOiAnam9pbi1lbmRlZC1jYWxsJyxcbiAgTVVURV9VU0VSUzogJ211dGUtdXNlcnMnLFxuICBQSU5fRk9SX0VWRVJZT05FOiAncGluLWZvci1ldmVyeW9uZScsXG4gIFJFQURfQ0FMTDogJ3JlYWQtY2FsbCcsXG4gIFJFTU9WRV9DQUxMX01FTUJFUjogJ3JlbW92ZS1jYWxsLW1lbWJlcicsXG4gIFNDUkVFTlNIQVJFOiAnc2NyZWVuc2hhcmUnLFxuICBTRU5EX0FVRElPOiAnc2VuZC1hdWRpbycsXG4gIFNFTkRfVklERU86ICdzZW5kLXZpZGVvJyxcbiAgU1RBUlRfQlJPQURDQVNUX0NBTEw6ICdzdGFydC1icm9hZGNhc3QtY2FsbCcsXG4gIFNUQVJUX1JFQ09SRF9DQUxMOiAnc3RhcnQtcmVjb3JkLWNhbGwnLFxuICBTVEFSVF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdGFydC10cmFuc2NyaXB0aW9uLWNhbGwnLFxuICBTVE9QX0JST0FEQ0FTVF9DQUxMOiAnc3RvcC1icm9hZGNhc3QtY2FsbCcsXG4gIFNUT1BfUkVDT1JEX0NBTEw6ICdzdG9wLXJlY29yZC1jYWxsJyxcbiAgU1RPUF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdG9wLXRyYW5zY3JpcHRpb24tY2FsbCcsXG4gIFVQREFURV9DQUxMOiAndXBkYXRlLWNhbGwnLFxuICBVUERBVEVfQ0FMTF9NRU1CRVI6ICd1cGRhdGUtY2FsbC1tZW1iZXInLFxuICBVUERBVEVfQ0FMTF9QRVJNSVNTSU9OUzogJ3VwZGF0ZS1jYWxsLXBlcm1pc3Npb25zJyxcbiAgVVBEQVRFX0NBTExfU0VUVElOR1M6ICd1cGRhdGUtY2FsbC1zZXR0aW5ncycsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgT3duQ2FwYWJpbGl0eSA9ICh0eXBlb2YgT3duQ2FwYWJpbGl0eSlba2V5b2YgdHlwZW9mIE93bkNhcGFiaWxpdHldO1xuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIE93blVzZXJSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE93blVzZXJSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgT3duVXNlclJlc3BvbnNlXG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBhbnk7IH19XG4gICAqIEBtZW1iZXJvZiBPd25Vc2VyUmVzcG9uc2VcbiAgICovXG4gIGN1c3RvbTogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBPd25Vc2VyUmVzcG9uc2VcbiAgICovXG4gIGRlbGV0ZWRfYXQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8RGV2aWNlPn1cbiAgICogQG1lbWJlcm9mIE93blVzZXJSZXNwb25zZVxuICAgKi9cbiAgZGV2aWNlczogQXJyYXk8RGV2aWNlPjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBPd25Vc2VyUmVzcG9uc2VcbiAgICovXG4gIGlkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgT3duVXNlclJlc3BvbnNlXG4gICAqL1xuICBpbWFnZT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBPd25Vc2VyUmVzcG9uc2VcbiAgICovXG4gIGxhbmd1YWdlOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgT3duVXNlclJlc3BvbnNlXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIE93blVzZXJSZXNwb25zZVxuICAgKi9cbiAgcm9sZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBPd25Vc2VyUmVzcG9uc2VcbiAgICovXG4gIHRlYW1zOiBBcnJheTxzdHJpbmc+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIE93blVzZXJSZXNwb25zZVxuICAgKi9cbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xufVxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHNlbnQgd2hlbiBhIHVzZXIgcmVxdWVzdHMgYWNjZXNzIHRvIGEgZmVhdHVyZSBvbiBhIGNhbGwsXG4gKiBjbGllbnRzIHJlY2VpdmluZyB0aGlzIGV2ZW50IHNob3VsZCBkaXNwbGF5IGEgcGVybWlzc2lvbiByZXF1ZXN0IHRvIHRoZSB1c2VyXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFBlcm1pc3Npb25SZXF1ZXN0RXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQZXJtaXNzaW9uUmVxdWVzdEV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBQZXJtaXNzaW9uUmVxdWVzdEV2ZW50XG4gICAqL1xuICBjYWxsX2NpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFBlcm1pc3Npb25SZXF1ZXN0RXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHBlcm1pc3Npb25zIHJlcXVlc3RlZCBieSB0aGUgdXNlclxuICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICogQG1lbWJlcm9mIFBlcm1pc3Npb25SZXF1ZXN0RXZlbnRcbiAgICovXG4gIHBlcm1pc3Npb25zOiBBcnJheTxzdHJpbmc+O1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5wZXJtaXNzaW9uX3JlcXVlc3RcIiBpbiB0aGlzIGNhc2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFBlcm1pc3Npb25SZXF1ZXN0RXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtVc2VyUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBQZXJtaXNzaW9uUmVxdWVzdEV2ZW50XG4gICAqL1xuICB1c2VyOiBVc2VyUmVzcG9uc2U7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFBpblJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQaW5SZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBQaW5SZXF1ZXN0XG4gICAqL1xuICBzZXNzaW9uX2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUGluUmVxdWVzdFxuICAgKi9cbiAgdXNlcl9pZDogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBQaW5SZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBpblJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUGluUmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFF1ZXJ5Q2FsbFN0YXRzUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5Q2FsbFN0YXRzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBhbnk7IH19XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxTdGF0c1JlcXVlc3RcbiAgICovXG4gIGZpbHRlcl9jb25kaXRpb25zPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxTdGF0c1JlcXVlc3RcbiAgICovXG4gIGxpbWl0PzogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFF1ZXJ5Q2FsbFN0YXRzUmVxdWVzdFxuICAgKi9cbiAgbmV4dD86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxTdGF0c1JlcXVlc3RcbiAgICovXG4gIHByZXY/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8U29ydFBhcmFtUmVxdWVzdD59XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxTdGF0c1JlcXVlc3RcbiAgICovXG4gIHNvcnQ/OiBBcnJheTxTb3J0UGFyYW1SZXF1ZXN0Pjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgUXVlcnlDYWxsU3RhdHNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5Q2FsbFN0YXRzUmVzcG9uc2Uge1xuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIHJlcXVlc3QgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxTdGF0c1Jlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFF1ZXJ5Q2FsbFN0YXRzUmVzcG9uc2VcbiAgICovXG4gIG5leHQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUXVlcnlDYWxsU3RhdHNSZXNwb25zZVxuICAgKi9cbiAgcHJldj86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxDYWxsU3RhdHNSZXBvcnRTdW1tYXJ5UmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgUXVlcnlDYWxsU3RhdHNSZXNwb25zZVxuICAgKi9cbiAgcmVwb3J0czogQXJyYXk8Q2FsbFN0YXRzUmVwb3J0U3VtbWFyeVJlc3BvbnNlPjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgUXVlcnlDYWxsc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeUNhbGxzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBhbnk7IH19XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxzUmVxdWVzdFxuICAgKi9cbiAgZmlsdGVyX2NvbmRpdGlvbnM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFF1ZXJ5Q2FsbHNSZXF1ZXN0XG4gICAqL1xuICBsaW1pdD86IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxzUmVxdWVzdFxuICAgKi9cbiAgbmV4dD86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxzUmVxdWVzdFxuICAgKi9cbiAgcHJldj86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxTb3J0UGFyYW1SZXF1ZXN0Pn1cbiAgICogQG1lbWJlcm9mIFF1ZXJ5Q2FsbHNSZXF1ZXN0XG4gICAqL1xuICBzb3J0PzogQXJyYXk8U29ydFBhcmFtUmVxdWVzdD47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIFF1ZXJ5Q2FsbHNSZXF1ZXN0XG4gICAqL1xuICB3YXRjaD86IGJvb2xlYW47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFF1ZXJ5Q2FsbHNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5Q2FsbHNSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8Q2FsbFN0YXRlUmVzcG9uc2VGaWVsZHM+fVxuICAgKiBAbWVtYmVyb2YgUXVlcnlDYWxsc1Jlc3BvbnNlXG4gICAqL1xuICBjYWxsczogQXJyYXk8Q2FsbFN0YXRlUmVzcG9uc2VGaWVsZHM+O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFF1ZXJ5Q2FsbHNSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeUNhbGxzUmVzcG9uc2VcbiAgICovXG4gIG5leHQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUXVlcnlDYWxsc1Jlc3BvbnNlXG4gICAqL1xuICBwcmV2Pzogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBRdWVyeU1lbWJlcnNSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlNZW1iZXJzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBhbnk7IH19XG4gICAqIEBtZW1iZXJvZiBRdWVyeU1lbWJlcnNSZXF1ZXN0XG4gICAqL1xuICBmaWx0ZXJfY29uZGl0aW9ucz86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUXVlcnlNZW1iZXJzUmVxdWVzdFxuICAgKi9cbiAgaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBRdWVyeU1lbWJlcnNSZXF1ZXN0XG4gICAqL1xuICBsaW1pdD86IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeU1lbWJlcnNSZXF1ZXN0XG4gICAqL1xuICBuZXh0Pzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFF1ZXJ5TWVtYmVyc1JlcXVlc3RcbiAgICovXG4gIHByZXY/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8U29ydFBhcmFtUmVxdWVzdD59XG4gICAqIEBtZW1iZXJvZiBRdWVyeU1lbWJlcnNSZXF1ZXN0XG4gICAqL1xuICBzb3J0PzogQXJyYXk8U29ydFBhcmFtUmVxdWVzdD47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUXVlcnlNZW1iZXJzUmVxdWVzdFxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBRdWVyeU1lbWJlcnNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5TWVtYmVyc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUXVlcnlNZW1iZXJzUmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8TWVtYmVyUmVzcG9uc2U+fVxuICAgKiBAbWVtYmVyb2YgUXVlcnlNZW1iZXJzUmVzcG9uc2VcbiAgICovXG4gIG1lbWJlcnM6IEFycmF5PE1lbWJlclJlc3BvbnNlPjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeU1lbWJlcnNSZXNwb25zZVxuICAgKi9cbiAgbmV4dD86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBRdWVyeU1lbWJlcnNSZXNwb25zZVxuICAgKi9cbiAgcHJldj86IHN0cmluZztcbn1cbi8qKlxuICogUlRNUCBpbnB1dCBzZXR0aW5nc1xuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBSVE1QSW5ncmVzc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJUTVBJbmdyZXNzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBSVE1QSW5ncmVzc1xuICAgKi9cbiAgYWRkcmVzczogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBSZWFjdGlvblJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhY3Rpb25SZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBhbnk7IH19XG4gICAqIEBtZW1iZXJvZiBSZWFjdGlvblJlc3BvbnNlXG4gICAqL1xuICBjdXN0b20/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFJlYWN0aW9uUmVzcG9uc2VcbiAgICovXG4gIGVtb2ppX2NvZGU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUmVhY3Rpb25SZXNwb25zZVxuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1VzZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIFJlYWN0aW9uUmVzcG9uc2VcbiAgICovXG4gIHVzZXI6IFVzZXJSZXNwb25zZTtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBhdWRpb19vbmx5PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBSZWNvcmRTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIG1vZGU6IFJlY29yZFNldHRpbmdzUmVxdWVzdE1vZGVFbnVtO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFJlY29yZFNldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgcXVhbGl0eT86IFJlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtO1xufVxuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJlY29yZFNldHRpbmdzUmVxdWVzdE1vZGVFbnVtID0ge1xuICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgQVVUT19PTjogJ2F1dG8tb24nLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFJlY29yZFNldHRpbmdzUmVxdWVzdE1vZGVFbnVtID1cbiAgKHR5cGVvZiBSZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSlba2V5b2YgdHlwZW9mIFJlY29yZFNldHRpbmdzUmVxdWVzdE1vZGVFbnVtXTtcblxuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBSZWNvcmRTZXR0aW5nc1JlcXVlc3RRdWFsaXR5RW51bSA9IHtcbiAgXzM2MFA6ICczNjBwJyxcbiAgXzQ4MFA6ICc0ODBwJyxcbiAgXzcyMFA6ICc3MjBwJyxcbiAgXzEwODBQOiAnMTA4MHAnLFxuICBfMTQ0MFA6ICcxNDQwcCcsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW0gPVxuICAodHlwZW9mIFJlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtKVtrZXlvZiB0eXBlb2YgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW1dO1xuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFJlY29yZFNldHRpbmdzUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWNvcmRTZXR0aW5nc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUmVjb3JkU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgYXVkaW9fb25seTogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBSZWNvcmRTZXR0aW5nc1Jlc3BvbnNlXG4gICAqL1xuICBtb2RlOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUmVjb3JkU2V0dGluZ3NSZXNwb25zZVxuICAgKi9cbiAgcXVhbGl0eTogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBSZWplY3RDYWxsUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWplY3RDYWxsUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFJlamVjdENhbGxSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgUmVxdWVzdFBlcm1pc3Npb25SZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdFBlcm1pc3Npb25SZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKiBAbWVtYmVyb2YgUmVxdWVzdFBlcm1pc3Npb25SZXF1ZXN0XG4gICAqL1xuICBwZXJtaXNzaW9uczogQXJyYXk8c3RyaW5nPjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgUmVxdWVzdFBlcm1pc3Npb25SZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RQZXJtaXNzaW9uUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFJlcXVlc3RQZXJtaXNzaW9uUmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2Uge1xuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIHJlcXVlc3QgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgUmluZ1NldHRpbmdzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmluZ1NldHRpbmdzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBSaW5nU2V0dGluZ3NcbiAgICovXG4gIGF1dG9fY2FuY2VsX3RpbWVvdXRfbXM6IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBSaW5nU2V0dGluZ3NcbiAgICovXG4gIGluY29taW5nX2NhbGxfdGltZW91dF9tczogbnVtYmVyO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBSaW5nU2V0dGluZ3NSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmluZ1NldHRpbmdzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgUmluZ1NldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgYXV0b19jYW5jZWxfdGltZW91dF9tcz86IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBSaW5nU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBpbmNvbWluZ19jYWxsX3RpbWVvdXRfbXM/OiBudW1iZXI7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFNGVUxvY2F0aW9uUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTRlVMb2NhdGlvblJlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDb29yZGluYXRlc31cbiAgICogQG1lbWJlcm9mIFNGVUxvY2F0aW9uUmVzcG9uc2VcbiAgICovXG4gIGNvb3JkaW5hdGVzOiBDb29yZGluYXRlcztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTRlVMb2NhdGlvblJlc3BvbnNlXG4gICAqL1xuICBkYXRhY2VudGVyOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU0ZVTG9jYXRpb25SZXNwb25zZVxuICAgKi9cbiAgaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtMb2NhdGlvbn1cbiAgICogQG1lbWJlcm9mIFNGVUxvY2F0aW9uUmVzcG9uc2VcbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgU0ZVUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTRlVSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU0ZVUmVzcG9uc2VcbiAgICovXG4gIGVkZ2VfbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFNGVVJlc3BvbnNlXG4gICAqL1xuICB1cmw6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTRlVSZXNwb25zZVxuICAgKi9cbiAgd3NfZW5kcG9pbnQ6IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgU2NyZWVuc2hhcmluZ1NldHRpbmdzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2NyZWVuc2hhcmluZ1NldHRpbmdzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgU2NyZWVuc2hhcmluZ1NldHRpbmdzXG4gICAqL1xuICBhY2Nlc3NfcmVxdWVzdF9lbmFibGVkOiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBTY3JlZW5zaGFyaW5nU2V0dGluZ3NcbiAgICovXG4gIGVuYWJsZWQ6IGJvb2xlYW47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFNjcmVlbnNoYXJpbmdTZXR0aW5nc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTY3JlZW5zaGFyaW5nU2V0dGluZ3NSZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgU2NyZWVuc2hhcmluZ1NldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgYWNjZXNzX3JlcXVlc3RfZW5hYmxlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIFNjcmVlbnNoYXJpbmdTZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGVuYWJsZWQ/OiBib29sZWFuO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBTZW5kRXZlbnRSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZEV2ZW50UmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBhbnk7IH19XG4gICAqIEBtZW1iZXJvZiBTZW5kRXZlbnRSZXF1ZXN0XG4gICAqL1xuICBjdXN0b20/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBTZW5kRXZlbnRSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlbmRFdmVudFJlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTZW5kRXZlbnRSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgU2VuZFJlYWN0aW9uUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlbmRSZWFjdGlvblJlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3sgW2tleTogc3RyaW5nXTogYW55OyB9fVxuICAgKiBAbWVtYmVyb2YgU2VuZFJlYWN0aW9uUmVxdWVzdFxuICAgKi9cbiAgY3VzdG9tPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTZW5kUmVhY3Rpb25SZXF1ZXN0XG4gICAqL1xuICBlbW9qaV9jb2RlPzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFNlbmRSZWFjdGlvblJlcXVlc3RcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgU2VuZFJlYWN0aW9uUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZW5kUmVhY3Rpb25SZXNwb25zZSB7XG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmVxdWVzdCBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFNlbmRSZWFjdGlvblJlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1JlYWN0aW9uUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBTZW5kUmVhY3Rpb25SZXNwb25zZVxuICAgKi9cbiAgcmVhY3Rpb246IFJlYWN0aW9uUmVzcG9uc2U7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFNvcnRQYXJhbVJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTb3J0UGFyYW1SZXF1ZXN0IHtcbiAgLyoqXG4gICAqIERpcmVjdGlvbiBvZiBzb3J0aW5nLCAtMSBmb3IgZGVzY2VuZGluZywgMSBmb3IgYXNjZW5kaW5nXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBTb3J0UGFyYW1SZXF1ZXN0XG4gICAqL1xuICBkaXJlY3Rpb24/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBOYW1lIG9mIGZpZWxkIHRvIHNvcnQgYnlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFNvcnRQYXJhbVJlcXVlc3RcbiAgICovXG4gIGZpZWxkPzogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBTdGFydEhMU0Jyb2FkY2FzdGluZ1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRITFNCcm9hZGNhc3RpbmdSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmVxdWVzdCBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFN0YXJ0SExTQnJvYWRjYXN0aW5nUmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU3RhcnRITFNCcm9hZGNhc3RpbmdSZXNwb25zZVxuICAgKi9cbiAgcGxheWxpc3RfdXJsOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFN0YXJ0UmVjb3JkaW5nUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0UmVjb3JkaW5nUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU3RhcnRSZWNvcmRpbmdSZXF1ZXN0XG4gICAqL1xuICByZWNvcmRpbmdfZXh0ZXJuYWxfc3RvcmFnZT86IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgU3RhcnRSZWNvcmRpbmdSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0UmVjb3JkaW5nUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFN0YXJ0UmVjb3JkaW5nUmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFN0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0XG4gICAqL1xuICB0cmFuc2NyaXB0aW9uX2V4dGVybmFsX3N0b3JhZ2U/OiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFN0YXJ0VHJhbnNjcmlwdGlvblJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRUcmFuc2NyaXB0aW9uUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFN0YXJ0VHJhbnNjcmlwdGlvblJlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBTdGF0c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBTdGF0c1xuICAgKi9cbiAgYXZlcmFnZV9zZWNvbmRzOiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgU3RhdHNcbiAgICovXG4gIG1heF9zZWNvbmRzOiBudW1iZXI7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFN0YXRzT3B0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRzT3B0aW9ucyB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgU3RhdHNPcHRpb25zXG4gICAqL1xuICByZXBvcnRpbmdfaW50ZXJ2YWxfbXM6IG51bWJlcjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgU3RvcEhMU0Jyb2FkY2FzdGluZ1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcEhMU0Jyb2FkY2FzdGluZ1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU3RvcEhMU0Jyb2FkY2FzdGluZ1Jlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBTdG9wTGl2ZVJlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcExpdmVSZXNwb25zZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Q2FsbFJlc3BvbnNlfVxuICAgKiBAbWVtYmVyb2YgU3RvcExpdmVSZXNwb25zZVxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIHJlcXVlc3QgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTdG9wTGl2ZVJlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBTdG9wUmVjb3JkaW5nUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdG9wUmVjb3JkaW5nUmVzcG9uc2Uge1xuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIHJlcXVlc3QgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTdG9wUmVjb3JkaW5nUmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFN0b3BUcmFuc2NyaXB0aW9uUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdG9wVHJhbnNjcmlwdGlvblJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU3RvcFRyYW5zY3JpcHRpb25SZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBTdWJzZXNzaW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2Vzc2lvbiB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgU3Vic2Vzc2lvblxuICAgKi9cbiAgZW5kZWRfYXQ6IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBTdWJzZXNzaW9uXG4gICAqL1xuICBqb2luZWRfYXQ6IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTdWJzZXNzaW9uXG4gICAqL1xuICBzZnVfaWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBUYXJnZXRSZXNvbHV0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFyZ2V0UmVzb2x1dGlvbiB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgVGFyZ2V0UmVzb2x1dGlvblxuICAgKi9cbiAgYml0cmF0ZTogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFRhcmdldFJlc29sdXRpb25cbiAgICovXG4gIGhlaWdodDogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFRhcmdldFJlc29sdXRpb25cbiAgICovXG4gIHdpZHRoOiBudW1iZXI7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFRhcmdldFJlc29sdXRpb25SZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFyZ2V0UmVzb2x1dGlvblJlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFRhcmdldFJlc29sdXRpb25SZXF1ZXN0XG4gICAqL1xuICBiaXRyYXRlPzogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFRhcmdldFJlc29sdXRpb25SZXF1ZXN0XG4gICAqL1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgVGFyZ2V0UmVzb2x1dGlvblJlcXVlc3RcbiAgICovXG4gIHdpZHRoPzogbnVtYmVyO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBUaHVtYm5haWxSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRodW1ibmFpbFJlc3BvbnNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBUaHVtYm5haWxSZXNwb25zZVxuICAgKi9cbiAgaW1hZ2VfdXJsOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFRodW1ibmFpbHNTZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFRodW1ibmFpbHNTZXR0aW5ncyB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIFRodW1ibmFpbHNTZXR0aW5nc1xuICAgKi9cbiAgZW5hYmxlZDogYm9vbGVhbjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVGh1bWJuYWlsc1NldHRpbmdzUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRodW1ibmFpbHNTZXR0aW5nc1JlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBUaHVtYm5haWxzU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBlbmFibGVkPzogYm9vbGVhbjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvblNldHRpbmdzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvblNldHRpbmdzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBUcmFuc2NyaXB0aW9uU2V0dGluZ3NcbiAgICovXG4gIGNsb3NlZF9jYXB0aW9uX21vZGU6IHN0cmluZztcbiAgLyoqXG4gICAqIG9taXRlbXB0eSxtYXg9MixkaXZlLG9uZW9mPSBlbiwgZnIsIGVzLCBkZSwgaXQsIG5sLCBwdCwgcGwsIGNhLCBjcywgZGEsIGVsLCBmaSwgaWQsIGphLCBydSwgc3YsIHRhLCB0aCwgdHIsIGh1LCBybywgemgsIGFyLCB0bCwgaGUsIGhpLCBociwga28sIG1zLCBubywgdWtcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBUcmFuc2NyaXB0aW9uU2V0dGluZ3NcbiAgICovXG4gIGxhbmd1YWdlczogQXJyYXk8c3RyaW5nPjtcbiAgLyoqXG4gICAqIG9uZW9mPWF2YWlsYWJsZSBkaXNhYmxlZCBhdXRvLW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBUcmFuc2NyaXB0aW9uU2V0dGluZ3NcbiAgICovXG4gIG1vZGU6IFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtO1xufVxuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID0ge1xuICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgQVVUT19PTjogJ2F1dG8tb24nLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID1cbiAgKHR5cGVvZiBUcmFuc2NyaXB0aW9uU2V0dGluZ3NNb2RlRW51bSlba2V5b2YgdHlwZW9mIFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtXTtcblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgY2xvc2VkX2NhcHRpb25fbW9kZT86IHN0cmluZztcbiAgLyoqXG4gICAqIG9taXRlbXB0eSxtYXg9MixkaXZlLG9uZW9mPSBlbiwgZnIsIGVzLCBkZSwgaXQsIG5sLCBwdCwgcGwsIGNhLCBjcywgZGEsIGVsLCBmaSwgaWQsIGphLCBydSwgc3YsIHRhLCB0aCwgdHIsIGh1LCBybywgemgsIGFyLCB0bCwgaGUsIGhpLCBociwga28sIG1zLCBubywgdWtcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBsYW5ndWFnZXM/OiBBcnJheTxzdHJpbmc+O1xuICAvKipcbiAgICogb25lb2Y9YXZhaWxhYmxlIGRpc2FibGVkIGF1dG8tb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFRyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIG1vZGU/OiBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW07XG59XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtID0ge1xuICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgQVVUT19PTjogJ2F1dG8tb24nLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFRyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9XG4gICh0eXBlb2YgVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtKVtrZXlvZiB0eXBlb2YgVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtXTtcblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBVbmJsb2NrVXNlclJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVbmJsb2NrVXNlclJlcXVlc3Qge1xuICAvKipcbiAgICogdGhlIHVzZXIgdG8gdW5ibG9ja1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVW5ibG9ja1VzZXJSZXF1ZXN0XG4gICAqL1xuICB1c2VyX2lkOiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFVuYmxvY2tVc2VyUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVbmJsb2NrVXNlclJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVW5ibG9ja1VzZXJSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbn1cbi8qKlxuICogVGhpcyBldmVudCBpcyBzZW50IHdoZW4gYSB1c2VyIGlzIHVuYmxvY2tlZCBvbiBhIGNhbGwsXG4gKiB0aGlzIGNhbiBiZSB1c2VmdWwgdG8gbm90aWZ5IHRoZSB1c2VyIHRoYXQgdGhleSBjYW4gbm93IGpvaW4gdGhlIGNhbGwgYWdhaW5cbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVW5ibG9ja2VkVXNlckV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5ibG9ja2VkVXNlckV2ZW50IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVbmJsb2NrZWRVc2VyRXZlbnRcbiAgICovXG4gIGNhbGxfY2lkOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVW5ibG9ja2VkVXNlckV2ZW50XG4gICAqL1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudDogXCJjYWxsLnVuYmxvY2tlZF91c2VyXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVbmJsb2NrZWRVc2VyRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtVc2VyUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBVbmJsb2NrZWRVc2VyRXZlbnRcbiAgICovXG4gIHVzZXI6IFVzZXJSZXNwb25zZTtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVW5waW5SZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5waW5SZXF1ZXN0IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVbnBpblJlcXVlc3RcbiAgICovXG4gIHNlc3Npb25faWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVbnBpblJlcXVlc3RcbiAgICovXG4gIHVzZXJfaWQ6IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVW5waW5SZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVucGluUmVzcG9uc2Uge1xuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIHJlcXVlc3QgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVbnBpblJlc3BvbnNlXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBVcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3Qge1xuICAvKipcbiAgICogTGlzdCBvZiB1c2VySUQgdG8gcmVtb3ZlXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKiBAbWVtYmVyb2YgVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0XG4gICAqL1xuICByZW1vdmVfbWVtYmVycz86IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKiBMaXN0IG9mIG1lbWJlcnMgdG8gdXBkYXRlIG9yIGluc2VydFxuICAgKiBAdHlwZSB7QXJyYXk8TWVtYmVyUmVxdWVzdD59XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3RcbiAgICovXG4gIHVwZGF0ZV9tZW1iZXJzPzogQXJyYXk8TWVtYmVyUmVxdWVzdD47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFVwZGF0ZUNhbGxNZW1iZXJzUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVDYWxsTWVtYmVyc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXBkYXRlQ2FsbE1lbWJlcnNSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxNZW1iZXJSZXNwb25zZT59XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVDYWxsTWVtYmVyc1Jlc3BvbnNlXG4gICAqL1xuICBtZW1iZXJzOiBBcnJheTxNZW1iZXJSZXNwb25zZT47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFVwZGF0ZUNhbGxSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlQ2FsbFJlcXVlc3Qge1xuICAvKipcbiAgICogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgb2JqZWN0XG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IGFueTsgfX1cbiAgICogQG1lbWJlcm9mIFVwZGF0ZUNhbGxSZXF1ZXN0XG4gICAqL1xuICBjdXN0b20/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxTZXR0aW5nc1JlcXVlc3R9XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVDYWxsUmVxdWVzdFxuICAgKi9cbiAgc2V0dGluZ3Nfb3ZlcnJpZGU/OiBDYWxsU2V0dGluZ3NSZXF1ZXN0O1xuICAvKipcbiAgICogdGhlIHRpbWUgdGhlIGNhbGwgaXMgc2NoZWR1bGVkIHRvIHN0YXJ0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVDYWxsUmVxdWVzdFxuICAgKi9cbiAgc3RhcnRzX2F0Pzogc3RyaW5nO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2FsbFxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBVcGRhdGVDYWxsUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVDYWxsUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0NhbGxSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIFVwZGF0ZUNhbGxSZXNwb25zZVxuICAgKi9cbiAgY2FsbDogQ2FsbFJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVwZGF0ZUNhbGxSZXNwb25zZVxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxNZW1iZXJSZXNwb25zZT59XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVDYWxsUmVzcG9uc2VcbiAgICovXG4gIG1lbWJlcnM6IEFycmF5PE1lbWJlclJlc3BvbnNlPjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtNZW1iZXJSZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIFVwZGF0ZUNhbGxSZXNwb25zZVxuICAgKi9cbiAgbWVtYmVyc2hpcD86IE1lbWJlclJlc3BvbnNlO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PE93bkNhcGFiaWxpdHk+fVxuICAgKiBAbWVtYmVyb2YgVXBkYXRlQ2FsbFJlc3BvbnNlXG4gICAqL1xuICBvd25fY2FwYWJpbGl0aWVzOiBBcnJheTxPd25DYXBhYmlsaXR5Pjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0XG4gICAqL1xuICBncmFudF9wZXJtaXNzaW9ucz86IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICogQG1lbWJlcm9mIFVwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3RcbiAgICovXG4gIHJldm9rZV9wZXJtaXNzaW9ucz86IEFycmF5PHN0cmluZz47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdFxuICAgKi9cbiAgdXNlcl9pZDogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBVcGRhdGVVc2VyUGVybWlzc2lvbnNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVVzZXJQZXJtaXNzaW9uc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXF1ZXN0IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXBkYXRlVXNlclBlcm1pc3Npb25zUmVzcG9uc2VcbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG59XG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2VudCB0byBub3RpZnkgYWJvdXQgcGVybWlzc2lvbiBjaGFuZ2VzIGZvciBhIHVzZXIsIGNsaWVudHMgcmVjZWl2aW5nIHRoaXMgZXZlbnQgc2hvdWxkIHVwZGF0ZSB0aGVpciBVSSBhY2NvcmRpbmdseVxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBVcGRhdGVkQ2FsbFBlcm1pc3Npb25zRXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVkQ2FsbFBlcm1pc3Npb25zRXZlbnQge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVwZGF0ZWRDYWxsUGVybWlzc2lvbnNFdmVudFxuICAgKi9cbiAgY2FsbF9jaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVkQ2FsbFBlcm1pc3Npb25zRXZlbnRcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIGN1cnJlbnQgdXNlclxuICAgKiBAdHlwZSB7QXJyYXk8T3duQ2FwYWJpbGl0eT59XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVkQ2FsbFBlcm1pc3Npb25zRXZlbnRcbiAgICovXG4gIG93bl9jYXBhYmlsaXRpZXM6IEFycmF5PE93bkNhcGFiaWxpdHk+O1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQ6IFwiY2FsbC5wZXJtaXNzaW9uc191cGRhdGVkXCIgaW4gdGhpcyBjYXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVkQ2FsbFBlcm1pc3Npb25zRXZlbnRcbiAgICovXG4gIHR5cGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtVc2VyUmVzcG9uc2V9XG4gICAqIEBtZW1iZXJvZiBVcGRhdGVkQ2FsbFBlcm1pc3Npb25zRXZlbnRcbiAgICovXG4gIHVzZXI6IFVzZXJSZXNwb25zZTtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVXNlckluZm9SZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJJbmZvUmVzcG9uc2Uge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3sgW2tleTogc3RyaW5nXTogYW55OyB9fVxuICAgKiBAbWVtYmVyb2YgVXNlckluZm9SZXNwb25zZVxuICAgKi9cbiAgY3VzdG9tOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJJbmZvUmVzcG9uc2VcbiAgICovXG4gIGltYWdlOiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXNlckluZm9SZXNwb25zZVxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAqIEBtZW1iZXJvZiBVc2VySW5mb1Jlc3BvbnNlXG4gICAqL1xuICByb2xlczogQXJyYXk8c3RyaW5nPjtcbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVXNlclJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VyUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBhbnk7IH19XG4gICAqIEBtZW1iZXJvZiBVc2VyUmVxdWVzdFxuICAgKi9cbiAgY3VzdG9tPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqIFVzZXIgSURcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJSZXF1ZXN0XG4gICAqL1xuICBpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJSZXF1ZXN0XG4gICAqL1xuICBpbWFnZT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyUmVxdWVzdFxuICAgKi9cbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBPcHRpb25hbCBuYW1lIG9mIHVzZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJSZXF1ZXN0XG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBVc2VyUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VyUmVzcG9uc2Uge1xuICAvKipcbiAgICogRGF0ZS90aW1lIG9mIGNyZWF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyUmVzcG9uc2VcbiAgICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IGFueTsgfX1cbiAgICogQG1lbWJlcm9mIFVzZXJSZXNwb25zZVxuICAgKi9cbiAgY3VzdG9tOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKipcbiAgICogRGF0ZS90aW1lIG9mIGRlbGV0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyUmVzcG9uc2VcbiAgICovXG4gIGRlbGV0ZWRfYXQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXNlclJlc3BvbnNlXG4gICAqL1xuICBpZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJSZXNwb25zZVxuICAgKi9cbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXNlclJlc3BvbnNlXG4gICAqL1xuICBsYW5ndWFnZTogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJSZXNwb25zZVxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyUmVzcG9uc2VcbiAgICovXG4gIHJvbGU6IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgKiBAbWVtYmVyb2YgVXNlclJlc3BvbnNlXG4gICAqL1xuICB0ZWFtczogQXJyYXk8c3RyaW5nPjtcbiAgLyoqXG4gICAqIERhdGUvdGltZSBvZiB0aGUgbGFzdCB1cGRhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJSZXNwb25zZVxuICAgKi9cbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xufVxuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFVzZXJTZXNzaW9uU3RhdHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VyU2Vzc2lvblN0YXRzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICBicm93c2VyPzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIGJyb3dzZXJfdmVyc2lvbj86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICBjdXJyZW50X2lwPzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIGN1cnJlbnRfc2Z1Pzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIGRldmljZV9tb2RlbD86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICBkZXZpY2VfdmVyc2lvbj86IHN0cmluZztcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICBmcmVlemVfZHVyYXRpb25fc2Vjb25kczogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0dlb2xvY2F0aW9uUmVzdWx0fVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgZ2VvbG9jYXRpb24/OiBHZW9sb2NhdGlvblJlc3VsdDtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0c31cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIGppdHRlcj86IFN0YXRzO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1N0YXRzfVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgbGF0ZW5jeT86IFN0YXRzO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIG1heF9maXJfcGVyX3NlY29uZD86IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICBtYXhfZnJlZXplc19wZXJfc2Vjb25kPzogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIG1heF9uYWNrX3Blcl9zZWNvbmQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgbWF4X3BsaV9wZXJfc2Vjb25kPzogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1ZpZGVvUXVhbGl0eX1cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIG1heF9wdWJsaXNoaW5nX3ZpZGVvX3F1YWxpdHk/OiBWaWRlb1F1YWxpdHk7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VmlkZW9RdWFsaXR5fVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgbWF4X3JlY2VpdmluZ192aWRlb19xdWFsaXR5PzogVmlkZW9RdWFsaXR5O1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIG9zPzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIG9zX3ZlcnNpb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgcGFja2V0X2xvc3NfZnJhY3Rpb246IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICBwdWJsaXNoaW5nX2F1ZGlvX2NvZGVjPzogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIHB1Ymxpc2hpbmdfZHVyYXRpb25fc2Vjb25kczogbnVtYmVyO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFVzZXJTZXNzaW9uU3RhdHNcbiAgICovXG4gIHF1YWxpdHlfc2NvcmU6IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICByZWNlaXZpbmdfYXVkaW9fY29kZWM/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgcmVjZWl2aW5nX2R1cmF0aW9uX3NlY29uZHM6IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICBzZGs/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgc2RrX3ZlcnNpb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgc2Vzc2lvbl9pZDogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0FycmF5PFN1YnNlc3Npb24+fVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgc3Vic2Vzc2lvbnM/OiBBcnJheTxTdWJzZXNzaW9uPjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtDYWxsVGltZWxpbmV9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICB0aW1lbGluZT86IENhbGxUaW1lbGluZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICB0b3RhbF9waXhlbHNfaW46IG51bWJlcjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBVc2VyU2Vzc2lvblN0YXRzXG4gICAqL1xuICB0b3RhbF9waXhlbHNfb3V0OiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVXNlclNlc3Npb25TdGF0c1xuICAgKi9cbiAgd2VicnRjX3ZlcnNpb24/OiBzdHJpbmc7XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFVzZXJTdGF0c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJTdGF0cyB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VXNlckluZm9SZXNwb25zZX1cbiAgICogQG1lbWJlcm9mIFVzZXJTdGF0c1xuICAgKi9cbiAgaW5mbzogVXNlckluZm9SZXNwb25zZTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxVc2VyU2Vzc2lvblN0YXRzPn1cbiAgICogQG1lbWJlcm9mIFVzZXJTdGF0c1xuICAgKi9cbiAgc2Vzc2lvbl9zdGF0czogQXJyYXk8VXNlclNlc3Npb25TdGF0cz47XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFZpZGVvU2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWRlb1NldHRpbmdzIHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgVmlkZW9TZXR0aW5nc1xuICAgKi9cbiAgYWNjZXNzX3JlcXVlc3RfZW5hYmxlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgVmlkZW9TZXR0aW5nc1xuICAgKi9cbiAgY2FtZXJhX2RlZmF1bHRfb246IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgVmlkZW9TZXR0aW5nc1xuICAgKi9cbiAgY2FtZXJhX2ZhY2luZzogVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW07XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIFZpZGVvU2V0dGluZ3NcbiAgICovXG4gIGVuYWJsZWQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VGFyZ2V0UmVzb2x1dGlvbn1cbiAgICogQG1lbWJlcm9mIFZpZGVvU2V0dGluZ3NcbiAgICovXG4gIHRhcmdldF9yZXNvbHV0aW9uOiBUYXJnZXRSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtID0ge1xuICBGUk9OVDogJ2Zyb250JyxcbiAgQkFDSzogJ2JhY2snLFxuICBFWFRFUk5BTDogJ2V4dGVybmFsJyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBWaWRlb1NldHRpbmdzQ2FtZXJhRmFjaW5nRW51bSA9XG4gICh0eXBlb2YgVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0pW2tleW9mIHR5cGVvZiBWaWRlb1NldHRpbmdzQ2FtZXJhRmFjaW5nRW51bV07XG5cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVmlkZW9TZXR0aW5nc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWRlb1NldHRpbmdzUmVxdWVzdCB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIFZpZGVvU2V0dGluZ3NSZXF1ZXN0XG4gICAqL1xuICBhY2Nlc3NfcmVxdWVzdF9lbmFibGVkPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgVmlkZW9TZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGNhbWVyYV9kZWZhdWx0X29uPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBWaWRlb1NldHRpbmdzUmVxdWVzdFxuICAgKi9cbiAgY2FtZXJhX2ZhY2luZz86IFZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bTtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgVmlkZW9TZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge1RhcmdldFJlc29sdXRpb25SZXF1ZXN0fVxuICAgKiBAbWVtYmVyb2YgVmlkZW9TZXR0aW5nc1JlcXVlc3RcbiAgICovXG4gIHRhcmdldF9yZXNvbHV0aW9uPzogVGFyZ2V0UmVzb2x1dGlvblJlcXVlc3Q7XG59XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgVmlkZW9TZXR0aW5nc1JlcXVlc3RDYW1lcmFGYWNpbmdFbnVtID0ge1xuICBGUk9OVDogJ2Zyb250JyxcbiAgQkFDSzogJ2JhY2snLFxuICBFWFRFUk5BTDogJ2V4dGVybmFsJyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBWaWRlb1NldHRpbmdzUmVxdWVzdENhbWVyYUZhY2luZ0VudW0gPVxuICAodHlwZW9mIFZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSlba2V5b2YgdHlwZW9mIFZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bV07XG5cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgVmlkZW9RdWFsaXR5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9RdWFsaXR5IHtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtWaWRlb1Jlc29sdXRpb259XG4gICAqIEBtZW1iZXJvZiBWaWRlb1F1YWxpdHlcbiAgICovXG4gIHJlc29sdXRpb246IFZpZGVvUmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBWaWRlb1Jlc29sdXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWRlb1Jlc29sdXRpb24ge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQG1lbWJlcm9mIFZpZGVvUmVzb2x1dGlvblxuICAgKi9cbiAgaGVpZ2h0OiBudW1iZXI7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgVmlkZW9SZXNvbHV0aW9uXG4gICAqL1xuICB3aWR0aDogbnVtYmVyO1xufVxuXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIFdTQXV0aE1lc3NhZ2VSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV1NBdXRoTWVzc2FnZVJlcXVlc3Qge1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFdTQXV0aE1lc3NhZ2VSZXF1ZXN0XG4gICAqL1xuICB0b2tlbjogc3RyaW5nO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0Nvbm5lY3RVc2VyRGV0YWlsc1JlcXVlc3R9XG4gICAqIEBtZW1iZXJvZiBXU0F1dGhNZXNzYWdlUmVxdWVzdFxuICAgKi9cbiAgdXNlcl9kZXRhaWxzOiBDb25uZWN0VXNlckRldGFpbHNSZXF1ZXN0O1xufVxuLyoqXG4gKiBAdHlwZSBXU0V2ZW50XG4gKiBUaGUgZGlzY3JpbWluYXRvciBvYmplY3QgZm9yIGFsbCB3ZWJzb2NrZXQgZXZlbnRzLCBpdCBtYXBzIGV2ZW50cycgcGF5bG9hZCB0byB0aGUgZmluYWwgdHlwZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgdHlwZSBXU0V2ZW50ID1cbiAgfCAoeyB0eXBlOiAnY2FsbC5hY2NlcHRlZCcgfSAmIENhbGxBY2NlcHRlZEV2ZW50KVxuICB8ICh7IHR5cGU6ICdjYWxsLmJsb2NrZWRfdXNlcicgfSAmIEJsb2NrZWRVc2VyRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwuY2xvc2VkX2NhcHRpb24nIH0gJiBDbG9zZWRDYXB0aW9uRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwuY3JlYXRlZCcgfSAmIENhbGxDcmVhdGVkRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwuZGVsZXRlZCcgfSAmIENhbGxEZWxldGVkRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwuZW5kZWQnIH0gJiBDYWxsRW5kZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5obHNfYnJvYWRjYXN0aW5nX2ZhaWxlZCcgfSAmIENhbGxITFNCcm9hZGNhc3RpbmdGYWlsZWRFdmVudClcbiAgfCAoe1xuICAgICAgdHlwZTogJ2NhbGwuaGxzX2Jyb2FkY2FzdGluZ19zdGFydGVkJztcbiAgICB9ICYgQ2FsbEhMU0Jyb2FkY2FzdGluZ1N0YXJ0ZWRFdmVudClcbiAgfCAoe1xuICAgICAgdHlwZTogJ2NhbGwuaGxzX2Jyb2FkY2FzdGluZ19zdG9wcGVkJztcbiAgICB9ICYgQ2FsbEhMU0Jyb2FkY2FzdGluZ1N0b3BwZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5saXZlX3N0YXJ0ZWQnIH0gJiBDYWxsTGl2ZVN0YXJ0ZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5tZW1iZXJfYWRkZWQnIH0gJiBDYWxsTWVtYmVyQWRkZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5tZW1iZXJfcmVtb3ZlZCcgfSAmIENhbGxNZW1iZXJSZW1vdmVkRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwubWVtYmVyX3VwZGF0ZWQnIH0gJiBDYWxsTWVtYmVyVXBkYXRlZEV2ZW50KVxuICB8ICh7XG4gICAgICB0eXBlOiAnY2FsbC5tZW1iZXJfdXBkYXRlZF9wZXJtaXNzaW9uJztcbiAgICB9ICYgQ2FsbE1lbWJlclVwZGF0ZWRQZXJtaXNzaW9uRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwubm90aWZpY2F0aW9uJyB9ICYgQ2FsbE5vdGlmaWNhdGlvbkV2ZW50KVxuICB8ICh7IHR5cGU6ICdjYWxsLnBlcm1pc3Npb25fcmVxdWVzdCcgfSAmIFBlcm1pc3Npb25SZXF1ZXN0RXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwucGVybWlzc2lvbnNfdXBkYXRlZCcgfSAmIFVwZGF0ZWRDYWxsUGVybWlzc2lvbnNFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5yZWFjdGlvbl9uZXcnIH0gJiBDYWxsUmVhY3Rpb25FdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5yZWNvcmRpbmdfZmFpbGVkJyB9ICYgQ2FsbFJlY29yZGluZ0ZhaWxlZEV2ZW50KVxuICB8ICh7IHR5cGU6ICdjYWxsLnJlY29yZGluZ19yZWFkeScgfSAmIENhbGxSZWNvcmRpbmdSZWFkeUV2ZW50KVxuICB8ICh7IHR5cGU6ICdjYWxsLnJlY29yZGluZ19zdGFydGVkJyB9ICYgQ2FsbFJlY29yZGluZ1N0YXJ0ZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5yZWNvcmRpbmdfc3RvcHBlZCcgfSAmIENhbGxSZWNvcmRpbmdTdG9wcGVkRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwucmVqZWN0ZWQnIH0gJiBDYWxsUmVqZWN0ZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5yaW5nJyB9ICYgQ2FsbFJpbmdFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5zZXNzaW9uX2VuZGVkJyB9ICYgQ2FsbFNlc3Npb25FbmRlZEV2ZW50KVxuICB8ICh7XG4gICAgICB0eXBlOiAnY2FsbC5zZXNzaW9uX3BhcnRpY2lwYW50X2pvaW5lZCc7XG4gICAgfSAmIENhbGxTZXNzaW9uUGFydGljaXBhbnRKb2luZWRFdmVudClcbiAgfCAoe1xuICAgICAgdHlwZTogJ2NhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9sZWZ0JztcbiAgICB9ICYgQ2FsbFNlc3Npb25QYXJ0aWNpcGFudExlZnRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC5zZXNzaW9uX3N0YXJ0ZWQnIH0gJiBDYWxsU2Vzc2lvblN0YXJ0ZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC50cmFuc2NyaXB0aW9uX2ZhaWxlZCcgfSAmIENhbGxUcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2NhbGwudHJhbnNjcmlwdGlvbl9yZWFkeScgfSAmIENhbGxUcmFuc2NyaXB0aW9uUmVhZHlFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC50cmFuc2NyaXB0aW9uX3N0YXJ0ZWQnIH0gJiBDYWxsVHJhbnNjcmlwdGlvblN0YXJ0ZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC50cmFuc2NyaXB0aW9uX3N0b3BwZWQnIH0gJiBDYWxsVHJhbnNjcmlwdGlvblN0b3BwZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC51bmJsb2NrZWRfdXNlcicgfSAmIFVuYmxvY2tlZFVzZXJFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC51cGRhdGVkJyB9ICYgQ2FsbFVwZGF0ZWRFdmVudClcbiAgfCAoeyB0eXBlOiAnY2FsbC51c2VyX211dGVkJyB9ICYgQ2FsbFVzZXJNdXRlZClcbiAgfCAoeyB0eXBlOiAnY29ubmVjdGlvbi5lcnJvcicgfSAmIENvbm5lY3Rpb25FcnJvckV2ZW50KVxuICB8ICh7IHR5cGU6ICdjb25uZWN0aW9uLm9rJyB9ICYgQ29ubmVjdGVkRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2hlYWx0aC5jaGVjaycgfSAmIEhlYWx0aENoZWNrRXZlbnQpXG4gIHwgKHsgdHlwZTogJ2N1c3RvbScgfSAmIEN1c3RvbVZpZGVvRXZlbnQpO1xuIiwiaW1wb3J0IHsgQXhpb3NSZXF1ZXN0Q29uZmlnLCBBeGlvc1Jlc3BvbnNlIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgU3RhYmxlV1NDb25uZWN0aW9uIH0gZnJvbSAnLi9jb25uZWN0aW9uJztcbmltcG9ydCB7IENvbm5lY3RlZEV2ZW50LCBVc2VyUmVxdWVzdCwgV1NFdmVudCB9IGZyb20gJy4uLy4uL2dlbi9jb29yZGluYXRvcic7XG5pbXBvcnQgeyBBbGxTZnVFdmVudHMgfSBmcm9tICcuLi8uLi9ydGMnO1xuXG5leHBvcnQgdHlwZSBVUiA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG5leHBvcnQgdHlwZSBVc2VyID1cbiAgfCAoT21pdDxVc2VyUmVxdWVzdCwgJ3JvbGUnPiAmIHsgdHlwZT86ICdhdXRoZW50aWNhdGVkJyB9KVxuICB8IChPbWl0PFVzZXJSZXF1ZXN0LCAncm9sZSc+ICYgeyB0eXBlOiAnZ3Vlc3QnIH0pXG4gIHwgKE9taXQ8VXNlclJlcXVlc3QsICdpZCcgfCAncm9sZSc+ICYge1xuICAgICAgaWQ/OiAnIWFub24nO1xuICAgICAgdHlwZTogJ2Fub255bW91cyc7XG4gICAgfSk7XG5cbmV4cG9ydCB0eXBlIFVzZXJXaXRoSWQgPVxuICB8IChVc2VyUmVxdWVzdCAmIHsgdHlwZT86ICdhdXRoZW50aWNhdGVkJyB9KVxuICB8IChVc2VyUmVxdWVzdCAmIHsgdHlwZTogJ2d1ZXN0JyB9KVxuICB8IChVc2VyUmVxdWVzdCAmIHtcbiAgICAgIGlkOiAnIWFub24nO1xuICAgICAgdHlwZTogJ2Fub255bW91cyc7XG4gICAgfSk7XG5cbmV4cG9ydCB0eXBlIHsgT3duVXNlclJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vZ2VuL2Nvb3JkaW5hdG9yJztcblxuZXhwb3J0IHR5cGUgQ29ubmVjdEFQSVJlc3BvbnNlID0gUHJvbWlzZTx2b2lkIHwgQ29ubmVjdGVkRXZlbnQ+O1xuXG5leHBvcnQgdHlwZSBMb2dMZXZlbCA9ICd0cmFjZScgfCAnZGVidWcnIHwgJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJztcblxudHlwZSBFcnJvclJlc3BvbnNlRGV0YWlscyA9IHtcbiAgY29kZTogbnVtYmVyO1xuICBtZXNzYWdlczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBBUElFcnJvclJlc3BvbnNlID0ge1xuICBjb2RlOiBudW1iZXI7XG4gIGR1cmF0aW9uOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgbW9yZV9pbmZvOiBzdHJpbmc7XG4gIFN0YXR1c0NvZGU6IG51bWJlcjtcbiAgZGV0YWlscz86IEVycm9yUmVzcG9uc2VEZXRhaWxzO1xufTtcblxuZXhwb3J0IGNsYXNzIEVycm9yRnJvbVJlc3BvbnNlPFQ+IGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlPzogbnVtYmVyO1xuICByZXNwb25zZT86IEF4aW9zUmVzcG9uc2U8VD47XG4gIHN0YXR1cz86IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgQ29ubmVjdGlvbkNoYW5nZWRFdmVudCA9IHtcbiAgdHlwZTogJ2Nvbm5lY3Rpb24uY2hhbmdlZCc7XG4gIG9ubGluZTogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFRyYW5zcG9ydENoYW5nZWRFdmVudCA9IHtcbiAgdHlwZTogJ3RyYW5zcG9ydC5jaGFuZ2VkJztcbiAgbW9kZTogJ2xvbmdwb2xsJztcbn07XG5cbmV4cG9ydCB0eXBlIENvbm5lY3Rpb25SZWNvdmVyZWRFdmVudCA9IHtcbiAgdHlwZTogJ2Nvbm5lY3Rpb24ucmVjb3ZlcmVkJztcbn07XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVZpZGVvRXZlbnQgPSAoXG4gIHwgV1NFdmVudFxuICB8IENvbm5lY3Rpb25DaGFuZ2VkRXZlbnRcbiAgfCBUcmFuc3BvcnRDaGFuZ2VkRXZlbnRcbiAgfCBDb25uZWN0aW9uUmVjb3ZlcmVkRXZlbnRcbikgJiB7IHJlY2VpdmVkX2F0Pzogc3RyaW5nIHwgRGF0ZSB9O1xuXG4vLyBUT0RPOiB3ZSBzaG91bGQgdXNlIFdTQ2FsbEV2ZW50IGhlcmUgYnV0IHRoYXQgbmVlZHMgZml4aW5nXG5leHBvcnQgdHlwZSBTdHJlYW1DYWxsRXZlbnQgPSBFeHRyYWN0PFN0cmVhbVZpZGVvRXZlbnQsIHsgY2FsbF9jaWQ6IHN0cmluZyB9PjtcbmV4cG9ydCB0eXBlIEV2ZW50VHlwZXMgPSAnYWxsJyB8IFdTRXZlbnRbJ3R5cGUnXTtcblxuZXhwb3J0IHR5cGUgQWxsQ2xpZW50RXZlbnRUeXBlcyA9ICdhbGwnIHwgU3RyZWFtVmlkZW9FdmVudFsndHlwZSddO1xuZXhwb3J0IHR5cGUgQWxsQ2xpZW50RXZlbnRzID0ge1xuICBbSyBpbiBBbGxDbGllbnRFdmVudFR5cGVzXTogRXh0cmFjdDxTdHJlYW1WaWRlb0V2ZW50LCB7IHR5cGU6IEsgfT47XG59O1xuZXhwb3J0IHR5cGUgQ2xpZW50RXZlbnRMaXN0ZW5lcjxFIGV4dGVuZHMga2V5b2YgQWxsQ2xpZW50RXZlbnRzPiA9IChcbiAgZXZlbnQ6IEFsbENsaWVudEV2ZW50c1tFXSxcbikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgQWxsQ2xpZW50Q2FsbEV2ZW50cyA9IHtcbiAgW0sgaW4gRXZlbnRUeXBlc106IEV4dHJhY3Q8V1NFdmVudCwgeyB0eXBlOiBLIH0+O1xufTtcblxuZXhwb3J0IHR5cGUgQWxsQ2FsbEV2ZW50cyA9IEFsbENsaWVudENhbGxFdmVudHMgJiBBbGxTZnVFdmVudHM7XG5leHBvcnQgdHlwZSBDYWxsRXZlbnRMaXN0ZW5lcjxFIGV4dGVuZHMga2V5b2YgQWxsQ2FsbEV2ZW50cz4gPSAoXG4gIGV2ZW50OiBBbGxDYWxsRXZlbnRzW0VdLFxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBMb2dnZXIgPSAoXG4gIGxvZ0xldmVsOiBMb2dMZXZlbCxcbiAgbWVzc2FnZTogc3RyaW5nLFxuICAuLi5hcmdzOiB1bmtub3duW11cbikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgU3RyZWFtQ2xpZW50T3B0aW9ucyA9IFBhcnRpYWw8QXhpb3NSZXF1ZXN0Q29uZmlnPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgdG8gZGlzYWJsZSB3YXJuaW5ncyB0aGF0IGFyZSB0cmlnZ2VyZWQgYnkgdXNpbmcgY29ubmVjdFVzZXIgb3IgY29ubmVjdEFub255bW91c1VzZXIgc2VydmVyLXNpZGUuXG4gICAqL1xuICBhbGxvd1NlcnZlclNpZGVDb25uZWN0PzogYm9vbGVhbjtcbiAgYXhpb3NSZXF1ZXN0Q29uZmlnPzogQXhpb3NSZXF1ZXN0Q29uZmlnO1xuICAvKipcbiAgICogQmFzZSB1cmwgdG8gdXNlIGZvciBBUElcbiAgICogc3VjaCBhcyBodHRwczovL2NoYXQtcHJveHktZHVibGluLnN0cmVhbS1pby1hcGkuY29tXG4gICAqL1xuICBiYXNlVVJMPzogc3RyaW5nO1xuICBicm93c2VyPzogYm9vbGVhbjtcbiAgLy8gZGV2aWNlPzogQmFzZURldmljZUZpZWxkcztcbiAgZW5hYmxlSW5zaWdodHM/OiBib29sZWFuO1xuICAvKiogZXhwZXJpbWVudGFsIGZlYXR1cmUsIHBsZWFzZSBjb250YWN0IHN1cHBvcnQgaWYgeW91IHdhbnQgdGhpcyBmZWF0dXJlIGVuYWJsZWQgZm9yIHlvdSAqL1xuICBlbmFibGVXU0ZhbGxiYWNrPzogYm9vbGVhbjtcbiAgbG9nZ2VyPzogTG9nZ2VyO1xuICBsb2dMZXZlbD86IExvZ0xldmVsO1xuICAvKipcbiAgICogVGhlIFVSTCB0byB1c2UgZm9yIHRoZSBsb2NhdGlvbiBoaW50LlxuICAgKi9cbiAgbG9jYXRpb25IaW50VXJsPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGRlZmF1bHQgdGltZW91dCBmb3IgcmVxdWVzdGluZyBhIGxvY2F0aW9uIGhpbnQuXG4gICAqL1xuICBsb2NhdGlvbkhpbnRUaW1lb3V0PzogbnVtYmVyO1xuICAvKipcbiAgICogV2hlbiB0cnVlLCB1c2VyIHdpbGwgYmUgcGVyc2lzdGVkIG9uIGNsaWVudC4gT3RoZXJ3aXNlIGlmIGBjb25uZWN0VXNlcmAgY2FsbCBmYWlscywgdGhlbiB5b3UgbmVlZCB0b1xuICAgKiBjYWxsIGBjb25uZWN0VXNlcmAgYWdhaW4gdG8gcmV0cnkuXG4gICAqIFRoaXMgaXMgbWFpbmx5IHVzZWZ1bCBmb3IgY2hhdCBhcHBsaWNhdGlvbiB3b3JraW5nIGluIG9mZmxpbmUgbW9kZSwgd2hlcmUgeW91IHdpbGwgbmVlZCBjbGllbnQudXNlciB0b1xuICAgKiBwZXJzaXN0IGV2ZW4gaWYgY29ubmVjdFVzZXIgY2FsbCBmYWlscy5cbiAgICovXG4gIHBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBzZWNyZXQga2V5IGZvciB0aGUgQVBJIGtleS4gVGhpcyBpcyBvbmx5IG5lZWRlZCBmb3Igc2VydmVyIHNpZGUgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBzZWNyZXQ/OiBzdHJpbmc7XG5cbiAgd2FybVVwPzogYm9vbGVhbjtcbiAgLy8gU2V0IHRoZSBpbnN0YW5jZSBvZiBTdGFibGVXU0Nvbm5lY3Rpb24gb24gY2hhdCBjbGllbnQuIEl0cyBwdXJlbHkgZm9yIHRlc3RpbmcgcHVycG9zZSBhbmQgc2hvdWxkXG4gIC8vIG5vdCBiZSB1c2VkIGluIHByb2R1Y3Rpb24gYXBwcy5cbiAgd3NDb25uZWN0aW9uPzogU3RhYmxlV1NDb25uZWN0aW9uO1xufTtcblxuZXhwb3J0IHR5cGUgVG9rZW5Qcm92aWRlciA9ICgpID0+IFByb21pc2U8c3RyaW5nPjtcbmV4cG9ydCB0eXBlIFRva2VuT3JQcm92aWRlciA9IG51bGwgfCBzdHJpbmcgfCBUb2tlblByb3ZpZGVyIHwgdW5kZWZpbmVkO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9idWYtdHMgMi45LjMgd2l0aCBwYXJhbWV0ZXIgbG9uZ190eXBlX3N0cmluZyxjbGllbnRfZ2VuZXJpYyxzZXJ2ZXJfbm9uZSxlc2xpbnRfZGlzYWJsZVxuLy8gQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpbGUgXCJnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvXCIgKHBhY2thZ2UgXCJnb29nbGUucHJvdG9idWZcIiwgc3ludGF4IHByb3RvMylcbi8vIHRzbGludDpkaXNhYmxlXG4vL1xuLy8gUHJvdG9jb2wgQnVmZmVycyAtIEdvb2dsZSdzIGRhdGEgaW50ZXJjaGFuZ2UgZm9ybWF0XG4vLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG5pbXBvcnQgdHlwZSB7XG4gIEJpbmFyeVJlYWRPcHRpb25zLFxuICBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gIElCaW5hcnlSZWFkZXIsXG4gIElCaW5hcnlXcml0ZXIsXG4gIEpzb25PYmplY3QsXG4gIEpzb25SZWFkT3B0aW9ucyxcbiAgSnNvblZhbHVlLFxuICBKc29uV3JpdGVPcHRpb25zLFxuICBQYXJ0aWFsTWVzc2FnZSxcbn0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuaW1wb3J0IHtcbiAgaXNKc29uT2JqZWN0LFxuICBNZXNzYWdlVHlwZSxcbiAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCxcbiAgdHlwZW9mSnNvblZhbHVlLFxuICBVbmtub3duRmllbGRIYW5kbGVyLFxuICBXaXJlVHlwZSxcbn0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuXG4vKipcbiAqIGBTdHJ1Y3RgIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmVkIGRhdGEgdmFsdWUsIGNvbnNpc3Rpbmcgb2YgZmllbGRzXG4gKiB3aGljaCBtYXAgdG8gZHluYW1pY2FsbHkgdHlwZWQgdmFsdWVzLiBJbiBzb21lIGxhbmd1YWdlcywgYFN0cnVjdGBcbiAqIG1pZ2h0IGJlIHN1cHBvcnRlZCBieSBhIG5hdGl2ZSByZXByZXNlbnRhdGlvbi4gRm9yIGV4YW1wbGUsIGluXG4gKiBzY3JpcHRpbmcgbGFuZ3VhZ2VzIGxpa2UgSlMgYSBzdHJ1Y3QgaXMgcmVwcmVzZW50ZWQgYXMgYW5cbiAqIG9iamVjdC4gVGhlIGRldGFpbHMgb2YgdGhhdCByZXByZXNlbnRhdGlvbiBhcmUgZGVzY3JpYmVkIHRvZ2V0aGVyXG4gKiB3aXRoIHRoZSBwcm90byBzdXBwb3J0IGZvciB0aGUgbGFuZ3VhZ2UuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBTdHJ1Y3RgIGlzIEpTT04gb2JqZWN0LlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdHJ1Y3Qge1xuICAvKipcbiAgICogVW5vcmRlcmVkIG1hcCBvZiBkeW5hbWljYWxseSB0eXBlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogbWFwPHN0cmluZywgZ29vZ2xlLnByb3RvYnVmLlZhbHVlPiBmaWVsZHMgPSAxO1xuICAgKi9cbiAgZmllbGRzOiB7XG4gICAgW2tleTogc3RyaW5nXTogVmFsdWU7XG4gIH07XG59XG4vKipcbiAqIGBWYWx1ZWAgcmVwcmVzZW50cyBhIGR5bmFtaWNhbGx5IHR5cGVkIHZhbHVlIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAqIG51bGwsIGEgbnVtYmVyLCBhIHN0cmluZywgYSBib29sZWFuLCBhIHJlY3Vyc2l2ZSBzdHJ1Y3QgdmFsdWUsIG9yIGFcbiAqIGxpc3Qgb2YgdmFsdWVzLiBBIHByb2R1Y2VyIG9mIHZhbHVlIGlzIGV4cGVjdGVkIHRvIHNldCBvbmUgb2YgdGhlc2VcbiAqIHZhcmlhbnRzLiBBYnNlbmNlIG9mIGFueSB2YXJpYW50IGluZGljYXRlcyBhbiBlcnJvci5cbiAqXG4gKiBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgYFZhbHVlYCBpcyBKU09OIHZhbHVlLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZhbHVlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBvbmVvZjoga2luZFxuICAgKi9cbiAga2luZDpcbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnbnVsbFZhbHVlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgYSBudWxsIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUgbnVsbF92YWx1ZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICBudWxsVmFsdWU6IE51bGxWYWx1ZTtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnbnVtYmVyVmFsdWUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyBhIGRvdWJsZSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBkb3VibGUgbnVtYmVyX3ZhbHVlID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIG51bWJlclZhbHVlOiBudW1iZXI7XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIG9uZW9mS2luZDogJ3N0cmluZ1ZhbHVlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHN0cmluZ192YWx1ZSA9IDM7XG4gICAgICAgICAqL1xuICAgICAgICBzdHJpbmdWYWx1ZTogc3RyaW5nO1xuICAgICAgfVxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdib29sVmFsdWUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogYm9vbCBib29sX3ZhbHVlID0gNDtcbiAgICAgICAgICovXG4gICAgICAgIGJvb2xWYWx1ZTogYm9vbGVhbjtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnc3RydWN0VmFsdWUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyBhIHN0cnVjdHVyZWQgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBzdHJ1Y3RfdmFsdWUgPSA1O1xuICAgICAgICAgKi9cbiAgICAgICAgc3RydWN0VmFsdWU6IFN0cnVjdDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnbGlzdFZhbHVlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgYSByZXBlYXRlZCBgVmFsdWVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgbGlzdF92YWx1ZSA9IDY7XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VmFsdWU6IExpc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiB1bmRlZmluZWQ7XG4gICAgICB9O1xufVxuLyoqXG4gKiBgTGlzdFZhbHVlYCBpcyBhIHdyYXBwZXIgYXJvdW5kIGEgcmVwZWF0ZWQgZmllbGQgb2YgdmFsdWVzLlxuICpcbiAqIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBgTGlzdFZhbHVlYCBpcyBKU09OIGFycmF5LlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0VmFsdWUge1xuICAvKipcbiAgICogUmVwZWF0ZWQgZmllbGQgb2YgZHluYW1pY2FsbHkgdHlwZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZSB2YWx1ZXMgPSAxO1xuICAgKi9cbiAgdmFsdWVzOiBWYWx1ZVtdO1xufVxuLyoqXG4gKiBgTnVsbFZhbHVlYCBpcyBhIHNpbmdsZXRvbiBlbnVtZXJhdGlvbiB0byByZXByZXNlbnQgdGhlIG51bGwgdmFsdWUgZm9yIHRoZVxuICogYFZhbHVlYCB0eXBlIHVuaW9uLlxuICpcbiAqICBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgYE51bGxWYWx1ZWAgaXMgSlNPTiBgbnVsbGAuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVxuICovXG5leHBvcnQgZW51bSBOdWxsVmFsdWUge1xuICAvKipcbiAgICogTnVsbCB2YWx1ZS5cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IE5VTExfVkFMVUUgPSAwO1xuICAgKi9cbiAgTlVMTF9WQUxVRSA9IDAsXG59XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTdHJ1Y3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFN0cnVjdD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCcsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdmaWVsZHMnLFxuICAgICAgICBraW5kOiAnbWFwJyxcbiAgICAgICAgSzogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgIFY6IHsga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBWYWx1ZSB9LFxuICAgICAgfSxcbiAgICBdKTtcbiAgfVxuICAvKipcbiAgICogRW5jb2RlIGBTdHJ1Y3RgIHRvIEpTT04gb2JqZWN0LlxuICAgKi9cbiAgaW50ZXJuYWxKc29uV3JpdGUobWVzc2FnZTogU3RydWN0LCBvcHRpb25zOiBKc29uV3JpdGVPcHRpb25zKTogSnNvblZhbHVlIHtcbiAgICBsZXQganNvbjogSnNvbk9iamVjdCA9IHt9O1xuICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhtZXNzYWdlLmZpZWxkcykpIHtcbiAgICAgIGpzb25ba10gPSBWYWx1ZS50b0pzb24odik7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgYFN0cnVjdGAgZnJvbSBKU09OIG9iamVjdC5cbiAgICovXG4gIGludGVybmFsSnNvblJlYWQoXG4gICAganNvbjogSnNvblZhbHVlLFxuICAgIG9wdGlvbnM6IEpzb25SZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBTdHJ1Y3QsXG4gICk6IFN0cnVjdCB7XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpXG4gICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgJ1VuYWJsZSB0byBwYXJzZSBtZXNzYWdlICcgK1xuICAgICAgICAgIHRoaXMudHlwZU5hbWUgK1xuICAgICAgICAgICcgZnJvbSBKU09OICcgK1xuICAgICAgICAgIHR5cGVvZkpzb25WYWx1ZShqc29uKSArXG4gICAgICAgICAgJy4nLFxuICAgICAgKTtcbiAgICBpZiAoIXRhcmdldCkgdGFyZ2V0ID0gdGhpcy5jcmVhdGUoKTtcbiAgICBmb3IgKGxldCBbaywgdl0gb2YgZ2xvYmFsVGhpcy5PYmplY3QuZW50cmllcyhqc29uKSkge1xuICAgICAgdGFyZ2V0LmZpZWxkc1trXSA9IFZhbHVlLmZyb21Kc29uKHYpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFN0cnVjdD4pOiBTdHJ1Y3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5maWVsZHMgPSB7fTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8U3RydWN0Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBTdHJ1Y3QsXG4gICk6IFN0cnVjdCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogbWFwPHN0cmluZywgZ29vZ2xlLnByb3RvYnVmLlZhbHVlPiBmaWVsZHMgKi8gMTpcbiAgICAgICAgICB0aGlzLmJpbmFyeVJlYWRNYXAxKG1lc3NhZ2UuZmllbGRzLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgcHJpdmF0ZSBiaW5hcnlSZWFkTWFwMShcbiAgICBtYXA6IFN0cnVjdFsnZmllbGRzJ10sXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICApOiB2b2lkIHtcbiAgICBsZXQgbGVuID0gcmVhZGVyLnVpbnQzMigpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbixcbiAgICAgIGtleToga2V5b2YgU3RydWN0WydmaWVsZHMnXSB8IHVuZGVmaW5lZCxcbiAgICAgIHZhbDogU3RydWN0WydmaWVsZHMnXVthbnldIHwgdW5kZWZpbmVkO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAga2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdmFsID0gVmFsdWUuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICd1bmtub3duIG1hcCBlbnRyeSBmaWVsZCBmb3IgZmllbGQgZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5maWVsZHMnLFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcFtrZXkgPz8gJyddID0gdmFsID8/IFZhbHVlLmNyZWF0ZSgpO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogU3RydWN0LFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIG1hcDxzdHJpbmcsIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZT4gZmllbGRzID0gMTsgKi9cbiAgICBmb3IgKGxldCBrIG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMobWVzc2FnZS5maWVsZHMpKSB7XG4gICAgICB3cml0ZXJcbiAgICAgICAgLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgIC5mb3JrKClcbiAgICAgICAgLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgIC5zdHJpbmcoayk7XG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpO1xuICAgICAgVmFsdWUuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmZpZWxkc1trXSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgIHdyaXRlci5qb2luKCkuam9pbigpO1xuICAgIH1cbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlN0cnVjdFxuICovXG5leHBvcnQgY29uc3QgU3RydWN0ID0gbmV3IFN0cnVjdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWYWx1ZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8VmFsdWU+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5WYWx1ZScsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdudWxsX3ZhbHVlJyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICBUOiAoKSA9PiBbJ2dvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUnLCBOdWxsVmFsdWVdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDIsXG4gICAgICAgIG5hbWU6ICdudW1iZXJfdmFsdWUnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgVDogMSAvKlNjYWxhclR5cGUuRE9VQkxFKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMyxcbiAgICAgICAgbmFtZTogJ3N0cmluZ192YWx1ZScsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA0LFxuICAgICAgICBuYW1lOiAnYm9vbF92YWx1ZScsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNSxcbiAgICAgICAgbmFtZTogJ3N0cnVjdF92YWx1ZScsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgVDogKCkgPT4gU3RydWN0LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDYsXG4gICAgICAgIG5hbWU6ICdsaXN0X3ZhbHVlJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICBUOiAoKSA9PiBMaXN0VmFsdWUsXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmNvZGUgYFZhbHVlYCB0byBKU09OIHZhbHVlLlxuICAgKi9cbiAgaW50ZXJuYWxKc29uV3JpdGUobWVzc2FnZTogVmFsdWUsIG9wdGlvbnM6IEpzb25Xcml0ZU9wdGlvbnMpOiBKc29uVmFsdWUge1xuICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgc3dpdGNoIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kKSB7XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoKTtcbiAgICAgIGNhc2UgJ2Jvb2xWYWx1ZSc6XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmtpbmQuYm9vbFZhbHVlO1xuICAgICAgY2FzZSAnbnVsbFZhbHVlJzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlICdudW1iZXJWYWx1ZSc6XG4gICAgICAgIGxldCBudW1iZXJWYWx1ZSA9IG1lc3NhZ2Uua2luZC5udW1iZXJWYWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXJWYWx1ZSA9PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzRmluaXRlKG51bWJlclZhbHVlKSlcbiAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgICBjYXNlICdzdHJpbmdWYWx1ZSc6XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmtpbmQuc3RyaW5nVmFsdWU7XG4gICAgICBjYXNlICdsaXN0VmFsdWUnOlxuICAgICAgICBsZXQgbGlzdFZhbHVlRmllbGQgPSB0aGlzLmZpZWxkcy5maW5kKChmKSA9PiBmLm5vID09PSA2KTtcbiAgICAgICAgaWYgKGxpc3RWYWx1ZUZpZWxkPy5raW5kICE9PSAnbWVzc2FnZScpIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgICAgIHJldHVybiBsaXN0VmFsdWVGaWVsZC5UKCkudG9Kc29uKG1lc3NhZ2Uua2luZC5saXN0VmFsdWUpO1xuICAgICAgY2FzZSAnc3RydWN0VmFsdWUnOlxuICAgICAgICBsZXQgc3RydWN0VmFsdWVGaWVsZCA9IHRoaXMuZmllbGRzLmZpbmQoKGYpID0+IGYubm8gPT09IDUpO1xuICAgICAgICBpZiAoc3RydWN0VmFsdWVGaWVsZD8ua2luZCAhPT0gJ21lc3NhZ2UnKSB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICAgICAgICByZXR1cm4gc3RydWN0VmFsdWVGaWVsZC5UKCkudG9Kc29uKG1lc3NhZ2Uua2luZC5zdHJ1Y3RWYWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgYFZhbHVlYCBmcm9tIEpTT04gdmFsdWUuXG4gICAqL1xuICBpbnRlcm5hbEpzb25SZWFkKFxuICAgIGpzb246IEpzb25WYWx1ZSxcbiAgICBvcHRpb25zOiBKc29uUmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVmFsdWUsXG4gICk6IFZhbHVlIHtcbiAgICBpZiAoIXRhcmdldCkgdGFyZ2V0ID0gdGhpcy5jcmVhdGUoKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICB0YXJnZXQua2luZCA9IHsgb25lb2ZLaW5kOiAnbnVtYmVyVmFsdWUnLCBudW1iZXJWYWx1ZToganNvbiB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHRhcmdldC5raW5kID0geyBvbmVvZktpbmQ6ICdzdHJpbmdWYWx1ZScsIHN0cmluZ1ZhbHVlOiBqc29uIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHRhcmdldC5raW5kID0geyBvbmVvZktpbmQ6ICdib29sVmFsdWUnLCBib29sVmFsdWU6IGpzb24gfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldC5raW5kID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAnbnVsbFZhbHVlJyxcbiAgICAgICAgICAgIG51bGxWYWx1ZTogTnVsbFZhbHVlLk5VTExfVkFMVUUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgICB0YXJnZXQua2luZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2xpc3RWYWx1ZScsXG4gICAgICAgICAgICBsaXN0VmFsdWU6IExpc3RWYWx1ZS5mcm9tSnNvbihqc29uKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5raW5kID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAnc3RydWN0VmFsdWUnLFxuICAgICAgICAgICAgc3RydWN0VmFsdWU6IFN0cnVjdC5mcm9tSnNvbihqc29uKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgJ1VuYWJsZSB0byBwYXJzZSAnICtcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUgK1xuICAgICAgICAgICAgJyBmcm9tIEpTT04gJyArXG4gICAgICAgICAgICB0eXBlb2ZKc29uVmFsdWUoanNvbiksXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8VmFsdWU+KTogVmFsdWUge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5raW5kID0geyBvbmVvZktpbmQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxWYWx1ZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVmFsdWUsXG4gICk6IFZhbHVlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlIG51bGxfdmFsdWUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdudWxsVmFsdWUnLFxuICAgICAgICAgICAgbnVsbFZhbHVlOiByZWFkZXIuaW50MzIoKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGRvdWJsZSBudW1iZXJfdmFsdWUgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdudW1iZXJWYWx1ZScsXG4gICAgICAgICAgICBudW1iZXJWYWx1ZTogcmVhZGVyLmRvdWJsZSgpLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHN0cmluZ192YWx1ZSAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ3N0cmluZ1ZhbHVlJyxcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiByZWFkZXIuc3RyaW5nKCksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIGJvb2xfdmFsdWUgKi8gNDpcbiAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdib29sVmFsdWUnLFxuICAgICAgICAgICAgYm9vbFZhbHVlOiByZWFkZXIuYm9vbCgpLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBzdHJ1Y3RfdmFsdWUgKi8gNTpcbiAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdzdHJ1Y3RWYWx1ZScsXG4gICAgICAgICAgICBzdHJ1Y3RWYWx1ZTogU3RydWN0LmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIChtZXNzYWdlLmtpbmQgYXMgYW55KS5zdHJ1Y3RWYWx1ZSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlIGxpc3RfdmFsdWUgKi8gNjpcbiAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdsaXN0VmFsdWUnLFxuICAgICAgICAgICAgbGlzdFZhbHVlOiBMaXN0VmFsdWUuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgKG1lc3NhZ2Uua2luZCBhcyBhbnkpLmxpc3RWYWx1ZSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogVmFsdWUsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZSBudWxsX3ZhbHVlID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ251bGxWYWx1ZScpXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5raW5kLm51bGxWYWx1ZSk7XG4gICAgLyogZG91YmxlIG51bWJlcl92YWx1ZSA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQgPT09ICdudW1iZXJWYWx1ZScpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkJpdDY0KS5kb3VibGUobWVzc2FnZS5raW5kLm51bWJlclZhbHVlKTtcbiAgICAvKiBzdHJpbmcgc3RyaW5nX3ZhbHVlID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ3N0cmluZ1ZhbHVlJylcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5raW5kLnN0cmluZ1ZhbHVlKTtcbiAgICAvKiBib29sIGJvb2xfdmFsdWUgPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSAnYm9vbFZhbHVlJylcbiAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2Uua2luZC5ib29sVmFsdWUpO1xuICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3Qgc3RydWN0X3ZhbHVlID0gNTsgKi9cbiAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ3N0cnVjdFZhbHVlJylcbiAgICAgIFN0cnVjdC5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmtpbmQuc3RydWN0VmFsdWUsXG4gICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlIGxpc3RfdmFsdWUgPSA2OyAqL1xuICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSAnbGlzdFZhbHVlJylcbiAgICAgIExpc3RWYWx1ZS5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmtpbmQubGlzdFZhbHVlLFxuICAgICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZVxuICovXG5leHBvcnQgY29uc3QgVmFsdWUgPSBuZXcgVmFsdWUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgTGlzdFZhbHVlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxMaXN0VmFsdWU+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUnLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAndmFsdWVzJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICBUOiAoKSA9PiBWYWx1ZSxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuY29kZSBgTGlzdFZhbHVlYCB0byBKU09OIGFycmF5LlxuICAgKi9cbiAgaW50ZXJuYWxKc29uV3JpdGUobWVzc2FnZTogTGlzdFZhbHVlLCBvcHRpb25zOiBKc29uV3JpdGVPcHRpb25zKTogSnNvblZhbHVlIHtcbiAgICByZXR1cm4gbWVzc2FnZS52YWx1ZXMubWFwKCh2KSA9PiBWYWx1ZS50b0pzb24odikpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgYExpc3RWYWx1ZWAgZnJvbSBKU09OIGFycmF5LlxuICAgKi9cbiAgaW50ZXJuYWxKc29uUmVhZChcbiAgICBqc29uOiBKc29uVmFsdWUsXG4gICAgb3B0aW9uczogSnNvblJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IExpc3RWYWx1ZSxcbiAgKTogTGlzdFZhbHVlIHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAnVW5hYmxlIHRvIHBhcnNlICcgK1xuICAgICAgICAgIHRoaXMudHlwZU5hbWUgK1xuICAgICAgICAgICcgZnJvbSBKU09OICcgK1xuICAgICAgICAgIHR5cGVvZkpzb25WYWx1ZShqc29uKSxcbiAgICAgICk7XG4gICAgaWYgKCF0YXJnZXQpIHRhcmdldCA9IHRoaXMuY3JlYXRlKCk7XG4gICAgbGV0IHZhbHVlcyA9IGpzb24ubWFwKCh2KSA9PiBWYWx1ZS5mcm9tSnNvbih2KSk7XG4gICAgdGFyZ2V0LnZhbHVlcy5wdXNoKC4uLnZhbHVlcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxMaXN0VmFsdWU+KTogTGlzdFZhbHVlIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPExpc3RWYWx1ZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogTGlzdFZhbHVlLFxuICApOiBMaXN0VmFsdWUge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZSB2YWx1ZXMgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnZhbHVlcy5wdXNoKFxuICAgICAgICAgICAgVmFsdWUuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBMaXN0VmFsdWUsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIHZhbHVlcyA9IDE7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgIFZhbHVlLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UudmFsdWVzW2ldLFxuICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IExpc3RWYWx1ZSA9IG5ldyBMaXN0VmFsdWUkVHlwZSgpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9idWYtdHMgMi45LjMgd2l0aCBwYXJhbWV0ZXIgbG9uZ190eXBlX3N0cmluZyxjbGllbnRfZ2VuZXJpYyxzZXJ2ZXJfbm9uZSxlc2xpbnRfZGlzYWJsZVxuLy8gQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpbGUgXCJnb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvXCIgKHBhY2thZ2UgXCJnb29nbGUucHJvdG9idWZcIiwgc3ludGF4IHByb3RvMylcbi8vIHRzbGludDpkaXNhYmxlXG4vL1xuLy8gUHJvdG9jb2wgQnVmZmVycyAtIEdvb2dsZSdzIGRhdGEgaW50ZXJjaGFuZ2UgZm9ybWF0XG4vLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG5pbXBvcnQgdHlwZSB7XG4gIEJpbmFyeVJlYWRPcHRpb25zLFxuICBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gIElCaW5hcnlSZWFkZXIsXG4gIElCaW5hcnlXcml0ZXIsXG4gIEpzb25SZWFkT3B0aW9ucyxcbiAgSnNvblZhbHVlLFxuICBKc29uV3JpdGVPcHRpb25zLFxuICBQYXJ0aWFsTWVzc2FnZSxcbn0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuaW1wb3J0IHtcbiAgTWVzc2FnZVR5cGUsXG4gIFBiTG9uZyxcbiAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCxcbiAgdHlwZW9mSnNvblZhbHVlLFxuICBVbmtub3duRmllbGRIYW5kbGVyLFxuICBXaXJlVHlwZSxcbn0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuXG4vKipcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcbiAqIGNhbGVuZGFyLCBlbmNvZGVkIGFzIGEgY291bnQgb2Ygc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXRcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS5cbiAqXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxuICogc2Vjb25kIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24sIHVzaW5nIGEgWzI0LWhvdXIgbGluZWFyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXG4gKlxuICogVGhlIHJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLiBCeVxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgdGltZSgpYC5cbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModGltZShOVUxMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYGdldHRpbWVvZmRheSgpYC5cbiAqXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XG4gKiAgICAgZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHR2LnR2X3NlYyk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XG4gKlxuICogRXhhbXBsZSAzOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFdpbjMyIGBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgpYC5cbiAqXG4gKiAgICAgRklMRVRJTUUgZnQ7XG4gKiAgICAgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoJmZ0KTtcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XG4gKlxuICogICAgIC8vIEEgV2luZG93cyB0aWNrIGlzIDEwMCBuYW5vc2Vjb25kcy4gV2luZG93cyBlcG9jaCAxNjAxLTAxLTAxVDAwOjAwOjAwWlxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHMoKElOVDY0KSAoKHRpY2tzIC8gMTAwMDAwMDApIC0gMTE2NDQ0NzM2MDBMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XG4gKlxuICogRXhhbXBsZSA0OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpYC5cbiAqXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xuICpcbiAqXG4gKiBFeGFtcGxlIDU6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgSW5zdGFudC5ub3coKWAuXG4gKlxuICogICAgIEluc3RhbnQgbm93ID0gSW5zdGFudC5ub3coKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9XG4gKiAgICAgICAgIFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhub3cuZ2V0RXBvY2hTZWNvbmQoKSlcbiAqICAgICAgICAgICAgIC5zZXROYW5vcyhub3cuZ2V0TmFubygpKS5idWlsZCgpO1xuICpcbiAqXG4gKiBFeGFtcGxlIDY6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gY3VycmVudCB0aW1lIGluIFB5dGhvbi5cbiAqXG4gKiAgICAgdGltZXN0YW1wID0gVGltZXN0YW1wKClcbiAqICAgICB0aW1lc3RhbXAuR2V0Q3VycmVudFRpbWUoKVxuICpcbiAqICMgSlNPTiBNYXBwaW5nXG4gKlxuICogSW4gSlNPTiBmb3JtYXQsIHRoZSBUaW1lc3RhbXAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nIGluIHRoZVxuICogW1JGQyAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGZvcm1hdC4gVGhhdCBpcywgdGhlXG4gKiBmb3JtYXQgaXMgXCJ7eWVhcn0te21vbnRofS17ZGF5fVR7aG91cn06e21pbn06e3NlY31bLntmcmFjX3NlY31dWlwiXG4gKiB3aGVyZSB7eWVhcn0gaXMgYWx3YXlzIGV4cHJlc3NlZCB1c2luZyBmb3VyIGRpZ2l0cyB3aGlsZSB7bW9udGh9LCB7ZGF5fSxcbiAqIHtob3VyfSwge21pbn0sIGFuZCB7c2VjfSBhcmUgemVyby1wYWRkZWQgdG8gdHdvIGRpZ2l0cyBlYWNoLiBUaGUgZnJhY3Rpb25hbFxuICogc2Vjb25kcywgd2hpY2ggY2FuIGdvIHVwIHRvIDkgZGlnaXRzIChpLmUuIHVwIHRvIDEgbmFub3NlY29uZCByZXNvbHV0aW9uKSxcbiAqIGFyZSBvcHRpb25hbC4gVGhlIFwiWlwiIHN1ZmZpeCBpbmRpY2F0ZXMgdGhlIHRpbWV6b25lIChcIlVUQ1wiKTsgdGhlIHRpbWV6b25lXG4gKiBpcyByZXF1aXJlZC4gQSBwcm90bzMgSlNPTiBzZXJpYWxpemVyIHNob3VsZCBhbHdheXMgdXNlIFVUQyAoYXMgaW5kaWNhdGVkIGJ5XG4gKiBcIlpcIikgd2hlbiBwcmludGluZyB0aGUgVGltZXN0YW1wIHR5cGUgYW5kIGEgcHJvdG8zIEpTT04gcGFyc2VyIHNob3VsZCBiZVxuICogYWJsZSB0byBhY2NlcHQgYm90aCBVVEMgYW5kIG90aGVyIHRpbWV6b25lcyAoYXMgaW5kaWNhdGVkIGJ5IGFuIG9mZnNldCkuXG4gKlxuICogRm9yIGV4YW1wbGUsIFwiMjAxNy0wMS0xNVQwMTozMDoxNS4wMVpcIiBlbmNvZGVzIDE1LjAxIHNlY29uZHMgcGFzdFxuICogMDE6MzAgVVRDIG9uIEphbnVhcnkgMTUsIDIwMTcuXG4gKlxuICogSW4gSmF2YVNjcmlwdCwgb25lIGNhbiBjb252ZXJ0IGEgRGF0ZSBvYmplY3QgdG8gdGhpcyBmb3JtYXQgdXNpbmcgdGhlXG4gKiBzdGFuZGFyZFxuICogW3RvSVNPU3RyaW5nKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmcpXG4gKiBtZXRob2QuIEluIFB5dGhvbiwgYSBzdGFuZGFyZCBgZGF0ZXRpbWUuZGF0ZXRpbWVgIG9iamVjdCBjYW4gYmUgY29udmVydGVkXG4gKiB0byB0aGlzIGZvcm1hdCB1c2luZ1xuICogW2BzdHJmdGltZWBdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIvbGlicmFyeS90aW1lLmh0bWwjdGltZS5zdHJmdGltZSkgd2l0aFxuICogdGhlIHRpbWUgZm9ybWF0IHNwZWMgJyVZLSVtLSVkVCVIOiVNOiVTLiVmWicuIExpa2V3aXNlLCBpbiBKYXZhLCBvbmUgY2FuIHVzZVxuICogdGhlIEpvZGEgVGltZSdzIFtgSVNPRGF0ZVRpbWVGb3JtYXQuZGF0ZVRpbWUoKWBdKFxuICogaHR0cDovL3d3dy5qb2RhLm9yZy9qb2RhLXRpbWUvYXBpZG9jcy9vcmcvam9kYS90aW1lL2Zvcm1hdC9JU09EYXRlVGltZUZvcm1hdC5odG1sI2RhdGVUaW1lJTJEJTJEXG4gKiApIHRvIG9idGFpbiBhIGZvcm1hdHRlciBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGltZXN0YW1wcyBpbiB0aGlzIGZvcm1hdC5cbiAqXG4gKlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUaW1lc3RhbXAge1xuICAvKipcbiAgICogUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICogMTk3MC0wMS0wMVQwMDowMDowMFouIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICAgKiA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogaW50NjQgc2Vjb25kcyA9IDE7XG4gICAqL1xuICBzZWNvbmRzOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBOb24tbmVnYXRpdmUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gTmVnYXRpdmVcbiAgICogc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmUgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlc1xuICAgKiB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZSBmcm9tIDAgdG8gOTk5LDk5OSw5OTlcbiAgICogaW5jbHVzaXZlLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGludDMyIG5hbm9zID0gMjtcbiAgICovXG4gIG5hbm9zOiBudW1iZXI7XG59XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUaW1lc3RhbXAkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFRpbWVzdGFtcD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCcsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICdzZWNvbmRzJywga2luZDogJ3NjYWxhcicsIFQ6IDMgLypTY2FsYXJUeXBlLklOVDY0Ki8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICduYW5vcycsIGtpbmQ6ICdzY2FsYXInLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgXSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFRpbWVzdGFtcGAgZm9yIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBub3coKTogVGltZXN0YW1wIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IG1zID0gRGF0ZS5ub3coKTtcbiAgICBtc2cuc2Vjb25kcyA9IFBiTG9uZy5mcm9tKE1hdGguZmxvb3IobXMgLyAxMDAwKSkudG9TdHJpbmcoKTtcbiAgICBtc2cubmFub3MgPSAobXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgcmV0dXJuIG1zZztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIEphdmFTY3JpcHQgRGF0ZS5cbiAgICovXG4gIHRvRGF0ZShtZXNzYWdlOiBUaW1lc3RhbXApOiBEYXRlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICBQYkxvbmcuZnJvbShtZXNzYWdlLnNlY29uZHMpLnRvTnVtYmVyKCkgKiAxMDAwICtcbiAgICAgICAgTWF0aC5jZWlsKG1lc3NhZ2UubmFub3MgLyAxMDAwMDAwKSxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgRGF0ZSB0byBhIGBUaW1lc3RhbXBgLlxuICAgKi9cbiAgZnJvbURhdGUoZGF0ZTogRGF0ZSk6IFRpbWVzdGFtcCB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5jcmVhdGUoKTtcbiAgICBjb25zdCBtcyA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIG1zZy5zZWNvbmRzID0gUGJMb25nLmZyb20oTWF0aC5mbG9vcihtcyAvIDEwMDApKS50b1N0cmluZygpO1xuICAgIG1zZy5uYW5vcyA9IChtcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICByZXR1cm4gbXNnO1xuICB9XG4gIC8qKlxuICAgKiBJbiBKU09OIGZvcm1hdCwgdGhlIGBUaW1lc3RhbXBgIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZ1xuICAgKiBpbiB0aGUgUkZDIDMzMzkgZm9ybWF0LlxuICAgKi9cbiAgaW50ZXJuYWxKc29uV3JpdGUobWVzc2FnZTogVGltZXN0YW1wLCBvcHRpb25zOiBKc29uV3JpdGVPcHRpb25zKTogSnNvblZhbHVlIHtcbiAgICBsZXQgbXMgPSBQYkxvbmcuZnJvbShtZXNzYWdlLnNlY29uZHMpLnRvTnVtYmVyKCkgKiAxMDAwO1xuICAgIGlmIChcbiAgICAgIG1zIDwgRGF0ZS5wYXJzZSgnMDAwMS0wMS0wMVQwMDowMDowMFonKSB8fFxuICAgICAgbXMgPiBEYXRlLnBhcnNlKCc5OTk5LTEyLTMxVDIzOjU5OjU5WicpXG4gICAgKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5hYmxlIHRvIGVuY29kZSBUaW1lc3RhbXAgdG8gSlNPTi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS4nLFxuICAgICAgKTtcbiAgICBpZiAobWVzc2FnZS5uYW5vcyA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmFibGUgdG8gZW5jb2RlIGludmFsaWQgVGltZXN0YW1wIHRvIEpTT04uIE5hbm9zIG11c3Qgbm90IGJlIG5lZ2F0aXZlLicsXG4gICAgICApO1xuICAgIGxldCB6ID0gJ1onO1xuICAgIGlmIChtZXNzYWdlLm5hbm9zID4gMCkge1xuICAgICAgbGV0IG5hbm9zU3RyID0gKG1lc3NhZ2UubmFub3MgKyAxMDAwMDAwMDAwKS50b1N0cmluZygpLnN1YnN0cmluZygxKTtcbiAgICAgIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoMykgPT09ICcwMDAwMDAnKVxuICAgICAgICB6ID0gJy4nICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDMpICsgJ1onO1xuICAgICAgZWxzZSBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDYpID09PSAnMDAwJylcbiAgICAgICAgeiA9ICcuJyArIG5hbm9zU3RyLnN1YnN0cmluZygwLCA2KSArICdaJztcbiAgICAgIGVsc2UgeiA9ICcuJyArIG5hbm9zU3RyICsgJ1onO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnLjAwMFonLCB6KTtcbiAgfVxuICAvKipcbiAgICogSW4gSlNPTiBmb3JtYXQsIHRoZSBgVGltZXN0YW1wYCB0eXBlIGlzIGVuY29kZWQgYXMgYSBzdHJpbmdcbiAgICogaW4gdGhlIFJGQyAzMzM5IGZvcm1hdC5cbiAgICovXG4gIGludGVybmFsSnNvblJlYWQoXG4gICAganNvbjogSnNvblZhbHVlLFxuICAgIG9wdGlvbnM6IEpzb25SZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBUaW1lc3RhbXAsXG4gICk6IFRpbWVzdGFtcCB7XG4gICAgaWYgKHR5cGVvZiBqc29uICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuYWJsZSB0byBwYXJzZSBUaW1lc3RhbXAgZnJvbSBKU09OICcgKyB0eXBlb2ZKc29uVmFsdWUoanNvbikgKyAnLicsXG4gICAgICApO1xuICAgIGxldCBtYXRjaGVzID0ganNvbi5tYXRjaChcbiAgICAgIC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSlUKFswLTldezJ9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoPzpafFxcLihbMC05XXszLDl9KVp8KFsrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvLFxuICAgICk7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgVGltZXN0YW1wIGZyb20gSlNPTi4gSW52YWxpZCBmb3JtYXQuJyk7XG4gICAgbGV0IG1zID0gRGF0ZS5wYXJzZShcbiAgICAgIG1hdGNoZXNbMV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBtYXRjaGVzWzJdICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgbWF0Y2hlc1szXSArXG4gICAgICAgICdUJyArXG4gICAgICAgIG1hdGNoZXNbNF0gK1xuICAgICAgICAnOicgK1xuICAgICAgICBtYXRjaGVzWzVdICtcbiAgICAgICAgJzonICtcbiAgICAgICAgbWF0Y2hlc1s2XSArXG4gICAgICAgIChtYXRjaGVzWzhdID8gbWF0Y2hlc1s4XSA6ICdaJyksXG4gICAgKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG1zKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIFRpbWVzdGFtcCBmcm9tIEpTT04uIEludmFsaWQgdmFsdWUuJyk7XG4gICAgaWYgKFxuICAgICAgbXMgPCBEYXRlLnBhcnNlKCcwMDAxLTAxLTAxVDAwOjAwOjAwWicpIHx8XG4gICAgICBtcyA+IERhdGUucGFyc2UoJzk5OTktMTItMzFUMjM6NTk6NTlaJylcbiAgICApXG4gICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgJ1VuYWJsZSB0byBwYXJzZSBUaW1lc3RhbXAgZnJvbSBKU09OLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLicsXG4gICAgICApO1xuICAgIGlmICghdGFyZ2V0KSB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgIHRhcmdldC5zZWNvbmRzID0gUGJMb25nLmZyb20obXMgLyAxMDAwKS50b1N0cmluZygpO1xuICAgIHRhcmdldC5uYW5vcyA9IDA7XG4gICAgaWYgKG1hdGNoZXNbN10pXG4gICAgICB0YXJnZXQubmFub3MgPVxuICAgICAgICBwYXJzZUludCgnMScgKyBtYXRjaGVzWzddICsgJzAnLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtXG4gICAgICAgIDEwMDAwMDAwMDA7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxUaW1lc3RhbXA+KTogVGltZXN0YW1wIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2Uuc2Vjb25kcyA9ICcwJztcbiAgICBtZXNzYWdlLm5hbm9zID0gMDtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8VGltZXN0YW1wPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBUaW1lc3RhbXAsXG4gICk6IFRpbWVzdGFtcCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogaW50NjQgc2Vjb25kcyAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2Uuc2Vjb25kcyA9IHJlYWRlci5pbnQ2NCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogaW50MzIgbmFub3MgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLm5hbm9zID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFRpbWVzdGFtcCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBpbnQ2NCBzZWNvbmRzID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5zZWNvbmRzICE9PSAnMCcpXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50NjQobWVzc2FnZS5zZWNvbmRzKTtcbiAgICAvKiBpbnQzMiBuYW5vcyA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UubmFub3MgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5uYW5vcyk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcbiAqL1xuZXhwb3J0IGNvbnN0IFRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAkVHlwZSgpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9idWYtdHMgMi45LjMgd2l0aCBwYXJhbWV0ZXIgbG9uZ190eXBlX3N0cmluZyxjbGllbnRfZ2VuZXJpYyxzZXJ2ZXJfbm9uZSxlc2xpbnRfZGlzYWJsZVxuLy8gQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpbGUgXCJ2aWRlby9zZnUvbW9kZWxzL21vZGVscy5wcm90b1wiIChwYWNrYWdlIFwic3RyZWFtLnZpZGVvLnNmdS5tb2RlbHNcIiwgc3ludGF4IHByb3RvMylcbi8vIHRzbGludDpkaXNhYmxlXG5pbXBvcnQgdHlwZSB7XG4gIEJpbmFyeVJlYWRPcHRpb25zLFxuICBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gIElCaW5hcnlSZWFkZXIsXG4gIElCaW5hcnlXcml0ZXIsXG4gIFBhcnRpYWxNZXNzYWdlLFxufSBmcm9tICdAcHJvdG9idWYtdHMvcnVudGltZSc7XG5pbXBvcnQge1xuICBNZXNzYWdlVHlwZSxcbiAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCxcbiAgVW5rbm93bkZpZWxkSGFuZGxlcixcbiAgV2lyZVR5cGUsXG59IGZyb20gJ0Bwcm90b2J1Zi10cy9ydW50aW1lJztcbmltcG9ydCB7IFN0cnVjdCB9IGZyb20gJy4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QnO1xuaW1wb3J0IHsgVGltZXN0YW1wIH0gZnJvbSAnLi4vLi4vLi4vZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcCc7XG5cbi8qKlxuICogQ2FsbFN0YXRlIGlzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjYWxsXG4gKiBhcyBzZWVuIGJ5IGFuIFNGVS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsU3RhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsU3RhdGUge1xuICAvKipcbiAgICogcGFydGljaXBhbnRzIGlzIHRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY2FsbC5cbiAgICogSW4gbGFyZ2UgY2FsbHMsIHRoZSBsaXN0IGNvdWxkIGJlIHRydW5jYXRlZCBpbiB3aGljaFxuICAgKiBjYXNlLCB0aGUgbGlzdCBvZiBwYXJ0aWNpcGFudHMgY29udGFpbnMgZmV3ZXIgcGFydGljaXBhbnRzXG4gICAqIHRoYW4gdGhlIGNvdW50cyByZXR1cm5lZCBpbiBwYXJ0aWNpcGFudF9jb3VudC4gQW5vbnltb3VzXG4gICAqIHBhcnRpY2lwYW50cyBhcmUgKipOT1QqKiBpbmNsdWRlZCBpbiB0aGUgbGlzdC5cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudHMgPSAxO1xuICAgKi9cbiAgcGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudFtdO1xuICAvKipcbiAgICogc3RhcnRlZF9hdCBpcyB0aGUgdGltZSB0aGUgY2FsbCBzZXNzaW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBzdGFydGVkX2F0ID0gMjtcbiAgICovXG4gIHN0YXJ0ZWRBdD86IFRpbWVzdGFtcDtcbiAgLyoqXG4gICAqIHBhcnRpY2lwYW50X2NvdW50IGNvbnRhaW5zIHRoZSBzdW1tYXJ5IG9mIHRoZSBjb3VudHMuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCA9IDM7XG4gICAqL1xuICBwYXJ0aWNpcGFudENvdW50PzogUGFydGljaXBhbnRDb3VudDtcbiAgLyoqXG4gICAqIHRoZSBsaXN0IG9mIHBpbnMgaW4gdGhlIGNhbGwuXG4gICAqIFBpbnMgYXJlIG9yZGVyZWQgaW4gZGVzY2VuZGluZyBvcmRlciAobW9zdCBpbXBvcnRhbnQgZmlyc3QpLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zID0gNDtcbiAgICovXG4gIHBpbnM6IFBpbltdO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFydGljaXBhbnRDb3VudCB7XG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjYWxsIGluY2x1ZGluZ1xuICAgKiB0aGUgYW5vbnltb3VzIHBhcnRpY2lwYW50cy5cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiB1aW50MzIgdG90YWwgPSAxO1xuICAgKi9cbiAgdG90YWw6IG51bWJlcjtcbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGluIHRoZSBjYWxsLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHVpbnQzMiBhbm9ueW1vdXMgPSAyO1xuICAgKi9cbiAgYW5vbnltb3VzOiBudW1iZXI7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBpbiB7XG4gIC8qKlxuICAgKiB0aGUgdXNlciB0byBwaW5cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgdXNlcl9pZCA9IDE7XG4gICAqL1xuICB1c2VySWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIHRoZSB1c2VyIHNlc2lvbl9pZCB0byBwaW4sIGlmIG5vdCBwcm92aWRlZCwgYXBwbGllcyB0byBhbGwgc2Vzc2lvbnNcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7XG4gICAqL1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbn1cbi8qKlxuICogdGhvc2Ugd2hvIGFyZSBvbmxpbmUgaW4gdGhlIGNhbGxcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHVzZXJfaWQgPSAxO1xuICAgKi9cbiAgdXNlcklkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZXNzaW9uX2lkID0gMjtcbiAgICovXG4gIHNlc3Npb25JZDogc3RyaW5nO1xuICAvKipcbiAgICogbWFwIG9mIHRyYWNrIGlkIHRvIHRyYWNrIHR5cGVcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgcHVibGlzaGVkX3RyYWNrcyA9IDM7XG4gICAqL1xuICBwdWJsaXNoZWRUcmFja3M6IFRyYWNrVHlwZVtdO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGpvaW5lZF9hdCA9IDQ7XG4gICAqL1xuICBqb2luZWRBdD86IFRpbWVzdGFtcDtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHRyYWNrX2xvb2t1cF9wcmVmaXggPSA1O1xuICAgKi9cbiAgdHJhY2tMb29rdXBQcmVmaXg6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHkgY29ubmVjdGlvbl9xdWFsaXR5ID0gNjtcbiAgICovXG4gIGNvbm5lY3Rpb25RdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eTtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogYm9vbCBpc19zcGVha2luZyA9IDc7XG4gICAqL1xuICBpc1NwZWFraW5nOiBib29sZWFuO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBib29sIGlzX2RvbWluYW50X3NwZWFrZXIgPSA4O1xuICAgKi9cbiAgaXNEb21pbmFudFNwZWFrZXI6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGZsb2F0IGF1ZGlvX2xldmVsID0gOTtcbiAgICovXG4gIGF1ZGlvTGV2ZWw6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIG5hbWUgPSAxMDtcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIGltYWdlID0gMTE7XG4gICAqL1xuICBpbWFnZTogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBnb29nbGUucHJvdG9idWYuU3RydWN0IGN1c3RvbSA9IDEyO1xuICAgKi9cbiAgY3VzdG9tPzogU3RydWN0O1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgcm9sZXMgPSAxMztcbiAgICovXG4gIHJvbGVzOiBzdHJpbmdbXTtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU3RyZWFtUXVhbGl0eVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbVF1YWxpdHkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHkgdmlkZW9fcXVhbGl0eSA9IDE7XG4gICAqL1xuICB2aWRlb1F1YWxpdHk6IFZpZGVvUXVhbGl0eTtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHVzZXJfaWQgPSAyO1xuICAgKi9cbiAgdXNlcklkOiBzdHJpbmc7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9EaW1lbnNpb24ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiB1aW50MzIgd2lkdGggPSAxO1xuICAgKi9cbiAgd2lkdGg6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogdWludDMyIGhlaWdodCA9IDI7XG4gICAqL1xuICBoZWlnaHQ6IG51bWJlcjtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9MYXllclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvTGF5ZXIge1xuICAvKipcbiAgICogZm9yIHRyYWNrcyB3aXRoIGEgc2luZ2xlIGxheWVyLCB0aGlzIHNob3VsZCBiZSBISUdIXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHJpZCA9IDE7XG4gICAqL1xuICByaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24gdmlkZW9fZGltZW5zaW9uID0gMjtcbiAgICovXG4gIHZpZGVvRGltZW5zaW9uPzogVmlkZW9EaW1lbnNpb247XG4gIC8qKlxuICAgKiB0YXJnZXQgYml0cmF0ZSwgc2VydmVyIHdpbGwgbWVhc3VyZSBhY3R1YWxcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiB1aW50MzIgYml0cmF0ZSA9IDQ7XG4gICAqL1xuICBiaXRyYXRlOiBudW1iZXI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHVpbnQzMiBmcHMgPSA1O1xuICAgKi9cbiAgZnBzOiBudW1iZXI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSBxdWFsaXR5ID0gNjtcbiAgICovXG4gIHF1YWxpdHk6IFZpZGVvUXVhbGl0eTtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2RlYyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHVpbnQzMiBwYXlsb2FkX3R5cGUgPSAxO1xuICAgKi9cbiAgcGF5bG9hZFR5cGU6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIG5hbWUgPSAyO1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgZm10cF9saW5lID0gMztcbiAgICovXG4gIGZtdHBMaW5lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHVpbnQzMiBjbG9ja19yYXRlID0gNDtcbiAgICovXG4gIGNsb2NrUmF0ZTogbnVtYmVyO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgZW5jb2RpbmdfcGFyYW1ldGVycyA9IDU7XG4gICAqL1xuICBlbmNvZGluZ1BhcmFtZXRlcnM6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIGZlZWRiYWNrcyA9IDY7XG4gICAqL1xuICBmZWVkYmFja3M6IHN0cmluZ1tdO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNFVHJpY2tsZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDE7XG4gICAqL1xuICBwZWVyVHlwZTogUGVlclR5cGU7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBpY2VfY2FuZGlkYXRlID0gMjtcbiAgICovXG4gIGljZUNhbmRpZGF0ZTogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDM7XG4gICAqL1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tJbmZvIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHRyYWNrX2lkID0gMTtcbiAgICovXG4gIHRyYWNrSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgPSAyO1xuICAgKi9cbiAgdHJhY2tUeXBlOiBUcmFja1R5cGU7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvTGF5ZXIgbGF5ZXJzID0gNTtcbiAgICovXG4gIGxheWVyczogVmlkZW9MYXllcltdO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgbWlkID0gNjtcbiAgICovXG4gIG1pZDogc3RyaW5nO1xuICAvKipcbiAgICogZm9yIGF1ZGlvIHRyYWNrc1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGJvb2wgZHR4ID0gNztcbiAgICovXG4gIGR0eDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogYm9vbCBzdGVyZW8gPSA4O1xuICAgKi9cbiAgc3RlcmVvOiBib29sZWFuO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBib29sIHJlZCA9IDk7XG4gICAqL1xuICByZWQ6IGJvb2xlYW47XG59XG4vKipcbiAqIHRvZG8gcmVtb3ZlIHRoaXNcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbCB7XG4gIC8qKlxuICAgKiB0aGUgY2FsbCB0eXBlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHR5cGUgPSAxO1xuICAgKi9cbiAgdHlwZTogc3RyaW5nO1xuICAvKipcbiAgICogdGhlIGNhbGwgaWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgaWQgPSAyO1xuICAgKi9cbiAgaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIHRoZSBpZCBvZiB0aGUgdXNlciB0aGF0IGNyZWF0ZWQgdGhpcyBjYWxsXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIGNyZWF0ZWRfYnlfdXNlcl9pZCA9IDM7XG4gICAqL1xuICBjcmVhdGVkQnlVc2VySWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIHRoZSBpZCBvZiB0aGUgY3VycmVudCBob3N0IGZvciB0aGlzIGNhbGxcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgaG9zdF91c2VyX2lkID0gNDtcbiAgICovXG4gIGhvc3RVc2VySWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBjdXN0b20gPSA1O1xuICAgKi9cbiAgY3VzdG9tPzogU3RydWN0O1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGNyZWF0ZWRfYXQgPSA2O1xuICAgKi9cbiAgY3JlYXRlZEF0PzogVGltZXN0YW1wO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHVwZGF0ZWRfYXQgPSA3O1xuICAgKi9cbiAgdXBkYXRlZEF0PzogVGltZXN0YW1wO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlIGNvZGUgPSAxO1xuICAgKi9cbiAgY29kZTogRXJyb3JDb2RlO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgbWVzc2FnZSA9IDI7XG4gICAqL1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGJvb2wgc2hvdWxkX3JldHJ5ID0gMztcbiAgICovXG4gIHNob3VsZFJldHJ5OiBib29sZWFuO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DbGllbnREZXRhaWxzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50RGV0YWlscyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNkayBzZGsgPSAxO1xuICAgKi9cbiAgc2RrPzogU2RrO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUyBvcyA9IDI7XG4gICAqL1xuICBvcz86IE9TO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Ccm93c2VyIGJyb3dzZXIgPSAzO1xuICAgKi9cbiAgYnJvd3Nlcj86IEJyb3dzZXI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkRldmljZSBkZXZpY2UgPSA0O1xuICAgKi9cbiAgZGV2aWNlPzogRGV2aWNlO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZGsge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlIHR5cGUgPSAxO1xuICAgKi9cbiAgdHlwZTogU2RrVHlwZTtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIG1ham9yID0gMjtcbiAgICovXG4gIG1ham9yOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBtaW5vciA9IDM7XG4gICAqL1xuICBtaW5vcjogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgcGF0Y2ggPSA0O1xuICAgKi9cbiAgcGF0Y2g6IHN0cmluZztcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuT1NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPUyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBuYW1lID0gMTtcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHZlcnNpb24gPSAyO1xuICAgKi9cbiAgdmVyc2lvbjogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgYXJjaGl0ZWN0dXJlID0gMztcbiAgICovXG4gIGFyY2hpdGVjdHVyZTogc3RyaW5nO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Ccm93c2VyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3NlciB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBuYW1lID0gMTtcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHZlcnNpb24gPSAyO1xuICAgKi9cbiAgdmVyc2lvbjogc3RyaW5nO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5EZXZpY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXZpY2Uge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDE7XG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyB2ZXJzaW9uID0gMjtcbiAgICovXG4gIHZlcnNpb246IHN0cmluZztcbn1cbi8qKlxuICogQ2FsbEdyYW50cyByZXByZXNlbnRzIHRoZSBzZXQgb2YgcGVybWlzc2lvbnMgZ2l2ZW5cbiAqIHRvIHRoZSB1c2VyIGZvciB0aGUgY3VycmVudCBjYWxsLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxHcmFudHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxsR3JhbnRzIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogYm9vbCBjYW5fcHVibGlzaF9hdWRpbyA9IDE7XG4gICAqL1xuICBjYW5QdWJsaXNoQXVkaW86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGJvb2wgY2FuX3B1Ymxpc2hfdmlkZW8gPSAyO1xuICAgKi9cbiAgY2FuUHVibGlzaFZpZGVvOiBib29sZWFuO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBib29sIGNhbl9zY3JlZW5zaGFyZSA9IDM7XG4gICAqL1xuICBjYW5TY3JlZW5zaGFyZTogYm9vbGVhbjtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGVcbiAqL1xuZXhwb3J0IGVudW0gUGVlclR5cGUge1xuICAvKipcbiAgICogdG9kbyBmaXggbWUgKG1hcmNlbG8pXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBQRUVSX1RZUEVfUFVCTElTSEVSX1VOU1BFQ0lGSUVEID0gMDtcbiAgICovXG4gIFBVQkxJU0hFUl9VTlNQRUNJRklFRCA9IDAsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogUEVFUl9UWVBFX1NVQlNDUklCRVIgPSAxO1xuICAgKi9cbiAgU1VCU0NSSUJFUiA9IDEsXG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5XG4gKi9cbmV4cG9ydCBlbnVtIENvbm5lY3Rpb25RdWFsaXR5IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBDT05ORUNUSU9OX1FVQUxJVFlfVU5TUEVDSUZJRUQgPSAwO1xuICAgKi9cbiAgVU5TUEVDSUZJRUQgPSAwLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IENPTk5FQ1RJT05fUVVBTElUWV9QT09SID0gMTtcbiAgICovXG4gIFBPT1IgPSAxLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IENPTk5FQ1RJT05fUVVBTElUWV9HT09EID0gMjtcbiAgICovXG4gIEdPT0QgPSAyLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IENPTk5FQ1RJT05fUVVBTElUWV9FWENFTExFTlQgPSAzO1xuICAgKi9cbiAgRVhDRUxMRU5UID0gMyxcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9RdWFsaXR5XG4gKi9cbmV4cG9ydCBlbnVtIFZpZGVvUXVhbGl0eSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVklERU9fUVVBTElUWV9MT1dfVU5TUEVDSUZJRUQgPSAwO1xuICAgKi9cbiAgTE9XX1VOU1BFQ0lGSUVEID0gMCxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBWSURFT19RVUFMSVRZX01JRCA9IDE7XG4gICAqL1xuICBNSUQgPSAxLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFZJREVPX1FVQUxJVFlfSElHSCA9IDI7XG4gICAqL1xuICBISUdIID0gMixcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBWSURFT19RVUFMSVRZX09GRiA9IDM7XG4gICAqL1xuICBPRkYgPSAzLFxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGVcbiAqL1xuZXhwb3J0IGVudW0gVHJhY2tUeXBlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX1VOU1BFQ0lGSUVEID0gMDtcbiAgICovXG4gIFVOU1BFQ0lGSUVEID0gMCxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX0FVRElPID0gMTtcbiAgICovXG4gIEFVRElPID0gMSxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX1ZJREVPID0gMjtcbiAgICovXG4gIFZJREVPID0gMixcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX1NDUkVFTl9TSEFSRSA9IDM7XG4gICAqL1xuICBTQ1JFRU5fU0hBUkUgPSAzLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFX0FVRElPID0gNDtcbiAgICovXG4gIFNDUkVFTl9TSEFSRV9BVURJTyA9IDQsXG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yQ29kZVxuICovXG5leHBvcnQgZW51bSBFcnJvckNvZGUge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfVU5TUEVDSUZJRUQgPSAwO1xuICAgKi9cbiAgVU5TUEVDSUZJRUQgPSAwLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUFVCTElTSF9UUkFDS19OT1RfRk9VTkQgPSAxMDA7XG4gICAqL1xuICBQVUJMSVNIX1RSQUNLX05PVF9GT1VORCA9IDEwMCxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BVQkxJU0hfVFJBQ0tTX01JU01BVENIID0gMTAxO1xuICAgKi9cbiAgUFVCTElTSF9UUkFDS1NfTUlTTUFUQ0ggPSAxMDEsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QVUJMSVNIX1RSQUNLX09VVF9PRl9PUkRFUiA9IDEwMjtcbiAgICovXG4gIFBVQkxJU0hfVFJBQ0tfT1VUX09GX09SREVSID0gMTAyLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUFVCTElTSF9UUkFDS19WSURFT19MQVlFUl9OT1RfRk9VTkQgPSAxMDM7XG4gICAqL1xuICBQVUJMSVNIX1RSQUNLX1ZJREVPX0xBWUVSX05PVF9GT1VORCA9IDEwMyxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX0xJVkVfRU5ERUQgPSAxMDQ7XG4gICAqL1xuICBMSVZFX0VOREVEID0gMTA0LFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTk9UX0ZPVU5EID0gMjAwO1xuICAgKi9cbiAgUEFSVElDSVBBTlRfTk9UX0ZPVU5EID0gMjAwLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTUlHUkFUSU5HX09VVCA9IDIwMTtcbiAgICovXG4gIFBBUlRJQ0lQQU5UX01JR1JBVElOR19PVVQgPSAyMDEsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QQVJUSUNJUEFOVF9NSUdSQVRJT05fRkFJTEVEID0gMjAyO1xuICAgKi9cbiAgUEFSVElDSVBBTlRfTUlHUkFUSU9OX0ZBSUxFRCA9IDIwMixcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX01JR1JBVElORyA9IDIwMztcbiAgICovXG4gIFBBUlRJQ0lQQU5UX01JR1JBVElORyA9IDIwMyxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX1JFQ09OTkVDVF9GQUlMRUQgPSAyMDQ7XG4gICAqL1xuICBQQVJUSUNJUEFOVF9SRUNPTk5FQ1RfRkFJTEVEID0gMjA0LFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTUVESUFfVFJBTlNQT1JUX0ZBSUxVUkUgPSAyMDU7XG4gICAqL1xuICBQQVJUSUNJUEFOVF9NRURJQV9UUkFOU1BPUlRfRkFJTFVSRSA9IDIwNSxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX0NBTExfTk9UX0ZPVU5EID0gMzAwO1xuICAgKi9cbiAgQ0FMTF9OT1RfRk9VTkQgPSAzMDAsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9SRVFVRVNUX1ZBTElEQVRJT05fRkFJTEVEID0gNDAwO1xuICAgKi9cbiAgUkVRVUVTVF9WQUxJREFUSU9OX0ZBSUxFRCA9IDQwMCxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1VOQVVUSEVOVElDQVRFRCA9IDQwMTtcbiAgICovXG4gIFVOQVVUSEVOVElDQVRFRCA9IDQwMSxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BFUk1JU1NJT05fREVOSUVEID0gNDAzO1xuICAgKi9cbiAgUEVSTUlTU0lPTl9ERU5JRUQgPSA0MDMsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9UT09fTUFOWV9SRVFVRVNUUyA9IDQyOTtcbiAgICovXG4gIFRPT19NQU5ZX1JFUVVFU1RTID0gNDI5LFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfSU5URVJOQUxfU0VSVkVSX0VSUk9SID0gNTAwO1xuICAgKi9cbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SID0gNTAwLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfU0ZVX1NIVVRUSU5HX0RPV04gPSA2MDA7XG4gICAqL1xuICBTRlVfU0hVVFRJTkdfRE9XTiA9IDYwMCxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1NGVV9GVUxMID0gNzAwO1xuICAgKi9cbiAgU0ZVX0ZVTEwgPSA3MDAsXG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNka1R5cGVcbiAqL1xuZXhwb3J0IGVudW0gU2RrVHlwZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfVU5TUEVDSUZJRUQgPSAwO1xuICAgKi9cbiAgVU5TUEVDSUZJRUQgPSAwLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX1JFQUNUID0gMTtcbiAgICovXG4gIFJFQUNUID0gMSxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9BTkdVTEFSID0gMjtcbiAgICovXG4gIEFOR1VMQVIgPSAyLFxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX0FORFJPSUQgPSAzO1xuICAgKi9cbiAgQU5EUk9JRCA9IDMsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfSU9TID0gNDtcbiAgICovXG4gIElPUyA9IDQsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfRkxVVFRFUiA9IDU7XG4gICAqL1xuICBGTFVUVEVSID0gNSxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9SRUFDVF9OQVRJVkUgPSA2O1xuICAgKi9cbiAgUkVBQ1RfTkFUSVZFID0gNixcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9VTklUWSA9IDc7XG4gICAqL1xuICBVTklUWSA9IDcsXG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVW5wdWJsaXNoUmVhc29uXG4gKi9cbmV4cG9ydCBlbnVtIFRyYWNrVW5wdWJsaXNoUmVhc29uIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWUgd2hpY2ggaXMgdXNlZCB3aGVuIHRoZSBzcGVjaWZpYyByZWFzb25cbiAgICogZm9yIG11dGluZyB0aGUgdHJhY2sgaXMgbm90IGtub3duLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl9VTlNQRUNJRklFRCA9IDA7XG4gICAqL1xuICBVTlNQRUNJRklFRCA9IDAsXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIHVzZXIgbXV0aW5nIHRoZWlyIHRyYWNrcy5cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1VOUFVCTElTSF9SRUFTT05fVVNFUl9NVVRFRCA9IDE7XG4gICAqL1xuICBVU0VSX01VVEVEID0gMSxcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgbXV0aW5nIHRoZSB0cmFjayBiZWNhdXNlIHRoZSBwZXJtaXNzaW9uIHRvXG4gICAqIHB1Ymxpc2ggdGhlIHRyYWNrIGhhcyBiZWVuIHJldm9rZWQuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19VTlBVQkxJU0hfUkVBU09OX1BFUk1JU1NJT05fUkVWT0tFRCA9IDI7XG4gICAqL1xuICBQRVJNSVNTSU9OX1JFVk9LRUQgPSAyLFxuICAvKipcbiAgICogUmVwcmVzZW50cyBtdXRpbmcgdGhlIHRyYWNrIGR1ZSB0byBtb2RlcmF0aW9uIGFjdGlvbnMuXG4gICAqIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gcGVybWlzc2lvbiByZXZva2VkIGJlY2F1c2UgdGhlXG4gICAqIHBhcnRpY2lwYW50IGNhbiB1bm11dGUgdGhlbXNlbHZlcyBoZXJlIHdoZXJlYXMgaW4gY2FzZVxuICAgKiBvZiBcInBlcm1pc3Npb24gcmV2b2tlXCIgaXQgaXMgbm90IHBvc3NpYmxlIHVudGlsIHRoZVxuICAgKiBjYWxsIHBlcm1pc3Npb25zIGFyZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl9NT0RFUkFUSU9OID0gMztcbiAgICovXG4gIE1PREVSQVRJT04gPSAzLFxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Hb0F3YXlSZWFzb25cbiAqL1xuZXhwb3J0IGVudW0gR29Bd2F5UmVhc29uIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBHT19BV0FZX1JFQVNPTl9VTlNQRUNJRklFRCA9IDA7XG4gICAqL1xuICBVTlNQRUNJRklFRCA9IDAsXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogR09fQVdBWV9SRUFTT05fU0hVVFRJTkdfRE9XTiA9IDE7XG4gICAqL1xuICBTSFVUVElOR19ET1dOID0gMSxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBHT19BV0FZX1JFQVNPTl9SRUJBTEFOQ0UgPSAyO1xuICAgKi9cbiAgUkVCQUxBTkNFID0gMixcbn1cbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENhbGxTdGF0ZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8Q2FsbFN0YXRlPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsU3RhdGUnLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAncGFydGljaXBhbnRzJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICBUOiAoKSA9PiBQYXJ0aWNpcGFudCxcbiAgICAgIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnc3RhcnRlZF9hdCcsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gVGltZXN0YW1wIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAncGFydGljaXBhbnRfY291bnQnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIFQ6ICgpID0+IFBhcnRpY2lwYW50Q291bnQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNCxcbiAgICAgICAgbmFtZTogJ3BpbnMnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgIFQ6ICgpID0+IFBpbixcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8Q2FsbFN0YXRlPik6IENhbGxTdGF0ZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgIG1lc3NhZ2UucGlucyA9IFtdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxDYWxsU3RhdGU+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IENhbGxTdGF0ZSxcbiAgKTogQ2FsbFN0YXRlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudHMgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50cy5wdXNoKFxuICAgICAgICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgc3RhcnRlZF9hdCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2Uuc3RhcnRlZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLnN0YXJ0ZWRBdCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50Q291bnQgcGFydGljaXBhbnRfY291bnQgKi8gMzpcbiAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQgPSBQYXJ0aWNpcGFudENvdW50LmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QaW4gcGlucyAqLyA0OlxuICAgICAgICAgIG1lc3NhZ2UucGlucy5wdXNoKFxuICAgICAgICAgICAgUGluLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogQ2FsbFN0YXRlLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50cyA9IDE7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBhcnRpY2lwYW50cy5sZW5ndGg7IGkrKylcbiAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRzW2ldLFxuICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBzdGFydGVkX2F0ID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5zdGFydGVkQXQpXG4gICAgICBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5zdGFydGVkQXQsXG4gICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50IHBhcnRpY2lwYW50X2NvdW50ID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudENvdW50KVxuICAgICAgUGFydGljaXBhbnRDb3VudC5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQsXG4gICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QaW4gcGlucyA9IDQ7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBpbnMubGVuZ3RoOyBpKyspXG4gICAgICBQaW4uaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5waW5zW2ldLFxuICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZVxuICovXG5leHBvcnQgY29uc3QgQ2FsbFN0YXRlID0gbmV3IENhbGxTdGF0ZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBQYXJ0aWNpcGFudENvdW50JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxQYXJ0aWNpcGFudENvdW50PiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50JywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3RvdGFsJywga2luZDogJ3NjYWxhcicsIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ2Fub255bW91cycsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxQYXJ0aWNpcGFudENvdW50Pik6IFBhcnRpY2lwYW50Q291bnQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS50b3RhbCA9IDA7XG4gICAgbWVzc2FnZS5hbm9ueW1vdXMgPSAwO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxQYXJ0aWNpcGFudENvdW50Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBQYXJ0aWNpcGFudENvdW50LFxuICApOiBQYXJ0aWNpcGFudENvdW50IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiB1aW50MzIgdG90YWwgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnRvdGFsID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHVpbnQzMiBhbm9ueW1vdXMgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLmFub255bW91cyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogUGFydGljaXBhbnRDb3VudCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiB1aW50MzIgdG90YWwgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnRvdGFsICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLnRvdGFsKTtcbiAgICAvKiB1aW50MzIgYW5vbnltb3VzID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5hbm9ueW1vdXMgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuYW5vbnltb3VzKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudFxuICovXG5leHBvcnQgY29uc3QgUGFydGljaXBhbnRDb3VudCA9IG5ldyBQYXJ0aWNpcGFudENvdW50JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFBpbiRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8UGluPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QaW4nLCBbXG4gICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxQaW4+KTogUGluIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxQaW4+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFBpbixcbiAgKTogUGluIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFBpbixcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UudXNlcklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS51c2VySWQpO1xuICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpblxuICovXG5leHBvcnQgY29uc3QgUGluID0gbmV3IFBpbiRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBQYXJ0aWNpcGFudCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8UGFydGljaXBhbnQ+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50JywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAncHVibGlzaGVkX3RyYWNrcycsXG4gICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUnLFxuICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDQsIG5hbWU6ICdqb2luZWRfYXQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFRpbWVzdGFtcCB9LFxuICAgICAge1xuICAgICAgICBubzogNSxcbiAgICAgICAgbmFtZTogJ3RyYWNrX2xvb2t1cF9wcmVmaXgnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNixcbiAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eScsXG4gICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db25uZWN0aW9uUXVhbGl0eScsXG4gICAgICAgICAgQ29ubmVjdGlvblF1YWxpdHksXG4gICAgICAgICAgJ0NPTk5FQ1RJT05fUVVBTElUWV8nLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDcsIG5hbWU6ICdpc19zcGVha2luZycsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDgsXG4gICAgICAgIG5hbWU6ICdpc19kb21pbmFudF9zcGVha2VyJyxcbiAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyxcbiAgICAgIH0sXG4gICAgICB7IG5vOiA5LCBuYW1lOiAnYXVkaW9fbGV2ZWwnLCBraW5kOiAnc2NhbGFyJywgVDogMiAvKlNjYWxhclR5cGUuRkxPQVQqLyB9LFxuICAgICAgeyBubzogMTAsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAxMSwgbmFtZTogJ2ltYWdlJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAxMiwgbmFtZTogJ2N1c3RvbScsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gU3RydWN0IH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAxMyxcbiAgICAgICAgbmFtZTogJ3JvbGVzJyxcbiAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgIHJlcGVhdDogMiAvKlJlcGVhdFR5cGUuVU5QQUNLRUQqLyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFBhcnRpY2lwYW50Pik6IFBhcnRpY2lwYW50IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICBtZXNzYWdlLnB1Ymxpc2hlZFRyYWNrcyA9IFtdO1xuICAgIG1lc3NhZ2UudHJhY2tMb29rdXBQcmVmaXggPSAnJztcbiAgICBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ID0gMDtcbiAgICBtZXNzYWdlLmlzU3BlYWtpbmcgPSBmYWxzZTtcbiAgICBtZXNzYWdlLmlzRG9taW5hbnRTcGVha2VyID0gZmFsc2U7XG4gICAgbWVzc2FnZS5hdWRpb0xldmVsID0gMDtcbiAgICBtZXNzYWdlLm5hbWUgPSAnJztcbiAgICBtZXNzYWdlLmltYWdlID0gJyc7XG4gICAgbWVzc2FnZS5yb2xlcyA9IFtdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxQYXJ0aWNpcGFudD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogUGFydGljaXBhbnQsXG4gICk6IFBhcnRpY2lwYW50IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHB1Ymxpc2hlZF90cmFja3MgKi8gMzpcbiAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSByZWFkZXIuaW50MzIoKSArIHJlYWRlci5wb3M7IHJlYWRlci5wb3MgPCBlOyApXG4gICAgICAgICAgICAgIG1lc3NhZ2UucHVibGlzaGVkVHJhY2tzLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgIGVsc2UgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBqb2luZWRfYXQgKi8gNDpcbiAgICAgICAgICBtZXNzYWdlLmpvaW5lZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmpvaW5lZEF0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHRyYWNrX2xvb2t1cF9wcmVmaXggKi8gNTpcbiAgICAgICAgICBtZXNzYWdlLnRyYWNrTG9va3VwUHJlZml4ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5IGNvbm5lY3Rpb25fcXVhbGl0eSAqLyA2OlxuICAgICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIGlzX3NwZWFraW5nICovIDc6XG4gICAgICAgICAgbWVzc2FnZS5pc1NwZWFraW5nID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIGlzX2RvbWluYW50X3NwZWFrZXIgKi8gODpcbiAgICAgICAgICBtZXNzYWdlLmlzRG9taW5hbnRTcGVha2VyID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBmbG9hdCBhdWRpb19sZXZlbCAqLyA5OlxuICAgICAgICAgIG1lc3NhZ2UuYXVkaW9MZXZlbCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBuYW1lICovIDEwOlxuICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgaW1hZ2UgKi8gMTE6XG4gICAgICAgICAgbWVzc2FnZS5pbWFnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuU3RydWN0IGN1c3RvbSAqLyAxMjpcbiAgICAgICAgICBtZXNzYWdlLmN1c3RvbSA9IFN0cnVjdC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5jdXN0b20sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJpbmcgcm9sZXMgKi8gMTM6XG4gICAgICAgICAgbWVzc2FnZS5yb2xlcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFBhcnRpY2lwYW50LFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgcHVibGlzaGVkX3RyYWNrcyA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UucHVibGlzaGVkVHJhY2tzLmxlbmd0aCkge1xuICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHdyaXRlci5pbnQzMihtZXNzYWdlLnB1Ymxpc2hlZFRyYWNrc1tpXSk7XG4gICAgICB3cml0ZXIuam9pbigpO1xuICAgIH1cbiAgICAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGpvaW5lZF9hdCA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2Uuam9pbmVkQXQpXG4gICAgICBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5qb2luZWRBdCxcbiAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmluZyB0cmFja19sb29rdXBfcHJlZml4ID0gNTsgKi9cbiAgICBpZiAobWVzc2FnZS50cmFja0xvb2t1cFByZWZpeCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHJhY2tMb29rdXBQcmVmaXgpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5IGNvbm5lY3Rpb25fcXVhbGl0eSA9IDY7ICovXG4gICAgaWYgKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgLyogYm9vbCBpc19zcGVha2luZyA9IDc7ICovXG4gICAgaWYgKG1lc3NhZ2UuaXNTcGVha2luZyAhPT0gZmFsc2UpXG4gICAgICB3cml0ZXIudGFnKDcsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmlzU3BlYWtpbmcpO1xuICAgIC8qIGJvb2wgaXNfZG9taW5hbnRfc3BlYWtlciA9IDg7ICovXG4gICAgaWYgKG1lc3NhZ2UuaXNEb21pbmFudFNwZWFrZXIgIT09IGZhbHNlKVxuICAgICAgd3JpdGVyLnRhZyg4LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5pc0RvbWluYW50U3BlYWtlcik7XG4gICAgLyogZmxvYXQgYXVkaW9fbGV2ZWwgPSA5OyAqL1xuICAgIGlmIChtZXNzYWdlLmF1ZGlvTGV2ZWwgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDksIFdpcmVUeXBlLkJpdDMyKS5mbG9hdChtZXNzYWdlLmF1ZGlvTGV2ZWwpO1xuICAgIC8qIHN0cmluZyBuYW1lID0gMTA7ICovXG4gICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDEwLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgIC8qIHN0cmluZyBpbWFnZSA9IDExOyAqL1xuICAgIGlmIChtZXNzYWdlLmltYWdlICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMTEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaW1hZ2UpO1xuICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tID0gMTI7ICovXG4gICAgaWYgKG1lc3NhZ2UuY3VzdG9tKVxuICAgICAgU3RydWN0LmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuY3VzdG9tLFxuICAgICAgICB3cml0ZXIudGFnKDEyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHJlcGVhdGVkIHN0cmluZyByb2xlcyA9IDEzOyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5yb2xlcy5sZW5ndGg7IGkrKylcbiAgICAgIHdyaXRlci50YWcoMTMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uucm9sZXNbaV0pO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudFxuICovXG5leHBvcnQgY29uc3QgUGFydGljaXBhbnQgPSBuZXcgUGFydGljaXBhbnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU3RyZWFtUXVhbGl0eSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8U3RyZWFtUXVhbGl0eT4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU3RyZWFtUXVhbGl0eScsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICd2aWRlb19xdWFsaXR5JyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eScsXG4gICAgICAgICAgVmlkZW9RdWFsaXR5LFxuICAgICAgICAgICdWSURFT19RVUFMSVRZXycsXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxTdHJlYW1RdWFsaXR5Pik6IFN0cmVhbVF1YWxpdHkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS52aWRlb1F1YWxpdHkgPSAwO1xuICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFN0cmVhbVF1YWxpdHk+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFN0cmVhbVF1YWxpdHksXG4gICk6IFN0cmVhbVF1YWxpdHkge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSB2aWRlb19xdWFsaXR5ICovIDE6XG4gICAgICAgICAgbWVzc2FnZS52aWRlb1F1YWxpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBTdHJlYW1RdWFsaXR5LFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSB2aWRlb19xdWFsaXR5ID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS52aWRlb1F1YWxpdHkgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS52aWRlb1F1YWxpdHkpO1xuICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlN0cmVhbVF1YWxpdHlcbiAqL1xuZXhwb3J0IGNvbnN0IFN0cmVhbVF1YWxpdHkgPSBuZXcgU3RyZWFtUXVhbGl0eSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb0RpbWVuc2lvbiRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8VmlkZW9EaW1lbnNpb24+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3dpZHRoJywga2luZDogJ3NjYWxhcicsIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ2hlaWdodCcsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxWaWRlb0RpbWVuc2lvbj4pOiBWaWRlb0RpbWVuc2lvbiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLndpZHRoID0gMDtcbiAgICBtZXNzYWdlLmhlaWdodCA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFZpZGVvRGltZW5zaW9uPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBWaWRlb0RpbWVuc2lvbixcbiAgKTogVmlkZW9EaW1lbnNpb24ge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHVpbnQzMiB3aWR0aCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogdWludDMyIGhlaWdodCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBWaWRlb0RpbWVuc2lvbixcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiB1aW50MzIgd2lkdGggPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLndpZHRoICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLndpZHRoKTtcbiAgICAvKiB1aW50MzIgaGVpZ2h0ID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5oZWlnaHQgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb25cbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvRGltZW5zaW9uID0gbmV3IFZpZGVvRGltZW5zaW9uJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvTGF5ZXIkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFZpZGVvTGF5ZXI+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvTGF5ZXInLCBbXG4gICAgICB7IG5vOiAxLCBuYW1lOiAncmlkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAyLFxuICAgICAgICBuYW1lOiAndmlkZW9fZGltZW5zaW9uJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBUOiAoKSA9PiBWaWRlb0RpbWVuc2lvbixcbiAgICAgIH0sXG4gICAgICB7IG5vOiA0LCBuYW1lOiAnYml0cmF0ZScsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgIHsgbm86IDUsIG5hbWU6ICdmcHMnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA2LFxuICAgICAgICBuYW1lOiAncXVhbGl0eScsXG4gICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHknLFxuICAgICAgICAgIFZpZGVvUXVhbGl0eSxcbiAgICAgICAgICAnVklERU9fUVVBTElUWV8nLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxWaWRlb0xheWVyPik6IFZpZGVvTGF5ZXIge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5yaWQgPSAnJztcbiAgICBtZXNzYWdlLmJpdHJhdGUgPSAwO1xuICAgIG1lc3NhZ2UuZnBzID0gMDtcbiAgICBtZXNzYWdlLnF1YWxpdHkgPSAwO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxWaWRlb0xheWVyPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBWaWRlb0xheWVyLFxuICApOiBWaWRlb0xheWVyIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgcmlkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5yaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24gdmlkZW9fZGltZW5zaW9uICovIDI6XG4gICAgICAgICAgbWVzc2FnZS52aWRlb0RpbWVuc2lvbiA9IFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLnZpZGVvRGltZW5zaW9uLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogdWludDMyIGJpdHJhdGUgKi8gNDpcbiAgICAgICAgICBtZXNzYWdlLmJpdHJhdGUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogdWludDMyIGZwcyAqLyA1OlxuICAgICAgICAgIG1lc3NhZ2UuZnBzID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSBxdWFsaXR5ICovIDY6XG4gICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFZpZGVvTGF5ZXIsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyaW5nIHJpZCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UucmlkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5yaWQpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uIHZpZGVvX2RpbWVuc2lvbiA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UudmlkZW9EaW1lbnNpb24pXG4gICAgICBWaWRlb0RpbWVuc2lvbi5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLnZpZGVvRGltZW5zaW9uLFxuICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogdWludDMyIGJpdHJhdGUgPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLmJpdHJhdGUgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuYml0cmF0ZSk7XG4gICAgLyogdWludDMyIGZwcyA9IDU7ICovXG4gICAgaWYgKG1lc3NhZ2UuZnBzICE9PSAwKSB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuZnBzKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHkgcXVhbGl0eSA9IDY7ICovXG4gICAgaWYgKG1lc3NhZ2UucXVhbGl0eSAhPT0gMClcbiAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnF1YWxpdHkpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb0xheWVyID0gbmV3IFZpZGVvTGF5ZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ29kZWMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPENvZGVjPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYycsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdwYXlsb2FkX3R5cGUnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAzLCBuYW1lOiAnZm10cF9saW5lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA0LFxuICAgICAgICBuYW1lOiAnY2xvY2tfcmF0ZScsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNSxcbiAgICAgICAgbmFtZTogJ2VuY29kaW5nX3BhcmFtZXRlcnMnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNixcbiAgICAgICAgbmFtZTogJ2ZlZWRiYWNrcycsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICByZXBlYXQ6IDIgLypSZXBlYXRUeXBlLlVOUEFDS0VEKi8sXG4gICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxDb2RlYz4pOiBDb2RlYyB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLnBheWxvYWRUeXBlID0gMDtcbiAgICBtZXNzYWdlLm5hbWUgPSAnJztcbiAgICBtZXNzYWdlLmZtdHBMaW5lID0gJyc7XG4gICAgbWVzc2FnZS5jbG9ja1JhdGUgPSAwO1xuICAgIG1lc3NhZ2UuZW5jb2RpbmdQYXJhbWV0ZXJzID0gJyc7XG4gICAgbWVzc2FnZS5mZWVkYmFja3MgPSBbXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8Q29kZWM+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IENvZGVjLFxuICApOiBDb2RlYyB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogdWludDMyIHBheWxvYWRfdHlwZSAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZFR5cGUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIGZtdHBfbGluZSAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UuZm10cExpbmUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogdWludDMyIGNsb2NrX3JhdGUgKi8gNDpcbiAgICAgICAgICBtZXNzYWdlLmNsb2NrUmF0ZSA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgZW5jb2RpbmdfcGFyYW1ldGVycyAqLyA1OlxuICAgICAgICAgIG1lc3NhZ2UuZW5jb2RpbmdQYXJhbWV0ZXJzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmluZyBmZWVkYmFja3MgKi8gNjpcbiAgICAgICAgICBtZXNzYWdlLmZlZWRiYWNrcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IENvZGVjLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHVpbnQzMiBwYXlsb2FkX3R5cGUgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnBheWxvYWRUeXBlICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLnBheWxvYWRUeXBlKTtcbiAgICAvKiBzdHJpbmcgbmFtZSA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgLyogc3RyaW5nIGZtdHBfbGluZSA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UuZm10cExpbmUgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmZtdHBMaW5lKTtcbiAgICAvKiB1aW50MzIgY2xvY2tfcmF0ZSA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuY2xvY2tSYXRlICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLmNsb2NrUmF0ZSk7XG4gICAgLyogc3RyaW5nIGVuY29kaW5nX3BhcmFtZXRlcnMgPSA1OyAqL1xuICAgIGlmIChtZXNzYWdlLmVuY29kaW5nUGFyYW1ldGVycyAhPT0gJycpXG4gICAgICB3cml0ZXJcbiAgICAgICAgLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgIC5zdHJpbmcobWVzc2FnZS5lbmNvZGluZ1BhcmFtZXRlcnMpO1xuICAgIC8qIHJlcGVhdGVkIHN0cmluZyBmZWVkYmFja3MgPSA2OyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5mZWVkYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZmVlZGJhY2tzW2ldKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWNcbiAqL1xuZXhwb3J0IGNvbnN0IENvZGVjID0gbmV3IENvZGVjJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIElDRVRyaWNrbGUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPElDRVRyaWNrbGU+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUnLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAncGVlcl90eXBlJyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMixcbiAgICAgICAgbmFtZTogJ2ljZV9jYW5kaWRhdGUnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgICAgeyBubzogMywgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxJQ0VUcmlja2xlPik6IElDRVRyaWNrbGUge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5wZWVyVHlwZSA9IDA7XG4gICAgbWVzc2FnZS5pY2VDYW5kaWRhdGUgPSAnJztcbiAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxJQ0VUcmlja2xlPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBJQ0VUcmlja2xlLFxuICApOiBJQ0VUcmlja2xlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIGljZV9jYW5kaWRhdGUgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBJQ0VUcmlja2xlLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgLyogc3RyaW5nIGljZV9jYW5kaWRhdGUgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLmljZUNhbmRpZGF0ZSAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaWNlQ2FuZGlkYXRlKTtcbiAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlXG4gKi9cbmV4cG9ydCBjb25zdCBJQ0VUcmlja2xlID0gbmV3IElDRVRyaWNrbGUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVHJhY2tJbmZvJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxUcmFja0luZm8+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrSW5mbycsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICd0cmFja19pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAge1xuICAgICAgICBubzogMixcbiAgICAgICAgbmFtZTogJ3RyYWNrX3R5cGUnLFxuICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICBUcmFja1R5cGUsXG4gICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA1LFxuICAgICAgICBuYW1lOiAnbGF5ZXJzJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICBUOiAoKSA9PiBWaWRlb0xheWVyLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDYsIG5hbWU6ICdtaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDcsIG5hbWU6ICdkdHgnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICB7IG5vOiA4LCBuYW1lOiAnc3RlcmVvJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgeyBubzogOSwgbmFtZTogJ3JlZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxUcmFja0luZm8+KTogVHJhY2tJbmZvIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UudHJhY2tJZCA9ICcnO1xuICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gMDtcbiAgICBtZXNzYWdlLmxheWVycyA9IFtdO1xuICAgIG1lc3NhZ2UubWlkID0gJyc7XG4gICAgbWVzc2FnZS5kdHggPSBmYWxzZTtcbiAgICBtZXNzYWdlLnN0ZXJlbyA9IGZhbHNlO1xuICAgIG1lc3NhZ2UucmVkID0gZmFsc2U7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFRyYWNrSW5mbz4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVHJhY2tJbmZvLFxuICApOiBUcmFja0luZm8ge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyB0cmFja19pZCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UudHJhY2tJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9MYXllciBsYXllcnMgKi8gNTpcbiAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKFxuICAgICAgICAgICAgVmlkZW9MYXllci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIG1pZCAqLyA2OlxuICAgICAgICAgIG1lc3NhZ2UubWlkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGJvb2wgZHR4ICovIDc6XG4gICAgICAgICAgbWVzc2FnZS5kdHggPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGJvb2wgc3RlcmVvICovIDg6XG4gICAgICAgICAgbWVzc2FnZS5zdGVyZW8gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGJvb2wgcmVkICovIDk6XG4gICAgICAgICAgbWVzc2FnZS5yZWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBUcmFja0luZm8sXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyaW5nIHRyYWNrX2lkID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS50cmFja0lkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50cmFja0lkKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UudHJhY2tUeXBlICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHJhY2tUeXBlKTtcbiAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyIGxheWVycyA9IDU7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmxheWVycy5sZW5ndGg7IGkrKylcbiAgICAgIFZpZGVvTGF5ZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5sYXllcnNbaV0sXG4gICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJpbmcgbWlkID0gNjsgKi9cbiAgICBpZiAobWVzc2FnZS5taWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1pZCk7XG4gICAgLyogYm9vbCBkdHggPSA3OyAqL1xuICAgIGlmIChtZXNzYWdlLmR0eCAhPT0gZmFsc2UpIHdyaXRlci50YWcoNywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuZHR4KTtcbiAgICAvKiBib29sIHN0ZXJlbyA9IDg7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc3RlcmVvICE9PSBmYWxzZSlcbiAgICAgIHdyaXRlci50YWcoOCwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2Uuc3RlcmVvKTtcbiAgICAvKiBib29sIHJlZCA9IDk7ICovXG4gICAgaWYgKG1lc3NhZ2UucmVkICE9PSBmYWxzZSkgd3JpdGVyLnRhZyg5LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5yZWQpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm9cbiAqL1xuZXhwb3J0IGNvbnN0IFRyYWNrSW5mbyA9IG5ldyBUcmFja0luZm8kVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2FsbCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8Q2FsbD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbCcsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICd0eXBlJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDMsXG4gICAgICAgIG5hbWU6ICdjcmVhdGVkX2J5X3VzZXJfaWQnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNCxcbiAgICAgICAgbmFtZTogJ2hvc3RfdXNlcl9pZCcsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgIH0sXG4gICAgICB7IG5vOiA1LCBuYW1lOiAnY3VzdG9tJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBTdHJ1Y3QgfSxcbiAgICAgIHsgbm86IDYsIG5hbWU6ICdjcmVhdGVkX2F0Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBUaW1lc3RhbXAgfSxcbiAgICAgIHsgbm86IDcsIG5hbWU6ICd1cGRhdGVkX2F0Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBUaW1lc3RhbXAgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxDYWxsPik6IENhbGwge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS50eXBlID0gJyc7XG4gICAgbWVzc2FnZS5pZCA9ICcnO1xuICAgIG1lc3NhZ2UuY3JlYXRlZEJ5VXNlcklkID0gJyc7XG4gICAgbWVzc2FnZS5ob3N0VXNlcklkID0gJyc7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8Q2FsbD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogQ2FsbCxcbiAgKTogQ2FsbCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHR5cGUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIGlkICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgY3JlYXRlZF9ieV91c2VyX2lkICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5jcmVhdGVkQnlVc2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIGhvc3RfdXNlcl9pZCAqLyA0OlxuICAgICAgICAgIG1lc3NhZ2UuaG9zdFVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuU3RydWN0IGN1c3RvbSAqLyA1OlxuICAgICAgICAgIG1lc3NhZ2UuY3VzdG9tID0gU3RydWN0LmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmN1c3RvbSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgY3JlYXRlZF9hdCAqLyA2OlxuICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWRBdCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdXBkYXRlZF9hdCAqLyA3OlxuICAgICAgICAgIG1lc3NhZ2UudXBkYXRlZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZWRBdCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBDYWxsLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS50eXBlICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50eXBlKTtcbiAgICAvKiBzdHJpbmcgaWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLmlkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pZCk7XG4gICAgLyogc3RyaW5nIGNyZWF0ZWRfYnlfdXNlcl9pZCA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UuY3JlYXRlZEJ5VXNlcklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5jcmVhdGVkQnlVc2VySWQpO1xuICAgIC8qIHN0cmluZyBob3N0X3VzZXJfaWQgPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLmhvc3RVc2VySWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmhvc3RVc2VySWQpO1xuICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tID0gNTsgKi9cbiAgICBpZiAobWVzc2FnZS5jdXN0b20pXG4gICAgICBTdHJ1Y3QuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5jdXN0b20sXG4gICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGNyZWF0ZWRfYXQgPSA2OyAqL1xuICAgIGlmIChtZXNzYWdlLmNyZWF0ZWRBdClcbiAgICAgIFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmNyZWF0ZWRBdCxcbiAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdXBkYXRlZF9hdCA9IDc7ICovXG4gICAgaWYgKG1lc3NhZ2UudXBkYXRlZEF0KVxuICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UudXBkYXRlZEF0LFxuICAgICAgICB3cml0ZXIudGFnKDcsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxcbiAqL1xuZXhwb3J0IGNvbnN0IENhbGwgPSBuZXcgQ2FsbCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBFcnJvciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8RXJyb3I+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yJywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ2NvZGUnLFxuICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlJyxcbiAgICAgICAgICBFcnJvckNvZGUsXG4gICAgICAgICAgJ0VSUk9SX0NPREVfJyxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnbWVzc2FnZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgeyBubzogMywgbmFtZTogJ3Nob3VsZF9yZXRyeScsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxFcnJvcj4pOiBFcnJvciB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLmNvZGUgPSAwO1xuICAgIG1lc3NhZ2UubWVzc2FnZSA9ICcnO1xuICAgIG1lc3NhZ2Uuc2hvdWxkUmV0cnkgPSBmYWxzZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8RXJyb3I+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IEVycm9yLFxuICApOiBFcnJvciB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlIGNvZGUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLmNvZGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWVzc2FnZSAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIHNob3VsZF9yZXRyeSAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2Uuc2hvdWxkUmV0cnkgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBFcnJvcixcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvckNvZGUgY29kZSA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UuY29kZSAhPT0gMCkgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuY29kZSk7XG4gICAgLyogc3RyaW5nIG1lc3NhZ2UgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1lc3NhZ2UpO1xuICAgIC8qIGJvb2wgc2hvdWxkX3JldHJ5ID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5zaG91bGRSZXRyeSAhPT0gZmFsc2UpXG4gICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnNob3VsZFJldHJ5KTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IEVycm9yID0gbmV3IEVycm9yJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENsaWVudERldGFpbHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPENsaWVudERldGFpbHM+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNsaWVudERldGFpbHMnLCBbXG4gICAgICB7IG5vOiAxLCBuYW1lOiAnc2RrJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBTZGsgfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdvcycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gT1MgfSxcbiAgICAgIHsgbm86IDMsIG5hbWU6ICdicm93c2VyJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBCcm93c2VyIH0sXG4gICAgICB7IG5vOiA0LCBuYW1lOiAnZGV2aWNlJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBEZXZpY2UgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxDbGllbnREZXRhaWxzPik6IENsaWVudERldGFpbHMge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPENsaWVudERldGFpbHM+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IENsaWVudERldGFpbHMsXG4gICk6IENsaWVudERldGFpbHMge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNkayBzZGsgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnNkayA9IFNkay5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5zZGssXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUyBvcyAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2Uub3MgPSBPUy5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5vcyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkJyb3dzZXIgYnJvd3NlciAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UuYnJvd3NlciA9IEJyb3dzZXIuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1lc3NhZ2UuYnJvd3NlcixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkRldmljZSBkZXZpY2UgKi8gNDpcbiAgICAgICAgICBtZXNzYWdlLmRldmljZSA9IERldmljZS5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5kZXZpY2UsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogQ2xpZW50RGV0YWlscyxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGsgc2RrID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5zZGspXG4gICAgICBTZGsuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5zZGssXG4gICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUyBvcyA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2Uub3MpXG4gICAgICBPUy5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLm9zLFxuICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlciBicm93c2VyID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5icm93c2VyKVxuICAgICAgQnJvd3Nlci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmJyb3dzZXIsXG4gICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5EZXZpY2UgZGV2aWNlID0gNDsgKi9cbiAgICBpZiAobWVzc2FnZS5kZXZpY2UpXG4gICAgICBEZXZpY2UuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5kZXZpY2UsXG4gICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2xpZW50RGV0YWlsc1xuICovXG5leHBvcnQgY29uc3QgQ2xpZW50RGV0YWlscyA9IG5ldyBDbGllbnREZXRhaWxzJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNkayRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8U2RrPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGsnLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAndHlwZScsXG4gICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgVDogKCkgPT4gWydzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlJywgU2RrVHlwZSwgJ1NES19UWVBFXyddLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdtYWpvcicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgeyBubzogMywgbmFtZTogJ21pbm9yJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiA0LCBuYW1lOiAncGF0Y2gnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxTZGs+KTogU2RrIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgbWVzc2FnZS5tYWpvciA9ICcnO1xuICAgIG1lc3NhZ2UubWlub3IgPSAnJztcbiAgICBtZXNzYWdlLnBhdGNoID0gJyc7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8U2RrPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBTZGssXG4gICk6IFNkayB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrVHlwZSB0eXBlICovIDE6XG4gICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIG1ham9yICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5tYWpvciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWlub3IgKi8gMzpcbiAgICAgICAgICBtZXNzYWdlLm1pbm9yID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBwYXRjaCAqLyA0OlxuICAgICAgICAgIG1lc3NhZ2UucGF0Y2ggPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFNkayxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlIHR5cGUgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IDApIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgIC8qIHN0cmluZyBtYWpvciA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UubWFqb3IgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1ham9yKTtcbiAgICAvKiBzdHJpbmcgbWlub3IgPSAzOyAqL1xuICAgIGlmIChtZXNzYWdlLm1pbm9yICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5taW5vcik7XG4gICAgLyogc3RyaW5nIHBhdGNoID0gNDsgKi9cbiAgICBpZiAobWVzc2FnZS5wYXRjaCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGF0Y2gpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtcbiAqL1xuZXhwb3J0IGNvbnN0IFNkayA9IG5ldyBTZGskVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgT1MkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPE9TPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUycsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAndmVyc2lvbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAge1xuICAgICAgICBubzogMyxcbiAgICAgICAgbmFtZTogJ2FyY2hpdGVjdHVyZScsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8T1M+KTogT1Mge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgbWVzc2FnZS52ZXJzaW9uID0gJyc7XG4gICAgbWVzc2FnZS5hcmNoaXRlY3R1cmUgPSAnJztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxPUz4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogT1MsXG4gICk6IE9TIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgdmVyc2lvbiAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgYXJjaGl0ZWN0dXJlICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5hcmNoaXRlY3R1cmUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IE9TLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyBuYW1lID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5uYW1lICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAvKiBzdHJpbmcgdmVyc2lvbiA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudmVyc2lvbik7XG4gICAgLyogc3RyaW5nIGFyY2hpdGVjdHVyZSA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UuYXJjaGl0ZWN0dXJlICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5hcmNoaXRlY3R1cmUpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PU1xuICovXG5leHBvcnQgY29uc3QgT1MgPSBuZXcgT1MkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQnJvd3NlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8QnJvd3Nlcj4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlcicsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAndmVyc2lvbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPEJyb3dzZXI+KTogQnJvd3NlciB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLm5hbWUgPSAnJztcbiAgICBtZXNzYWdlLnZlcnNpb24gPSAnJztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8QnJvd3Nlcj4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogQnJvd3NlcixcbiAgKTogQnJvd3NlciB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHZlcnNpb24gKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IEJyb3dzZXIsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyaW5nIG5hbWUgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgIC8qIHN0cmluZyB2ZXJzaW9uID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS52ZXJzaW9uKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlclxuICovXG5leHBvcnQgY29uc3QgQnJvd3NlciA9IG5ldyBCcm93c2VyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIERldmljZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8RGV2aWNlPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5EZXZpY2UnLCBbXG4gICAgICB7IG5vOiAxLCBuYW1lOiAnbmFtZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ3ZlcnNpb24nLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxEZXZpY2U+KTogRGV2aWNlIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgIG1lc3NhZ2UudmVyc2lvbiA9ICcnO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxEZXZpY2U+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IERldmljZSxcbiAgKTogRGV2aWNlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgdmVyc2lvbiAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogRGV2aWNlLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyBuYW1lID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5uYW1lICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAvKiBzdHJpbmcgdmVyc2lvbiA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudmVyc2lvbik7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkRldmljZVxuICovXG5leHBvcnQgY29uc3QgRGV2aWNlID0gbmV3IERldmljZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDYWxsR3JhbnRzJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxDYWxsR3JhbnRzPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsR3JhbnRzJywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ2Nhbl9wdWJsaXNoX2F1ZGlvJyxcbiAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAyLFxuICAgICAgICBuYW1lOiAnY2FuX3B1Ymxpc2hfdmlkZW8nLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDMsXG4gICAgICAgIG5hbWU6ICdjYW5fc2NyZWVuc2hhcmUnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxDYWxsR3JhbnRzPik6IENhbGxHcmFudHMge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5jYW5QdWJsaXNoQXVkaW8gPSBmYWxzZTtcbiAgICBtZXNzYWdlLmNhblB1Ymxpc2hWaWRlbyA9IGZhbHNlO1xuICAgIG1lc3NhZ2UuY2FuU2NyZWVuc2hhcmUgPSBmYWxzZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8Q2FsbEdyYW50cz4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogQ2FsbEdyYW50cyxcbiAgKTogQ2FsbEdyYW50cyB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogYm9vbCBjYW5fcHVibGlzaF9hdWRpbyAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UuY2FuUHVibGlzaEF1ZGlvID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIGNhbl9wdWJsaXNoX3ZpZGVvICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGJvb2wgY2FuX3NjcmVlbnNoYXJlICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5jYW5TY3JlZW5zaGFyZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IENhbGxHcmFudHMsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogYm9vbCBjYW5fcHVibGlzaF9hdWRpbyA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UuY2FuUHVibGlzaEF1ZGlvICE9PSBmYWxzZSlcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuY2FuUHVibGlzaEF1ZGlvKTtcbiAgICAvKiBib29sIGNhbl9wdWJsaXNoX3ZpZGVvID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8gIT09IGZhbHNlKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8pO1xuICAgIC8qIGJvb2wgY2FuX3NjcmVlbnNoYXJlID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5jYW5TY3JlZW5zaGFyZSAhPT0gZmFsc2UpXG4gICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmNhblNjcmVlbnNoYXJlKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50c1xuICovXG5leHBvcnQgY29uc3QgQ2FsbEdyYW50cyA9IG5ldyBDYWxsR3JhbnRzJFR5cGUoKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAZ2VuZXJhdGVkIGJ5IHByb3RvYnVmLXRzIDIuOS4zIHdpdGggcGFyYW1ldGVyIGxvbmdfdHlwZV9zdHJpbmcsY2xpZW50X2dlbmVyaWMsc2VydmVyX25vbmUsZXNsaW50X2Rpc2FibGVcbi8vIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWxlIFwidmlkZW8vc2Z1L3NpZ25hbF9ycGMvc2lnbmFsLnByb3RvXCIgKHBhY2thZ2UgXCJzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbFwiLCBzeW50YXggcHJvdG8zKVxuLy8gdHNsaW50OmRpc2FibGVcbmltcG9ydCB7XG4gIEVycm9yLFxuICBJQ0VUcmlja2xlLFxuICBQZWVyVHlwZSxcbiAgVHJhY2tJbmZvLFxuICBUcmFja1R5cGUsXG4gIFZpZGVvRGltZW5zaW9uLFxufSBmcm9tICcuLi9tb2RlbHMvbW9kZWxzJztcbmltcG9ydCB7IFNlcnZpY2VUeXBlIH0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUtcnBjJztcbmltcG9ydCB0eXBlIHtcbiAgQmluYXJ5UmVhZE9wdGlvbnMsXG4gIEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgSUJpbmFyeVJlYWRlcixcbiAgSUJpbmFyeVdyaXRlcixcbiAgUGFydGlhbE1lc3NhZ2UsXG59IGZyb20gJ0Bwcm90b2J1Zi10cy9ydW50aW1lJztcbmltcG9ydCB7XG4gIE1lc3NhZ2VUeXBlLFxuICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsLFxuICBVbmtub3duRmllbGRIYW5kbGVyLFxuICBXaXJlVHlwZSxcbn0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZW5kU3RhdHNSZXF1ZXN0IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHNlc3Npb25faWQgPSAxO1xuICAgKi9cbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzdWJzY3JpYmVyX3N0YXRzID0gMjtcbiAgICovXG4gIHN1YnNjcmliZXJTdGF0czogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgcHVibGlzaGVyX3N0YXRzID0gMztcbiAgICovXG4gIHB1Ymxpc2hlclN0YXRzOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyB3ZWJydGNfdmVyc2lvbiA9IDQ7XG4gICAqL1xuICB3ZWJydGNWZXJzaW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZGsgPSA1O1xuICAgKi9cbiAgc2RrOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZGtfdmVyc2lvbiA9IDY7XG4gICAqL1xuICBzZGtWZXJzaW9uOiBzdHJpbmc7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZFN0YXRzUmVzcG9uc2Uge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDE7XG4gICAqL1xuICBlcnJvcj86IEVycm9yO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VSZXN0YXJ0UmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDRVJlc3RhcnRSZXF1ZXN0IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHNlc3Npb25faWQgPSAxO1xuICAgKi9cbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDI7XG4gICAqL1xuICBwZWVyVHlwZTogUGVlclR5cGU7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDRVJlc3RhcnRSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yID0gMTtcbiAgICovXG4gIGVycm9yPzogRXJyb3I7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3Qge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDE7XG4gICAqL1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tNdXRlU3RhdGUgbXV0ZV9zdGF0ZXMgPSAzO1xuICAgKi9cbiAgbXV0ZVN0YXRlczogVHJhY2tNdXRlU3RhdGVbXTtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0O1xuICAgKi9cbiAgZXJyb3I/OiBFcnJvcjtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tNdXRlU3RhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFja011dGVTdGF0ZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0cmFja190eXBlID0gMTtcbiAgICovXG4gIHRyYWNrVHlwZTogVHJhY2tUeXBlO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBib29sIG11dGVkID0gMjtcbiAgICovXG4gIG11dGVkOiBib29sZWFuO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5BdWRpb011dGVDaGFuZ2VkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9NdXRlQ2hhbmdlZCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGJvb2wgbXV0ZWQgPSAxO1xuICAgKi9cbiAgbXV0ZWQ6IGJvb2xlYW47XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlZpZGVvTXV0ZUNoYW5nZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWRlb011dGVDaGFuZ2VkIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogYm9vbCBtdXRlZCA9IDI7XG4gICAqL1xuICBtdXRlZDogYm9vbGVhbjtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZXNzaW9uX2lkID0gMjtcbiAgICovXG4gIHNlc3Npb25JZDogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgdHJhY2tzID0gMztcbiAgICovXG4gIHRyYWNrczogVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzW107XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yID0gNDtcbiAgICovXG4gIGVycm9yPzogRXJyb3I7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyB1c2VyX2lkID0gMTtcbiAgICovXG4gIHVzZXJJZDogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7XG4gICAqL1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgPSAzO1xuICAgKi9cbiAgdHJhY2tUeXBlOiBUcmFja1R5cGU7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uIGRpbWVuc2lvbiA9IDQ7XG4gICAqL1xuICBkaW1lbnNpb24/OiBWaWRlb0RpbWVuc2lvbjtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZEFuc3dlclJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZW5kQW5zd2VyUmVxdWVzdCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDE7XG4gICAqL1xuICBwZWVyVHlwZTogUGVlclR5cGU7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZHAgPSAyO1xuICAgKi9cbiAgc2RwOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZXNzaW9uX2lkID0gMztcbiAgICovXG4gIHNlc3Npb25JZDogc3RyaW5nO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZW5kQW5zd2VyUmVzcG9uc2Uge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7XG4gICAqL1xuICBlcnJvcj86IEVycm9yO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VUcmlja2xlUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQ0VUcmlja2xlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7XG4gICAqL1xuICBlcnJvcj86IEVycm9yO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2V0UHVibGlzaGVyUmVxdWVzdCB7XG4gIC8qKlxuICAgKiBzZHAgb2ZmZXJcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2RwID0gMTtcbiAgICovXG4gIHNkcDogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7XG4gICAqL1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIHRyYWNrcyA9IDM7XG4gICAqL1xuICB0cmFja3M6IFRyYWNrSW5mb1tdO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNldFB1Ymxpc2hlclJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIHNkcCBhbnN3ZXJcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2RwID0gMTtcbiAgICovXG4gIHNkcDogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7XG4gICAqL1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogYm9vbCBpY2VfcmVzdGFydCA9IDM7XG4gICAqL1xuICBpY2VSZXN0YXJ0OiBib29sZWFuO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7XG4gICAqL1xuICBlcnJvcj86IEVycm9yO1xufVxuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2VuZFN0YXRzUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8U2VuZFN0YXRzUmVxdWVzdD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZFN0YXRzUmVxdWVzdCcsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAyLFxuICAgICAgICBuYW1lOiAnc3Vic2NyaWJlcl9zdGF0cycsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAncHVibGlzaGVyX3N0YXRzJyxcbiAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDQsXG4gICAgICAgIG5hbWU6ICd3ZWJydGNfdmVyc2lvbicsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgIH0sXG4gICAgICB7IG5vOiA1LCBuYW1lOiAnc2RrJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA2LFxuICAgICAgICBuYW1lOiAnc2RrX3ZlcnNpb24nLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFNlbmRTdGF0c1JlcXVlc3Q+KTogU2VuZFN0YXRzUmVxdWVzdCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgIG1lc3NhZ2Uuc3Vic2NyaWJlclN0YXRzID0gJyc7XG4gICAgbWVzc2FnZS5wdWJsaXNoZXJTdGF0cyA9ICcnO1xuICAgIG1lc3NhZ2Uud2VicnRjVmVyc2lvbiA9ICcnO1xuICAgIG1lc3NhZ2Uuc2RrID0gJyc7XG4gICAgbWVzc2FnZS5zZGtWZXJzaW9uID0gJyc7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFNlbmRTdGF0c1JlcXVlc3Q+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFNlbmRTdGF0c1JlcXVlc3QsXG4gICk6IFNlbmRTdGF0c1JlcXVlc3Qge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHN1YnNjcmliZXJfc3RhdHMgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJTdGF0cyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgcHVibGlzaGVyX3N0YXRzICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5wdWJsaXNoZXJTdGF0cyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgd2VicnRjX3ZlcnNpb24gKi8gNDpcbiAgICAgICAgICBtZXNzYWdlLndlYnJ0Y1ZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNkayAqLyA1OlxuICAgICAgICAgIG1lc3NhZ2Uuc2RrID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBzZGtfdmVyc2lvbiAqLyA2OlxuICAgICAgICAgIG1lc3NhZ2Uuc2RrVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogU2VuZFN0YXRzUmVxdWVzdCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgIC8qIHN0cmluZyBzdWJzY3JpYmVyX3N0YXRzID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5zdWJzY3JpYmVyU3RhdHMgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnN1YnNjcmliZXJTdGF0cyk7XG4gICAgLyogc3RyaW5nIHB1Ymxpc2hlcl9zdGF0cyA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UucHVibGlzaGVyU3RhdHMgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnB1Ymxpc2hlclN0YXRzKTtcbiAgICAvKiBzdHJpbmcgd2VicnRjX3ZlcnNpb24gPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLndlYnJ0Y1ZlcnNpb24gIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLndlYnJ0Y1ZlcnNpb24pO1xuICAgIC8qIHN0cmluZyBzZGsgPSA1OyAqL1xuICAgIGlmIChtZXNzYWdlLnNkayAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RrKTtcbiAgICAvKiBzdHJpbmcgc2RrX3ZlcnNpb24gPSA2OyAqL1xuICAgIGlmIChtZXNzYWdlLnNka1ZlcnNpb24gIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNka1ZlcnNpb24pO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBTZW5kU3RhdHNSZXF1ZXN0ID0gbmV3IFNlbmRTdGF0c1JlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2VuZFN0YXRzUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFNlbmRTdGF0c1Jlc3BvbnNlPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXNwb25zZScsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxTZW5kU3RhdHNSZXNwb25zZT4pOiBTZW5kU3RhdHNSZXNwb25zZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8U2VuZFN0YXRzUmVzcG9uc2U+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFNlbmRTdGF0c1Jlc3BvbnNlLFxuICApOiBTZW5kU3RhdHNSZXNwb25zZSB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogU2VuZFN0YXRzUmVzcG9uc2UsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgRXJyb3IuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5lcnJvcixcbiAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgU2VuZFN0YXRzUmVzcG9uc2UgPSBuZXcgU2VuZFN0YXRzUmVzcG9uc2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSUNFUmVzdGFydFJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPElDRVJlc3RhcnRSZXF1ZXN0PiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VSZXN0YXJ0UmVxdWVzdCcsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAyLFxuICAgICAgICBuYW1lOiAncGVlcl90eXBlJyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPElDRVJlc3RhcnRSZXF1ZXN0Pik6IElDRVJlc3RhcnRSZXF1ZXN0IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgbWVzc2FnZS5wZWVyVHlwZSA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPElDRVJlc3RhcnRSZXF1ZXN0Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBJQ0VSZXN0YXJ0UmVxdWVzdCxcbiAgKTogSUNFUmVzdGFydFJlcXVlc3Qge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5wZWVyVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBJQ0VSZXN0YXJ0UmVxdWVzdCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBJQ0VSZXN0YXJ0UmVxdWVzdCA9IG5ldyBJQ0VSZXN0YXJ0UmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VSZXN0YXJ0UmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPElDRVJlc3RhcnRSZXNwb25zZT4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlc3BvbnNlJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPElDRVJlc3RhcnRSZXNwb25zZT4pOiBJQ0VSZXN0YXJ0UmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPElDRVJlc3RhcnRSZXNwb25zZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogSUNFUmVzdGFydFJlc3BvbnNlLFxuICApOiBJQ0VSZXN0YXJ0UmVzcG9uc2Uge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IElDRVJlc3RhcnRSZXNwb25zZSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICBFcnJvci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgSUNFUmVzdGFydFJlc3BvbnNlID0gbmV3IElDRVJlc3RhcnRSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8VXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3Q+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0JywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDMsXG4gICAgICAgIG5hbWU6ICdtdXRlX3N0YXRlcycsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgVDogKCkgPT4gVHJhY2tNdXRlU3RhdGUsXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZShcbiAgICB2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0PixcbiAgKTogVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICBtZXNzYWdlLm11dGVTdGF0ZXMgPSBbXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8VXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3Q+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0LFxuICApOiBVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja011dGVTdGF0ZSBtdXRlX3N0YXRlcyAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UubXV0ZVN0YXRlcy5wdXNoKFxuICAgICAgICAgICAgVHJhY2tNdXRlU3RhdGUuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrTXV0ZVN0YXRlIG11dGVfc3RhdGVzID0gMzsgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UubXV0ZVN0YXRlcy5sZW5ndGg7IGkrKylcbiAgICAgIFRyYWNrTXV0ZVN0YXRlLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UubXV0ZVN0YXRlc1tpXSxcbiAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVNdXRlU3RhdGVzUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QgPSBuZXcgVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2U+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZScsIFtcbiAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUoXG4gICAgdmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2U+LFxuICApOiBVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlLFxuICApOiBVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2Uge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICBFcnJvci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlID0gbmV3IFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja011dGVTdGF0ZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8VHJhY2tNdXRlU3RhdGU+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrTXV0ZVN0YXRlJywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ3RyYWNrX3R5cGUnLFxuICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICBUcmFja1R5cGUsXG4gICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnbXV0ZWQnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8VHJhY2tNdXRlU3RhdGU+KTogVHJhY2tNdXRlU3RhdGUge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS50cmFja1R5cGUgPSAwO1xuICAgIG1lc3NhZ2UubXV0ZWQgPSBmYWxzZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8VHJhY2tNdXRlU3RhdGU+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFRyYWNrTXV0ZVN0YXRlLFxuICApOiBUcmFja011dGVTdGF0ZSB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGJvb2wgbXV0ZWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLm11dGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogVHJhY2tNdXRlU3RhdGUsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnRyYWNrVHlwZSAhPT0gMClcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnRyYWNrVHlwZSk7XG4gICAgLyogYm9vbCBtdXRlZCA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UubXV0ZWQgIT09IGZhbHNlKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5tdXRlZCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrTXV0ZVN0YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFja011dGVTdGF0ZSA9IG5ldyBUcmFja011dGVTdGF0ZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBBdWRpb011dGVDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxBdWRpb011dGVDaGFuZ2VkPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5BdWRpb011dGVDaGFuZ2VkJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ211dGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPEF1ZGlvTXV0ZUNoYW5nZWQ+KTogQXVkaW9NdXRlQ2hhbmdlZCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLm11dGVkID0gZmFsc2U7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPEF1ZGlvTXV0ZUNoYW5nZWQ+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IEF1ZGlvTXV0ZUNoYW5nZWQsXG4gICk6IEF1ZGlvTXV0ZUNoYW5nZWQge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIGJvb2wgbXV0ZWQgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLm11dGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogQXVkaW9NdXRlQ2hhbmdlZCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBib29sIG11dGVkID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5tdXRlZCAhPT0gZmFsc2UpXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLm11dGVkKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuQXVkaW9NdXRlQ2hhbmdlZFxuICovXG5leHBvcnQgY29uc3QgQXVkaW9NdXRlQ2hhbmdlZCA9IG5ldyBBdWRpb011dGVDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvTXV0ZUNoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFZpZGVvTXV0ZUNoYW5nZWQ+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlZpZGVvTXV0ZUNoYW5nZWQnLCBbXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnbXV0ZWQnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8VmlkZW9NdXRlQ2hhbmdlZD4pOiBWaWRlb011dGVDaGFuZ2VkIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UubXV0ZWQgPSBmYWxzZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8VmlkZW9NdXRlQ2hhbmdlZD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVmlkZW9NdXRlQ2hhbmdlZCxcbiAgKTogVmlkZW9NdXRlQ2hhbmdlZCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogYm9vbCBtdXRlZCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UubXV0ZWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBWaWRlb011dGVDaGFuZ2VkLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIGJvb2wgbXV0ZWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLm11dGVkICE9PSBmYWxzZSlcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UubXV0ZWQpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5WaWRlb011dGVDaGFuZ2VkXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb011dGVDaGFuZ2VkID0gbmV3IFZpZGVvTXV0ZUNoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0PiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCcsIFtcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAndHJhY2tzJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICBUOiAoKSA9PiBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMsXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZShcbiAgICB2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0PixcbiAgKTogVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICBtZXNzYWdlLnRyYWNrcyA9IFtdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QsXG4gICk6IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyB0cmFja3MgKi8gMzpcbiAgICAgICAgICBtZXNzYWdlLnRyYWNrcy5wdXNoKFxuICAgICAgICAgICAgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0LFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIHRyYWNrcyA9IDM7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgIFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscy5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLnRyYWNrc1tpXSxcbiAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QgPSBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2U+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZScsIFtcbiAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUoXG4gICAgdmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2U+LFxuICApOiBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlLFxuICApOiBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2Uge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICBFcnJvci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlID1cbiAgbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscz4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAndHJhY2tfdHlwZScsXG4gICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUnLFxuICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDQsIG5hbWU6ICdkaW1lbnNpb24nLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFZpZGVvRGltZW5zaW9uIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKFxuICAgIHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8VHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzPixcbiAgKTogVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscz4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICApOiBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24gZGltZW5zaW9uICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5kaW1lbnNpb24gPSBWaWRlb0RpbWVuc2lvbi5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5kaW1lbnNpb24sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UudHJhY2tUeXBlICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHJhY2tUeXBlKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvbiBkaW1lbnNpb24gPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLmRpbWVuc2lvbilcbiAgICAgIFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuZGltZW5zaW9uLFxuICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1xuICovXG5leHBvcnQgY29uc3QgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzID0gbmV3IFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZW5kQW5zd2VyUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8U2VuZEFuc3dlclJlcXVlc3Q+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXF1ZXN0JywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ3BlZXJfdHlwZScsXG4gICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgVDogKCkgPT4gWydzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZScsIFBlZXJUeXBlLCAnUEVFUl9UWVBFXyddLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZHAnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDMsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8U2VuZEFuc3dlclJlcXVlc3Q+KTogU2VuZEFuc3dlclJlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5wZWVyVHlwZSA9IDA7XG4gICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxTZW5kQW5zd2VyUmVxdWVzdD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogU2VuZEFuc3dlclJlcXVlc3QsXG4gICk6IFNlbmRBbnN3ZXJSZXF1ZXN0IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFNlbmRBbnN3ZXJSZXF1ZXN0LFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgLyogc3RyaW5nIHNkcCA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBTZW5kQW5zd2VyUmVxdWVzdCA9IG5ldyBTZW5kQW5zd2VyUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZW5kQW5zd2VyUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFNlbmRBbnN3ZXJSZXNwb25zZT4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZEFuc3dlclJlc3BvbnNlJywgW1xuICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFNlbmRBbnN3ZXJSZXNwb25zZT4pOiBTZW5kQW5zd2VyUmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFNlbmRBbnN3ZXJSZXNwb25zZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogU2VuZEFuc3dlclJlc3BvbnNlLFxuICApOiBTZW5kQW5zd2VyUmVzcG9uc2Uge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFNlbmRBbnN3ZXJSZXNwb25zZSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICBFcnJvci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgU2VuZEFuc3dlclJlc3BvbnNlID0gbmV3IFNlbmRBbnN3ZXJSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VUcmlja2xlUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPElDRVRyaWNrbGVSZXNwb25zZT4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFVHJpY2tsZVJlc3BvbnNlJywgW1xuICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPElDRVRyaWNrbGVSZXNwb25zZT4pOiBJQ0VUcmlja2xlUmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPElDRVRyaWNrbGVSZXNwb25zZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogSUNFVHJpY2tsZVJlc3BvbnNlLFxuICApOiBJQ0VUcmlja2xlUmVzcG9uc2Uge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IElDRVRyaWNrbGVSZXNwb25zZSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICBFcnJvci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVRyaWNrbGVSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgSUNFVHJpY2tsZVJlc3BvbnNlID0gbmV3IElDRVRyaWNrbGVSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZXRQdWJsaXNoZXJSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxTZXRQdWJsaXNoZXJSZXF1ZXN0PiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0JywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDMsXG4gICAgICAgIG5hbWU6ICd0cmFja3MnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgIFQ6ICgpID0+IFRyYWNrSW5mbyxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8U2V0UHVibGlzaGVyUmVxdWVzdD4pOiBTZXRQdWJsaXNoZXJSZXF1ZXN0IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2Uuc2RwID0gJyc7XG4gICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICBtZXNzYWdlLnRyYWNrcyA9IFtdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxTZXRQdWJsaXNoZXJSZXF1ZXN0Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBTZXRQdWJsaXNoZXJSZXF1ZXN0LFxuICApOiBTZXRQdWJsaXNoZXJSZXF1ZXN0IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8gdHJhY2tzICovIDM6XG4gICAgICAgICAgbWVzc2FnZS50cmFja3MucHVzaChcbiAgICAgICAgICAgIFRyYWNrSW5mby5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFNldFB1Ymxpc2hlclJlcXVlc3QsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyaW5nIHNkcCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIHRyYWNrcyA9IDM7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgIFRyYWNrSW5mby5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLnRyYWNrc1tpXSxcbiAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBTZXRQdWJsaXNoZXJSZXF1ZXN0ID0gbmV3IFNldFB1Ymxpc2hlclJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2V0UHVibGlzaGVyUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFNldFB1Ymxpc2hlclJlc3BvbnNlPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXNwb25zZScsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICdzZHAnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAzLCBuYW1lOiAnaWNlX3Jlc3RhcnQnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICB7IG5vOiA0LCBuYW1lOiAnZXJyb3InLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IEVycm9yIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8U2V0UHVibGlzaGVyUmVzcG9uc2U+KTogU2V0UHVibGlzaGVyUmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgIG1lc3NhZ2UuaWNlUmVzdGFydCA9IGZhbHNlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxTZXRQdWJsaXNoZXJSZXNwb25zZT4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogU2V0UHVibGlzaGVyUmVzcG9uc2UsXG4gICk6IFNldFB1Ymxpc2hlclJlc3BvbnNlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIGljZV9yZXN0YXJ0ICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5pY2VSZXN0YXJ0ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyA0OlxuICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBFcnJvci5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5lcnJvcixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBTZXRQdWJsaXNoZXJSZXNwb25zZSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgc2RwID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5zZHAgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAvKiBib29sIGljZV9yZXN0YXJ0ID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5pY2VSZXN0YXJ0ICE9PSBmYWxzZSlcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuaWNlUmVzdGFydCk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgRXJyb3IuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5lcnJvcixcbiAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgU2V0UHVibGlzaGVyUmVzcG9uc2UgPSBuZXcgU2V0UHVibGlzaGVyUmVzcG9uc2UkVHlwZSgpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIFNlcnZpY2VUeXBlIGZvciBwcm90b2J1ZiBzZXJ2aWNlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNpZ25hbFNlcnZlclxuICovXG5leHBvcnQgY29uc3QgU2lnbmFsU2VydmVyID0gbmV3IFNlcnZpY2VUeXBlKFxuICAnc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2lnbmFsU2VydmVyJyxcbiAgW1xuICAgIHtcbiAgICAgIG5hbWU6ICdTZXRQdWJsaXNoZXInLFxuICAgICAgb3B0aW9uczoge30sXG4gICAgICBJOiBTZXRQdWJsaXNoZXJSZXF1ZXN0LFxuICAgICAgTzogU2V0UHVibGlzaGVyUmVzcG9uc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnU2VuZEFuc3dlcicsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIEk6IFNlbmRBbnN3ZXJSZXF1ZXN0LFxuICAgICAgTzogU2VuZEFuc3dlclJlc3BvbnNlLFxuICAgIH0sXG4gICAgeyBuYW1lOiAnSWNlVHJpY2tsZScsIG9wdGlvbnM6IHt9LCBJOiBJQ0VUcmlja2xlLCBPOiBJQ0VUcmlja2xlUmVzcG9uc2UgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnVXBkYXRlU3Vic2NyaXB0aW9ucycsXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIEk6IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0LFxuICAgICAgTzogVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ1VwZGF0ZU11dGVTdGF0ZXMnLFxuICAgICAgb3B0aW9uczoge30sXG4gICAgICBJOiBVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCxcbiAgICAgIE86IFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdJY2VSZXN0YXJ0JyxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgSTogSUNFUmVzdGFydFJlcXVlc3QsXG4gICAgICBPOiBJQ0VSZXN0YXJ0UmVzcG9uc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnU2VuZFN0YXRzJyxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgSTogU2VuZFN0YXRzUmVxdWVzdCxcbiAgICAgIE86IFNlbmRTdGF0c1Jlc3BvbnNlLFxuICAgIH0sXG4gIF0sXG4pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9idWYtdHMgMi45LjMgd2l0aCBwYXJhbWV0ZXIgbG9uZ190eXBlX3N0cmluZyxjbGllbnRfZ2VuZXJpYyxzZXJ2ZXJfbm9uZSxlc2xpbnRfZGlzYWJsZVxuLy8gQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpbGUgXCJ2aWRlby9zZnUvZXZlbnQvZXZlbnRzLnByb3RvXCIgKHBhY2thZ2UgXCJzdHJlYW0udmlkZW8uc2Z1LmV2ZW50XCIsIHN5bnRheCBwcm90bzMpXG4vLyB0c2xpbnQ6ZGlzYWJsZVxuaW1wb3J0IHR5cGUge1xuICBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgQmluYXJ5V3JpdGVPcHRpb25zLFxuICBJQmluYXJ5UmVhZGVyLFxuICBJQmluYXJ5V3JpdGVyLFxuICBQYXJ0aWFsTWVzc2FnZSxcbn0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuaW1wb3J0IHtcbiAgTWVzc2FnZVR5cGUsXG4gIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwsXG4gIFVua25vd25GaWVsZEhhbmRsZXIsXG4gIFdpcmVUeXBlLFxufSBmcm9tICdAcHJvdG9idWYtdHMvcnVudGltZSc7XG5pbXBvcnQge1xuICBDYWxsR3JhbnRzLFxuICBDYWxsU3RhdGUsXG4gIENsaWVudERldGFpbHMsXG4gIENvZGVjLFxuICBDb25uZWN0aW9uUXVhbGl0eSxcbiAgRXJyb3IgYXMgRXJyb3IkLFxuICBHb0F3YXlSZWFzb24sXG4gIElDRVRyaWNrbGUgYXMgSUNFVHJpY2tsZSQsXG4gIFBhcnRpY2lwYW50LFxuICBQYXJ0aWNpcGFudENvdW50LFxuICBQZWVyVHlwZSxcbiAgUGluLFxuICBUcmFja0luZm8sXG4gIFRyYWNrVHlwZSxcbiAgVHJhY2tVbnB1Ymxpc2hSZWFzb24sXG59IGZyb20gJy4uL21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHsgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIH0gZnJvbSAnLi4vc2lnbmFsX3JwYy9zaWduYWwnO1xuXG4vKipcbiAqIFNGVUV2ZW50IGlzIGEgbWVzc2FnZSB0aGF0IGlzIHNlbnQgZnJvbSB0aGUgU0ZVIHRvIHRoZSBjbGllbnQuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVFdmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNmdUV2ZW50IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBvbmVvZjogZXZlbnRfcGF5bG9hZFxuICAgKi9cbiAgZXZlbnRQYXlsb2FkOlxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdzdWJzY3JpYmVyT2ZmZXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic2NyaWJlck9mZmVyIHNlbmRzIHRoZSBTRFAgb2ZmZXIgZm9yIGVzdGFibGlzaGluZyB0aGVcbiAgICAgICAgICogc3Vic2NyaWJlciBQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlciBzdWJzY3JpYmVyX29mZmVyID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHN1YnNjcmliZXJPZmZlcjogU3Vic2NyaWJlck9mZmVyO1xuICAgICAgfVxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdwdWJsaXNoZXJBbnN3ZXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHVibGlzaGVyQW5zd2VyIHNlbmRzIHRoZSBTRFAgYW5zd2VyIHRvIHRoZSBvZmZlciBzZW50IGJ5XG4gICAgICAgICAqIHRoZSBjbGllbnQgZm9yIGVzdGFibGlzaGluZyB0aGUgUHVibGlzaGVyIFBlZXJDb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUHVibGlzaGVyQW5zd2VyIHB1Ymxpc2hlcl9hbnN3ZXIgPSAyO1xuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaGVyQW5zd2VyOiBQdWJsaXNoZXJBbnN3ZXI7XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIG9uZW9mS2luZDogJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgaXMgc2VudCB0byBpbmZvcm0gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICogcXVhbGl0eSBvZiB0aGUgcGFydGljaXBhbnRzIGluIHRoZSBjYWxsLiBJdCBkb2VzIG5vdCBoYXZlXG4gICAgICAgICAqIHRvIGNvbnRhaW4gdGhlIGZ1bGwgbGlzdCBvZiBjYWxsIHBhcnRpY2lwYW50cyBpbiBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCBjb25uZWN0aW9uX3F1YWxpdHlfY2hhbmdlZCA9IDM7XG4gICAgICAgICAqL1xuICAgICAgICBjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnYXVkaW9MZXZlbENoYW5nZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXVkaW9MZXZlbENoYW5nZWQgaXMgc2VudCBmb3IgY2hhbmdlIGluIGF1ZGlvIGxldmVscyBvZlxuICAgICAgICAgKiB0aGUgcGFydGljaXBhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbENoYW5nZWQgYXVkaW9fbGV2ZWxfY2hhbmdlZCA9IDQ7XG4gICAgICAgICAqL1xuICAgICAgICBhdWRpb0xldmVsQ2hhbmdlZDogQXVkaW9MZXZlbENoYW5nZWQ7XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIG9uZW9mS2luZDogJ2ljZVRyaWNrbGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSUNFVHJpY2tsZSBjb250YWlucyB0aGUgSUNFIGNhbmRpZGF0ZSByZXF1aXJlZCB0byBlc3RhYmxpc2hcbiAgICAgICAgICogdGhlIElDRSB0cmFuc3BvcnQ6IHBhcnQgb2YgZXN0YWJsaXNoaW5nIHRoZSBQZWVyQ29ubmVjdGlvblxuICAgICAgICAgKiBhbmQgYWxzbyBmb3IgSUNFIHJlc3RhcnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUgaWNlX3RyaWNrbGUgPSA1O1xuICAgICAgICAgKi9cbiAgICAgICAgaWNlVHJpY2tsZTogSUNFVHJpY2tsZSQ7XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIG9uZW9mS2luZDogJ2NoYW5nZVB1Ymxpc2hRdWFsaXR5JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZVB1Ymxpc2hRdWFsaXR5IGFkdmlzZXMgdGhlIHB1Ymxpc2hlciB0byBzd2l0Y2ggb24vb2ZmXG4gICAgICAgICAqIHZhcmlvdXMgcXVhbGl0aWVzIG9mIHRoZWlyIHZpZGVvIHN0cmVhbSBiYXNlZCBvbiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKiBUaGlzIGlzIGRvbmUgdG8gc2F2ZSB0aGUgYmFuZHdpZHRoIGFuZCB0aGUgQ1BVIG9mIHRoZSBwdWJsaXNoZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DaGFuZ2VQdWJsaXNoUXVhbGl0eSBjaGFuZ2VfcHVibGlzaF9xdWFsaXR5ID0gNjtcbiAgICAgICAgICovXG4gICAgICAgIGNoYW5nZVB1Ymxpc2hRdWFsaXR5OiBDaGFuZ2VQdWJsaXNoUXVhbGl0eTtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAncGFydGljaXBhbnRKb2luZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFydGljaXBhbnRKb2luZWQgbm90aWZpZXMgdGhlIGNsaWVudCB0aGF0IGEgbmV3IHBhcnRpY2lwYW50XG4gICAgICAgICAqIGhhcyBqb2luZWQgdGhlIGNhbGwuIFRoaXMgaXMgbm90IHNlbnQgZm9yIGFub255bW91cyB1c2Vycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkIHBhcnRpY2lwYW50X2pvaW5lZCA9IDEwO1xuICAgICAgICAgKi9cbiAgICAgICAgcGFydGljaXBhbnRKb2luZWQ6IFBhcnRpY2lwYW50Sm9pbmVkO1xuICAgICAgfVxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdwYXJ0aWNpcGFudExlZnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFydGljaXBhbnRMZWZ0IG5vdGlmaWVzIHRoZSBjbGllbnQgdGhhdCBhIGNhbGwgcGFydGljaXBhbnRcbiAgICAgICAgICogaGFzIGxlZnQgdGhlIGNhbGwuIFRoaXMgaXMgbm90IHNlbnQgZm9yIGFub255bW91cyB1c2Vycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdCBwYXJ0aWNpcGFudF9sZWZ0ID0gMTE7XG4gICAgICAgICAqL1xuICAgICAgICBwYXJ0aWNpcGFudExlZnQ6IFBhcnRpY2lwYW50TGVmdDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkIG5vdGlmaWVzIHRoZSBjbGllbnQgYWJvdXQgdGhlIGN1cnJlbnRcbiAgICAgICAgICogZG9taW5hbnQgc3BlYWtlci4gVGhpcyBpcyByZXF1aXJlZCBmb3IgY2VydGFpbiB1c2UgY2FzZXMgbGlrZVxuICAgICAgICAgKiB0aGUgc3BvdGxpZ2h0IHZpZXcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Eb21pbmFudFNwZWFrZXJDaGFuZ2VkIGRvbWluYW50X3NwZWFrZXJfY2hhbmdlZCA9IDEyO1xuICAgICAgICAgKi9cbiAgICAgICAgZG9taW5hbnRTcGVha2VyQ2hhbmdlZDogRG9taW5hbnRTcGVha2VyQ2hhbmdlZDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnam9pblJlc3BvbnNlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEpvaW5SZXNwb25zZSBhY2tub3dsZWRnZXMgYSBwYXJ0aWNpcGFudCBzdWNjZXNzZnVsbHkgam9pbmluZ1xuICAgICAgICAgKiB0aGUgY2FsbC4gVGhpcyBpcyBzZW50IGluIHJlc3BvbnNlIHRvIHRoZSBKb2luUmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZSBqb2luX3Jlc3BvbnNlID0gMTM7XG4gICAgICAgICAqL1xuICAgICAgICBqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZTtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnaGVhbHRoQ2hlY2tSZXNwb25zZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWFsdGhDaGVja1Jlc3BvbnNlIGlzIHNlbnQgaW4gcmVzcG9uc2UgdG8gdGhlIEhlYWx0aENoZWNrUmVxdWVzdC5cbiAgICAgICAgICogSXQgY29udGFpbnMgdGhlIHBhcnRpY2lwYW50IGNvdW50IGluIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXNwb25zZSBoZWFsdGhfY2hlY2tfcmVzcG9uc2UgPSAxNDtcbiAgICAgICAgICovXG4gICAgICAgIGhlYWx0aENoZWNrUmVzcG9uc2U6IEhlYWx0aENoZWNrUmVzcG9uc2U7XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIG9uZW9mS2luZDogJ3RyYWNrUHVibGlzaGVkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrUHVibGlzaGVkIGlzIHNlbnQgd2hlbiBhIG5ldyB0cmFjayAobGlrZSBhdWRpbywgdmlkZW8sIHNjcmVlbnNoYXJlKVxuICAgICAgICAgKiBpcyBwdWJsaXNoZWQgYnkgYSBwYXJ0aWNpcGFudCBpbiB0aGUgY2FsbC4gSXQgaXMgYWxzbyBzZW50IG9uIG11dGUvdW5tdXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tQdWJsaXNoZWQgdHJhY2tfcHVibGlzaGVkID0gMTY7XG4gICAgICAgICAqL1xuICAgICAgICB0cmFja1B1Ymxpc2hlZDogVHJhY2tQdWJsaXNoZWQ7XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIG9uZW9mS2luZDogJ3RyYWNrVW5wdWJsaXNoZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tVbnB1Ymxpc2hlZCBpcyBzZW50IHdoZW4gYSB0cmFjayAobGlrZSBhdWRpbywgdmlkZW8sIHNjcmVlbnNoYXJlKVxuICAgICAgICAgKiBpcyBubyBsb25nZXIgcHVibGlzaGVkLiBJdCBpcyBzZW50IG9uIG11dGluZyBhIHRyYWNrIG9yIHdoZW4gdGhlIHBhcnRpY2lwYW50XG4gICAgICAgICAqIGlzIGxlYXZpbmcgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1VucHVibGlzaGVkIHRyYWNrX3VucHVibGlzaGVkID0gMTc7XG4gICAgICAgICAqL1xuICAgICAgICB0cmFja1VucHVibGlzaGVkOiBUcmFja1VucHVibGlzaGVkO1xuICAgICAgfVxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdlcnJvcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFcnJvciBpcyB1c2VkIHRvIGNvbW11bmljYXRlIGFueSBlcnJvciByZWxhdGVkIHRvIHRoZSBwYXJ0aWNpcGFudC4gVGhlXG4gICAgICAgICAqIGVycm9yIGNvZGUgYW5kIHRoZSBtZXNzYWdlIGV4cGxhaW4gd2hhdCB3ZW50IHdyb25nLiBXaGV0aGVyIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgICAgKiBjYW4gcmV0cnkgaXMgYWxzbyBpbmRpY2F0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5FcnJvciBlcnJvciA9IDE4O1xuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3I6IEVycm9yO1xuICAgICAgfVxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdjYWxsR3JhbnRzVXBkYXRlZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsR3JhbnRzVXBkYXRlZCB0ZWxscyB3aGF0IHRyYWNrcyBhIHBhcnRpY2lwYW50IGlzIGFsbG93ZWQgdG8gcHVibGlzaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNhbGxHcmFudHNVcGRhdGVkIGNhbGxfZ3JhbnRzX3VwZGF0ZWQgPSAxOTtcbiAgICAgICAgICovXG4gICAgICAgIGNhbGxHcmFudHNVcGRhdGVkOiBDYWxsR3JhbnRzVXBkYXRlZDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAnZ29Bd2F5JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdvQXdheSB0ZWxscyB0aGUgY2xpZW50IHRvIG1pZ3JhdGUgYXdheSBmcm9tIHRoZSBTRlUgaXQgaXMgY29ubmVjdGVkIHRvLlxuICAgICAgICAgKiBUaGUgcmVhc29uIGZpZWxkIGluZGljYXRlcyB3aHkgdGhpcyBtZXNzYWdlIHdhcyBzZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuR29Bd2F5IGdvX2F3YXkgPSAyMDtcbiAgICAgICAgICovXG4gICAgICAgIGdvQXdheTogR29Bd2F5O1xuICAgICAgfVxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdpY2VSZXN0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElDRVJlc3RhcnQgdGVsbHMgdGhlIGNsaWVudCB0byBwZXJmb3JtIElDRSByZXN0YXJ0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCBpY2VfcmVzdGFydCA9IDIxO1xuICAgICAgICAgKi9cbiAgICAgICAgaWNlUmVzdGFydDogSUNFUmVzdGFydDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiAncGluc1VwZGF0ZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGluc0NoYW5nZWQgaXMgc2VudCB0aGUgbGlzdCBvZiBwaW5zIGluIHRoZSBjYWxsIGNoYW5nZXMuIFRoaXMgZXZlbnQgY29udGFpbnMgdGhlIGVudGlyZSBsaXN0IG9mIHBpbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QaW5zQ2hhbmdlZCBwaW5zX3VwZGF0ZWQgPSAyMjtcbiAgICAgICAgICovXG4gICAgICAgIHBpbnNVcGRhdGVkOiBQaW5zQ2hhbmdlZDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiB1bmRlZmluZWQ7XG4gICAgICB9O1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGluc0NoYW5nZWQge1xuICAvKipcbiAgICogdGhlIGxpc3Qgb2YgcGlucyBpbiB0aGUgY2FsbC5cbiAgICogUGlucyBhcmUgb3JkZXJlZCBpbiBkZXNjZW5kaW5nIG9yZGVyIChtb3N0IGltcG9ydGFudCBmaXJzdCkuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluIHBpbnMgPSAxO1xuICAgKi9cbiAgcGluczogUGluW107XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRXJyb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFcnJvciB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yID0gNDtcbiAgICovXG4gIGVycm9yPzogRXJyb3IkO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVRyaWNrbGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQ0VUcmlja2xlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTtcbiAgICovXG4gIHBlZXJUeXBlOiBQZWVyVHlwZTtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIGljZV9jYW5kaWRhdGUgPSAyO1xuICAgKi9cbiAgaWNlQ2FuZGlkYXRlOiBzdHJpbmc7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDRVJlc3RhcnQge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAxO1xuICAgKi9cbiAgcGVlclR5cGU6IFBlZXJUeXBlO1xufVxuLyoqXG4gKiBTZnVSZXF1ZXN0IGlzIGEgbWVzc2FnZSB0aGF0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBTRlUuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVSZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Z1UmVxdWVzdCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgb25lb2Y6IHJlcXVlc3RfcGF5bG9hZFxuICAgKi9cbiAgcmVxdWVzdFBheWxvYWQ6XG4gICAgfCB7XG4gICAgICAgIG9uZW9mS2luZDogJ2pvaW5SZXF1ZXN0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVxdWVzdCBqb2luX3JlcXVlc3QgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgam9pblJlcXVlc3Q6IEpvaW5SZXF1ZXN0O1xuICAgICAgfVxuICAgIHwge1xuICAgICAgICBvbmVvZktpbmQ6ICdoZWFsdGhDaGVja1JlcXVlc3QnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVxdWVzdCBoZWFsdGhfY2hlY2tfcmVxdWVzdCA9IDI7XG4gICAgICAgICAqL1xuICAgICAgICBoZWFsdGhDaGVja1JlcXVlc3Q6IEhlYWx0aENoZWNrUmVxdWVzdDtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgb25lb2ZLaW5kOiB1bmRlZmluZWQ7XG4gICAgICB9O1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrUmVxdWVzdCB7fVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCA9IDE7XG4gICAqL1xuICBwYXJ0aWNpcGFudENvdW50PzogUGFydGljaXBhbnRDb3VudDtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrUHVibGlzaGVkIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHVzZXJfaWQgPSAxO1xuICAgKi9cbiAgdXNlcklkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZXNzaW9uX2lkID0gMjtcbiAgICovXG4gIHNlc3Npb25JZDogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSA9IDM7XG4gICAqL1xuICB0eXBlOiBUcmFja1R5cGU7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBpbmZvcm1hdGlvbiBoZXJlIGlzIGluY2x1ZGVkIGFzIGFuIG9wdGltaXNhdGlvblxuICAgKiBmb3IgbGFyZ2UgY2FsbHMgd2hlcmUgYnJvYWRjYXN0aW5nIG9uIGV2ZXJ5IHBhcnRpY2lwYW50IGpvaW5cbiAgICogaXMgZXhwZW5zaXZlLiBZb3Ugc2hvdWxkICoqTk9UKiogYXNzdW1lIHRoYXQgdGhpcyB3aWxsIGFsd2F5c1xuICAgKiBiZSBhdmFpbGFibGUgdGhvdWdoIHlvdSBjYW4gdXNlIGl0IHRvIHVwZGF0ZSB0aGUgcGFydGljaXBhbnRcbiAgICogbGlzdCB3aGVuIGl0IGlzIHRoZXJlLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ID0gNDtcbiAgICovXG4gIHBhcnRpY2lwYW50PzogUGFydGljaXBhbnQ7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrVW5wdWJsaXNoZWQge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgdXNlcl9pZCA9IDE7XG4gICAqL1xuICB1c2VySWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHNlc3Npb25faWQgPSAyO1xuICAgKi9cbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0eXBlID0gMztcbiAgICovXG4gIHR5cGU6IFRyYWNrVHlwZTtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tVbnB1Ymxpc2hSZWFzb24gY2F1c2UgPSA0O1xuICAgKi9cbiAgY2F1c2U6IFRyYWNrVW5wdWJsaXNoUmVhc29uO1xuICAvKipcbiAgICogUGFydGljaXBhbnQgaW5mb3JtYXRpb24gaGVyZSBpcyBpbmNsdWRlZCBhcyBhbiBvcHRpbWlzYXRpb25cbiAgICogZm9yIGxhcmdlIGNhbGxzIHdoZXJlIGJyb2FkY2FzdGluZyBvbiBldmVyeSBwYXJ0aWNpcGFudCBqb2luXG4gICAqIGlzIGV4cGVuc2l2ZS4gWW91IHNob3VsZCAqKk5PVCoqIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBhbHdheXNcbiAgICogYmUgYXZhaWxhYmxlIHRob3VnaCB5b3UgY2FuIHVzZSBpdCB0byB1cGRhdGUgdGhlIHBhcnRpY2lwYW50XG4gICAqIGxpc3Qgd2hlbiBpdCBpcyB0aGVyZS5cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCA9IDU7XG4gICAqL1xuICBwYXJ0aWNpcGFudD86IFBhcnRpY2lwYW50O1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSm9pblJlcXVlc3Qge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgdG9rZW4gPSAxO1xuICAgKi9cbiAgdG9rZW46IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHNlc3Npb25faWQgPSAyO1xuICAgKi9cbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBkdW1iIFNEUCB0aGF0IGFsbG93IHVzIHRvIGV4dHJhY3Qgc3Vic2NyaWJlcidzIGRlY29kZSBjb2RlY3NcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc3Vic2NyaWJlcl9zZHAgPSAzO1xuICAgKi9cbiAgc3Vic2NyaWJlclNkcDogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DbGllbnREZXRhaWxzIGNsaWVudF9kZXRhaWxzID0gNDtcbiAgICovXG4gIGNsaWVudERldGFpbHM/OiBDbGllbnREZXRhaWxzO1xuICAvKipcbiAgICogVE9ETzogd2Ugc2hvdWxkIGtub3cgaWYgdGhpcyBpcyBnb2luZyB0byBiZVxuICAgKiAtIHB1Ymxpc2hpbmcgYW5kIHN1YnNjcmliaW5nLCBvciBqdXN0IHN1YnNjcmliaW5nIGZvciBmdXR1cmUgcm91dGluZ1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuTWlncmF0aW9uIG1pZ3JhdGlvbiA9IDU7XG4gICAqL1xuICBtaWdyYXRpb24/OiBNaWdyYXRpb247XG4gIC8qKlxuICAgKiBGYXN0IHJlY29ubmVjdCBmbGFnIGV4cGxpY2l0bHkgaW5kaWNhdGVzIHRoYXQgaWYgdGhlIHBhcnRpY2lwYW50IHNlc3Npb25cbiAgICogYW5kIHRoZSBhc3NvY2lhdGVkIHN0YXRlIGlzIHN0aWxsIHByZXNlbnQgaW4gdGhlIFNGVSwgdGhlIGNsaWVudCBpcyByZWFkeVxuICAgKiB0byByZXN0b3JlIHRoZSBQZWVyQ29ubmVjdGlvbiB3aXRoIGFuIElDRSByZXN0YXJ0LiBJZiB0aGUgU0ZVIHJlcGxpZXMgd2l0aFxuICAgKiBcInJlY29ubmVjdGVkOiB0cnVlXCIgaW4gaXRzIEpvaW5SZXNwb25zZSwgdGhlbiBpdCBpcyBzYWZlIHRvIHBlcmZvcm0gYW4gSUNFXG4gICAqIHJlc3RhcnQgb3IgZWxzZSB0aGUgZXhpc3RpbmcgUGVlckNvbm5lY3Rpb25zIG11c3QgYmUgY2xlYW5lZCB1cC5cbiAgICpcbiAgICogRm9yIHRoZSBTRlUsIGZhc3RfcmVjb25uZWN0OmZhbHNlIGluZGljYXRlcyB0aGF0IGV2ZW4gaWYgaXQgaGFzIHRoZSBzdGF0ZVxuICAgKiBjYWNoZWQsIHRoZSBjbGllbnQgc3RhdGUgaXMgbm90IGluIHN5bmMgYW5kIGhlbmNlIGl0IG11c3QgYmUgY2xlYW5lZCB1cCBiZWZvcmVcbiAgICogcHJvY2VlZGluZyBmdXJ0aGVyLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGJvb2wgZmFzdF9yZWNvbm5lY3QgPSA2O1xuICAgKi9cbiAgZmFzdFJlY29ubmVjdDogYm9vbGVhbjtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNaWdyYXRpb24ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgZnJvbV9zZnVfaWQgPSAxO1xuICAgKi9cbiAgZnJvbVNmdUlkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrSW5mbyBhbm5vdW5jZWRfdHJhY2tzID0gMjtcbiAgICovXG4gIGFubm91bmNlZFRyYWNrczogVHJhY2tJbmZvW107XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyBzdWJzY3JpcHRpb25zID0gMztcbiAgICovXG4gIHN1YnNjcmlwdGlvbnM6IFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1tdO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEpvaW5SZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZSBjYWxsX3N0YXRlID0gMTtcbiAgICovXG4gIGNhbGxTdGF0ZT86IENhbGxTdGF0ZTtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogYm9vbCByZWNvbm5lY3RlZCA9IDI7XG4gICAqL1xuICByZWNvbm5lY3RlZDogYm9vbGVhbjtcbn1cbi8qKlxuICogUGFydGljaXBhbnRKb2luZWQgaXMgZmlyZWQgd2hlbiBhIHVzZXIgam9pbnMgYSBjYWxsXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudEpvaW5lZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50Sm9pbmVkIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIGNhbGxfY2lkID0gMTtcbiAgICovXG4gIGNhbGxDaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSAyO1xuICAgKi9cbiAgcGFydGljaXBhbnQ/OiBQYXJ0aWNpcGFudDtcbn1cbi8qKlxuICogUGFydGljaXBhbnRKb2luZWQgaXMgZmlyZWQgd2hlbiBhIHVzZXIgbGVhdmVzIGEgY2FsbFxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRMZWZ0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFydGljaXBhbnRMZWZ0IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIGNhbGxfY2lkID0gMTtcbiAgICovXG4gIGNhbGxDaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSAyO1xuICAgKi9cbiAgcGFydGljaXBhbnQ/OiBQYXJ0aWNpcGFudDtcbn1cbi8qKlxuICogU3Vic2NyaWJlck9mZmVyIGlzIHNlbnQgd2hlbiB0aGUgU0ZVIGFkZHMgdHJhY2tzIHRvIGEgc3Vic2NyaXB0aW9uXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TdWJzY3JpYmVyT2ZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpYmVyT2ZmZXIge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBib29sIGljZV9yZXN0YXJ0ID0gMTtcbiAgICovXG4gIGljZVJlc3RhcnQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyBzZHAgPSAyO1xuICAgKi9cbiAgc2RwOiBzdHJpbmc7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUHVibGlzaGVyQW5zd2VyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHVibGlzaGVyQW5zd2VyIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHNkcCA9IDE7XG4gICAqL1xuICBzZHA6IHN0cmluZztcbn1cbi8qKlxuICogQ29ubmVjdGlvblF1YWxpdHkgaXMgc2VudCB0byBpbmZvcm0gYWJvdXQgY29ubmVjdGlvbiBxdWFsaXR5IGNoYW5nZXNcbiAqIGVnLiB0aGllcnJ5J3MgY29ubmVjdGlvbiBpcyBub3QgZ29vZCAtPiByZW5kZXIgYSByZWQgaWNvbiBab29tIHN0eWxlXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5SW5mbyBjb25uZWN0aW9uX3F1YWxpdHlfdXBkYXRlcyA9IDE7XG4gICAqL1xuICBjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXM6IENvbm5lY3Rpb25RdWFsaXR5SW5mb1tdO1xufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5SW5mb1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3Rpb25RdWFsaXR5SW5mbyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmluZyB1c2VyX2lkID0gMTtcbiAgICovXG4gIHVzZXJJZDogc3RyaW5nO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7XG4gICAqL1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHkgY29ubmVjdGlvbl9xdWFsaXR5ID0gMztcbiAgICovXG4gIGNvbm5lY3Rpb25RdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eTtcbn1cbi8qKlxuICogRG9taW5hbnRTcGVha2VyQ2hhbmdlZCBpcyBzZW50IGJ5IHRoZSBTRlUgdG8gbm90aWZ5IHdoZW4gdGhlcmUgaXMgYSBuZXcgZG9taW5hbnQgc3BlYWtlciBpbiB0aGUgY2FsbFxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRG9taW5hbnRTcGVha2VyQ2hhbmdlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIERvbWluYW50U3BlYWtlckNoYW5nZWQge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgdXNlcl9pZCA9IDE7XG4gICAqL1xuICB1c2VySWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHNlc3Npb25faWQgPSAyO1xuICAgKi9cbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvTGV2ZWwge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgdXNlcl9pZCA9IDE7XG4gICAqL1xuICB1c2VySWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyaW5nIHNlc3Npb25faWQgPSAyO1xuICAgKi9cbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAwLjAgbWVhbnMgY29tcGxldGUgc2lsZW5jZSwgMS4wIGxvdWRlc3RcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBmbG9hdCBsZXZlbCA9IDM7XG4gICAqL1xuICBsZXZlbDogbnVtYmVyO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBib29sIGlzX3NwZWFraW5nID0gNDtcbiAgICovXG4gIGlzU3BlYWtpbmc6IGJvb2xlYW47XG59XG4vKipcbiAqIEF1ZGlvTGV2ZWxDaGFuZ2VkIGlzIHNlbnQgYnkgdGhlIFNGVSB0byBub3RpZnkgYWJvdXQgYXVkaW8gbGV2ZWxzIGJ5IHVzZXJcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxDaGFuZ2VkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9MZXZlbENoYW5nZWQge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWwgYXVkaW9fbGV2ZWxzID0gMTtcbiAgICovXG4gIGF1ZGlvTGV2ZWxzOiBBdWRpb0xldmVsW107XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9NZWRpYVJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdWRpb01lZGlhUmVxdWVzdCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGludDMyIGNoYW5uZWxfY291bnQgPSAxO1xuICAgKi9cbiAgY2hhbm5lbENvdW50OiBudW1iZXI7XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9TZW5kZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdWRpb1NlbmRlciB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCA9IDE7XG4gICAqL1xuICBtZWRpYVJlcXVlc3Q/OiBBdWRpb01lZGlhUmVxdWVzdDtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgPSAyO1xuICAgKi9cbiAgY29kZWM/OiBDb2RlYztcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb01lZGlhUmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvTWVkaWFSZXF1ZXN0IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogaW50MzIgaWRlYWxfaGVpZ2h0ID0gMTtcbiAgICovXG4gIGlkZWFsSGVpZ2h0OiBudW1iZXI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGludDMyIGlkZWFsX3dpZHRoID0gMjtcbiAgICovXG4gIGlkZWFsV2lkdGg6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogaW50MzIgaWRlYWxfZnJhbWVfcmF0ZSA9IDM7XG4gICAqL1xuICBpZGVhbEZyYW1lUmF0ZTogbnVtYmVyO1xufVxuLyoqXG4gKiBWaWRlb0xheWVyU2V0dGluZyBpcyB1c2VkIHRvIHNwZWNpZnkgdmFyaW91cyBwYXJhbWV0ZXJzIG9mIGEgcGFydGljdWxhciBlbmNvZGluZyBpbiBzaW11bGNhc3QuXG4gKiBUaGUgcGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGhlcmUgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzXG4gKiBTREtzIHVzZSB0aGVzZSBwYXJhbWV0ZXJzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIGR5bmFtaWNhbGx5IGFkanVzdCB0aGVzZSBwYXJhbWV0ZXJzIHRvIHNhdmUgQ1BVLCBiYW5kd2lkdGhcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9MYXllclNldHRpbmcge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDE7XG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IGJvb2wgYWN0aXZlID0gMjtcbiAgICovXG4gIGFjdGl2ZTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogaW50MzIgbWF4X2JpdHJhdGUgPSAzO1xuICAgKi9cbiAgbWF4Qml0cmF0ZTogbnVtYmVyO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBmbG9hdCBzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgPSA0O1xuICAgKi9cbiAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiBudW1iZXI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHkgcHJpb3JpdHkgPSA1O1xuICAgKi9cbiAgcHJpb3JpdHk6IFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5O1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyA9IDY7XG4gICAqL1xuICBjb2RlYz86IENvZGVjO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiB1aW50MzIgbWF4X2ZyYW1lcmF0ZSA9IDc7XG4gICAqL1xuICBtYXhGcmFtZXJhdGU6IG51bWJlcjtcbn1cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZy5Qcmlvcml0eVxuICovXG5leHBvcnQgZW51bSBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogUFJJT1JJVFlfSElHSF9VTlNQRUNJRklFRCA9IDA7XG4gICAqL1xuICBISUdIX1VOU1BFQ0lGSUVEID0gMCxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBQUklPUklUWV9MT1cgPSAxO1xuICAgKi9cbiAgTE9XID0gMSxcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBQUklPUklUWV9NRURJVU0gPSAyO1xuICAgKi9cbiAgTUVESVVNID0gMixcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBQUklPUklUWV9WRVJZX0xPVyA9IDM7XG4gICAqL1xuICBWRVJZX0xPVyA9IDMsXG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9TZW5kZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWRlb1NlbmRlciB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCA9IDE7XG4gICAqL1xuICBtZWRpYVJlcXVlc3Q/OiBWaWRlb01lZGlhUmVxdWVzdDtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgPSAyO1xuICAgKi9cbiAgY29kZWM/OiBDb2RlYztcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZyBsYXllcnMgPSAzO1xuICAgKi9cbiAgbGF5ZXJzOiBWaWRlb0xheWVyU2V0dGluZ1tdO1xufVxuLyoqXG4gKiBzZW50IHRvIHVzZXJzIHdoZW4gdGhleSBuZWVkIHRvIGNoYW5nZSB0aGUgcXVhbGl0eSBvZiB0aGVpciB2aWRlb1xuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2hhbmdlUHVibGlzaFF1YWxpdHlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGFuZ2VQdWJsaXNoUXVhbGl0eSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9TZW5kZXIgYXVkaW9fc2VuZGVycyA9IDE7XG4gICAqL1xuICBhdWRpb1NlbmRlcnM6IEF1ZGlvU2VuZGVyW107XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmllbGQ6IHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9TZW5kZXIgdmlkZW9fc2VuZGVycyA9IDI7XG4gICAqL1xuICB2aWRlb1NlbmRlcnM6IFZpZGVvU2VuZGVyW107XG59XG4vKipcbiAqIENhbGxHcmFudHMgaXMgc2VudCB0byB1c2VycyB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlIGluIHRoZSBjYWxsIHBlcm1pc3Npb25zXG4gKiB0byBwdWJsaXNoIGF1ZGlvLCB2aWRlbyBvciBzaGFyZSB0aGUgc2NyZWVuIGZvciBhIHVzZXIgb3IgYSByb2xlLiBUaGlzIGlzXG4gKiBpZGVtcG90ZW50IGFuZCBjYW4gYmUgc2VudCBhdCBhbnkgdGltZS4gT25seSB0aGUgY3VycmVudF9ncmFudHMgaW4gdGhlIGxhdGVzdFxuICogbWVzc2FnZSBzaG91bGQgYmUgY29uc2lkZXJlZC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgaXMgbm90IGRlcGVuZGVudCBvbiBhbnlcbiAqIG90aGVyIG1lc3NhZ2UgKGluY2x1ZGluZyBwcmV2aW91cyBjYWxsX2dyYW50c191cGRhdGVkIG1lc3NhZ2UpXG4gKlxuICogV2hlbiB0aGlzIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIHRoZSBjbGllbnQgKHNheSwgUmVhY3QgY29tcG9uZW50KSBzaG91bGQgbXV0ZVxuICogdGhlIHRyYWNrcyB3aGljaCBhcmUgbm90IGFsbG93ZWQgYW55bW9yZS4gRm9yIGV4YW1wbGUsIGlmIHRoZSBtZXNzYWdlIGhhc1xuICogZ3JhbnRzIHthdWRpbzp0cnVlLCB2aWRlbzpmYWxzZX0gd2hpbGUgdGhlIHVzZXIgaXMgcHVibGlzaGluZyB2aWRlbywgdGhlbiB0aGVcbiAqIGNsaWVudCBjb21wb25lbnQgc2hvdWxkIG11dGUgdGhlIHZpZGVvIHRyYWNrIGFuZCBncmF5IG91dCB0aGUgdmlkZW8gYnV0dG9uLlxuICogVGhpcyB3YXksIHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gcHVibGlzaCB2aWRlbyB1bnRpbCB0aGUgcGVybWlzc2lvbnNcbiAqIGFyZSBncmFudGVkIGFnYWluLiBBbHNvLCBtdXRpbmcgdGhlIHRyYWNrIG9uIHRoZSBjbGllbnQgc2lkZSB3aWxsIHByZXZlbnRcbiAqIHRoZSBTRlUgZnJvbSByZWNlaXZpbmcgdGhlIHZpZGVvIHRyYWNrIGFuZCB3aWxsIHNhdmUgYmFuZHdpZHRoLlxuICpcbiAqIEluIHNpbXBsZSB3b3JkcywgdGhpcyBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIG11dGluZyBhIHRyYWNrIG9uIHRoZSBjbGllbnQuXG4gKiBIZXJlLCBpbnN0ZWFkIG9mIHRoZSB1c2VyIGluc3RydWN0aW5nIHRoZSBjbGllbnQsIFNGVSB3b3VsZCBiZSBkb2luZyBpdC5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNhbGxHcmFudHNVcGRhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbEdyYW50c1VwZGF0ZWQge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsR3JhbnRzIGN1cnJlbnRfZ3JhbnRzID0gMTtcbiAgICovXG4gIGN1cnJlbnRHcmFudHM/OiBDYWxsR3JhbnRzO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGZpZWxkOiBzdHJpbmcgbWVzc2FnZSA9IDI7XG4gICAqL1xuICBtZXNzYWdlOiBzdHJpbmc7XG59XG4vKipcbiAqIEdvIGF3YXkgaXMgc2VudCBieSB0aGUgU0ZVIHRvIHRoZSBjbGllbnQgdG8gc2lnbmFsIHRvIG1pZ3JhdGUgYXdheSBmcm9tIHRoZSBTRlUuXG4gKiBUaGUgZXZpY3QgcmVhc29uIG1heSBzcGVjaWZ5IHdoeSB0aGUgdXNlciBpcyBiZWluZyBldmljdGVkLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuR29Bd2F5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR29Bd2F5IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWVsZDogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuR29Bd2F5UmVhc29uIHJlYXNvbiA9IDE7XG4gICAqL1xuICByZWFzb246IEdvQXdheVJlYXNvbjtcbn1cbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNmdUV2ZW50JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxTZnVFdmVudD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVFdmVudCcsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdzdWJzY3JpYmVyX29mZmVyJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IFN1YnNjcmliZXJPZmZlcixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAyLFxuICAgICAgICBuYW1lOiAncHVibGlzaGVyX2Fuc3dlcicsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICBUOiAoKSA9PiBQdWJsaXNoZXJBbnN3ZXIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMyxcbiAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eV9jaGFuZ2VkJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA0LFxuICAgICAgICBuYW1lOiAnYXVkaW9fbGV2ZWxfY2hhbmdlZCcsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICBUOiAoKSA9PiBBdWRpb0xldmVsQ2hhbmdlZCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA1LFxuICAgICAgICBuYW1lOiAnaWNlX3RyaWNrbGUnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgVDogKCkgPT4gSUNFVHJpY2tsZSQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNixcbiAgICAgICAgbmFtZTogJ2NoYW5nZV9wdWJsaXNoX3F1YWxpdHknLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgVDogKCkgPT4gQ2hhbmdlUHVibGlzaFF1YWxpdHksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMTAsXG4gICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9qb2luZWQnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnRKb2luZWQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMTEsXG4gICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9sZWZ0JyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IFBhcnRpY2lwYW50TGVmdCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAxMixcbiAgICAgICAgbmFtZTogJ2RvbWluYW50X3NwZWFrZXJfY2hhbmdlZCcsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICBUOiAoKSA9PiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDEzLFxuICAgICAgICBuYW1lOiAnam9pbl9yZXNwb25zZScsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICBUOiAoKSA9PiBKb2luUmVzcG9uc2UsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMTQsXG4gICAgICAgIG5hbWU6ICdoZWFsdGhfY2hlY2tfcmVzcG9uc2UnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgVDogKCkgPT4gSGVhbHRoQ2hlY2tSZXNwb25zZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAxNixcbiAgICAgICAgbmFtZTogJ3RyYWNrX3B1Ymxpc2hlZCcsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICBUOiAoKSA9PiBUcmFja1B1Ymxpc2hlZCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAxNyxcbiAgICAgICAgbmFtZTogJ3RyYWNrX3VucHVibGlzaGVkJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IFRyYWNrVW5wdWJsaXNoZWQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMTgsXG4gICAgICAgIG5hbWU6ICdlcnJvcicsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICBUOiAoKSA9PiBFcnJvcixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAxOSxcbiAgICAgICAgbmFtZTogJ2NhbGxfZ3JhbnRzX3VwZGF0ZWQnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgVDogKCkgPT4gQ2FsbEdyYW50c1VwZGF0ZWQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMjAsXG4gICAgICAgIG5hbWU6ICdnb19hd2F5JyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IEdvQXdheSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAyMSxcbiAgICAgICAgbmFtZTogJ2ljZV9yZXN0YXJ0JyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IElDRVJlc3RhcnQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMjIsXG4gICAgICAgIG5hbWU6ICdwaW5zX3VwZGF0ZWQnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgVDogKCkgPT4gUGluc0NoYW5nZWQsXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFNmdUV2ZW50Pik6IFNmdUV2ZW50IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0geyBvbmVvZktpbmQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxTZnVFdmVudD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogU2Z1RXZlbnQsXG4gICk6IFNmdUV2ZW50IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlciBzdWJzY3JpYmVyX29mZmVyICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdzdWJzY3JpYmVyT2ZmZXInLFxuICAgICAgICAgICAgc3Vic2NyaWJlck9mZmVyOiBTdWJzY3JpYmVyT2ZmZXIuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkIGFzIGFueSkuc3Vic2NyaWJlck9mZmVyLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUHVibGlzaGVyQW5zd2VyIHB1Ymxpc2hlcl9hbnN3ZXIgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ3B1Ymxpc2hlckFuc3dlcicsXG4gICAgICAgICAgICBwdWJsaXNoZXJBbnN3ZXI6IFB1Ymxpc2hlckFuc3dlci5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5ldmVudFBheWxvYWQgYXMgYW55KS5wdWJsaXNoZXJBbnN3ZXIsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgY29ubmVjdGlvbl9xdWFsaXR5X2NoYW5nZWQgKi8gMzpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcsXG4gICAgICAgICAgICBjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6XG4gICAgICAgICAgICAgIENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIChtZXNzYWdlLmV2ZW50UGF5bG9hZCBhcyBhbnkpLmNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbENoYW5nZWQgYXVkaW9fbGV2ZWxfY2hhbmdlZCAqLyA0OlxuICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAnYXVkaW9MZXZlbENoYW5nZWQnLFxuICAgICAgICAgICAgYXVkaW9MZXZlbENoYW5nZWQ6IEF1ZGlvTGV2ZWxDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIChtZXNzYWdlLmV2ZW50UGF5bG9hZCBhcyBhbnkpLmF1ZGlvTGV2ZWxDaGFuZ2VkLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUgaWNlX3RyaWNrbGUgKi8gNTpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2ljZVRyaWNrbGUnLFxuICAgICAgICAgICAgaWNlVHJpY2tsZTogSUNFVHJpY2tsZSQuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkIGFzIGFueSkuaWNlVHJpY2tsZSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNoYW5nZVB1Ymxpc2hRdWFsaXR5IGNoYW5nZV9wdWJsaXNoX3F1YWxpdHkgKi8gNjpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2NoYW5nZVB1Ymxpc2hRdWFsaXR5JyxcbiAgICAgICAgICAgIGNoYW5nZVB1Ymxpc2hRdWFsaXR5OiBDaGFuZ2VQdWJsaXNoUXVhbGl0eS5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5ldmVudFBheWxvYWQgYXMgYW55KS5jaGFuZ2VQdWJsaXNoUXVhbGl0eSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkIHBhcnRpY2lwYW50X2pvaW5lZCAqLyAxMDpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ3BhcnRpY2lwYW50Sm9pbmVkJyxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50Sm9pbmVkOiBQYXJ0aWNpcGFudEpvaW5lZC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5ldmVudFBheWxvYWQgYXMgYW55KS5wYXJ0aWNpcGFudEpvaW5lZCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdCBwYXJ0aWNpcGFudF9sZWZ0ICovIDExOlxuICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAncGFydGljaXBhbnRMZWZ0JyxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50TGVmdDogUGFydGljaXBhbnRMZWZ0LmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIChtZXNzYWdlLmV2ZW50UGF5bG9hZCBhcyBhbnkpLnBhcnRpY2lwYW50TGVmdCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkRvbWluYW50U3BlYWtlckNoYW5nZWQgZG9taW5hbnRfc3BlYWtlcl9jaGFuZ2VkICovIDEyOlxuICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcsXG4gICAgICAgICAgICBkb21pbmFudFNwZWFrZXJDaGFuZ2VkOiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIChtZXNzYWdlLmV2ZW50UGF5bG9hZCBhcyBhbnkpLmRvbWluYW50U3BlYWtlckNoYW5nZWQsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVzcG9uc2Ugam9pbl9yZXNwb25zZSAqLyAxMzpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2pvaW5SZXNwb25zZScsXG4gICAgICAgICAgICBqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZS5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5ldmVudFBheWxvYWQgYXMgYW55KS5qb2luUmVzcG9uc2UsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1Jlc3BvbnNlIGhlYWx0aF9jaGVja19yZXNwb25zZSAqLyAxNDpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2hlYWx0aENoZWNrUmVzcG9uc2UnLFxuICAgICAgICAgICAgaGVhbHRoQ2hlY2tSZXNwb25zZTogSGVhbHRoQ2hlY2tSZXNwb25zZS5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5ldmVudFBheWxvYWQgYXMgYW55KS5oZWFsdGhDaGVja1Jlc3BvbnNlLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tQdWJsaXNoZWQgdHJhY2tfcHVibGlzaGVkICovIDE2OlxuICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAndHJhY2tQdWJsaXNoZWQnLFxuICAgICAgICAgICAgdHJhY2tQdWJsaXNoZWQ6IFRyYWNrUHVibGlzaGVkLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIChtZXNzYWdlLmV2ZW50UGF5bG9hZCBhcyBhbnkpLnRyYWNrUHVibGlzaGVkLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCB0cmFja191bnB1Ymxpc2hlZCAqLyAxNzpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ3RyYWNrVW5wdWJsaXNoZWQnLFxuICAgICAgICAgICAgdHJhY2tVbnB1Ymxpc2hlZDogVHJhY2tVbnB1Ymxpc2hlZC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5ldmVudFBheWxvYWQgYXMgYW55KS50cmFja1VucHVibGlzaGVkLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRXJyb3IgZXJyb3IgKi8gMTg6XG4gICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogRXJyb3IuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkIGFzIGFueSkuZXJyb3IsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DYWxsR3JhbnRzVXBkYXRlZCBjYWxsX2dyYW50c191cGRhdGVkICovIDE5OlxuICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAnY2FsbEdyYW50c1VwZGF0ZWQnLFxuICAgICAgICAgICAgY2FsbEdyYW50c1VwZGF0ZWQ6IENhbGxHcmFudHNVcGRhdGVkLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIChtZXNzYWdlLmV2ZW50UGF5bG9hZCBhcyBhbnkpLmNhbGxHcmFudHNVcGRhdGVkLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuR29Bd2F5IGdvX2F3YXkgKi8gMjA6XG4gICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICBvbmVvZktpbmQ6ICdnb0F3YXknLFxuICAgICAgICAgICAgZ29Bd2F5OiBHb0F3YXkuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkIGFzIGFueSkuZ29Bd2F5LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCBpY2VfcmVzdGFydCAqLyAyMTpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2ljZVJlc3RhcnQnLFxuICAgICAgICAgICAgaWNlUmVzdGFydDogSUNFUmVzdGFydC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5ldmVudFBheWxvYWQgYXMgYW55KS5pY2VSZXN0YXJ0LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGluc0NoYW5nZWQgcGluc191cGRhdGVkICovIDIyOlxuICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgb25lb2ZLaW5kOiAncGluc1VwZGF0ZWQnLFxuICAgICAgICAgICAgcGluc1VwZGF0ZWQ6IFBpbnNDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIChtZXNzYWdlLmV2ZW50UGF5bG9hZCBhcyBhbnkpLnBpbnNVcGRhdGVkLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBTZnVFdmVudCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlciBzdWJzY3JpYmVyX29mZmVyID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnc3Vic2NyaWJlck9mZmVyJylcbiAgICAgIFN1YnNjcmliZXJPZmZlci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZC5zdWJzY3JpYmVyT2ZmZXIsXG4gICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlciBwdWJsaXNoZXJfYW5zd2VyID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAncHVibGlzaGVyQW5zd2VyJylcbiAgICAgIFB1Ymxpc2hlckFuc3dlci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZC5wdWJsaXNoZXJBbnN3ZXIsXG4gICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCBjb25uZWN0aW9uX3F1YWxpdHlfY2hhbmdlZCA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcpXG4gICAgICBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQuY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLFxuICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsQ2hhbmdlZCBhdWRpb19sZXZlbF9jaGFuZ2VkID0gNDsgKi9cbiAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnYXVkaW9MZXZlbENoYW5nZWQnKVxuICAgICAgQXVkaW9MZXZlbENoYW5nZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQuYXVkaW9MZXZlbENoYW5nZWQsXG4gICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlIGljZV90cmlja2xlID0gNTsgKi9cbiAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnaWNlVHJpY2tsZScpXG4gICAgICBJQ0VUcmlja2xlJC5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZC5pY2VUcmlja2xlLFxuICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DaGFuZ2VQdWJsaXNoUXVhbGl0eSBjaGFuZ2VfcHVibGlzaF9xdWFsaXR5ID0gNjsgKi9cbiAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnY2hhbmdlUHVibGlzaFF1YWxpdHknKVxuICAgICAgQ2hhbmdlUHVibGlzaFF1YWxpdHkuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQuY2hhbmdlUHVibGlzaFF1YWxpdHksXG4gICAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkIHBhcnRpY2lwYW50X2pvaW5lZCA9IDEwOyAqL1xuICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdwYXJ0aWNpcGFudEpvaW5lZCcpXG4gICAgICBQYXJ0aWNpcGFudEpvaW5lZC5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZC5wYXJ0aWNpcGFudEpvaW5lZCxcbiAgICAgICAgd3JpdGVyLnRhZygxMCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdCBwYXJ0aWNpcGFudF9sZWZ0ID0gMTE7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3BhcnRpY2lwYW50TGVmdCcpXG4gICAgICBQYXJ0aWNpcGFudExlZnQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQucGFydGljaXBhbnRMZWZ0LFxuICAgICAgICB3cml0ZXIudGFnKDExLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRG9taW5hbnRTcGVha2VyQ2hhbmdlZCBkb21pbmFudF9zcGVha2VyX2NoYW5nZWQgPSAxMjsgKi9cbiAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcpXG4gICAgICBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmRvbWluYW50U3BlYWtlckNoYW5nZWQsXG4gICAgICAgIHdyaXRlci50YWcoMTIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVzcG9uc2Ugam9pbl9yZXNwb25zZSA9IDEzOyAqL1xuICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdqb2luUmVzcG9uc2UnKVxuICAgICAgSm9pblJlc3BvbnNlLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmpvaW5SZXNwb25zZSxcbiAgICAgICAgd3JpdGVyLnRhZygxMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVzcG9uc2UgaGVhbHRoX2NoZWNrX3Jlc3BvbnNlID0gMTQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2hlYWx0aENoZWNrUmVzcG9uc2UnKVxuICAgICAgSGVhbHRoQ2hlY2tSZXNwb25zZS5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZC5oZWFsdGhDaGVja1Jlc3BvbnNlLFxuICAgICAgICB3cml0ZXIudGFnKDE0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tQdWJsaXNoZWQgdHJhY2tfcHVibGlzaGVkID0gMTY7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3RyYWNrUHVibGlzaGVkJylcbiAgICAgIFRyYWNrUHVibGlzaGVkLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnRyYWNrUHVibGlzaGVkLFxuICAgICAgICB3cml0ZXIudGFnKDE2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCB0cmFja191bnB1Ymxpc2hlZCA9IDE3OyAqL1xuICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICd0cmFja1VucHVibGlzaGVkJylcbiAgICAgIFRyYWNrVW5wdWJsaXNoZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQudHJhY2tVbnB1Ymxpc2hlZCxcbiAgICAgICAgd3JpdGVyLnRhZygxNywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yIGVycm9yID0gMTg7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2Vycm9yJylcbiAgICAgIEVycm9yLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmVycm9yLFxuICAgICAgICB3cml0ZXIudGFnKDE4LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2FsbEdyYW50c1VwZGF0ZWQgY2FsbF9ncmFudHNfdXBkYXRlZCA9IDE5OyAqL1xuICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdjYWxsR3JhbnRzVXBkYXRlZCcpXG4gICAgICBDYWxsR3JhbnRzVXBkYXRlZC5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZC5jYWxsR3JhbnRzVXBkYXRlZCxcbiAgICAgICAgd3JpdGVyLnRhZygxOSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkdvQXdheSBnb19hd2F5ID0gMjA7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2dvQXdheScpXG4gICAgICBHb0F3YXkuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQuZ29Bd2F5LFxuICAgICAgICB3cml0ZXIudGFnKDIwLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCBpY2VfcmVzdGFydCA9IDIxOyAqL1xuICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdpY2VSZXN0YXJ0JylcbiAgICAgIElDRVJlc3RhcnQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQuaWNlUmVzdGFydCxcbiAgICAgICAgd3JpdGVyLnRhZygyMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkIHBpbnNfdXBkYXRlZCA9IDIyOyAqL1xuICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdwaW5zVXBkYXRlZCcpXG4gICAgICBQaW5zQ2hhbmdlZC5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZC5waW5zVXBkYXRlZCxcbiAgICAgICAgd3JpdGVyLnRhZygyMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVFdmVudFxuICovXG5leHBvcnQgY29uc3QgU2Z1RXZlbnQgPSBuZXcgU2Z1RXZlbnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGluc0NoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFBpbnNDaGFuZ2VkPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkJywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ3BpbnMnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgIFQ6ICgpID0+IFBpbixcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8UGluc0NoYW5nZWQ+KTogUGluc0NoYW5nZWQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5waW5zID0gW107XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFBpbnNDaGFuZ2VkPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBQaW5zQ2hhbmdlZCxcbiAgKTogUGluc0NoYW5nZWQge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5waW5zLnB1c2goXG4gICAgICAgICAgICBQaW4uaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBQaW5zQ2hhbmdlZCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QaW4gcGlucyA9IDE7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBpbnMubGVuZ3RoOyBpKyspXG4gICAgICBQaW4uaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5waW5zW2ldLFxuICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGluc0NoYW5nZWRcbiAqL1xuZXhwb3J0IGNvbnN0IFBpbnNDaGFuZ2VkID0gbmV3IFBpbnNDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEVycm9yJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxFcnJvcj4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5FcnJvcicsIFtcbiAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8RXJyb3I+KTogRXJyb3Ige1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPEVycm9yPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBFcnJvcixcbiAgKTogRXJyb3Ige1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5lcnJvcixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBFcnJvcixcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICBFcnJvciQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5lcnJvcixcbiAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBFcnJvciA9IG5ldyBFcnJvciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VUcmlja2xlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxJQ0VUcmlja2xlPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVRyaWNrbGUnLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAncGVlcl90eXBlJyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMixcbiAgICAgICAgbmFtZTogJ2ljZV9jYW5kaWRhdGUnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPElDRVRyaWNrbGU+KTogSUNFVHJpY2tsZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9ICcnO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxJQ0VUcmlja2xlPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBJQ0VUcmlja2xlLFxuICApOiBJQ0VUcmlja2xlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIGljZV9jYW5kaWRhdGUgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogSUNFVHJpY2tsZSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnBlZXJUeXBlICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucGVlclR5cGUpO1xuICAgIC8qIHN0cmluZyBpY2VfY2FuZGlkYXRlID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5pY2VDYW5kaWRhdGUgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmljZUNhbmRpZGF0ZSk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFVHJpY2tsZVxuICovXG5leHBvcnQgY29uc3QgSUNFVHJpY2tsZSA9IG5ldyBJQ0VUcmlja2xlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIElDRVJlc3RhcnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPElDRVJlc3RhcnQ+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCcsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdwZWVyX3R5cGUnLFxuICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUnLCBQZWVyVHlwZSwgJ1BFRVJfVFlQRV8nXSxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8SUNFUmVzdGFydD4pOiBJQ0VSZXN0YXJ0IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UucGVlclR5cGUgPSAwO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxJQ0VSZXN0YXJ0Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBJQ0VSZXN0YXJ0LFxuICApOiBJQ0VSZXN0YXJ0IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IElDRVJlc3RhcnQsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5JQ0VSZXN0YXJ0XG4gKi9cbmV4cG9ydCBjb25zdCBJQ0VSZXN0YXJ0ID0gbmV3IElDRVJlc3RhcnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2Z1UmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8U2Z1UmVxdWVzdD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVSZXF1ZXN0JywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ2pvaW5fcmVxdWVzdCcsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdyZXF1ZXN0UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IEpvaW5SZXF1ZXN0LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDIsXG4gICAgICAgIG5hbWU6ICdoZWFsdGhfY2hlY2tfcmVxdWVzdCcsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgb25lb2Y6ICdyZXF1ZXN0UGF5bG9hZCcsXG4gICAgICAgIFQ6ICgpID0+IEhlYWx0aENoZWNrUmVxdWVzdCxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8U2Z1UmVxdWVzdD4pOiBTZnVSZXF1ZXN0IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UucmVxdWVzdFBheWxvYWQgPSB7IG9uZW9mS2luZDogdW5kZWZpbmVkIH07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFNmdVJlcXVlc3Q+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFNmdVJlcXVlc3QsXG4gICk6IFNmdVJlcXVlc3Qge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlcXVlc3Qgam9pbl9yZXF1ZXN0ICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2pvaW5SZXF1ZXN0JyxcbiAgICAgICAgICAgIGpvaW5SZXF1ZXN0OiBKb2luUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZCBhcyBhbnkpLmpvaW5SZXF1ZXN0LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXF1ZXN0IGhlYWx0aF9jaGVja19yZXF1ZXN0ICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG9uZW9mS2luZDogJ2hlYWx0aENoZWNrUmVxdWVzdCcsXG4gICAgICAgICAgICBoZWFsdGhDaGVja1JlcXVlc3Q6IEhlYWx0aENoZWNrUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZCBhcyBhbnkpLmhlYWx0aENoZWNrUmVxdWVzdCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogU2Z1UmVxdWVzdCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXF1ZXN0IGpvaW5fcmVxdWVzdCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UucmVxdWVzdFBheWxvYWQub25lb2ZLaW5kID09PSAnam9pblJlcXVlc3QnKVxuICAgICAgSm9pblJlcXVlc3QuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5qb2luUmVxdWVzdCxcbiAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXF1ZXN0IGhlYWx0aF9jaGVja19yZXF1ZXN0ID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5vbmVvZktpbmQgPT09ICdoZWFsdGhDaGVja1JlcXVlc3QnKVxuICAgICAgSGVhbHRoQ2hlY2tSZXF1ZXN0LmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UucmVxdWVzdFBheWxvYWQuaGVhbHRoQ2hlY2tSZXF1ZXN0LFxuICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1UmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgU2Z1UmVxdWVzdCA9IG5ldyBTZnVSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEhlYWx0aENoZWNrUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8SGVhbHRoQ2hlY2tSZXF1ZXN0PiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVxdWVzdCcsIFtdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxIZWFsdGhDaGVja1JlcXVlc3Q+KTogSGVhbHRoQ2hlY2tSZXF1ZXN0IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxIZWFsdGhDaGVja1JlcXVlc3Q+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IEhlYWx0aENoZWNrUmVxdWVzdCxcbiAgKTogSGVhbHRoQ2hlY2tSZXF1ZXN0IHtcbiAgICByZXR1cm4gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCk7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBIZWFsdGhDaGVja1JlcXVlc3QsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBIZWFsdGhDaGVja1JlcXVlc3QgPSBuZXcgSGVhbHRoQ2hlY2tSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEhlYWx0aENoZWNrUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPEhlYWx0aENoZWNrUmVzcG9uc2U+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXNwb25zZScsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9jb3VudCcsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnRDb3VudCxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8SGVhbHRoQ2hlY2tSZXNwb25zZT4pOiBIZWFsdGhDaGVja1Jlc3BvbnNlIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxIZWFsdGhDaGVja1Jlc3BvbnNlPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBIZWFsdGhDaGVja1Jlc3BvbnNlLFxuICApOiBIZWFsdGhDaGVja1Jlc3BvbnNlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50IHBhcnRpY2lwYW50X2NvdW50ICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudENvdW50ID0gUGFydGljaXBhbnRDb3VudC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudENvdW50LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IEhlYWx0aENoZWNrUmVzcG9uc2UsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnRDb3VudClcbiAgICAgIFBhcnRpY2lwYW50Q291bnQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudENvdW50LFxuICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgSGVhbHRoQ2hlY2tSZXNwb25zZSA9IG5ldyBIZWFsdGhDaGVja1Jlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRyYWNrUHVibGlzaGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxUcmFja1B1Ymxpc2hlZD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZCcsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAge1xuICAgICAgICBubzogMyxcbiAgICAgICAgbmFtZTogJ3R5cGUnLFxuICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICBUcmFja1R5cGUsXG4gICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7IG5vOiA0LCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8VHJhY2tQdWJsaXNoZWQ+KTogVHJhY2tQdWJsaXNoZWQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFRyYWNrUHVibGlzaGVkPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBUcmFja1B1Ymxpc2hlZCxcbiAgKTogVHJhY2tQdWJsaXNoZWQge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCA9IFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFRyYWNrUHVibGlzaGVkLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMCkgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHlwZSk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50KVxuICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCxcbiAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrUHVibGlzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFja1B1Ymxpc2hlZCA9IG5ldyBUcmFja1B1Ymxpc2hlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja1VucHVibGlzaGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxUcmFja1VucHVibGlzaGVkPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrVW5wdWJsaXNoZWQnLCBbXG4gICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDMsXG4gICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgVHJhY2tUeXBlLFxuICAgICAgICAgICdUUkFDS19UWVBFXycsXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNCxcbiAgICAgICAgbmFtZTogJ2NhdXNlJyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVW5wdWJsaXNoUmVhc29uJyxcbiAgICAgICAgICBUcmFja1VucHVibGlzaFJlYXNvbixcbiAgICAgICAgICAnVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl8nLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDUsIG5hbWU6ICdwYXJ0aWNpcGFudCcsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gUGFydGljaXBhbnQgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxUcmFja1VucHVibGlzaGVkPik6IFRyYWNrVW5wdWJsaXNoZWQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgbWVzc2FnZS5jYXVzZSA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFRyYWNrVW5wdWJsaXNoZWQ+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFRyYWNrVW5wdWJsaXNoZWQsXG4gICk6IFRyYWNrVW5wdWJsaXNoZWQge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVW5wdWJsaXNoUmVhc29uIGNhdXNlICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5jYXVzZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ICovIDU6XG4gICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCA9IFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFRyYWNrVW5wdWJsaXNoZWQsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0eXBlID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS50eXBlICE9PSAwKSB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1VucHVibGlzaFJlYXNvbiBjYXVzZSA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2UuY2F1c2UgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jYXVzZSk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSA1OyAqL1xuICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50KVxuICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCxcbiAgICAgICAgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrVW5wdWJsaXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYWNrVW5wdWJsaXNoZWQgPSBuZXcgVHJhY2tVbnB1Ymxpc2hlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBKb2luUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8Sm9pblJlcXVlc3Q+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlcXVlc3QnLCBbXG4gICAgICB7IG5vOiAxLCBuYW1lOiAndG9rZW4nLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAnc3Vic2NyaWJlcl9zZHAnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogNCxcbiAgICAgICAgbmFtZTogJ2NsaWVudF9kZXRhaWxzJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBUOiAoKSA9PiBDbGllbnREZXRhaWxzLFxuICAgICAgfSxcbiAgICAgIHsgbm86IDUsIG5hbWU6ICdtaWdyYXRpb24nLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IE1pZ3JhdGlvbiB9LFxuICAgICAge1xuICAgICAgICBubzogNixcbiAgICAgICAgbmFtZTogJ2Zhc3RfcmVjb25uZWN0JyxcbiAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8Sm9pblJlcXVlc3Q+KTogSm9pblJlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS50b2tlbiA9ICcnO1xuICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgbWVzc2FnZS5zdWJzY3JpYmVyU2RwID0gJyc7XG4gICAgbWVzc2FnZS5mYXN0UmVjb25uZWN0ID0gZmFsc2U7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPEpvaW5SZXF1ZXN0Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBKb2luUmVxdWVzdCxcbiAgKTogSm9pblJlcXVlc3Qge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyB0b2tlbiAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UudG9rZW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgc3Vic2NyaWJlcl9zZHAgKi8gMzpcbiAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJTZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2xpZW50RGV0YWlscyBjbGllbnRfZGV0YWlscyAqLyA0OlxuICAgICAgICAgIG1lc3NhZ2UuY2xpZW50RGV0YWlscyA9IENsaWVudERldGFpbHMuaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1lc3NhZ2UuY2xpZW50RGV0YWlscyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuTWlncmF0aW9uIG1pZ3JhdGlvbiAqLyA1OlxuICAgICAgICAgIG1lc3NhZ2UubWlncmF0aW9uID0gTWlncmF0aW9uLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLm1pZ3JhdGlvbixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGJvb2wgZmFzdF9yZWNvbm5lY3QgKi8gNjpcbiAgICAgICAgICBtZXNzYWdlLmZhc3RSZWNvbm5lY3QgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBKb2luUmVxdWVzdCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgdG9rZW4gPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnRva2VuICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50b2tlbik7XG4gICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAvKiBzdHJpbmcgc3Vic2NyaWJlcl9zZHAgPSAzOyAqL1xuICAgIGlmIChtZXNzYWdlLnN1YnNjcmliZXJTZHAgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnN1YnNjcmliZXJTZHApO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNsaWVudERldGFpbHMgY2xpZW50X2RldGFpbHMgPSA0OyAqL1xuICAgIGlmIChtZXNzYWdlLmNsaWVudERldGFpbHMpXG4gICAgICBDbGllbnREZXRhaWxzLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuY2xpZW50RGV0YWlscyxcbiAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuTWlncmF0aW9uIG1pZ3JhdGlvbiA9IDU7ICovXG4gICAgaWYgKG1lc3NhZ2UubWlncmF0aW9uKVxuICAgICAgTWlncmF0aW9uLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UubWlncmF0aW9uLFxuICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogYm9vbCBmYXN0X3JlY29ubmVjdCA9IDY7ICovXG4gICAgaWYgKG1lc3NhZ2UuZmFzdFJlY29ubmVjdCAhPT0gZmFsc2UpXG4gICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmZhc3RSZWNvbm5lY3QpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBKb2luUmVxdWVzdCA9IG5ldyBKb2luUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBNaWdyYXRpb24kVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPE1pZ3JhdGlvbj4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb24nLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAnZnJvbV9zZnVfaWQnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMixcbiAgICAgICAgbmFtZTogJ2Fubm91bmNlZF90cmFja3MnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgIFQ6ICgpID0+IFRyYWNrSW5mbyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAnc3Vic2NyaXB0aW9ucycsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgVDogKCkgPT4gVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICAgICAgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxNaWdyYXRpb24+KTogTWlncmF0aW9uIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UuZnJvbVNmdUlkID0gJyc7XG4gICAgbWVzc2FnZS5hbm5vdW5jZWRUcmFja3MgPSBbXTtcbiAgICBtZXNzYWdlLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8TWlncmF0aW9uPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBNaWdyYXRpb24sXG4gICk6IE1pZ3JhdGlvbiB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIGZyb21fc2Z1X2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5mcm9tU2Z1SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIGFubm91bmNlZF90cmFja3MgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLmFubm91bmNlZFRyYWNrcy5wdXNoKFxuICAgICAgICAgICAgVHJhY2tJbmZvLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgc3Vic2NyaXB0aW9ucyAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgICAgICAgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IE1pZ3JhdGlvbixcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgZnJvbV9zZnVfaWQgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLmZyb21TZnVJZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZnJvbVNmdUlkKTtcbiAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8gYW5ub3VuY2VkX3RyYWNrcyA9IDI7ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmFubm91bmNlZFRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgIFRyYWNrSW5mby5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmFubm91bmNlZFRyYWNrc1tpXSxcbiAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyBzdWJzY3JpcHRpb25zID0gMzsgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2Uuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgIFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscy5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvbnNbaV0sXG4gICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IE1pZ3JhdGlvbiA9IG5ldyBNaWdyYXRpb24kVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSm9pblJlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxKb2luUmVzcG9uc2U+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlc3BvbnNlJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ2NhbGxfc3RhdGUnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENhbGxTdGF0ZSB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ3JlY29ubmVjdGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPEpvaW5SZXNwb25zZT4pOiBKb2luUmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5yZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxKb2luUmVzcG9uc2U+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IEpvaW5SZXNwb25zZSxcbiAgKTogSm9pblJlc3BvbnNlIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsU3RhdGUgY2FsbF9zdGF0ZSAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UuY2FsbFN0YXRlID0gQ2FsbFN0YXRlLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmNhbGxTdGF0ZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGJvb2wgcmVjb25uZWN0ZWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnJlY29ubmVjdGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogSm9pblJlc3BvbnNlLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZSBjYWxsX3N0YXRlID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5jYWxsU3RhdGUpXG4gICAgICBDYWxsU3RhdGUuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5jYWxsU3RhdGUsXG4gICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBib29sIHJlY29ubmVjdGVkID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5yZWNvbm5lY3RlZCAhPT0gZmFsc2UpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnJlY29ubmVjdGVkKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNvbnN0IEpvaW5SZXNwb25zZSA9IG5ldyBKb2luUmVzcG9uc2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnRKb2luZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFBhcnRpY2lwYW50Sm9pbmVkPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ2NhbGxfY2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8UGFydGljaXBhbnRKb2luZWQ+KTogUGFydGljaXBhbnRKb2luZWQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5jYWxsQ2lkID0gJyc7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFBhcnRpY2lwYW50Sm9pbmVkPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBQYXJ0aWNpcGFudEpvaW5lZCxcbiAgKTogUGFydGljaXBhbnRKb2luZWQge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBjYWxsX2NpZCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UuY2FsbENpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQgPSBQYXJ0aWNpcGFudC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBQYXJ0aWNpcGFudEpvaW5lZCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgY2FsbF9jaWQgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLmNhbGxDaWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmNhbGxDaWQpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudClcbiAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQsXG4gICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudEpvaW5lZFxuICovXG5leHBvcnQgY29uc3QgUGFydGljaXBhbnRKb2luZWQgPSBuZXcgUGFydGljaXBhbnRKb2luZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnRMZWZ0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxQYXJ0aWNpcGFudExlZnQ+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRMZWZ0JywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ2NhbGxfY2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8UGFydGljaXBhbnRMZWZ0Pik6IFBhcnRpY2lwYW50TGVmdCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLmNhbGxDaWQgPSAnJztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8UGFydGljaXBhbnRMZWZ0Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBQYXJ0aWNpcGFudExlZnQsXG4gICk6IFBhcnRpY2lwYW50TGVmdCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIGNhbGxfY2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5jYWxsQ2lkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCA9IFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFBhcnRpY2lwYW50TGVmdCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgY2FsbF9jaWQgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLmNhbGxDaWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmNhbGxDaWQpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudClcbiAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQsXG4gICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudExlZnRcbiAqL1xuZXhwb3J0IGNvbnN0IFBhcnRpY2lwYW50TGVmdCA9IG5ldyBQYXJ0aWNpcGFudExlZnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU3Vic2NyaWJlck9mZmVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxTdWJzY3JpYmVyT2ZmZXI+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuU3Vic2NyaWJlck9mZmVyJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ2ljZV9yZXN0YXJ0Jywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFN1YnNjcmliZXJPZmZlcj4pOiBTdWJzY3JpYmVyT2ZmZXIge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5pY2VSZXN0YXJ0ID0gZmFsc2U7XG4gICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8U3Vic2NyaWJlck9mZmVyPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBTdWJzY3JpYmVyT2ZmZXIsXG4gICk6IFN1YnNjcmliZXJPZmZlciB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogYm9vbCBpY2VfcmVzdGFydCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UuaWNlUmVzdGFydCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBTdWJzY3JpYmVyT2ZmZXIsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogYm9vbCBpY2VfcmVzdGFydCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UuaWNlUmVzdGFydCAhPT0gZmFsc2UpXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmljZVJlc3RhcnQpO1xuICAgIC8qIHN0cmluZyBzZHAgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLnNkcCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TdWJzY3JpYmVyT2ZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IFN1YnNjcmliZXJPZmZlciA9IG5ldyBTdWJzY3JpYmVyT2ZmZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUHVibGlzaGVyQW5zd2VyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxQdWJsaXNoZXJBbnN3ZXI+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuUHVibGlzaGVyQW5zd2VyJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFB1Ymxpc2hlckFuc3dlcj4pOiBQdWJsaXNoZXJBbnN3ZXIge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8UHVibGlzaGVyQW5zd2VyPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBQdWJsaXNoZXJBbnN3ZXIsXG4gICk6IFB1Ymxpc2hlckFuc3dlciB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBQdWJsaXNoZXJBbnN3ZXIsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyaW5nIHNkcCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlclxuICovXG5leHBvcnQgY29uc3QgUHVibGlzaGVyQW5zd2VyID0gbmV3IFB1Ymxpc2hlckFuc3dlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQnLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAnY29ubmVjdGlvbl9xdWFsaXR5X3VwZGF0ZXMnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgIFQ6ICgpID0+IENvbm5lY3Rpb25RdWFsaXR5SW5mbyxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKFxuICAgIHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8Q29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkPixcbiAgKTogQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzID0gW107XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLFxuICApOiBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvIGNvbm5lY3Rpb25fcXVhbGl0eV91cGRhdGVzICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMucHVzaChcbiAgICAgICAgICAgIENvbm5lY3Rpb25RdWFsaXR5SW5mby5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgcmVhZGVyLnVpbnQzMigpLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUluZm8gY29ubmVjdGlvbl9xdWFsaXR5X3VwZGF0ZXMgPSAxOyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICBDb25uZWN0aW9uUXVhbGl0eUluZm8uaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXNbaV0sXG4gICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcbiAqL1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IG5ldyBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ29ubmVjdGlvblF1YWxpdHlJbmZvJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxDb25uZWN0aW9uUXVhbGl0eUluZm8+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAnY29ubmVjdGlvbl9xdWFsaXR5JyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5JyxcbiAgICAgICAgICBDb25uZWN0aW9uUXVhbGl0eSxcbiAgICAgICAgICAnQ09OTkVDVElPTl9RVUFMSVRZXycsXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPENvbm5lY3Rpb25RdWFsaXR5SW5mbz4pOiBDb25uZWN0aW9uUXVhbGl0eUluZm8ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSAwO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxDb25uZWN0aW9uUXVhbGl0eUluZm8+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IENvbm5lY3Rpb25RdWFsaXR5SW5mbyxcbiAgKTogQ29ubmVjdGlvblF1YWxpdHlJbmZvIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHkgY29ubmVjdGlvbl9xdWFsaXR5ICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBDb25uZWN0aW9uUXVhbGl0eUluZm8sXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5IGNvbm5lY3Rpb25fcXVhbGl0eSA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXG4gKi9cbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uUXVhbGl0eUluZm8gPSBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIERvbWluYW50U3BlYWtlckNoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPERvbWluYW50U3BlYWtlckNoYW5nZWQ+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuRG9taW5hbnRTcGVha2VyQ2hhbmdlZCcsIFtcbiAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZShcbiAgICB2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPERvbWluYW50U3BlYWtlckNoYW5nZWQ+LFxuICApOiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8RG9taW5hbnRTcGVha2VyQ2hhbmdlZD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogRG9taW5hbnRTcGVha2VyQ2hhbmdlZCxcbiAgKTogRG9taW5hbnRTcGVha2VyQ2hhbmdlZCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Eb21pbmFudFNwZWFrZXJDaGFuZ2VkXG4gKi9cbmV4cG9ydCBjb25zdCBEb21pbmFudFNwZWFrZXJDaGFuZ2VkID0gbmV3IERvbWluYW50U3BlYWtlckNoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9MZXZlbCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8QXVkaW9MZXZlbD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICB7IG5vOiAzLCBuYW1lOiAnbGV2ZWwnLCBraW5kOiAnc2NhbGFyJywgVDogMiAvKlNjYWxhclR5cGUuRkxPQVQqLyB9LFxuICAgICAgeyBubzogNCwgbmFtZTogJ2lzX3NwZWFraW5nJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPEF1ZGlvTGV2ZWw+KTogQXVkaW9MZXZlbCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLnVzZXJJZCA9ICcnO1xuICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgbWVzc2FnZS5sZXZlbCA9IDA7XG4gICAgbWVzc2FnZS5pc1NwZWFraW5nID0gZmFsc2U7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPEF1ZGlvTGV2ZWw+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IEF1ZGlvTGV2ZWwsXG4gICk6IEF1ZGlvTGV2ZWwge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBmbG9hdCBsZXZlbCAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UubGV2ZWwgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIGlzX3NwZWFraW5nICovIDQ6XG4gICAgICAgICAgbWVzc2FnZS5pc1NwZWFraW5nID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogQXVkaW9MZXZlbCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UudXNlcklkICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS51c2VySWQpO1xuICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgLyogZmxvYXQgbGV2ZWwgPSAzOyAqL1xuICAgIGlmIChtZXNzYWdlLmxldmVsICE9PSAwKSB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkJpdDMyKS5mbG9hdChtZXNzYWdlLmxldmVsKTtcbiAgICAvKiBib29sIGlzX3NwZWFraW5nID0gNDsgKi9cbiAgICBpZiAobWVzc2FnZS5pc1NwZWFraW5nICE9PSBmYWxzZSlcbiAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuaXNTcGVha2luZyk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbFxuICovXG5leHBvcnQgY29uc3QgQXVkaW9MZXZlbCA9IG5ldyBBdWRpb0xldmVsJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEF1ZGlvTGV2ZWxDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxBdWRpb0xldmVsQ2hhbmdlZD4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsQ2hhbmdlZCcsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdhdWRpb19sZXZlbHMnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgIFQ6ICgpID0+IEF1ZGlvTGV2ZWwsXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPEF1ZGlvTGV2ZWxDaGFuZ2VkPik6IEF1ZGlvTGV2ZWxDaGFuZ2VkIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UuYXVkaW9MZXZlbHMgPSBbXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8QXVkaW9MZXZlbENoYW5nZWQ+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IEF1ZGlvTGV2ZWxDaGFuZ2VkLFxuICApOiBBdWRpb0xldmVsQ2hhbmdlZCB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsIGF1ZGlvX2xldmVscyAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UuYXVkaW9MZXZlbHMucHVzaChcbiAgICAgICAgICAgIEF1ZGlvTGV2ZWwuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBBdWRpb0xldmVsQ2hhbmdlZCxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWwgYXVkaW9fbGV2ZWxzID0gMTsgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuYXVkaW9MZXZlbHMubGVuZ3RoOyBpKyspXG4gICAgICBBdWRpb0xldmVsLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuYXVkaW9MZXZlbHNbaV0sXG4gICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsQ2hhbmdlZFxuICovXG5leHBvcnQgY29uc3QgQXVkaW9MZXZlbENoYW5nZWQgPSBuZXcgQXVkaW9MZXZlbENoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9NZWRpYVJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPEF1ZGlvTWVkaWFSZXF1ZXN0PiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTWVkaWFSZXF1ZXN0JywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ2NoYW5uZWxfY291bnQnLFxuICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8QXVkaW9NZWRpYVJlcXVlc3Q+KTogQXVkaW9NZWRpYVJlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5jaGFubmVsQ291bnQgPSAwO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxBdWRpb01lZGlhUmVxdWVzdD4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogQXVkaW9NZWRpYVJlcXVlc3QsXG4gICk6IEF1ZGlvTWVkaWFSZXF1ZXN0IHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBpbnQzMiBjaGFubmVsX2NvdW50ICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5jaGFubmVsQ291bnQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogQXVkaW9NZWRpYVJlcXVlc3QsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogaW50MzIgY2hhbm5lbF9jb3VudCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UuY2hhbm5lbENvdW50ICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuY2hhbm5lbENvdW50KTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb01lZGlhUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgQXVkaW9NZWRpYVJlcXVlc3QgPSBuZXcgQXVkaW9NZWRpYVJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9TZW5kZXIkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPEF1ZGlvU2VuZGVyPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvU2VuZGVyJywgW1xuICAgICAge1xuICAgICAgICBubzogMSxcbiAgICAgICAgbmFtZTogJ21lZGlhX3JlcXVlc3QnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIFQ6ICgpID0+IEF1ZGlvTWVkaWFSZXF1ZXN0LFxuICAgICAgfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdjb2RlYycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQ29kZWMgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxBdWRpb1NlbmRlcj4pOiBBdWRpb1NlbmRlciB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8QXVkaW9TZW5kZXI+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IEF1ZGlvU2VuZGVyLFxuICApOiBBdWRpb1NlbmRlciB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb01lZGlhUmVxdWVzdCBtZWRpYV9yZXF1ZXN0ICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5tZWRpYVJlcXVlc3QgPSBBdWRpb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5tZWRpYVJlcXVlc3QsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5jb2RlYyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkoXG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZpZWxkTm8sXG4gICAgICAgICAgICAgIHdpcmVUeXBlLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICBtZXNzYWdlOiBBdWRpb1NlbmRlcixcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTWVkaWFSZXF1ZXN0IG1lZGlhX3JlcXVlc3QgPSAxOyAqL1xuICAgIGlmIChtZXNzYWdlLm1lZGlhUmVxdWVzdClcbiAgICAgIEF1ZGlvTWVkaWFSZXF1ZXN0LmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UubWVkaWFSZXF1ZXN0LFxuICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLmNvZGVjKVxuICAgICAgQ29kZWMuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5jb2RlYyxcbiAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvU2VuZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBBdWRpb1NlbmRlciA9IG5ldyBBdWRpb1NlbmRlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb01lZGlhUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8VmlkZW9NZWRpYVJlcXVlc3Q+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3QnLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAnaWRlYWxfaGVpZ2h0JyxcbiAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8sXG4gICAgICB9LFxuICAgICAgeyBubzogMiwgbmFtZTogJ2lkZWFsX3dpZHRoJywga2luZDogJ3NjYWxhcicsIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8gfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDMsXG4gICAgICAgIG5hbWU6ICdpZGVhbF9mcmFtZV9yYXRlJyxcbiAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8sXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFZpZGVvTWVkaWFSZXF1ZXN0Pik6IFZpZGVvTWVkaWFSZXF1ZXN0IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UuaWRlYWxIZWlnaHQgPSAwO1xuICAgIG1lc3NhZ2UuaWRlYWxXaWR0aCA9IDA7XG4gICAgbWVzc2FnZS5pZGVhbEZyYW1lUmF0ZSA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPFZpZGVvTWVkaWFSZXF1ZXN0Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBWaWRlb01lZGlhUmVxdWVzdCxcbiAgKTogVmlkZW9NZWRpYVJlcXVlc3Qge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIGludDMyIGlkZWFsX2hlaWdodCAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UuaWRlYWxIZWlnaHQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBpbnQzMiBpZGVhbF93aWR0aCAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UuaWRlYWxXaWR0aCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGludDMyIGlkZWFsX2ZyYW1lX3JhdGUgKi8gMzpcbiAgICAgICAgICBtZXNzYWdlLmlkZWFsRnJhbWVSYXRlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFZpZGVvTWVkaWFSZXF1ZXN0LFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIGludDMyIGlkZWFsX2hlaWdodCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UuaWRlYWxIZWlnaHQgIT09IDApXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5pZGVhbEhlaWdodCk7XG4gICAgLyogaW50MzIgaWRlYWxfd2lkdGggPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLmlkZWFsV2lkdGggIT09IDApXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5pZGVhbFdpZHRoKTtcbiAgICAvKiBpbnQzMiBpZGVhbF9mcmFtZV9yYXRlID0gMzsgKi9cbiAgICBpZiAobWVzc2FnZS5pZGVhbEZyYW1lUmF0ZSAhPT0gMClcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmlkZWFsRnJhbWVSYXRlKTtcbiAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KShcbiAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgd3JpdGVyLFxuICAgICAgKTtcbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb01lZGlhUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgVmlkZW9NZWRpYVJlcXVlc3QgPSBuZXcgVmlkZW9NZWRpYVJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVmlkZW9MYXllclNldHRpbmckVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPFZpZGVvTGF5ZXJTZXR0aW5nPiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nJywgW1xuICAgICAgeyBubzogMSwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdhY3RpdmUnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICB7IG5vOiAzLCBuYW1lOiAnbWF4X2JpdHJhdGUnLCBraW5kOiAnc2NhbGFyJywgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAge1xuICAgICAgICBubzogNCxcbiAgICAgICAgbmFtZTogJ3NjYWxlX3Jlc29sdXRpb25fZG93bl9ieScsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBUOiAyIC8qU2NhbGFyVHlwZS5GTE9BVCovLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm86IDUsXG4gICAgICAgIG5hbWU6ICdwcmlvcml0eScsXG4gICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nLlByaW9yaXR5JyxcbiAgICAgICAgICBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSxcbiAgICAgICAgICAnUFJJT1JJVFlfJyxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7IG5vOiA2LCBuYW1lOiAnY29kZWMnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENvZGVjIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiA3LFxuICAgICAgICBuYW1lOiAnbWF4X2ZyYW1lcmF0ZScsXG4gICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8sXG4gICAgICB9LFxuICAgIF0pO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZT86IFBhcnRpYWxNZXNzYWdlPFZpZGVvTGF5ZXJTZXR0aW5nPik6IFZpZGVvTGF5ZXJTZXR0aW5nIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgIG1lc3NhZ2UuYWN0aXZlID0gZmFsc2U7XG4gICAgbWVzc2FnZS5tYXhCaXRyYXRlID0gMDtcbiAgICBtZXNzYWdlLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IDA7XG4gICAgbWVzc2FnZS5wcmlvcml0eSA9IDA7XG4gICAgbWVzc2FnZS5tYXhGcmFtZXJhdGUgPSAwO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbDxWaWRlb0xheWVyU2V0dGluZz4odGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5UmVhZChcbiAgICByZWFkZXI6IElCaW5hcnlSZWFkZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgb3B0aW9uczogQmluYXJ5UmVhZE9wdGlvbnMsXG4gICAgdGFyZ2V0PzogVmlkZW9MYXllclNldHRpbmcsXG4gICk6IFZpZGVvTGF5ZXJTZXR0aW5nIHtcbiAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLFxuICAgICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBib29sIGFjdGl2ZSAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UuYWN0aXZlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBpbnQzMiBtYXhfYml0cmF0ZSAqLyAzOlxuICAgICAgICAgIG1lc3NhZ2UubWF4Qml0cmF0ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIGZsb2F0IHNjYWxlX3Jlc29sdXRpb25fZG93bl9ieSAqLyA0OlxuICAgICAgICAgIG1lc3NhZ2Uuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZy5Qcmlvcml0eSBwcmlvcml0eSAqLyA1OlxuICAgICAgICAgIG1lc3NhZ2UucHJpb3JpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyAqLyA2OlxuICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5jb2RlYyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHVpbnQzMiBtYXhfZnJhbWVyYXRlICovIDc6XG4gICAgICAgICAgbWVzc2FnZS5tYXhGcmFtZXJhdGUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFZpZGVvTGF5ZXJTZXR0aW5nLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmluZyBuYW1lID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5uYW1lICE9PSAnJylcbiAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAvKiBib29sIGFjdGl2ZSA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UuYWN0aXZlICE9PSBmYWxzZSlcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuYWN0aXZlKTtcbiAgICAvKiBpbnQzMiBtYXhfYml0cmF0ZSA9IDM7ICovXG4gICAgaWYgKG1lc3NhZ2UubWF4Qml0cmF0ZSAhPT0gMClcbiAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLm1heEJpdHJhdGUpO1xuICAgIC8qIGZsb2F0IHNjYWxlX3Jlc29sdXRpb25fZG93bl9ieSA9IDQ7ICovXG4gICAgaWYgKG1lc3NhZ2Uuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5CaXQzMikuZmxvYXQobWVzc2FnZS5zY2FsZVJlc29sdXRpb25Eb3duQnkpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHkgcHJpb3JpdHkgPSA1OyAqL1xuICAgIGlmIChtZXNzYWdlLnByaW9yaXR5ICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucHJpb3JpdHkpO1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjID0gNjsgKi9cbiAgICBpZiAobWVzc2FnZS5jb2RlYylcbiAgICAgIENvZGVjLmludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgICAgIG1lc3NhZ2UuY29kZWMsXG4gICAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiB1aW50MzIgbWF4X2ZyYW1lcmF0ZSA9IDc7ICovXG4gICAgaWYgKG1lc3NhZ2UubWF4RnJhbWVyYXRlICE9PSAwKVxuICAgICAgd3JpdGVyLnRhZyg3LCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLm1heEZyYW1lcmF0ZSk7XG4gICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkoXG4gICAgICAgIHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHdyaXRlcixcbiAgICAgICk7XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvTGF5ZXJTZXR0aW5nID0gbmV3IFZpZGVvTGF5ZXJTZXR0aW5nJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvU2VuZGVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZTxWaWRlb1NlbmRlcj4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlcicsIFtcbiAgICAgIHtcbiAgICAgICAgbm86IDEsXG4gICAgICAgIG5hbWU6ICdtZWRpYV9yZXF1ZXN0JyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICBUOiAoKSA9PiBWaWRlb01lZGlhUmVxdWVzdCxcbiAgICAgIH0sXG4gICAgICB7IG5vOiAyLCBuYW1lOiAnY29kZWMnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENvZGVjIH0sXG4gICAgICB7XG4gICAgICAgIG5vOiAzLFxuICAgICAgICBuYW1lOiAnbGF5ZXJzJyxcbiAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICBUOiAoKSA9PiBWaWRlb0xheWVyU2V0dGluZyxcbiAgICAgIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8VmlkZW9TZW5kZXI+KTogVmlkZW9TZW5kZXIge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5sYXllcnMgPSBbXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8VmlkZW9TZW5kZXI+KHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgcmVhZGVyOiBJQmluYXJ5UmVhZGVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVJlYWRPcHRpb25zLFxuICAgIHRhcmdldD86IFZpZGVvU2VuZGVyLFxuICApOiBWaWRlb1NlbmRlciB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb01lZGlhUmVxdWVzdCBtZWRpYV9yZXF1ZXN0ICovIDE6XG4gICAgICAgICAgbWVzc2FnZS5tZWRpYVJlcXVlc3QgPSBWaWRlb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5tZWRpYVJlcXVlc3QsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWVzc2FnZS5jb2RlYyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcgbGF5ZXJzICovIDM6XG4gICAgICAgICAgbWVzc2FnZS5sYXllcnMucHVzaChcbiAgICAgICAgICAgIFZpZGVvTGF5ZXJTZXR0aW5nLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICByZWFkZXIudWludDMyKCksXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IFZpZGVvU2VuZGVyLFxuICAgIHdyaXRlcjogSUJpbmFyeVdyaXRlcixcbiAgICBvcHRpb25zOiBCaW5hcnlXcml0ZU9wdGlvbnMsXG4gICk6IElCaW5hcnlXcml0ZXIge1xuICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UubWVkaWFSZXF1ZXN0KVxuICAgICAgVmlkZW9NZWRpYVJlcXVlc3QuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5tZWRpYVJlcXVlc3QsXG4gICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyA9IDI7ICovXG4gICAgaWYgKG1lc3NhZ2UuY29kZWMpXG4gICAgICBDb2RlYy5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmNvZGVjLFxuICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZyBsYXllcnMgPSAzOyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5sYXllcnMubGVuZ3RoOyBpKyspXG4gICAgICBWaWRlb0xheWVyU2V0dGluZy5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLmxheWVyc1tpXSxcbiAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvU2VuZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb1NlbmRlciA9IG5ldyBWaWRlb1NlbmRlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDaGFuZ2VQdWJsaXNoUXVhbGl0eSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8Q2hhbmdlUHVibGlzaFF1YWxpdHk+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2hhbmdlUHVibGlzaFF1YWxpdHknLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAnYXVkaW9fc2VuZGVycycsXG4gICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgVDogKCkgPT4gQXVkaW9TZW5kZXIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBubzogMixcbiAgICAgICAgbmFtZTogJ3ZpZGVvX3NlbmRlcnMnLFxuICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgIFQ6ICgpID0+IFZpZGVvU2VuZGVyLFxuICAgICAgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxDaGFuZ2VQdWJsaXNoUXVhbGl0eT4pOiBDaGFuZ2VQdWJsaXNoUXVhbGl0eSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUhKTtcbiAgICBtZXNzYWdlLmF1ZGlvU2VuZGVycyA9IFtdO1xuICAgIG1lc3NhZ2UudmlkZW9TZW5kZXJzID0gW107XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPENoYW5nZVB1Ymxpc2hRdWFsaXR5Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBDaGFuZ2VQdWJsaXNoUXVhbGl0eSxcbiAgKTogQ2hhbmdlUHVibGlzaFF1YWxpdHkge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9TZW5kZXIgYXVkaW9fc2VuZGVycyAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UuYXVkaW9TZW5kZXJzLnB1c2goXG4gICAgICAgICAgICBBdWRpb1NlbmRlci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlciB2aWRlb19zZW5kZXJzICovIDI6XG4gICAgICAgICAgbWVzc2FnZS52aWRlb1NlbmRlcnMucHVzaChcbiAgICAgICAgICAgIFZpZGVvU2VuZGVyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogQ2hhbmdlUHVibGlzaFF1YWxpdHksXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb1NlbmRlciBhdWRpb19zZW5kZXJzID0gMTsgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuYXVkaW9TZW5kZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgQXVkaW9TZW5kZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5hdWRpb1NlbmRlcnNbaV0sXG4gICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApLmpvaW4oKTtcbiAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvU2VuZGVyIHZpZGVvX3NlbmRlcnMgPSAyOyAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS52aWRlb1NlbmRlcnMubGVuZ3RoOyBpKyspXG4gICAgICBWaWRlb1NlbmRlci5pbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgICAgICBtZXNzYWdlLnZpZGVvU2VuZGVyc1tpXSxcbiAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICkuam9pbigpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNoYW5nZVB1Ymxpc2hRdWFsaXR5XG4gKi9cbmV4cG9ydCBjb25zdCBDaGFuZ2VQdWJsaXNoUXVhbGl0eSA9IG5ldyBDaGFuZ2VQdWJsaXNoUXVhbGl0eSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDYWxsR3JhbnRzVXBkYXRlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGU8Q2FsbEdyYW50c1VwZGF0ZWQ+IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2FsbEdyYW50c1VwZGF0ZWQnLCBbXG4gICAgICB7IG5vOiAxLCBuYW1lOiAnY3VycmVudF9ncmFudHMnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENhbGxHcmFudHMgfSxcbiAgICAgIHsgbm86IDIsIG5hbWU6ICdtZXNzYWdlJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgXSk7XG4gIH1cbiAgY3JlYXRlKHZhbHVlPzogUGFydGlhbE1lc3NhZ2U8Q2FsbEdyYW50c1VwZGF0ZWQ+KTogQ2FsbEdyYW50c1VwZGF0ZWQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlISk7XG4gICAgbWVzc2FnZS5tZXNzYWdlID0gJyc7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsPENhbGxHcmFudHNVcGRhdGVkPih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBDYWxsR3JhbnRzVXBkYXRlZCxcbiAgKTogQ2FsbEdyYW50c1VwZGF0ZWQge1xuICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksXG4gICAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxHcmFudHMgY3VycmVudF9ncmFudHMgKi8gMTpcbiAgICAgICAgICBtZXNzYWdlLmN1cnJlbnRHcmFudHMgPSBDYWxsR3JhbnRzLmludGVybmFsQmluYXJ5UmVhZChcbiAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgIHJlYWRlci51aW50MzIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZXNzYWdlLmN1cnJlbnRHcmFudHMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWVzc2FnZSAqLyAyOlxuICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKFxuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICBmaWVsZE5vLFxuICAgICAgICAgICAgICB3aXJlVHlwZSxcbiAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGludGVybmFsQmluYXJ5V3JpdGUoXG4gICAgbWVzc2FnZTogQ2FsbEdyYW50c1VwZGF0ZWQsXG4gICAgd3JpdGVyOiBJQmluYXJ5V3JpdGVyLFxuICAgIG9wdGlvbnM6IEJpbmFyeVdyaXRlT3B0aW9ucyxcbiAgKTogSUJpbmFyeVdyaXRlciB7XG4gICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50cyBjdXJyZW50X2dyYW50cyA9IDE7ICovXG4gICAgaWYgKG1lc3NhZ2UuY3VycmVudEdyYW50cylcbiAgICAgIENhbGxHcmFudHMuaW50ZXJuYWxCaW5hcnlXcml0ZShcbiAgICAgICAgbWVzc2FnZS5jdXJyZW50R3JhbnRzLFxuICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKS5qb2luKCk7XG4gICAgLyogc3RyaW5nIG1lc3NhZ2UgPSAyOyAqL1xuICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT09ICcnKVxuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1lc3NhZ2UpO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNhbGxHcmFudHNVcGRhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBDYWxsR3JhbnRzVXBkYXRlZCA9IG5ldyBDYWxsR3JhbnRzVXBkYXRlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBHb0F3YXkkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlPEdvQXdheT4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Hb0F3YXknLCBbXG4gICAgICB7XG4gICAgICAgIG5vOiAxLFxuICAgICAgICBuYW1lOiAncmVhc29uJyxcbiAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkdvQXdheVJlYXNvbicsXG4gICAgICAgICAgR29Bd2F5UmVhc29uLFxuICAgICAgICAgICdHT19BV0FZX1JFQVNPTl8nLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICBdKTtcbiAgfVxuICBjcmVhdGUodmFsdWU/OiBQYXJ0aWFsTWVzc2FnZTxHb0F3YXk+KTogR29Bd2F5IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSEpO1xuICAgIG1lc3NhZ2UucmVhc29uID0gMDtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWw8R29Bd2F5Pih0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgaW50ZXJuYWxCaW5hcnlSZWFkKFxuICAgIHJlYWRlcjogSUJpbmFyeVJlYWRlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBvcHRpb25zOiBCaW5hcnlSZWFkT3B0aW9ucyxcbiAgICB0YXJnZXQ/OiBHb0F3YXksXG4gICk6IEdvQXdheSB7XG4gICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSxcbiAgICAgIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuR29Bd2F5UmVhc29uIHJlYXNvbiAqLyAxOlxuICAgICAgICAgIG1lc3NhZ2UucmVhc29uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KShcbiAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgZmllbGRObyxcbiAgICAgICAgICAgICAgd2lyZVR5cGUsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpbnRlcm5hbEJpbmFyeVdyaXRlKFxuICAgIG1lc3NhZ2U6IEdvQXdheSxcbiAgICB3cml0ZXI6IElCaW5hcnlXcml0ZXIsXG4gICAgb3B0aW9uczogQmluYXJ5V3JpdGVPcHRpb25zLFxuICApOiBJQmluYXJ5V3JpdGVyIHtcbiAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Hb0F3YXlSZWFzb24gcmVhc29uID0gMTsgKi9cbiAgICBpZiAobWVzc2FnZS5yZWFzb24gIT09IDApXG4gICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5yZWFzb24pO1xuICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKFxuICAgICAgICB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB3cml0ZXIsXG4gICAgICApO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkdvQXdheVxuICovXG5leHBvcnQgY29uc3QgR29Bd2F5ID0gbmV3IEdvQXdheSRUeXBlKCk7XG4iLCJpbXBvcnQgdHlwZSB7XG4gIFBhcnRpY2lwYW50LFxuICBWaWRlb0RpbWVuc2lvbixcbn0gZnJvbSAnLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHR5cGUge1xuICBKb2luQ2FsbFJlcXVlc3QsXG4gIE1lbWJlclJlc3BvbnNlLFxuICBPd25DYXBhYmlsaXR5LFxuICBSZWFjdGlvblJlc3BvbnNlLFxufSBmcm9tICcuL2dlbi9jb29yZGluYXRvcic7XG5pbXBvcnQgdHlwZSB7IFN0cmVhbUNsaWVudCB9IGZyb20gJy4vY29vcmRpbmF0b3IvY29ubmVjdGlvbi9jbGllbnQnO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi9zb3J0aW5nJztcbmltcG9ydCB0eXBlIHsgU3RyZWFtVmlkZW9Xcml0ZWFibGVTdGF0ZVN0b3JlIH0gZnJvbSAnLi9zdG9yZSc7XG5pbXBvcnQgeyBBeGlvc0Vycm9yIH0gZnJvbSAnYXhpb3MnO1xuXG5leHBvcnQgdHlwZSBTdHJlYW1SZWFjdGlvbiA9IFBpY2s8XG4gIFJlYWN0aW9uUmVzcG9uc2UsXG4gICd0eXBlJyB8ICdlbW9qaV9jb2RlJyB8ICdjdXN0b20nXG4+O1xuXG5leHBvcnQgZW51bSBWaXNpYmlsaXR5U3RhdGUge1xuICBVTktOT1dOID0gJ1VOS05PV04nLFxuICBWSVNJQkxFID0gJ1ZJU0lCTEUnLFxuICBJTlZJU0lCTEUgPSAnSU5WSVNJQkxFJyxcbn1cblxuZXhwb3J0IGVudW0gRGVib3VuY2VUeXBlIHtcbiAgSU1NRURJQVRFID0gMjAsXG4gIEZBU1QgPSAxMDAsXG4gIE1FRElVTSA9IDYwMCxcbiAgU0xPVyA9IDEyMDAsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgLyoqXG4gICAqIFRoZSBwYXJ0aWNpcGFudCdzIGF1ZGlvIHN0cmVhbSwgaWYgdGhleSBhcmUgcHVibGlzaGluZyBhdWRpbyBhbmRcbiAgICogd2UgaGF2ZSBzdWJzY3JpYmVkIHRvIGl0LlxuICAgKi9cbiAgYXVkaW9TdHJlYW0/OiBNZWRpYVN0cmVhbTtcblxuICAvKipcbiAgICogVGhlIHBhcnRpY2lwYW50J3MgdmlkZW8gc3RyZWFtLCBpZiB0aGV5IGFyZSBzaGFyaW5nIHRoZWlyIHZpZGVvLFxuICAgKiBhbmQgd2UgYXJlIHN1YnNjcmliZWQgdG8gaXQuXG4gICAqL1xuICB2aWRlb1N0cmVhbT86IE1lZGlhU3RyZWFtO1xuXG4gIC8qKlxuICAgKiBUaGUgcGFydGljaXBhbnQncyBzY3JlZW4gc2hhcmUgc3RyZWFtLCBpZiB0aGV5IGFyZSBzaGFyaW5nIHRoZWlyIHNjcmVlbixcbiAgICogYW5kIHdlIGFyZSBzdWJzY3JpYmVkIHRvIGl0LlxuICAgKi9cbiAgc2NyZWVuU2hhcmVTdHJlYW0/OiBNZWRpYVN0cmVhbTtcblxuICAvKipcbiAgICogVGhlIHBhcnRpY2lwYW50J3Mgc2NyZWVuIGF1ZGlvIHN0cmVhbSwgaWYgdGhleSBhcmUgc2hhcmluZyB0aGVpciBhdWRpbyxcbiAgICogYW5kIHdlIGFyZSBzdWJzY3JpYmVkIHRvIGl0LlxuICAgKi9cbiAgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbT86IE1lZGlhU3RyZWFtO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJlZmVycmVkIHZpZGVvIGRpbWVuc2lvbnMgZm9yIHRoaXMgcGFydGljaXBhbnQuXG4gICAqIFNldCBpdCB0byBgdW5kZWZpbmVkYCB0byB1bnN1YnNjcmliZSBmcm9tIHRoaXMgcGFydGljaXBhbnQncyB2aWRlby5cbiAgICovXG4gIHZpZGVvRGltZW5zaW9uPzogVmlkZW9EaW1lbnNpb247XG5cbiAgLyoqXG4gICAqIFRoZSBwcmVmZXJyZWQgc2NyZWVuIHNoYXJlIGRpbWVuc2lvbnMgZm9yIHRoaXMgcGFydGljaXBhbnQuXG4gICAqIFNldCBpdCB0byBgdW5kZWZpbmVkYCB0byB1bnN1YnNjcmliZSBmcm9tIHRoaXMgcGFydGljaXBhbnQncyBzY3JlZW4gc2hhcmUuXG4gICAqL1xuICBzY3JlZW5TaGFyZURpbWVuc2lvbj86IFZpZGVvRGltZW5zaW9uO1xuXG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBwYXJ0aWNpcGFudCBpcyB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqL1xuICBpc0xvY2FsUGFydGljaXBhbnQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgcGluIHN0YXRlIG9mIHRoZSBwYXJ0aWNpcGFudC5cbiAgICovXG4gIHBpbj86IFBhcnRpY2lwYW50UGluO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCByZWFjdGlvbiB0aGlzIHVzZXIgaGFzIHNlbnQgdG8gdGhpcyBjYWxsLlxuICAgKiBJbnRlZ3JhdG9ycyBjYW4gYmF0Y2gvY29sbGVjdCBwYXN0IHJlYWN0aW9ucyBhbmQgc2hvdyB0aGVtIHRvIHRoZSBVSS5cbiAgICovXG4gIHJlYWN0aW9uPzogU3RyZWFtUmVhY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBwYXJ0aWNpcGFudCdzIHRyYWNrcyB3aXRoaW4gYSBkZWZpbmVkIHZpZXdwb3J0LlxuICAgKi9cbiAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/OiBSZWNvcmQ8VmlkZW9UcmFja1R5cGUsIFZpc2liaWxpdHlTdGF0ZT47XG5cbiAgLyoqXG4gICAqIFRoZSB2b2x1bWUgb2YgdGhlIHBhcnRpY2lwYW50J3MgYXVkaW8gc3RyZWFtIChmcm9tIDAgdG8gMSkuXG4gICAqIFNldCBpdCB0byBgdW5kZWZpbmVkYCB0byB1c2UgdGhlIGRlZmF1bHQgdm9sdW1lLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIHZhbHVlIGlzIG5vdCBhcHBsaWNhYmxlIGluIFJlYWN0IE5hdGl2ZS5cbiAgICovXG4gIGF1ZGlvVm9sdW1lPzogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBWaWRlb1RyYWNrVHlwZSA9ICd2aWRlb1RyYWNrJyB8ICdzY3JlZW5TaGFyZVRyYWNrJztcbmV4cG9ydCB0eXBlIEF1ZGlvVHJhY2tUeXBlID0gJ2F1ZGlvVHJhY2snIHwgJ3NjcmVlblNoYXJlQXVkaW9UcmFjayc7XG5leHBvcnQgdHlwZSBUcmFja011dGVUeXBlID1cbiAgfCAnYXVkaW8nXG4gIHwgJ3ZpZGVvJ1xuICB8ICdzY3JlZW5zaGFyZSdcbiAgfCAnc2NyZWVuc2hhcmVfYXVkaW8nO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBwYXJ0aWNpcGFudCdzIHBpbiBzdGF0ZS5cbiAqL1xuZXhwb3J0IHR5cGUgUGFydGljaXBhbnRQaW4gPSB7XG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB0aGUgcGFydGljaXBhbnQgaXMgcGlubmVkIGJ5IHRoZSBsb2NhbCB1c2VyLlxuICAgKiBGYWxzZSBpZiB0aGUgcGFydGljaXBhbnQgaXMgcGlubmVkIHNlcnZlci1zaWRlLCBieSB0aGUgY2FsbCBtb2RlcmF0b3IuXG4gICAqL1xuICBpc0xvY2FsUGluOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaW1lc3RhbXAgd2hlbiB0aGUgcGFydGljaXBhbnQgaXMgcGlubmVkLlxuICAgKi9cbiAgcGlubmVkQXQ6IG51bWJlcjtcbn07XG5cbi8qKlxuICogQSBwYXJ0aWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTdHJlYW1WaWRlb1BhcnRpY2lwYW50LlxuICovXG5leHBvcnQgdHlwZSBTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2ggPSBQYXJ0aWFsPFN0cmVhbVZpZGVvUGFydGljaXBhbnQ+O1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudFBhdGNofSBvcmdhbml6ZWQgYnkgc2Vzc2lvbklkLlxuICovXG5leHBvcnQgdHlwZSBTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2hlcyA9IHtcbiAgW3Nlc3Npb25JZDogc3RyaW5nXTogU3RyZWFtVmlkZW9QYXJ0aWNpcGFudFBhdGNoO1xufTtcblxuZXhwb3J0IHR5cGUgU3Vic2NyaXB0aW9uQ2hhbmdlID0ge1xuICAvKipcbiAgICogVGhlIHZpZGVvIGRpbWVuc2lvbiB0byByZXF1ZXN0LlxuICAgKiBTZXQgaXQgdG8gYHVuZGVmaW5lZGAgaW4gY2FzZSB5b3Ugd2FudCB0byB1bnN1YnNjcmliZS5cbiAgICovXG4gIGRpbWVuc2lvbjogVmlkZW9EaW1lbnNpb24gfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBTdWJzY3JpcHRpb25DaGFuZ2VzID0ge1xuICBbc2Vzc2lvbklkOiBzdHJpbmddOiBTdWJzY3JpcHRpb25DaGFuZ2U7XG59O1xuXG5leHBvcnQgdHlwZSBQdWJsaXNoT3B0aW9ucyA9IHtcbiAgcHJlZmVycmVkQ29kZWM/OiBzdHJpbmcgfCBudWxsO1xuICBzY3JlZW5TaGFyZVNldHRpbmdzPzogU2NyZWVuU2hhcmVTZXR0aW5ncztcbn07XG5cbmV4cG9ydCB0eXBlIFNjcmVlblNoYXJlU2V0dGluZ3MgPSB7XG4gIC8qKlxuICAgKiBMaW1pdHMgdGhlIG1heGltdW0gZnJhbWVyYXRlIChpbiBmcmFtZXMgcGVyIHNlY29uZCkgb2YgdGhlIHNjcmVlbiBzaGFyZS5cbiAgICogRGVmYXVsdHMgdG8gMzAuXG4gICAqL1xuICBtYXhGcmFtZXJhdGU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIExpbWl0cyB0aGUgbWF4aW11bSBiaXRyYXRlIChpbiBiaXRzIHBlciBzZWNvbmQpIG9mIHRoZSBzY3JlZW4gc2hhcmUuXG4gICAqIERlZmF1bHRzIHRvIDMwMDAwMDAgKDNNYnBzKS5cbiAgICovXG4gIG1heEJpdHJhdGU/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBDYWxsTGVhdmVPcHRpb25zID0ge1xuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIGNhbGxlciB3aWxsIGdldCBhIGBjYWxsLnJlamVjdGVkYCBldmVudC5cbiAgICogSGFzIGFuIGVmZmVjdCBvbmx5IGlmIHRoZSBjYWxsIGlzIGluIHRoZSBgcmluZ2luZ2Agc3RhdGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWAuXG4gICAqL1xuICByZWplY3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIGZvciBsZWF2aW5nIHRoZSBjYWxsLlxuICAgKiBUaGlzIHdpbGwgYmUgc2VudCB0byB0aGUgYmFja2VuZCBhbmQgd2lsbCBiZSB2aXNpYmxlIGluIHRoZSBsb2dzLlxuICAgKi9cbiAgcmVhc29uPzogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHtAbGluayBDYWxsfSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IHR5cGUgQ2FsbENvbnN0cnVjdG9yID0ge1xuICAvKipcbiAgICogVGhlIHN0cmVhbUNsaWVudCBpbnN0YW5jZSB0byB1c2UuXG4gICAqL1xuICBzdHJlYW1DbGllbnQ6IFN0cmVhbUNsaWVudDtcblxuICAvKipcbiAgICogVGhlIENhbGwgdHlwZS5cbiAgICovXG4gIHR5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIENhbGwgSUQuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBsaXN0IG9mIHtAbGluayBNZW1iZXJSZXNwb25zZX0gZnJvbSB0aGUgYmFja2VuZC5cbiAgICogSWYgcHJvdmlkZWQsIHRoZSBjYWxsIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZGF0YSBmcm9tIHRoaXMgb2JqZWN0LlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGluaXRpYWxpemluZyBhIG5ldyBcInBlbmRpbmcgY2FsbFwiIGZyb20gYW4gZXZlbnQuXG4gICAqL1xuICBtZW1iZXJzPzogTWVtYmVyUmVzcG9uc2VbXTtcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGlzdCBvZiB7QGxpbmsgT3duQ2FwYWJpbGl0eX0gY29taW5nIGZyb20gdGhlIGJhY2tlZC5cbiAgICogSWYgcHJvdmlkZWQsIHRoZSBjYWxsIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZGF0YSBmcm9tIHRoaXMgb2JqZWN0LlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGluaXRpYWxpemluZyBhIG5ldyBcInBlbmRpbmcgY2FsbFwiIGZyb20gYW4gZXZlbnQuXG4gICAqL1xuICBvd25DYXBhYmlsaXRpZXM/OiBPd25DYXBhYmlsaXR5W107XG5cbiAgLyoqXG4gICAqIEZsYWdzIHRoZSBjYWxsIGFzIGEgcmluZ2luZyBjYWxsLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmluZ2luZz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHRoaXMgY2FsbCBpbnN0YW5jZSBzaG91bGQgcmVjZWl2ZSB1cGRhdGVzIGZyb20gdGhlIGJhY2tlbmQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlLlxuICAgKi9cbiAgd2F0Y2hpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjb21wYXJhdG9yIHRvIHVzZSB3aGVuIHNvcnRpbmcgcGFydGljaXBhbnRzLlxuICAgKi9cbiAgc29ydFBhcnRpY2lwYW50c0J5PzogQ29tcGFyYXRvcjxTdHJlYW1WaWRlb1BhcnRpY2lwYW50PjtcblxuICAvKipcbiAgICogVGhlIHN0YXRlIHN0b3JlIG9mIHRoZSBjbGllbnRcbiAgICovXG4gIGNsaWVudFN0b3JlOiBTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmU7XG59O1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIENhbGwuam9pbn0gbWV0aG9kLlxuICovXG5leHBvcnQgdHlwZSBKb2luQ2FsbERhdGEgPSBPbWl0PEpvaW5DYWxsUmVxdWVzdCwgJ2xvY2F0aW9uJz47XG5leHBvcnQgeyBBeGlvc0Vycm9yIH07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQGdlbmVyYXRlZCBieSBwcm90b2J1Zi10cyAyLjkuMyB3aXRoIHBhcmFtZXRlciBsb25nX3R5cGVfc3RyaW5nLGNsaWVudF9nZW5lcmljLHNlcnZlcl9ub25lLGVzbGludF9kaXNhYmxlXG4vLyBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmlsZSBcInZpZGVvL3NmdS9zaWduYWxfcnBjL3NpZ25hbC5wcm90b1wiIChwYWNrYWdlIFwic3RyZWFtLnZpZGVvLnNmdS5zaWduYWxcIiwgc3ludGF4IHByb3RvMylcbi8vIHRzbGludDpkaXNhYmxlXG5pbXBvcnQgdHlwZSB7XG4gIFJwY09wdGlvbnMsXG4gIFJwY1RyYW5zcG9ydCxcbiAgU2VydmljZUluZm8sXG4gIFVuYXJ5Q2FsbCxcbn0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUtcnBjJztcbmltcG9ydCB7IHN0YWNrSW50ZXJjZXB0IH0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUtcnBjJztcbmltcG9ydCB0eXBlIHtcbiAgSUNFUmVzdGFydFJlcXVlc3QsXG4gIElDRVJlc3RhcnRSZXNwb25zZSxcbiAgSUNFVHJpY2tsZVJlc3BvbnNlLFxuICBTZW5kQW5zd2VyUmVxdWVzdCxcbiAgU2VuZEFuc3dlclJlc3BvbnNlLFxuICBTZW5kU3RhdHNSZXF1ZXN0LFxuICBTZW5kU3RhdHNSZXNwb25zZSxcbiAgU2V0UHVibGlzaGVyUmVxdWVzdCxcbiAgU2V0UHVibGlzaGVyUmVzcG9uc2UsXG4gIFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0LFxuICBVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UsXG4gIFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0LFxuICBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2UsXG59IGZyb20gJy4vc2lnbmFsJztcbmltcG9ydCB7IFNpZ25hbFNlcnZlciB9IGZyb20gJy4vc2lnbmFsJztcbmltcG9ydCB0eXBlIHsgSUNFVHJpY2tsZSB9IGZyb20gJy4uL21vZGVscy9tb2RlbHMnO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBzZXJ2aWNlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNpZ25hbFNlcnZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIElTaWduYWxTZXJ2ZXJDbGllbnQge1xuICAvKipcbiAgICogU2V0UHVibGlzaGVyIHNlbmRzIHRoZSBXZWJSVEMgb2ZmZXIgZm9yIHRoZSBwZWVyIGNvbm5lY3Rpb24gdXNlZCB0byBwdWJsaXNoIEEvVlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBTZXRQdWJsaXNoZXIoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVzcG9uc2UpO1xuICAgKi9cbiAgc2V0UHVibGlzaGVyKFxuICAgIGlucHV0OiBTZXRQdWJsaXNoZXJSZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBScGNPcHRpb25zLFxuICApOiBVbmFyeUNhbGw8U2V0UHVibGlzaGVyUmVxdWVzdCwgU2V0UHVibGlzaGVyUmVzcG9uc2U+O1xuICAvKipcbiAgICogYW5zd2VyIGlzIHNlbnQgYnkgdGhlIGNsaWVudCB0byB0aGUgU0ZVIGFmdGVyIHJlY2VpdmluZyBhIHN1YnNjcmliZXJfb2ZmZXIuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFNlbmRBbnN3ZXIoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZEFuc3dlclJlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXNwb25zZSk7XG4gICAqL1xuICBzZW5kQW5zd2VyKFxuICAgIGlucHV0OiBTZW5kQW5zd2VyUmVxdWVzdCxcbiAgICBvcHRpb25zPzogUnBjT3B0aW9ucyxcbiAgKTogVW5hcnlDYWxsPFNlbmRBbnN3ZXJSZXF1ZXN0LCBTZW5kQW5zd2VyUmVzcG9uc2U+O1xuICAvKipcbiAgICogU2VuZElDRUNhbmRpZGF0ZSBzZW5kcyBhbiBJQ0UgY2FuZGlkYXRlIHRvIHRoZSBjbGllbnRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogSWNlVHJpY2tsZShzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlKSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VUcmlja2xlUmVzcG9uc2UpO1xuICAgKi9cbiAgaWNlVHJpY2tsZShcbiAgICBpbnB1dDogSUNFVHJpY2tsZSxcbiAgICBvcHRpb25zPzogUnBjT3B0aW9ucyxcbiAgKTogVW5hcnlDYWxsPElDRVRyaWNrbGUsIElDRVRyaWNrbGVSZXNwb25zZT47XG4gIC8qKlxuICAgKiBVcGRhdGVTdWJzY3JpYmVycyBpcyB1c2VkIHRvIG5vdGlmeSB0aGUgU0ZVIGFib3V0IHRoZSBsaXN0IG9mIHZpZGVvIHN1YnNjcmlwdGlvbnNcbiAgICogVE9ETzogc3luYyBzdWJzY3JpcHRpb25zIGJhc2VkIG9uIHRoaXMgKyB1cGRhdGUgdHJhY2tzIHVzaW5nIHRoZSBkaW1lbnNpb24gaW5mbyBzZW50IGJ5IHRoZSB1c2VyXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFVwZGF0ZVN1YnNjcmlwdGlvbnMoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSk7XG4gICAqL1xuICB1cGRhdGVTdWJzY3JpcHRpb25zKFxuICAgIGlucHV0OiBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCxcbiAgICBvcHRpb25zPzogUnBjT3B0aW9ucyxcbiAgKTogVW5hcnlDYWxsPFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0LCBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2U+O1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogVXBkYXRlTXV0ZVN0YXRlcyhzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlKTtcbiAgICovXG4gIHVwZGF0ZU11dGVTdGF0ZXMoXG4gICAgaW5wdXQ6IFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBScGNPcHRpb25zLFxuICApOiBVbmFyeUNhbGw8VXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QsIFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZT47XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBJY2VSZXN0YXJ0KHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VSZXN0YXJ0UmVzcG9uc2UpO1xuICAgKi9cbiAgaWNlUmVzdGFydChcbiAgICBpbnB1dDogSUNFUmVzdGFydFJlcXVlc3QsXG4gICAgb3B0aW9ucz86IFJwY09wdGlvbnMsXG4gICk6IFVuYXJ5Q2FsbDxJQ0VSZXN0YXJ0UmVxdWVzdCwgSUNFUmVzdGFydFJlc3BvbnNlPjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFNlbmRTdGF0cyhzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXNwb25zZSk7XG4gICAqL1xuICBzZW5kU3RhdHMoXG4gICAgaW5wdXQ6IFNlbmRTdGF0c1JlcXVlc3QsXG4gICAgb3B0aW9ucz86IFJwY09wdGlvbnMsXG4gICk6IFVuYXJ5Q2FsbDxTZW5kU3RhdHNSZXF1ZXN0LCBTZW5kU3RhdHNSZXNwb25zZT47XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBzZXJ2aWNlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNpZ25hbFNlcnZlclxuICovXG5leHBvcnQgY2xhc3MgU2lnbmFsU2VydmVyQ2xpZW50IGltcGxlbWVudHMgSVNpZ25hbFNlcnZlckNsaWVudCwgU2VydmljZUluZm8ge1xuICB0eXBlTmFtZSA9IFNpZ25hbFNlcnZlci50eXBlTmFtZTtcbiAgbWV0aG9kcyA9IFNpZ25hbFNlcnZlci5tZXRob2RzO1xuICBvcHRpb25zID0gU2lnbmFsU2VydmVyLm9wdGlvbnM7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX3RyYW5zcG9ydDogUnBjVHJhbnNwb3J0KSB7fVxuICAvKipcbiAgICogU2V0UHVibGlzaGVyIHNlbmRzIHRoZSBXZWJSVEMgb2ZmZXIgZm9yIHRoZSBwZWVyIGNvbm5lY3Rpb24gdXNlZCB0byBwdWJsaXNoIEEvVlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBTZXRQdWJsaXNoZXIoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVzcG9uc2UpO1xuICAgKi9cbiAgc2V0UHVibGlzaGVyKFxuICAgIGlucHV0OiBTZXRQdWJsaXNoZXJSZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBScGNPcHRpb25zLFxuICApOiBVbmFyeUNhbGw8U2V0UHVibGlzaGVyUmVxdWVzdCwgU2V0UHVibGlzaGVyUmVzcG9uc2U+IHtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbMF0sXG4gICAgICBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBzdGFja0ludGVyY2VwdDxTZXRQdWJsaXNoZXJSZXF1ZXN0LCBTZXRQdWJsaXNoZXJSZXNwb25zZT4oXG4gICAgICAndW5hcnknLFxuICAgICAgdGhpcy5fdHJhbnNwb3J0LFxuICAgICAgbWV0aG9kLFxuICAgICAgb3B0LFxuICAgICAgaW5wdXQsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogYW5zd2VyIGlzIHNlbnQgYnkgdGhlIGNsaWVudCB0byB0aGUgU0ZVIGFmdGVyIHJlY2VpdmluZyBhIHN1YnNjcmliZXJfb2ZmZXIuXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFNlbmRBbnN3ZXIoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZEFuc3dlclJlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXNwb25zZSk7XG4gICAqL1xuICBzZW5kQW5zd2VyKFxuICAgIGlucHV0OiBTZW5kQW5zd2VyUmVxdWVzdCxcbiAgICBvcHRpb25zPzogUnBjT3B0aW9ucyxcbiAgKTogVW5hcnlDYWxsPFNlbmRBbnN3ZXJSZXF1ZXN0LCBTZW5kQW5zd2VyUmVzcG9uc2U+IHtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbMV0sXG4gICAgICBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBzdGFja0ludGVyY2VwdDxTZW5kQW5zd2VyUmVxdWVzdCwgU2VuZEFuc3dlclJlc3BvbnNlPihcbiAgICAgICd1bmFyeScsXG4gICAgICB0aGlzLl90cmFuc3BvcnQsXG4gICAgICBtZXRob2QsXG4gICAgICBvcHQsXG4gICAgICBpbnB1dCxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kSUNFQ2FuZGlkYXRlIHNlbmRzIGFuIElDRSBjYW5kaWRhdGUgdG8gdGhlIGNsaWVudFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBJY2VUcmlja2xlKHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVRyaWNrbGVSZXNwb25zZSk7XG4gICAqL1xuICBpY2VUcmlja2xlKFxuICAgIGlucHV0OiBJQ0VUcmlja2xlLFxuICAgIG9wdGlvbnM/OiBScGNPcHRpb25zLFxuICApOiBVbmFyeUNhbGw8SUNFVHJpY2tsZSwgSUNFVHJpY2tsZVJlc3BvbnNlPiB7XG4gICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzJdLFxuICAgICAgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQ8SUNFVHJpY2tsZSwgSUNFVHJpY2tsZVJlc3BvbnNlPihcbiAgICAgICd1bmFyeScsXG4gICAgICB0aGlzLl90cmFuc3BvcnQsXG4gICAgICBtZXRob2QsXG4gICAgICBvcHQsXG4gICAgICBpbnB1dCxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVTdWJzY3JpYmVycyBpcyB1c2VkIHRvIG5vdGlmeSB0aGUgU0ZVIGFib3V0IHRoZSBsaXN0IG9mIHZpZGVvIHN1YnNjcmlwdGlvbnNcbiAgICogVE9ETzogc3luYyBzdWJzY3JpcHRpb25zIGJhc2VkIG9uIHRoaXMgKyB1cGRhdGUgdHJhY2tzIHVzaW5nIHRoZSBkaW1lbnNpb24gaW5mbyBzZW50IGJ5IHRoZSB1c2VyXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFVwZGF0ZVN1YnNjcmlwdGlvbnMoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSk7XG4gICAqL1xuICB1cGRhdGVTdWJzY3JpcHRpb25zKFxuICAgIGlucHV0OiBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCxcbiAgICBvcHRpb25zPzogUnBjT3B0aW9ucyxcbiAgKTogVW5hcnlDYWxsPFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0LCBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2U+IHtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbM10sXG4gICAgICBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBzdGFja0ludGVyY2VwdDxcbiAgICAgIFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0LFxuICAgICAgVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlXG4gICAgPigndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gIH1cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFVwZGF0ZU11dGVTdGF0ZXMoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSk7XG4gICAqL1xuICB1cGRhdGVNdXRlU3RhdGVzKFxuICAgIGlucHV0OiBVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCxcbiAgICBvcHRpb25zPzogUnBjT3B0aW9ucyxcbiAgKTogVW5hcnlDYWxsPFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0LCBVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2U+IHtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbNF0sXG4gICAgICBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBzdGFja0ludGVyY2VwdDxVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCwgVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlPihcbiAgICAgICd1bmFyeScsXG4gICAgICB0aGlzLl90cmFuc3BvcnQsXG4gICAgICBtZXRob2QsXG4gICAgICBvcHQsXG4gICAgICBpbnB1dCxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBJY2VSZXN0YXJ0KHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VSZXN0YXJ0UmVzcG9uc2UpO1xuICAgKi9cbiAgaWNlUmVzdGFydChcbiAgICBpbnB1dDogSUNFUmVzdGFydFJlcXVlc3QsXG4gICAgb3B0aW9ucz86IFJwY09wdGlvbnMsXG4gICk6IFVuYXJ5Q2FsbDxJQ0VSZXN0YXJ0UmVxdWVzdCwgSUNFUmVzdGFydFJlc3BvbnNlPiB7XG4gICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzVdLFxuICAgICAgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQ8SUNFUmVzdGFydFJlcXVlc3QsIElDRVJlc3RhcnRSZXNwb25zZT4oXG4gICAgICAndW5hcnknLFxuICAgICAgdGhpcy5fdHJhbnNwb3J0LFxuICAgICAgbWV0aG9kLFxuICAgICAgb3B0LFxuICAgICAgaW5wdXQsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogU2VuZFN0YXRzKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1Jlc3BvbnNlKTtcbiAgICovXG4gIHNlbmRTdGF0cyhcbiAgICBpbnB1dDogU2VuZFN0YXRzUmVxdWVzdCxcbiAgICBvcHRpb25zPzogUnBjT3B0aW9ucyxcbiAgKTogVW5hcnlDYWxsPFNlbmRTdGF0c1JlcXVlc3QsIFNlbmRTdGF0c1Jlc3BvbnNlPiB7XG4gICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzZdLFxuICAgICAgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQ8U2VuZFN0YXRzUmVxdWVzdCwgU2VuZFN0YXRzUmVzcG9uc2U+KFxuICAgICAgJ3VuYXJ5JyxcbiAgICAgIHRoaXMuX3RyYW5zcG9ydCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG9wdCxcbiAgICAgIGlucHV0LFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIE1ldGhvZEluZm8sXG4gIE5leHRVbmFyeUZuLFxuICBScGNJbnRlcmNlcHRvcixcbiAgUnBjT3B0aW9ucyxcbiAgVW5hcnlDYWxsLFxufSBmcm9tICdAcHJvdG9idWYtdHMvcnVudGltZS1ycGMnO1xuaW1wb3J0IHtcbiAgVHdpcnBGZXRjaFRyYW5zcG9ydCxcbiAgVHdpcnBPcHRpb25zLFxufSBmcm9tICdAcHJvdG9idWYtdHMvdHdpcnAtdHJhbnNwb3J0JztcbmltcG9ydCB7IFNpZ25hbFNlcnZlckNsaWVudCB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvc2lnbmFsX3JwYy9zaWduYWwuY2xpZW50JztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnM6IFR3aXJwT3B0aW9ucyA9IHtcbiAgYmFzZVVybDogJycsXG4gIHNlbmRKc29uOiB0cnVlLFxuICB0aW1lb3V0OiA1ICogMTAwMCwgLy8gbXMuXG4gIGpzb25PcHRpb25zOiB7XG4gICAgaWdub3JlVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCB3aXRoSGVhZGVycyA9IChcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbik6IFJwY0ludGVyY2VwdG9yID0+IHtcbiAgcmV0dXJuIHtcbiAgICBpbnRlcmNlcHRVbmFyeShcbiAgICAgIG5leHQ6IE5leHRVbmFyeUZuLFxuICAgICAgbWV0aG9kOiBNZXRob2RJbmZvLFxuICAgICAgaW5wdXQ6IG9iamVjdCxcbiAgICAgIG9wdGlvbnM6IFJwY09wdGlvbnMsXG4gICAgKTogVW5hcnlDYWxsIHtcbiAgICAgIG9wdGlvbnMubWV0YSA9IHsgLi4ub3B0aW9ucy5tZXRhLCAuLi5oZWFkZXJzIH07XG4gICAgICByZXR1cm4gbmV4dChtZXRob2QsIGlucHV0LCBvcHRpb25zKTtcbiAgICB9LFxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBTaWduYWxTZXJ2ZXJDbGllbnQgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIHR3aXJwIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTaWduYWxDbGllbnQgPSAob3B0aW9ucz86IFR3aXJwT3B0aW9ucykgPT4ge1xuICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgVHdpcnBGZXRjaFRyYW5zcG9ydCh7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9ucyxcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBTaWduYWxTZXJ2ZXJDbGllbnQodHJhbnNwb3J0KTtcbn07XG4iLCIvKipcbiAqIENoZWNrcyB3aGV0aGVyIHdlIGFyZSB1c2luZyBSZWFjdCBOYXRpdmVcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUmVhY3ROYXRpdmUgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gbmF2aWdhdG9yLnByb2R1Y3Q/LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZSc7XG59O1xuIiwiaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJy4vY29vcmRpbmF0b3IvY29ubmVjdGlvbi90eXBlcyc7XG5pbXBvcnQgeyBpc1JlYWN0TmF0aXZlIH0gZnJvbSAnLi9oZWxwZXJzL3BsYXRmb3Jtcyc7XG5cbi8vIGxvZyBsZXZlbHMsIHNvcnRlZCBieSB2ZXJib3NpdHlcbmV4cG9ydCBjb25zdCBsb2dMZXZlbHM6IFJlY29yZDxMb2dMZXZlbCwgbnVtYmVyPiA9IE9iamVjdC5mcmVlemUoe1xuICB0cmFjZTogMCxcbiAgZGVidWc6IDEsXG4gIGluZm86IDIsXG4gIHdhcm46IDMsXG4gIGVycm9yOiA0LFxufSk7XG5cbmxldCBsb2dnZXI6IExvZ2dlciB8IHVuZGVmaW5lZDtcbmxldCBsZXZlbDogTG9nTGV2ZWwgPSAnaW5mbyc7XG5cbmV4cG9ydCBjb25zdCBsb2dUb0NvbnNvbGU6IExvZ2dlciA9IChsb2dMZXZlbCwgbWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICBsZXQgbG9nTWV0aG9kO1xuICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICBtZXNzYWdlID0gYEVSUk9SOiAke21lc3NhZ2V9YDtcbiAgICAgICAgbG9nTWV0aG9kID0gY29uc29sZS5pbmZvO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxvZ01ldGhvZCA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuJzpcbiAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgbWVzc2FnZSA9IGBXQVJOOiAke21lc3NhZ2V9YDtcbiAgICAgICAgbG9nTWV0aG9kID0gY29uc29sZS5pbmZvO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxvZ01ldGhvZCA9IGNvbnNvbGUud2FybjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgbG9nTWV0aG9kID0gY29uc29sZS5pbmZvO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndHJhY2UnOlxuICAgICAgbG9nTWV0aG9kID0gY29uc29sZS50cmFjZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dNZXRob2QgPSBjb25zb2xlLmxvZztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgbG9nTWV0aG9kKG1lc3NhZ2UsIC4uLmFyZ3MpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldExvZ2dlciA9IChsOiBMb2dnZXIsIGx2bD86IExvZ0xldmVsKSA9PiB7XG4gIGxvZ2dlciA9IGw7XG4gIGlmIChsdmwpIHtcbiAgICBzZXRMb2dMZXZlbChsdmwpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0TG9nTGV2ZWwgPSAobDogTG9nTGV2ZWwpID0+IHtcbiAgbGV2ZWwgPSBsO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldExvZ2dlciA9ICh3aXRoVGFncz86IHN0cmluZ1tdKSA9PiB7XG4gIGNvbnN0IGxvZ2dlck1ldGhvZCA9IGxvZ2dlciB8fCBsb2dUb0NvbnNvbGU7XG4gIGNvbnN0IHRhZ3MgPSAod2l0aFRhZ3MgfHwgW10pLmpvaW4oJzonKTtcbiAgY29uc3QgcmVzdWx0OiBMb2dnZXIgPSAobG9nTGV2ZWwsIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICBpZiAobG9nTGV2ZWxzW2xvZ0xldmVsXSA+PSBsb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICBsb2dnZXJNZXRob2QobG9nTGV2ZWwsIGBbJHt0YWdzfV06ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IGdldFByZWZlcnJlZENvZGVjcyA9IChcbiAga2luZDogJ2F1ZGlvJyB8ICd2aWRlbycsXG4gIHByZWZlcnJlZENvZGVjOiBzdHJpbmcsXG4gIGNvZGVjVG9SZW1vdmU/OiBzdHJpbmcsXG4pOiBSVENSdHBDb2RlY0NhcGFiaWxpdHlbXSB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ2NvZGVjcyddKTtcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwUmVjZWl2ZXIpKSB7XG4gICAgbG9nZ2VyKCd3YXJuJywgJ1JUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNhcCA9IFJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcbiAgaWYgKCFjYXApIHJldHVybjtcbiAgY29uc3QgbWF0Y2hlZDogUlRDUnRwQ29kZWNDYXBhYmlsaXR5W10gPSBbXTtcbiAgY29uc3QgcGFydGlhbE1hdGNoZWQ6IFJUQ1J0cENvZGVjQ2FwYWJpbGl0eVtdID0gW107XG4gIGNvbnN0IHVubWF0Y2hlZDogUlRDUnRwQ29kZWNDYXBhYmlsaXR5W10gPSBbXTtcbiAgY2FwLmNvZGVjcy5mb3JFYWNoKChjKSA9PiB7XG4gICAgY29uc3QgY29kZWMgPSBjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgbG9nZ2VyKCdkZWJ1ZycsIGBGb3VuZCBzdXBwb3J0ZWQgY29kZWM6ICR7Y29kZWN9YCk7XG4gICAgY29uc3Qgc2hvdWxkUmVtb3ZlQ29kZWMgPVxuICAgICAgY29kZWNUb1JlbW92ZSAmJiBjb2RlYyA9PT0gYCR7a2luZH0vJHtjb2RlY1RvUmVtb3ZlLnRvTG93ZXJDYXNlKCl9YDtcbiAgICBpZiAoc2hvdWxkUmVtb3ZlQ29kZWMpIHJldHVybjtcbiAgICBjb25zdCBtYXRjaGVzQ29kZWMgPSBjb2RlYyA9PT0gYCR7a2luZH0vJHtwcmVmZXJyZWRDb2RlYy50b0xvd2VyQ2FzZSgpfWA7XG4gICAgaWYgKCFtYXRjaGVzQ29kZWMpIHtcbiAgICAgIHVubWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBmb3IgaDI2NCBjb2RlY3MgdGhhdCBoYXZlIHNkcEZtdHBMaW5lIGF2YWlsYWJsZSwgdXNlIG9ubHkgaWYgdGhlXG4gICAgLy8gcHJvZmlsZS1sZXZlbC1pZCBpcyA0MmUwMWYgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgIGlmIChjb2RlYyA9PT0gJ2gyNjQnKSB7XG4gICAgICBpZiAoYy5zZHBGbXRwTGluZSAmJiBjLnNkcEZtdHBMaW5lLmluY2x1ZGVzKCdwcm9maWxlLWxldmVsLWlkPTQyZTAxZicpKSB7XG4gICAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRpYWxNYXRjaGVkLnB1c2goYyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoZWQucHVzaChjKTtcbiAgfSk7XG5cbiAgcmV0dXJuIFsuLi5tYXRjaGVkLCAuLi5wYXJ0aWFsTWF0Y2hlZCwgLi4udW5tYXRjaGVkXTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRHZW5lcmljU2RwID0gYXN5bmMgKGRpcmVjdGlvbjogUlRDUnRwVHJhbnNjZWl2ZXJEaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgdGVtcFBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCk7XG4gIHRlbXBQYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbiB9KTtcbiAgdGVtcFBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHsgZGlyZWN0aW9uIH0pO1xuXG4gIGNvbnN0IG9mZmVyID0gYXdhaXQgdGVtcFBjLmNyZWF0ZU9mZmVyKCk7XG4gIGxldCBzZHAgPSBvZmZlci5zZHAgPz8gJyc7XG5cbiAgdGVtcFBjLmdldFRyYW5zY2VpdmVycygpLmZvckVhY2goKHQpID0+IHtcbiAgICB0LnN0b3AoKTtcbiAgfSk7XG4gIHRlbXBQYy5jbG9zZSgpO1xuICByZXR1cm4gc2RwO1xufTtcbiIsImltcG9ydCB7IENhbGxFdmVudExpc3RlbmVyLCBFdmVudFR5cGVzIH0gZnJvbSAnLi4vY29vcmRpbmF0b3IvY29ubmVjdGlvbi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IFNmdUV2ZW50IH0gZnJvbSAnLi4vZ2VuL3ZpZGVvL3NmdS9ldmVudC9ldmVudHMnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcblxuZXhwb3J0IHR5cGUgU2Z1RXZlbnRLaW5kcyA9IE5vbk51bGxhYmxlPFNmdUV2ZW50WydldmVudFBheWxvYWQnXVsnb25lb2ZLaW5kJ10+O1xuZXhwb3J0IHR5cGUgQWxsU2Z1RXZlbnRzID0ge1xuICBbSyBpbiBTZnVFdmVudEtpbmRzXTogSyBleHRlbmRzIGtleW9mIEV4dHJhY3Q8XG4gICAgU2Z1RXZlbnRbJ2V2ZW50UGF5bG9hZCddLFxuICAgIHsgb25lb2ZLaW5kOiBLIH1cbiAgPlxuICAgID8gRXh0cmFjdDxTZnVFdmVudFsnZXZlbnRQYXlsb2FkJ10sIHsgb25lb2ZLaW5kOiBLIH0+W0tdXG4gICAgOiBuZXZlcjtcbn07XG5cbmV4cG9ydCB0eXBlIERpc3BhdGNoYWJsZU1lc3NhZ2U8SyBleHRlbmRzIFNmdUV2ZW50S2luZHM+ID0ge1xuICBldmVudFBheWxvYWQ6IHtcbiAgICBvbmVvZktpbmQ6IEs7XG4gIH0gJiB7XG4gICAgW0tleSBpbiBLXTogQWxsU2Z1RXZlbnRzW0tleV07XG4gIH07XG59O1xuXG5jb25zdCBzZnVFdmVudEtpbmRzOiB7IFtrZXkgaW4gU2Z1RXZlbnRLaW5kc106IHVuZGVmaW5lZCB9ID0ge1xuICBzdWJzY3JpYmVyT2ZmZXI6IHVuZGVmaW5lZCxcbiAgcHVibGlzaGVyQW5zd2VyOiB1bmRlZmluZWQsXG4gIGNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZDogdW5kZWZpbmVkLFxuICBhdWRpb0xldmVsQ2hhbmdlZDogdW5kZWZpbmVkLFxuICBpY2VUcmlja2xlOiB1bmRlZmluZWQsXG4gIGNoYW5nZVB1Ymxpc2hRdWFsaXR5OiB1bmRlZmluZWQsXG4gIHBhcnRpY2lwYW50Sm9pbmVkOiB1bmRlZmluZWQsXG4gIHBhcnRpY2lwYW50TGVmdDogdW5kZWZpbmVkLFxuICBkb21pbmFudFNwZWFrZXJDaGFuZ2VkOiB1bmRlZmluZWQsXG4gIGpvaW5SZXNwb25zZTogdW5kZWZpbmVkLFxuICBoZWFsdGhDaGVja1Jlc3BvbnNlOiB1bmRlZmluZWQsXG4gIHRyYWNrUHVibGlzaGVkOiB1bmRlZmluZWQsXG4gIHRyYWNrVW5wdWJsaXNoZWQ6IHVuZGVmaW5lZCxcbiAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgY2FsbEdyYW50c1VwZGF0ZWQ6IHVuZGVmaW5lZCxcbiAgZ29Bd2F5OiB1bmRlZmluZWQsXG4gIGljZVJlc3RhcnQ6IHVuZGVmaW5lZCxcbiAgcGluc1VwZGF0ZWQ6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBjb25zdCBpc1NmdUV2ZW50ID0gKFxuICBldmVudE5hbWU6IFNmdUV2ZW50S2luZHMgfCBFdmVudFR5cGVzLFxuKTogZXZlbnROYW1lIGlzIFNmdUV2ZW50S2luZHMgPT4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNmdUV2ZW50S2luZHMsIGV2ZW50TmFtZSk7XG59O1xuXG5leHBvcnQgY2xhc3MgRGlzcGF0Y2hlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnRGlzcGF0Y2hlciddKTtcbiAgcHJpdmF0ZSBzdWJzY3JpYmVyczogUGFydGlhbDxcbiAgICBSZWNvcmQ8U2Z1RXZlbnRLaW5kcywgQ2FsbEV2ZW50TGlzdGVuZXI8YW55PltdIHwgdW5kZWZpbmVkPlxuICA+ID0ge307XG5cbiAgZGlzcGF0Y2ggPSA8SyBleHRlbmRzIFNmdUV2ZW50S2luZHM+KG1lc3NhZ2U6IERpc3BhdGNoYWJsZU1lc3NhZ2U8Sz4pID0+IHtcbiAgICBjb25zdCBldmVudEtpbmQgPSBtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQ7XG4gICAgaWYgKCFldmVudEtpbmQpIHJldHVybjtcbiAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZS5ldmVudFBheWxvYWRbZXZlbnRLaW5kXTtcbiAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgRGlzcGF0Y2hpbmcgJHtldmVudEtpbmR9YCwgcGF5bG9hZCk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5zdWJzY3JpYmVyc1tldmVudEtpbmRdO1xuICAgIGlmICghbGlzdGVuZXJzKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBmbiBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKHBheWxvYWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsICdMaXN0ZW5lciBmYWlsZWQgd2l0aCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvbiA9IDxFIGV4dGVuZHMga2V5b2YgQWxsU2Z1RXZlbnRzPihcbiAgICBldmVudE5hbWU6IEUsXG4gICAgZm46IENhbGxFdmVudExpc3RlbmVyPEU+LFxuICApID0+IHtcbiAgICAodGhpcy5zdWJzY3JpYmVyc1tldmVudE5hbWVdID8/PSBbXSkucHVzaChmbiBhcyBuZXZlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgZm4pO1xuICAgIH07XG4gIH07XG5cbiAgb2ZmID0gPEUgZXh0ZW5kcyBrZXlvZiBBbGxTZnVFdmVudHM+KFxuICAgIGV2ZW50TmFtZTogRSxcbiAgICBmbjogQ2FsbEV2ZW50TGlzdGVuZXI8RT4sXG4gICkgPT4ge1xuICAgIHRoaXMuc3Vic2NyaWJlcnNbZXZlbnROYW1lXSA9ICh0aGlzLnN1YnNjcmliZXJzW2V2ZW50TmFtZV0gfHwgW10pLmZpbHRlcihcbiAgICAgIChmKSA9PiBmICE9PSBmbixcbiAgICApO1xuICB9O1xuXG4gIG9mZkFsbCA9IChldmVudE5hbWU/OiBTZnVFdmVudEtpbmRzKSA9PiB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5zdWJzY3JpYmVyc1tldmVudE5hbWVdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJQ0VUcmlja2xlIH0gZnJvbSAnLi4vZ2VuL3ZpZGVvL3NmdS9ldmVudC9ldmVudHMnO1xuaW1wb3J0IHsgUGVlclR5cGUgfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcblxuLyoqXG4gKiBBIGJ1ZmZlciBmb3IgSUNFIENhbmRpZGF0ZXMuIFVzZWQgZm9yIElDRSBUcmlja2xlOlxuICogLSBodHRwczovL2Jsb2dnZWVrLm1lL3dlYnJ0Y2dsb3NzYXJ5L3RyaWNrbGUtaWNlL1xuICovXG5leHBvcnQgY2xhc3MgSWNlVHJpY2tsZUJ1ZmZlciB7XG4gIHJlYWRvbmx5IHN1YnNjcmliZXJDYW5kaWRhdGVzID0gbmV3IFJlcGxheVN1YmplY3Q8SUNFVHJpY2tsZT4oKTtcbiAgcmVhZG9ubHkgcHVibGlzaGVyQ2FuZGlkYXRlcyA9IG5ldyBSZXBsYXlTdWJqZWN0PElDRVRyaWNrbGU+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnc2Z1LWNsaWVudCddKTtcblxuICBwdXNoID0gKGljZVRyaWNrbGU6IElDRVRyaWNrbGUpID0+IHtcbiAgICBpZiAoaWNlVHJpY2tsZS5wZWVyVHlwZSA9PT0gUGVlclR5cGUuU1VCU0NSSUJFUikge1xuICAgICAgdGhpcy5zdWJzY3JpYmVyQ2FuZGlkYXRlcy5uZXh0KGljZVRyaWNrbGUpO1xuICAgIH0gZWxzZSBpZiAoaWNlVHJpY2tsZS5wZWVyVHlwZSA9PT0gUGVlclR5cGUuUFVCTElTSEVSX1VOU1BFQ0lGSUVEKSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlckNhbmRpZGF0ZXMubmV4dChpY2VUcmlja2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgSUNFVHJpY2tsZSwgVW5rbm93biBwZWVyIHR5cGVgLCBpY2VUcmlja2xlKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBJQ0VUcmlja2xlIH0gZnJvbSAnLi4vLi4vZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEljZUNhbmRpZGF0ZShcbiAgY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGUsXG4pOiBJQ0VUcmlja2xlWydpY2VDYW5kaWRhdGUnXSB7XG4gIGlmICghY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQpIHtcbiAgICAvLyByZWFjdC1uYXRpdmUtd2VicnRjIGRvZXNuJ3QgaW5jbHVkZSB1c2VybmFtZUZyYWdtZW50IGluIHRoZSBjYW5kaWRhdGVcbiAgICBjb25zdCBzcGxpdHRlZENhbmRpZGF0ZSA9IGNhbmRpZGF0ZS5jYW5kaWRhdGUuc3BsaXQoJyAnKTtcbiAgICBjb25zdCB1ZnJhZ0luZGV4ID1cbiAgICAgIHNwbGl0dGVkQ2FuZGlkYXRlLmZpbmRJbmRleCgoczogc3RyaW5nKSA9PiBzID09PSAndWZyYWcnKSArIDE7XG4gICAgY29uc3QgdXNlcm5hbWVGcmFnbWVudCA9IHNwbGl0dGVkQ2FuZGlkYXRlW3VmcmFnSW5kZXhdO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IC4uLmNhbmRpZGF0ZSwgdXNlcm5hbWVGcmFnbWVudCB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2FuZGlkYXRlLnRvSlNPTigpKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2xpZW50RGV0YWlscywgRGV2aWNlLCBPUywgU2RrIH0gZnJvbSAnLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHsgaXNSZWFjdE5hdGl2ZSB9IGZyb20gJy4vaGVscGVycy9wbGF0Zm9ybXMnO1xuaW1wb3J0IHsgVUFQYXJzZXIgfSBmcm9tICd1YS1wYXJzZXItanMnO1xuXG50eXBlIFdlYlJUQ0luZm9UeXBlID0ge1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59O1xuXG5sZXQgc2RrSW5mbzogU2RrIHwgdW5kZWZpbmVkO1xubGV0IG9zSW5mbzogT1MgfCB1bmRlZmluZWQ7XG5sZXQgZGV2aWNlSW5mbzogRGV2aWNlIHwgdW5kZWZpbmVkO1xubGV0IHdlYlJ0Y0luZm86IFdlYlJUQ0luZm9UeXBlIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgY29uc3Qgc2V0U2RrSW5mbyA9IChpbmZvOiBTZGspID0+IHtcbiAgc2RrSW5mbyA9IGluZm87XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2RrSW5mbyA9ICgpID0+IHtcbiAgcmV0dXJuIHNka0luZm87XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0T1NJbmZvID0gKGluZm86IE9TKSA9PiB7XG4gIG9zSW5mbyA9IGluZm87XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0T1NJbmZvID0gKCkgPT4ge1xuICByZXR1cm4gb3NJbmZvO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldERldmljZUluZm8gPSAoaW5mbzogRGV2aWNlKSA9PiB7XG4gIGRldmljZUluZm8gPSBpbmZvO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldERldmljZUluZm8gPSAoKSA9PiB7XG4gIHJldHVybiBkZXZpY2VJbmZvO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFdlYlJUQ0luZm8gPSAoKSA9PiB7XG4gIHJldHVybiB3ZWJSdGNJbmZvO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldFdlYlJUQ0luZm8gPSAoaW5mbzogV2ViUlRDSW5mb1R5cGUpID0+IHtcbiAgd2ViUnRjSW5mbyA9IGluZm87XG59O1xuXG5leHBvcnQgdHlwZSBMb2NhbENsaWVudERldGFpbHNUeXBlID0gQ2xpZW50RGV0YWlscyAmIHtcbiAgd2ViUlRDSW5mbz86IFdlYlJUQ0luZm9UeXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENsaWVudERldGFpbHMgPSAoKTogTG9jYWxDbGllbnREZXRhaWxzVHlwZSA9PiB7XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAvLyBTaW5jZSBSTiBkb2Vzbid0IHN1cHBvcnQgd2ViLCBzaGFyaW5nIGJyb3dzZXIgaW5mbyBpcyBub3QgcmVxdWlyZWRcbiAgICByZXR1cm4ge1xuICAgICAgc2RrOiBnZXRTZGtJbmZvKCksXG4gICAgICBvczogZ2V0T1NJbmZvKCksXG4gICAgICBkZXZpY2U6IGdldERldmljZUluZm8oKSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdXNlckFnZW50ID0gbmV3IFVBUGFyc2VyKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCB7IGJyb3dzZXIsIG9zLCBkZXZpY2UsIGNwdSB9ID0gdXNlckFnZW50LmdldFJlc3VsdCgpO1xuICByZXR1cm4ge1xuICAgIHNkazogZ2V0U2RrSW5mbygpLFxuICAgIGJyb3dzZXI6IHtcbiAgICAgIG5hbWU6IGJyb3dzZXIubmFtZSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgdmVyc2lvbjogYnJvd3Nlci52ZXJzaW9uIHx8ICcnLFxuICAgIH0sXG4gICAgb3M6IHtcbiAgICAgIG5hbWU6IG9zLm5hbWUgfHwgJycsXG4gICAgICB2ZXJzaW9uOiBvcy52ZXJzaW9uIHx8ICcnLFxuICAgICAgYXJjaGl0ZWN0dXJlOiBjcHUuYXJjaGl0ZWN0dXJlIHx8ICcnLFxuICAgIH0sXG4gICAgZGV2aWNlOiB7XG4gICAgICBuYW1lOiBbZGV2aWNlLnZlbmRvciwgZGV2aWNlLm1vZGVsLCBkZXZpY2UudHlwZV1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbignICcpLFxuICAgICAgdmVyc2lvbjogJycsXG4gICAgfSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBnZXRPU0luZm8gfSBmcm9tICcuLi9jbGllbnQtZGV0YWlscyc7XG5pbXBvcnQgeyBTY3JlZW5TaGFyZVNldHRpbmdzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgVGFyZ2V0UmVzb2x1dGlvbiB9IGZyb20gJy4uL2dlbi9jb29yZGluYXRvcic7XG5pbXBvcnQgeyBpc1JlYWN0TmF0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9wbGF0Zm9ybXMnO1xuXG5leHBvcnQgdHlwZSBPcHRpbWFsVmlkZW9MYXllciA9IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycyAmIHtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG59O1xuXG5jb25zdCBERUZBVUxUX0JJVFJBVEUgPSAxMjUwMDAwO1xuY29uc3QgZGVmYXVsdFRhcmdldFJlc29sdXRpb246IFRhcmdldFJlc29sdXRpb24gPSB7XG4gIGJpdHJhdGU6IERFRkFVTFRfQklUUkFURSxcbiAgd2lkdGg6IDEyODAsXG4gIGhlaWdodDogNzIwLFxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBtb3N0IG9wdGltYWwgdmlkZW8gbGF5ZXJzIGZvciBzaW11bGNhc3RpbmdcbiAqIGZvciB0aGUgZ2l2ZW4gdHJhY2suXG4gKlxuICogQHBhcmFtIHZpZGVvVHJhY2sgdGhlIHZpZGVvIHRyYWNrIHRvIGZpbmQgb3B0aW1hbCBsYXllcnMgZm9yLlxuICogQHBhcmFtIHRhcmdldFJlc29sdXRpb24gdGhlIGV4cGVjdGVkIHRhcmdldCByZXNvbHV0aW9uLlxuICovXG5leHBvcnQgY29uc3QgZmluZE9wdGltYWxWaWRlb0xheWVycyA9IChcbiAgdmlkZW9UcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgdGFyZ2V0UmVzb2x1dGlvbjogVGFyZ2V0UmVzb2x1dGlvbiA9IGRlZmF1bHRUYXJnZXRSZXNvbHV0aW9uLFxuKSA9PiB7XG4gIGNvbnN0IG9wdGltYWxWaWRlb0xheWVyczogT3B0aW1hbFZpZGVvTGF5ZXJbXSA9IFtdO1xuICBjb25zdCBzZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgY29uc3QgeyB3aWR0aDogdyA9IDAsIGhlaWdodDogaCA9IDAgfSA9IHNldHRpbmdzO1xuXG4gIGNvbnN0IGlzUk5Jb3MgPSBpc1JlYWN0TmF0aXZlKCkgJiYgZ2V0T1NJbmZvKCk/Lm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lvcyc7XG5cbiAgY29uc3QgbWF4Qml0cmF0ZSA9IGdldENvbXB1dGVkTWF4Qml0cmF0ZSh0YXJnZXRSZXNvbHV0aW9uLCB3LCBoKTtcbiAgbGV0IGRvd25zY2FsZUZhY3RvciA9IDE7XG4gIFsnZicsICdoJywgJ3EnXS5mb3JFYWNoKChyaWQpID0+IHtcbiAgICAvLyBSZXZlcnNpbmcgdGhlIG9yZGVyIFtmLCBoLCBxXSB0byBbcSwgaCwgZl0gYXMgQ2hyb21lIHVzZXMgZW5jb2RpbmcgaW5kZXhcbiAgICAvLyB3aGVuIGRlY2lkaW5nIHdoaWNoIGxheWVyIHRvIGRpc2FibGUgd2hlbiBDUFUgb3IgYmFuZHdpZHRoIGlzIGNvbnN0cmFpbmVkLlxuICAgIC8vIEVuY29kaW5ncyBzaG91bGQgYmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHNwYXRpYWwgcmVzb2x1dGlvbiBvcmRlci5cbiAgICBvcHRpbWFsVmlkZW9MYXllcnMudW5zaGlmdCh7XG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgICByaWQsXG4gICAgICB3aWR0aDogTWF0aC5yb3VuZCh3IC8gZG93bnNjYWxlRmFjdG9yKSxcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZChoIC8gZG93bnNjYWxlRmFjdG9yKSxcbiAgICAgIG1heEJpdHJhdGU6IE1hdGgucm91bmQobWF4Qml0cmF0ZSAvIGRvd25zY2FsZUZhY3RvciksXG4gICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IGRvd25zY2FsZUZhY3RvcixcbiAgICAgIC8vIFNpbXVsY2FzdCBvbiBpT1MgUmVhY3QtTmF0aXZlIHJlcXVpcmVzIGFsbCBlbmNvZGluZ3MgdG8gc2hhcmUgdGhlIHNhbWUgZnJhbWVyYXRlXG4gICAgICBtYXhGcmFtZXJhdGU6IHtcbiAgICAgICAgZjogMzAsXG4gICAgICAgIGg6IGlzUk5Jb3MgPyAzMCA6IDI1LFxuICAgICAgICBxOiBpc1JOSW9zID8gMzAgOiAyMCxcbiAgICAgIH1bcmlkXSxcbiAgICB9KTtcbiAgICBkb3duc2NhbGVGYWN0b3IgKj0gMjtcbiAgfSk7XG5cbiAgLy8gZm9yIHNpbXBsaWNpdHksIHdlIHN0YXJ0IHdpdGggYWxsIGxheWVycyBlbmFibGVkLCB0aGVuIHRoaXMgZnVuY3Rpb25cbiAgLy8gd2lsbCBjbGVhci9yZWFzc2lnbiB0aGUgbGF5ZXJzIHRoYXQgYXJlIG5vdCBuZWVkZWRcbiAgcmV0dXJuIHdpdGhTaW11bGNhc3RDb25zdHJhaW50cyhzZXR0aW5ncywgb3B0aW1hbFZpZGVvTGF5ZXJzKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1heGltdW0gYml0cmF0ZSBmb3IgYSBnaXZlbiByZXNvbHV0aW9uLlxuICogSWYgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBpcyBsb3dlciB0aGFuIHRoZSB0YXJnZXQgcmVzb2x1dGlvbixcbiAqIHdlIHdhbnQgdG8gcHJvcG9ydGlvbmFsbHkgcmVkdWNlIHRoZSB0YXJnZXQgYml0cmF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHJlc29sdXRpb24gaXMgaGlnaGVyIHRoYW4gdGhlIHRhcmdldCByZXNvbHV0aW9uLFxuICogd2Ugd2FudCB0byB1c2UgdGhlIHRhcmdldCBiaXRyYXRlLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRSZXNvbHV0aW9uIHRoZSB0YXJnZXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSBjdXJyZW50V2lkdGggdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIHRyYWNrLlxuICogQHBhcmFtIGN1cnJlbnRIZWlnaHQgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSB0cmFjay5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldENvbXB1dGVkTWF4Qml0cmF0ZSA9IChcbiAgdGFyZ2V0UmVzb2x1dGlvbjogVGFyZ2V0UmVzb2x1dGlvbixcbiAgY3VycmVudFdpZHRoOiBudW1iZXIsXG4gIGN1cnJlbnRIZWlnaHQ6IG51bWJlcixcbik6IG51bWJlciA9PiB7XG4gIC8vIGlmIHRoZSBjdXJyZW50IHJlc29sdXRpb24gaXMgbG93ZXIgdGhhbiB0aGUgdGFyZ2V0IHJlc29sdXRpb24sXG4gIC8vIHdlIHdhbnQgdG8gcHJvcG9ydGlvbmFsbHkgcmVkdWNlIHRoZSB0YXJnZXQgYml0cmF0ZVxuICBjb25zdCB7IHdpZHRoOiB0YXJnZXRXaWR0aCwgaGVpZ2h0OiB0YXJnZXRIZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XG4gIGlmIChjdXJyZW50V2lkdGggPCB0YXJnZXRXaWR0aCB8fCBjdXJyZW50SGVpZ2h0IDwgdGFyZ2V0SGVpZ2h0KSB7XG4gICAgY29uc3QgY3VycmVudFBpeGVscyA9IGN1cnJlbnRXaWR0aCAqIGN1cnJlbnRIZWlnaHQ7XG4gICAgY29uc3QgdGFyZ2V0UGl4ZWxzID0gdGFyZ2V0V2lkdGggKiB0YXJnZXRIZWlnaHQ7XG4gICAgY29uc3QgcmVkdWN0aW9uRmFjdG9yID0gY3VycmVudFBpeGVscyAvIHRhcmdldFBpeGVscztcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0YXJnZXRSZXNvbHV0aW9uLmJpdHJhdGUgKiByZWR1Y3Rpb25GYWN0b3IpO1xuICB9XG4gIHJldHVybiB0YXJnZXRSZXNvbHV0aW9uLmJpdHJhdGU7XG59O1xuXG4vKipcbiAqIEJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IHNpbXVsY2FzdCBjb25zdHJhaW50cyBmb3IgZGlmZmVyZW50IHZpZGVvIHJlc29sdXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgdmlkZW8gbGF5ZXJzIGFjY29yZGluZyB0byB0aGVcbiAqIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2Ygc2ltdWxjYXN0IGNvbnN0cmFpbnRzIGluIHRoZSBDaHJvbWl1bSBiYXNlZCBicm93c2Vycy5cbiAqXG4gKiBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vZXh0ZXJuYWwvd2VicnRjLysvcmVmcy9oZWFkcy9tYWluL21lZGlhL2VuZ2luZS9zaW11bGNhc3QuY2MjOTBcbiAqL1xuY29uc3Qgd2l0aFNpbXVsY2FzdENvbnN0cmFpbnRzID0gKFxuICBzZXR0aW5nczogTWVkaWFUcmFja1NldHRpbmdzLFxuICBvcHRpbWFsVmlkZW9MYXllcnM6IE9wdGltYWxWaWRlb0xheWVyW10sXG4pID0+IHtcbiAgbGV0IGxheWVyczogT3B0aW1hbFZpZGVvTGF5ZXJbXTtcblxuICBjb25zdCBzaXplID0gTWF0aC5tYXgoc2V0dGluZ3Mud2lkdGggfHwgMCwgc2V0dGluZ3MuaGVpZ2h0IHx8IDApO1xuICBpZiAoc2l6ZSA8PSAzMjApIHtcbiAgICAvLyBwcm92aWRlIG9ubHkgb25lIGxheWVyIDMyMHgyNDAgKHEpLCB0aGUgb25lIHdpdGggdGhlIGhpZ2hlc3QgcXVhbGl0eVxuICAgIGxheWVycyA9IG9wdGltYWxWaWRlb0xheWVycy5maWx0ZXIoKGxheWVyKSA9PiBsYXllci5yaWQgPT09ICdmJyk7XG4gIH0gZWxzZSBpZiAoc2l6ZSA8PSA2NDApIHtcbiAgICAvLyBwcm92aWRlIHR3byBsYXllcnMsIDE2MHgxMjAgKHEpIGFuZCA2NDB4NDgwIChoKVxuICAgIGxheWVycyA9IG9wdGltYWxWaWRlb0xheWVycy5maWx0ZXIoKGxheWVyKSA9PiBsYXllci5yaWQgIT09ICdoJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcHJvdmlkZSB0aHJlZSBsYXllcnMgZm9yIHNpemVzID4gNjQweDQ4MFxuICAgIGxheWVycyA9IG9wdGltYWxWaWRlb0xheWVycztcbiAgfVxuXG4gIGNvbnN0IHJpZE1hcHBpbmcgPSBbJ3EnLCAnaCcsICdmJ107XG4gIHJldHVybiBsYXllcnMubWFwPE9wdGltYWxWaWRlb0xheWVyPigobGF5ZXIsIGluZGV4KSA9PiAoe1xuICAgIC4uLmxheWVyLFxuICAgIHJpZDogcmlkTWFwcGluZ1tpbmRleF0sIC8vIHJlYXNzaWduIHJpZFxuICB9KSk7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzID0gKFxuICB2aWRlb1RyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICBwcmVmZXJlbmNlcz86IFNjcmVlblNoYXJlU2V0dGluZ3MsXG4pOiBPcHRpbWFsVmlkZW9MYXllcltdID0+IHtcbiAgY29uc3Qgc2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgcmlkOiAncScsIC8vIHNpbmdsZSB0cmFjaywgc3RhcnQgZnJvbSAncSdcbiAgICAgIHdpZHRoOiBzZXR0aW5ncy53aWR0aCB8fCAwLFxuICAgICAgaGVpZ2h0OiBzZXR0aW5ncy5oZWlnaHQgfHwgMCxcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogMSxcbiAgICAgIG1heEJpdHJhdGU6IHByZWZlcmVuY2VzPy5tYXhCaXRyYXRlID8/IDMwMDAwMDAsXG4gICAgICBtYXhGcmFtZXJhdGU6IHByZWZlcmVuY2VzPy5tYXhGcmFtZXJhdGUgPz8gMzAsXG4gICAgfSxcbiAgXTtcbn07XG4iLCJpbXBvcnQgeyBUcmFja1R5cGUgfSBmcm9tICcuLi8uLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1WaWRlb1BhcnRpY2lwYW50IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgVHJhY2tNdXRlVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IHRyYWNrVHlwZVRvUGFydGljaXBhbnRTdHJlYW1LZXkgPSAoXG4gIHRyYWNrVHlwZTogVHJhY2tUeXBlLFxuKToga2V5b2YgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCA9PiB7XG4gIHN3aXRjaCAodHJhY2tUeXBlKSB7XG4gICAgY2FzZSBUcmFja1R5cGUuU0NSRUVOX1NIQVJFOlxuICAgICAgcmV0dXJuICdzY3JlZW5TaGFyZVN0cmVhbSc7XG4gICAgY2FzZSBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPOlxuICAgICAgcmV0dXJuICdzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtJztcbiAgICBjYXNlIFRyYWNrVHlwZS5WSURFTzpcbiAgICAgIHJldHVybiAndmlkZW9TdHJlYW0nO1xuICAgIGNhc2UgVHJhY2tUeXBlLkFVRElPOlxuICAgICAgcmV0dXJuICdhdWRpb1N0cmVhbSc7XG4gICAgY2FzZSBUcmFja1R5cGUuVU5TUEVDSUZJRUQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYWNrIHR5cGUgaXMgdW5zcGVjaWZpZWQnKTtcbiAgICBkZWZhdWx0OlxuICAgICAgY29uc3QgZXhoYXVzdGl2ZVRyYWNrVHlwZUNoZWNrOiBuZXZlciA9IHRyYWNrVHlwZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0cmFjayB0eXBlOiAke2V4aGF1c3RpdmVUcmFja1R5cGVDaGVja31gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG11dGVUeXBlVG9UcmFja1R5cGUgPSAobXV0ZVR5cGU6IFRyYWNrTXV0ZVR5cGUpOiBUcmFja1R5cGUgPT4ge1xuICBzd2l0Y2ggKG11dGVUeXBlKSB7XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgcmV0dXJuIFRyYWNrVHlwZS5BVURJTztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgIGNhc2UgJ3NjcmVlbnNoYXJlJzpcbiAgICAgIHJldHVybiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFO1xuICAgIGNhc2UgJ3NjcmVlbnNoYXJlX2F1ZGlvJzpcbiAgICAgIHJldHVybiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zdCBleGhhdXN0aXZlTXV0ZVR5cGVDaGVjazogbmV2ZXIgPSBtdXRlVHlwZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBtdXRlIHR5cGU6ICR7ZXhoYXVzdGl2ZU11dGVUeXBlQ2hlY2t9YCk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbnR5cGUgRnVuY3Rpb25QYXRjaDxUPiA9IChjdXJyZW50VmFsdWU6IFQpID0+IFQ7XG5cbi8qKlxuICogQSB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICovXG5leHBvcnQgdHlwZSBQYXRjaDxUPiA9IFQgfCBGdW5jdGlvblBhdGNoPFQ+O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgdXBkYXRlIGlzIGEgZnVuY3Rpb24gcGF0Y2guXG4gKlxuICogQHBhcmFtIHVwZGF0ZSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb25QYXRjaCA9IDxUPih1cGRhdGU6IFBhdGNoPFQ+KTogdXBkYXRlIGlzIEZ1bmN0aW9uUGF0Y2g8VD4gPT5cbiAgdHlwZW9mIHVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIG9ic2VydmFibGUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgb2JzZXJ2YWJsZSBoYXNcbiAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlJCB0aGUgb2JzZXJ2YWJsZSB0byBnZXQgdGhlIHZhbHVlIGZyb20uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50VmFsdWUgPSA8VD4ob2JzZXJ2YWJsZSQ6IE9ic2VydmFibGU8VD4pID0+IHtcbiAgbGV0IHZhbHVlITogVDtcbiAgbGV0IGVycjogRXJyb3IgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGNvbWJpbmVMYXRlc3QoW29ic2VydmFibGUkXSlcbiAgICAuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChbdl0pID0+IHtcbiAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgfSxcbiAgICAgIGVycm9yOiAoZSkgPT4ge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfSxcbiAgICB9KVxuICAgIC51bnN1YnNjcmliZSgpO1xuXG4gIGlmIChlcnIpIHRocm93IGVycjtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICogdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICogQHBhcmFtIHVwZGF0ZSB0aGUgdXBkYXRlIHRvIGFwcGx5IHRvIHRoZSBzdWJqZWN0LlxuICogQHJldHVybiB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEN1cnJlbnRWYWx1ZSA9IDxUPihzdWJqZWN0OiBTdWJqZWN0PFQ+LCB1cGRhdGU6IFBhdGNoPFQ+KSA9PiB7XG4gIGNvbnN0IG5leHQgPSBpc0Z1bmN0aW9uUGF0Y2godXBkYXRlKVxuICAgID8gdXBkYXRlKGdldEN1cnJlbnRWYWx1ZShzdWJqZWN0KSlcbiAgICA6IHVwZGF0ZTtcblxuICBzdWJqZWN0Lm5leHQobmV4dCk7XG4gIHJldHVybiBuZXh0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3Vic2NyaXB0aW9uIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gdW5zdWJzY3JpYmUuXG4gKlxuICogQHBhcmFtIG9ic2VydmFibGUgdGhlIG9ic2VydmFibGUgdG8gc3Vic2NyaWJlIHRvLlxuICogQHBhcmFtIGhhbmRsZXIgdGhlIGhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBvYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTdWJzY3JpcHRpb24gPSA8VD4oXG4gIG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4sXG4gIGhhbmRsZXI6ICh2YWx1ZTogVCkgPT4gdm9pZCxcbikgPT4ge1xuICBjb25zdCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShoYW5kbGVyKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfTtcbn07XG4iLCIvKipcbiAqIERlZmluZXMgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBzb3J0aW5nIGl0ZW1zLlxuICovXG5leHBvcnQgdHlwZSBDb21wYXJhdG9yPFQ+ID0gKGE6IFQsIGI6IFQpID0+IC0xIHwgMCB8IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjb21iaW5lZCB7QGxpbmsgQ29tcGFyYXRvcjxUPn0gd2hpY2ggc29ydHMgaXRlbXMgYnkgdGhlIGdpdmVuIGNvbXBhcmF0b3JzLlxuICogVGhlIGNvbXBhcmF0b3JzIGFyZSBhcHBsaWVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBnaXZlbiAobGVmdCAtPiByaWdodCkuXG4gKlxuICogQHBhcmFtIGNvbXBhcmF0b3JzIHRoZSBjb21wYXJhdG9ycyB0byB1c2UgZm9yIHNvcnRpbmcuXG4gKiBAcmV0dXJucyBhIGNvbWJpbmVkIHtAbGluayBDb21wYXJhdG9yPFQ+fS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVDb21wYXJhdG9ycyA9IDxUPihcbiAgLi4uY29tcGFyYXRvcnM6IENvbXBhcmF0b3I8VD5bXVxuKTogQ29tcGFyYXRvcjxUPiA9PiB7XG4gIHJldHVybiAoYSwgYikgPT4ge1xuICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyYXRvcihhLCBiKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IDApIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgaXRlbXMgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYnlWYWx1ZSA9IChhLCBiKSA9PiBhIDwgYiA/IC0gMSA6IGEgPiBiID8gMSA6IDA7XG4gKiBjb25zdCBieVZhbHVlRGVzYyA9IGRlc2NlbmRpbmcoYnlWYWx1ZSk7XG4gKlxuICogQHBhcmFtIGNvbXBhcmF0b3IgdGhlIGNvbXBhcmF0b3IgdG8gd3JhcC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlc2NlbmRpbmcgPSA8VD4oY29tcGFyYXRvcjogQ29tcGFyYXRvcjxUPik6IENvbXBhcmF0b3I8VD4gPT4ge1xuICByZXR1cm4gKGEsIGIpID0+IGNvbXBhcmF0b3IoYiwgYSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29tcGFyYXRvciB3aGljaCBjb25kaXRpb25hbGx5IGFwcGxpZXMgdGhlIGdpdmVuIGNvbXBhcmF0b3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNob3VsZFNvcnRCeVZhbHVlID0gKGEsIGIpID0+IGEgJSAyID09PSAwOyAvLyByZXR1cm4gZmFsc2UgdG8gdHVybiBpdCBvZmZcbiAqIGNvbnN0IGJ5VmFsdWUgPSAoYSwgYikgPT4gYSA8IGIgPyAtIDEgOiBhID4gYiA/IDEgOiAwO1xuICogY29uc3QgY29tcGFyYXRvciA9IGNvbmRpdGlvbmFsKHNob3VsZFNvcnRCeVZhbHVlKShieVZhbHVlKTtcbiAqXG4gKiBAcGFyYW0gcHJlZGljYXRlIHRoZSBwcmVkaWNhdGUgdG8gdXNlIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRvIGFwcGx5IHRoZSBjb21wYXJhdG9yLlxuICovXG5leHBvcnQgY29uc3QgY29uZGl0aW9uYWwgPSA8VD4ocHJlZGljYXRlOiAoYTogVCwgYjogVCkgPT4gYm9vbGVhbikgPT4ge1xuICByZXR1cm4gKGNvbXBhcmF0b3I6IENvbXBhcmF0b3I8VD4pOiBDb21wYXJhdG9yPFQ+ID0+IHtcbiAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgIGlmICghcHJlZGljYXRlKGEsIGIpKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIpO1xuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEEgbm8tb3AgY29tcGFyYXRvciB3aGljaCBhbHdheXMgcmV0dXJucyAwLlxuICovXG5leHBvcnQgY29uc3Qgbm9vcENvbXBhcmF0b3IgPSA8VD4oKTogQ29tcGFyYXRvcjxUPiA9PiB7XG4gIHJldHVybiAoKSA9PiAwO1xufTtcbiIsImltcG9ydCB7IENvbXBhcmF0b3IgfSBmcm9tICcuLyc7XG5pbXBvcnQgeyBUcmFja1R5cGUgfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHsgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgdGhlIGRvbWluYW50IHNwZWFrZXIgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBkb21pbmFudFNwZWFrZXI6IENvbXBhcmF0b3I8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudD4gPSAoYSwgYikgPT4ge1xuICBpZiAoYS5pc0RvbWluYW50U3BlYWtlciAmJiAhYi5pc0RvbWluYW50U3BlYWtlcikgcmV0dXJuIC0xO1xuICBpZiAoIWEuaXNEb21pbmFudFNwZWFrZXIgJiYgYi5pc0RvbWluYW50U3BlYWtlcikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgc3BlYWtpbmcgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBzcGVha2luZzogQ29tcGFyYXRvcjxTdHJlYW1WaWRlb1BhcnRpY2lwYW50PiA9IChhLCBiKSA9PiB7XG4gIGlmIChhLmlzU3BlYWtpbmcgJiYgIWIuaXNTcGVha2luZykgcmV0dXJuIC0xO1xuICBpZiAoIWEuaXNTcGVha2luZyAmJiBiLmlzU3BlYWtpbmcpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSBzY3JlZW4gc2hhcmluZyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjcmVlblNoYXJpbmc6IENvbXBhcmF0b3I8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudD4gPSAoYSwgYikgPT4ge1xuICBpZiAoaGFzU2NyZWVuU2hhcmUoYSkgJiYgIWhhc1NjcmVlblNoYXJlKGIpKSByZXR1cm4gLTE7XG4gIGlmICghaGFzU2NyZWVuU2hhcmUoYSkgJiYgaGFzU2NyZWVuU2hhcmUoYikpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSB2aWRlbyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHB1Ymxpc2hpbmdWaWRlbzogQ29tcGFyYXRvcjxTdHJlYW1WaWRlb1BhcnRpY2lwYW50PiA9IChhLCBiKSA9PiB7XG4gIGlmIChoYXNWaWRlbyhhKSAmJiAhaGFzVmlkZW8oYikpIHJldHVybiAtMTtcbiAgaWYgKCFoYXNWaWRlbyhhKSAmJiBoYXNWaWRlbyhiKSkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IGF1ZGlvIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3QgcGFydGljaXBhbnQuXG4gKiBAcGFyYW0gYiB0aGUgc2Vjb25kIHBhcnRpY2lwYW50LlxuICovXG5leHBvcnQgY29uc3QgcHVibGlzaGluZ0F1ZGlvOiBDb21wYXJhdG9yPFN0cmVhbVZpZGVvUGFydGljaXBhbnQ+ID0gKGEsIGIpID0+IHtcbiAgaWYgKGhhc0F1ZGlvKGEpICYmICFoYXNBdWRpbyhiKSkgcmV0dXJuIC0xO1xuICBpZiAoIWhhc0F1ZGlvKGEpICYmIGhhc0F1ZGlvKGIpKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIEEgY29tcGFyYXRvciB3aGljaCBwcmlvcml0aXplcyBwYXJ0aWNpcGFudHMgd2hvIGFyZSBwaW5uZWQuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBpbm5lZDogQ29tcGFyYXRvcjxTdHJlYW1WaWRlb1BhcnRpY2lwYW50PiA9IChhLCBiKSA9PiB7XG4gIGlmIChhLnBpbiAmJiBiLnBpbikge1xuICAgIGlmICghYS5waW4uaXNMb2NhbFBpbiAmJiBiLnBpbi5pc0xvY2FsUGluKSByZXR1cm4gLTE7XG4gICAgaWYgKGEucGluLmlzTG9jYWxQaW4gJiYgIWIucGluLmlzTG9jYWxQaW4pIHJldHVybiAxO1xuICAgIGlmIChhLnBpbi5waW5uZWRBdCA+IGIucGluLnBpbm5lZEF0KSByZXR1cm4gLTE7XG4gICAgaWYgKGEucGluLnBpbm5lZEF0IDwgYi5waW4ucGlubmVkQXQpIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGEucGluICYmICFiLnBpbikgcmV0dXJuIC0xO1xuICBpZiAoIWEucGluICYmIGIucGluKSByZXR1cm4gMTtcblxuICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQSBjb21wYXJhdG9yIGNyZWF0b3Igd2hpY2ggd2lsbCBzZXQgdXAgYSBjb21wYXJhdG9yIHdoaWNoIHByaW9yaXRpemVzXG4gKiBwYXJ0aWNpcGFudHMgd2hvIGhhdmUgYSBzcGVjaWZpYyByZWFjdGlvbi5cbiAqXG4gKiBAcGFyYW0gdHlwZSB0aGUgcmVhY3Rpb24gdHlwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWN0aW9uVHlwZSA9IChcbiAgdHlwZTogc3RyaW5nLFxuKTogQ29tcGFyYXRvcjxTdHJlYW1WaWRlb1BhcnRpY2lwYW50PiA9PiB7XG4gIHJldHVybiAoYSwgYikgPT4ge1xuICAgIGlmIChhLnJlYWN0aW9uPy50eXBlID09PSB0eXBlICYmIGIucmVhY3Rpb24/LnR5cGUgIT09IHR5cGUpIHJldHVybiAtMTtcbiAgICBpZiAoYS5yZWFjdGlvbj8udHlwZSAhPT0gdHlwZSAmJiBiLnJlYWN0aW9uPy50eXBlID09PSB0eXBlKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbi8qKlxuICogQSBjb21wYXJhdG9yIGNyZWF0b3Igd2hpY2ggd2lsbCBzZXQgdXAgYSBjb21wYXJhdG9yIHdoaWNoIHByaW9yaXRpemVzXG4gKiBwYXJ0aWNpcGFudHMgd2hvIGhhdmUgYSBzcGVjaWZpYyByb2xlLlxuICpcbiAqIEBwYXJhbSByb2xlcyB0aGUgcm9sZXMgdG8gcHJpb3JpdGl6ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHJvbGUgPVxuICAoLi4ucm9sZXM6IHN0cmluZ1tdKTogQ29tcGFyYXRvcjxTdHJlYW1WaWRlb1BhcnRpY2lwYW50PiA9PlxuICAoYSwgYikgPT4ge1xuICAgIGlmIChoYXNBbnlSb2xlKGEsIHJvbGVzKSAmJiAhaGFzQW55Um9sZShiLCByb2xlcykpIHJldHVybiAtMTtcbiAgICBpZiAoIWhhc0FueVJvbGUoYSwgcm9sZXMpICYmIGhhc0FueVJvbGUoYiwgcm9sZXMpKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5hbWU6IENvbXBhcmF0b3I8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudD4gPSAoYSwgYikgPT4ge1xuICBpZiAoYS5uYW1lIDwgYi5uYW1lKSByZXR1cm4gLTE7XG4gIGlmIChhLm5hbWUgPiBiLm5hbWUpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn07XG5cbmNvbnN0IGhhc0FueVJvbGUgPSAocDogU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCwgcm9sZXM6IHN0cmluZ1tdKSA9PlxuICAocC5yb2xlcyB8fCBbXSkuc29tZSgocikgPT4gcm9sZXMuaW5jbHVkZXMocikpO1xuXG5jb25zdCBoYXNTY3JlZW5TaGFyZSA9IChwOiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50KSA9PlxuICBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuU0NSRUVOX1NIQVJFKTtcblxuY29uc3QgaGFzVmlkZW8gPSAocDogU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCkgPT5cbiAgcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlZJREVPKTtcblxuY29uc3QgaGFzQXVkaW8gPSAocDogU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCkgPT5cbiAgcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLkFVRElPKTtcbiIsImltcG9ydCB7IFN0cmVhbVZpZGVvUGFydGljaXBhbnQsIFZpc2liaWxpdHlTdGF0ZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNvbWJpbmVDb21wYXJhdG9ycywgY29uZGl0aW9uYWwgfSBmcm9tICcuL2NvbXBhcmF0b3InO1xuaW1wb3J0IHtcbiAgZG9taW5hbnRTcGVha2VyLFxuICBwaW5uZWQsXG4gIHB1Ymxpc2hpbmdBdWRpbyxcbiAgcHVibGlzaGluZ1ZpZGVvLFxuICByZWFjdGlvblR5cGUsXG4gIHJvbGUsXG4gIHNjcmVlblNoYXJpbmcsXG4gIHNwZWFraW5nLFxufSBmcm9tICcuL3BhcnRpY2lwYW50cyc7XG5cbi8vIGEgY29tcGFyYXRvciBkZWNvcmF0b3Igd2hpY2ggYXBwbGllcyB0aGUgZGVjb3JhdGVkIGNvbXBhcmF0b3Igb25seSBpZiB0aGVcbi8vIHBhcnRpY2lwYW50IGlzIGludmlzaWJsZS5cbi8vIFRoaXMgZW5zdXJlcyBzdGFibGUgc29ydGluZyB3aGVuIGFsbCBwYXJ0aWNpcGFudHMgYXJlIHZpc2libGUuXG5jb25zdCBpZkludmlzaWJsZUJ5ID0gY29uZGl0aW9uYWwoXG4gIChhOiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50LCBiOiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50KSA9PlxuICAgIGEudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUgfHxcbiAgICBiLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFLFxuKTtcblxuLyoqXG4gKiBBIGNvbXBhcmF0b3IgdGhhdCBhcHBsaWVzIHRoZSBkZWNvcmF0ZWQgY29tcGFyYXRvciB3aGVuIGEgcGFydGljaXBhbnQgaXNcbiAqIGVpdGhlciBpbnZpc2libGUgb3IgaXRzIHZpc2liaWxpdHkgc3RhdGUgaXNuJ3Qga25vd24uXG4gKiBGb3IgdmlzaWJsZSBwYXJ0aWNpcGFudHMsIGl0IGVuc3VyZXMgc3RhYmxlIHNvcnRpbmcuXG4gKi9cbmNvbnN0IGlmSW52aXNpYmxlT3JVbmtub3duQnkgPSBjb25kaXRpb25hbChcbiAgKGE6IFN0cmVhbVZpZGVvUGFydGljaXBhbnQsIGI6IFN0cmVhbVZpZGVvUGFydGljaXBhbnQpID0+XG4gICAgYS52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8udmlkZW9UcmFjayA9PT0gVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRSB8fFxuICAgIGEudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOIHx8XG4gICAgYi52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8udmlkZW9UcmFjayA9PT0gVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRSB8fFxuICAgIGIudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxuKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzb3J0aW5nIHByZXNldC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTb3J0UHJlc2V0ID0gY29tYmluZUNvbXBhcmF0b3JzKFxuICBwaW5uZWQsXG4gIHNjcmVlblNoYXJpbmcsXG4gIGlmSW52aXNpYmxlQnkoXG4gICAgY29tYmluZUNvbXBhcmF0b3JzKFxuICAgICAgZG9taW5hbnRTcGVha2VyLFxuICAgICAgc3BlYWtpbmcsXG4gICAgICByZWFjdGlvblR5cGUoJ3JhaXNlZC1oYW5kJyksXG4gICAgICBwdWJsaXNoaW5nVmlkZW8sXG4gICAgICBwdWJsaXNoaW5nQXVkaW8sXG4gICAgKSxcbiAgKSxcbiAgLy8gaWZJbnZpc2libGVCeShuYW1lKSxcbik7XG5cbi8qKlxuICogVGhlIHNvcnRpbmcgcHJlc2V0IGZvciBzcGVha2VyIGxheW91dC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0ID0gY29tYmluZUNvbXBhcmF0b3JzKFxuICBwaW5uZWQsXG4gIHNjcmVlblNoYXJpbmcsXG4gIGRvbWluYW50U3BlYWtlcixcbiAgaWZJbnZpc2libGVCeShcbiAgICBjb21iaW5lQ29tcGFyYXRvcnMoXG4gICAgICBzcGVha2luZyxcbiAgICAgIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSxcbiAgICAgIHB1Ymxpc2hpbmdWaWRlbyxcbiAgICAgIHB1Ymxpc2hpbmdBdWRpbyxcbiAgICApLFxuICApLFxuICAvLyBpZkludmlzaWJsZUJ5KG5hbWUpLFxuKTtcblxuLyoqXG4gKiBUaGUgc29ydGluZyBwcmVzZXQgZm9yIGxheW91dHMgdGhhdCBkb24ndCByZW5kZXIgYWxsIHBhcnRpY2lwYW50cyBidXRcbiAqIGluc3RlYWQsIHJlbmRlciB0aGVtIGluIHBhZ2VzLlxuICovXG5leHBvcnQgY29uc3QgcGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhcbiAgcGlubmVkLFxuICBpZkludmlzaWJsZU9yVW5rbm93bkJ5KFxuICAgIGNvbWJpbmVDb21wYXJhdG9ycyhcbiAgICAgIGRvbWluYW50U3BlYWtlcixcbiAgICAgIHNwZWFraW5nLFxuICAgICAgcmVhY3Rpb25UeXBlKCdyYWlzZWQtaGFuZCcpLFxuICAgICAgcHVibGlzaGluZ1ZpZGVvLFxuICAgICAgcHVibGlzaGluZ0F1ZGlvLFxuICAgICksXG4gICksXG4gIC8vIGlmSW52aXNpYmxlT3JVbmtub3duQnkobmFtZSksXG4pO1xuXG4vKipcbiAqIFRoZSBzb3J0aW5nIHByZXNldCBmb3IgbGl2ZXN0cmVhbXMgYW5kIGF1ZGlvIHJvb21zLlxuICovXG5leHBvcnQgY29uc3QgbGl2ZXN0cmVhbU9yQXVkaW9Sb29tU29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhcbiAgaWZJbnZpc2libGVCeShcbiAgICBjb21iaW5lQ29tcGFyYXRvcnMoXG4gICAgICBkb21pbmFudFNwZWFrZXIsXG4gICAgICBzcGVha2luZyxcbiAgICAgIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSxcbiAgICAgIHB1Ymxpc2hpbmdWaWRlbyxcbiAgICAgIHB1Ymxpc2hpbmdBdWRpbyxcbiAgICApLFxuICApLFxuICByb2xlKCdhZG1pbicsICdob3N0JywgJ3NwZWFrZXInKSxcbiAgLy8gbmFtZSxcbik7XG4iLCJpbXBvcnQge1xuICBCZWhhdmlvclN1YmplY3QsXG4gIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuICBtYXAsXG4gIE9ic2VydmFibGUsXG4gIHNoYXJlUmVwbGF5LFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB0eXBlIHsgUGF0Y2ggfSBmcm9tICcuL3J4VXRpbHMnO1xuaW1wb3J0ICogYXMgUnhVdGlscyBmcm9tICcuL3J4VXRpbHMnO1xuaW1wb3J0IHtcbiAgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCxcbiAgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudFBhdGNoLFxuICBTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2hlcyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgQ2FsbFN0YXRzUmVwb3J0IH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHtcbiAgQmxvY2tlZFVzZXJFdmVudCxcbiAgQ2FsbEhMU0Jyb2FkY2FzdGluZ1N0YXJ0ZWRFdmVudCxcbiAgQ2FsbEluZ3Jlc3NSZXNwb25zZSxcbiAgQ2FsbE1lbWJlckFkZGVkRXZlbnQsXG4gIENhbGxNZW1iZXJSZW1vdmVkRXZlbnQsXG4gIENhbGxNZW1iZXJVcGRhdGVkRXZlbnQsXG4gIENhbGxNZW1iZXJVcGRhdGVkUGVybWlzc2lvbkV2ZW50LFxuICBDYWxsUmVhY3Rpb25FdmVudCxcbiAgQ2FsbFJlc3BvbnNlLFxuICBDYWxsU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkRXZlbnQsXG4gIENhbGxTZXNzaW9uUGFydGljaXBhbnRMZWZ0RXZlbnQsXG4gIENhbGxTZXNzaW9uUmVzcG9uc2UsXG4gIENhbGxTZXR0aW5nc1Jlc3BvbnNlLFxuICBFZ3Jlc3NSZXNwb25zZSxcbiAgTWVtYmVyUmVzcG9uc2UsXG4gIE93bkNhcGFiaWxpdHksXG4gIFRodW1ibmFpbFJlc3BvbnNlLFxuICBVbmJsb2NrZWRVc2VyRXZlbnQsXG4gIFVwZGF0ZWRDYWxsUGVybWlzc2lvbnNFdmVudCxcbiAgVXNlclJlc3BvbnNlLFxuICBXU0V2ZW50LFxufSBmcm9tICcuLi9nZW4vY29vcmRpbmF0b3InO1xuaW1wb3J0IHsgUGluLCBUcmFja1R5cGUgfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL3NvcnRpbmcnO1xuaW1wb3J0ICogYXMgU29ydGluZ1ByZXNldCBmcm9tICcuLi9zb3J0aW5nL3ByZXNldHMnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vdHlwZXMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKi9cbmV4cG9ydCBlbnVtIENhbGxpbmdTdGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgY2FsbCBpcyBpbiBhbiB1bmtub3duIHN0YXRlLlxuICAgKi9cbiAgVU5LTk9XTiA9ICd1bmtub3duJyxcbiAgLyoqXG4gICAqIFRoZSBjYWxsIGlzIGluIGFuIGlkbGUgc3RhdGUuXG4gICAqL1xuICBJRExFID0gJ2lkbGUnLFxuXG4gIC8qKlxuICAgKiBUaGUgY2FsbCBpcyBpbiB0aGUgcHJvY2VzcyBvZiByaW5naW5nLlxuICAgKiAoVXNlciBoYXNuJ3QgYWNjZXB0ZWQgbm9yIHJlamVjdGVkIHRoZSBjYWxsIHlldC4pXG4gICAqL1xuICBSSU5HSU5HID0gJ3JpbmdpbmcnLFxuXG4gIC8qKlxuICAgKiBUaGUgY2FsbCBpcyBpbiB0aGUgcHJvY2VzcyBvZiBqb2luaW5nLlxuICAgKi9cbiAgSk9JTklORyA9ICdqb2luaW5nJyxcblxuICAvKipcbiAgICogVGhlIGNhbGwgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICovXG4gIEpPSU5FRCA9ICdqb2luZWQnLFxuXG4gIC8qKlxuICAgKiBUaGUgY2FsbCBoYXMgYmVlbiBsZWZ0LlxuICAgKi9cbiAgTEVGVCA9ICdsZWZ0JyxcblxuICAvKipcbiAgICogVGhlIGNhbGwgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgcmVjb25uZWN0aW5nLlxuICAgKi9cbiAgUkVDT05ORUNUSU5HID0gJ3JlY29ubmVjdGluZycsXG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsIGlzIGluIHRoZSBwcm9jZXNzIG9mIG1pZ3JhdGluZyBmcm9tIG9uZSBub2RlIHRvIGFub3RoZXIuXG4gICAqL1xuICBNSUdSQVRJTkcgPSAnbWlncmF0aW5nJyxcblxuICAvKipcbiAgICogVGhlIGNhbGwgaGFzIGZhaWxlZCB0byByZWNvbm5lY3QuXG4gICAqL1xuICBSRUNPTk5FQ1RJTkdfRkFJTEVEID0gJ3JlY29ubmVjdGluZy1mYWlsZWQnLFxuXG4gIC8qKlxuICAgKiBUaGUgY2FsbCBpcyBpbiBvZmZsaW5lIG1vZGUuXG4gICAqL1xuICBPRkZMSU5FID0gJ29mZmxpbmUnLFxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgZWdyZXNzIG9iamVjdCAtIHdoZW4gbm8gZWdyZXNzIGRhdGEgaXMgYXZhaWxhYmxlLlxuICovXG5jb25zdCBkZWZhdWx0RWdyZXNzOiBFZ3Jlc3NSZXNwb25zZSA9IHtcbiAgYnJvYWRjYXN0aW5nOiBmYWxzZSxcbiAgaGxzOiB7IHBsYXlsaXN0X3VybDogJycgfSxcbiAgcnRtcHM6IFtdLFxufTtcblxuLyoqXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqIEByZWFjdCBZb3UgZG9uJ3QgaGF2ZSB0byB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgYXMgd2UgYXJlIGV4cG9zaW5nIHRoZSBzdGF0ZSB0aHJvdWdoIEhvb2tzLlxuICovXG5leHBvcnQgY2xhc3MgQ2FsbFN0YXRlIHtcbiAgcHJpdmF0ZSBiYWNrc3RhZ2VTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0cnVlKTtcbiAgcHJpdmF0ZSBibG9ja2VkVXNlcklkc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZ1tdPihbXSk7XG4gIHByaXZhdGUgY3JlYXRlZEF0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZT4obmV3IERhdGUoKSk7XG4gIHByaXZhdGUgZW5kZWRBdFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIHByaXZhdGUgc3RhcnRzQXRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXRlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBwcml2YXRlIHVwZGF0ZWRBdFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuICBwcml2YXRlIGNyZWF0ZWRCeVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFVzZXJSZXNwb25zZSB8IHVuZGVmaW5lZD4oXG4gICAgdW5kZWZpbmVkLFxuICApO1xuICBwcml2YXRlIGN1c3RvbVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFJlY29yZDxzdHJpbmcsIGFueT4+KHt9KTtcbiAgcHJpdmF0ZSBlZ3Jlc3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxFZ3Jlc3NSZXNwb25zZSB8IHVuZGVmaW5lZD4oXG4gICAgdW5kZWZpbmVkLFxuICApO1xuICBwcml2YXRlIGluZ3Jlc3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDYWxsSW5ncmVzc1Jlc3BvbnNlIHwgdW5kZWZpbmVkPihcbiAgICB1bmRlZmluZWQsXG4gICk7XG4gIHByaXZhdGUgcmVjb3JkaW5nU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICBwcml2YXRlIHNlc3Npb25TdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDYWxsU2Vzc2lvblJlc3BvbnNlIHwgdW5kZWZpbmVkPihcbiAgICB1bmRlZmluZWQsXG4gICk7XG4gIHByaXZhdGUgc2V0dGluZ3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxcbiAgICBDYWxsU2V0dGluZ3NSZXNwb25zZSB8IHVuZGVmaW5lZFxuICA+KHVuZGVmaW5lZCk7XG4gIHByaXZhdGUgdHJhbnNjcmliaW5nU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICBwcml2YXRlIGVuZGVkQnlTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxVc2VyUmVzcG9uc2UgfCB1bmRlZmluZWQ+KFxuICAgIHVuZGVmaW5lZCxcbiAgKTtcbiAgcHJpdmF0ZSB0aHVtYm5haWxzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8XG4gICAgVGh1bWJuYWlsUmVzcG9uc2UgfCB1bmRlZmluZWRcbiAgPih1bmRlZmluZWQpO1xuICBwcml2YXRlIG1lbWJlcnNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxNZW1iZXJSZXNwb25zZVtdPihbXSk7XG4gIHByaXZhdGUgb3duQ2FwYWJpbGl0aWVzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8T3duQ2FwYWJpbGl0eVtdPihbXSk7XG4gIHByaXZhdGUgY2FsbGluZ1N0YXRlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Q2FsbGluZ1N0YXRlPihcbiAgICBDYWxsaW5nU3RhdGUuVU5LTk9XTixcbiAgKTtcbiAgcHJpdmF0ZSBzdGFydGVkQXRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXRlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBwcml2YXRlIHBhcnRpY2lwYW50Q291bnRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KDApO1xuICBwcml2YXRlIGFub255bW91c1BhcnRpY2lwYW50Q291bnRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KDApO1xuICBwcml2YXRlIHBhcnRpY2lwYW50c1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFN0cmVhbVZpZGVvUGFydGljaXBhbnRbXT4oXG4gICAgW10sXG4gICk7XG4gIHByaXZhdGUgY2FsbFN0YXRzUmVwb3J0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8XG4gICAgQ2FsbFN0YXRzUmVwb3J0IHwgdW5kZWZpbmVkXG4gID4odW5kZWZpbmVkKTtcblxuICAvLyBEZXJpdmVkIHN0YXRlXG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBjYWxsIHNlc3Npb24gYWN0dWFsbHkgc3RhcnRlZC5cbiAgICogVXNlZnVsIGZvciBkaXNwbGF5aW5nIHRoZSBjYWxsIGR1cmF0aW9uLlxuICAgKi9cbiAgc3RhcnRlZEF0JDogT2JzZXJ2YWJsZTxEYXRlIHwgdW5kZWZpbmVkPjtcblxuICAvKipcbiAgICogVGhlIHNlcnZlci1zaWRlIGNvdW50ZWQgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyBjb25uZWN0ZWQgdG8gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICogVGhpcyBudW1iZXIgaW5jbHVkZXMgdGhlIGFub255bW91cyBwYXJ0aWNpcGFudHMgYXMgd2VsbC5cbiAgICovXG4gIHBhcnRpY2lwYW50Q291bnQkOiBPYnNlcnZhYmxlPG51bWJlcj47XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJ2ZXItc2lkZSBjb3VudGVkIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGNvbm5lY3RlZCB0byB0aGUgY3VycmVudCBjYWxsLlxuICAgKiBUaGlzIG51bWJlciBleGNsdWRlcyB0aGUgcmVndWxhciBwYXJ0aWNpcGFudHMuXG4gICAqL1xuICBhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50JDogT2JzZXJ2YWJsZTxudW1iZXI+O1xuXG4gIC8qKlxuICAgKiBBbGwgcGFydGljaXBhbnRzIG9mIHRoZSBjdXJyZW50IGNhbGwgKHRoaXMgaW5jbHVkZXMgdGhlIGN1cnJlbnQgdXNlciBhbmQgb3RoZXIgcGFydGljaXBhbnRzIGFzIHdlbGwpLlxuICAgKi9cbiAgcGFydGljaXBhbnRzJDogT2JzZXJ2YWJsZTxTdHJlYW1WaWRlb1BhcnRpY2lwYW50W10+O1xuXG4gIC8qKlxuICAgKiBSZW1vdGUgcGFydGljaXBhbnRzIG9mIHRoZSBjdXJyZW50IGNhbGwgKHRoaXMgaW5jbHVkZXMgZXZlcnkgcGFydGljaXBhbnQgZXhjZXB0IHRoZSBsb2dnZWQtaW4gdXNlcikuXG4gICAqL1xuICByZW1vdGVQYXJ0aWNpcGFudHMkOiBPYnNlcnZhYmxlPFN0cmVhbVZpZGVvUGFydGljaXBhbnRbXT47XG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBwYXJ0aWNpcGFudCBvZiB0aGUgY3VycmVudCBjYWxsICh0aGUgbG9nZ2VkLWluIHVzZXIpLlxuICAgKi9cbiAgbG9jYWxQYXJ0aWNpcGFudCQ6IE9ic2VydmFibGU8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudCB8IHVuZGVmaW5lZD47XG5cbiAgLyoqXG4gICAqIFBpbm5lZCBwYXJ0aWNpcGFudHMgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAgICovXG4gIHBpbm5lZFBhcnRpY2lwYW50cyQ6IE9ic2VydmFibGU8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudFtdPjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBlbGVjdGVkIGRvbWluYW50IHNwZWFrZXIgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICovXG4gIGRvbWluYW50U3BlYWtlciQ6IE9ic2VydmFibGU8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudCB8IHVuZGVmaW5lZD47XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRydWUgd2hlbmV2ZXIgdGhlcmUgaXMgYW4gYWN0aXZlIHNjcmVlbiBzaGFyaW5nIHNlc3Npb24gd2l0aGluXG4gICAqIHRoZSBjdXJyZW50IGNhbGwuIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBhIFwic2NyZWVuIHNoYXJpbmdcIiBpbmRpY2F0b3IgYW5kXG4gICAqIHN3aXRjaGluZyB0aGUgbGF5b3V0IHRvIGEgc2NyZWVuIHNoYXJpbmcgbGF5b3V0LlxuICAgKlxuICAgKiBUaGUgYWN0dWFsIHNjcmVlbiBzaGFyaW5nIHRyYWNrIGlzbid0IGV4cG9zZWQgaGVyZSwgYnV0IGNhbiBiZSByZXRyaWV2ZWRcbiAgICogZnJvbSB0aGUgbGlzdCBvZiBjYWxsIHBhcnRpY2lwYW50cy4gV2UgYWxzbyBkb24ndCB3YW50IHRvIGJlIGxpbWl0aW5nXG4gICAqIHRvIHRoZSBudW1iZXIgb2Ygc2hhcmUgc2NyZWVuIHRyYWNrcyBhcmUgZGlzcGxheWVkIGluIGEgY2FsbC5cbiAgICovXG4gIGhhc09uZ29pbmdTY3JlZW5TaGFyZSQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIFRoZSBsYXRlc3Qgc3RhdHMgcmVwb3J0IG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqIFdoZW4gc3RhdHMgZ2F0aGVyaW5nIGlzIGVuYWJsZWQsIHRoaXMgb2JzZXJ2YWJsZSB3aWxsIGVtaXQgYSBuZXcgdmFsdWVcbiAgICogYXQgYSByZWd1bGFyIChjb25maWd1cmFibGUpIGludGVydmFsLlxuICAgKlxuICAgKiBDb25zdW1lcnMgb2YgdGhpcyBvYnNlcnZhYmxlIGNhbiBpbXBsZW1lbnQgdGhlaXIgb3duIGJhdGNoaW5nIGxvZ2ljXG4gICAqIGluIGNhc2UgdGhleSB3YW50IHRvIHNob3cgaGlzdG9yaWNhbCBzdGF0cyBkYXRhLlxuICAgKi9cbiAgY2FsbFN0YXRzUmVwb3J0JDogT2JzZXJ2YWJsZTxDYWxsU3RhdHNSZXBvcnQgfCB1bmRlZmluZWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBtZW1iZXJzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqL1xuICBtZW1iZXJzJDogT2JzZXJ2YWJsZTxNZW1iZXJSZXNwb25zZVtdPjtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgY2FwYWJpbGl0aWVzIG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAqL1xuICBvd25DYXBhYmlsaXRpZXMkOiBPYnNlcnZhYmxlPE93bkNhcGFiaWxpdHlbXT47XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsaW5nIHN0YXRlLlxuICAgKi9cbiAgY2FsbGluZ1N0YXRlJDogT2JzZXJ2YWJsZTxDYWxsaW5nU3RhdGU+O1xuXG4gIC8qKlxuICAgKiBUaGUgYmFja3N0YWdlIHN0YXRlLlxuICAgKi9cbiAgYmFja3N0YWdlJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSBsaXN0IG9mIGJsb2NrZWQgdXNlciBJRHMuXG4gICAqL1xuICBibG9ja2VkVXNlcklkcyQ6IE9ic2VydmFibGU8c3RyaW5nW10+O1xuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRpbWUgd2hlbiB0aGlzIGNhbGwgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRBdCQ6IE9ic2VydmFibGU8RGF0ZT47XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgdGltZSB3aGVuIHRoaXMgY2FsbCBoYXMgYmVlbiBlbmRlZC5cbiAgICovXG4gIGVuZGVkQXQkOiBPYnNlcnZhYmxlPERhdGUgfCB1bmRlZmluZWQ+O1xuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRpbWUgd2hlbiB0aGlzIGNhbGwgaGFzIGJlZW4gc2NoZWR1bGVkIHRvIHN0YXJ0LlxuICAgKi9cbiAgc3RhcnRzQXQkOiBPYnNlcnZhYmxlPERhdGUgfCB1bmRlZmluZWQ+O1xuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRpbWUgd2hlbiB0aGlzIGNhbGwgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICovXG4gIHVwZGF0ZWRBdCQ6IE9ic2VydmFibGU8RGF0ZT47XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGlzIGNhbGwuXG4gICAqL1xuICBjcmVhdGVkQnkkOiBPYnNlcnZhYmxlPFVzZXJSZXNwb25zZSB8IHVuZGVmaW5lZD47XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgY3VzdG9tIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgY3VzdG9tJDogT2JzZXJ2YWJsZTxSZWNvcmQ8c3RyaW5nLCBhbnk+PjtcblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSBlZ3Jlc3MgZGF0YSBvZiB0aGlzIGNhbGwuXG4gICAqL1xuICBlZ3Jlc3MkOiBPYnNlcnZhYmxlPEVncmVzc1Jlc3BvbnNlIHwgdW5kZWZpbmVkPjtcblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSBpbmdyZXNzIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgaW5ncmVzcyQ6IE9ic2VydmFibGU8Q2FsbEluZ3Jlc3NSZXNwb25zZSB8IHVuZGVmaW5lZD47XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgcmVjb3JkaW5nIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICovXG4gIHJlY29yZGluZyQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgc2Vzc2lvbiBkYXRhIG9mIHRoaXMgY2FsbC5cbiAgICovXG4gIHNlc3Npb24kOiBPYnNlcnZhYmxlPENhbGxTZXNzaW9uUmVzcG9uc2UgfCB1bmRlZmluZWQ+O1xuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIHNldHRpbmdzIG9mIHRoaXMgY2FsbC5cbiAgICovXG4gIHNldHRpbmdzJDogT2JzZXJ2YWJsZTxDYWxsU2V0dGluZ3NSZXNwb25zZSB8IHVuZGVmaW5lZD47XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgdHJhbnNjcmliaW5nIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICovXG4gIHRyYW5zY3JpYmluZyQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgdXNlciB3aG8gZW5kZWQgdGhpcyBjYWxsLlxuICAgKi9cbiAgZW5kZWRCeSQ6IE9ic2VydmFibGU8VXNlclJlc3BvbnNlIHwgdW5kZWZpbmVkPjtcblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSB0aHVtYm5haWxzIG9mIHRoaXMgY2FsbC5cbiAgICovXG4gIHRodW1ibmFpbHMkOiBPYnNlcnZhYmxlPFRodW1ibmFpbFJlc3BvbnNlIHwgdW5kZWZpbmVkPjtcblxuICByZWFkb25seSBsb2dnZXI6IExvZ2dlcjtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNvbXBhcmF0b3JzIHRoYXQgYXJlIHVzZWQgdG8gc29ydCB0aGUgcGFydGljaXBhbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzb3J0UGFydGljaXBhbnRzQnk6IENvbXBhcmF0b3I8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudD4gPVxuICAgIFNvcnRpbmdQcmVzZXQuZGVmYXVsdFNvcnRQcmVzZXQ7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBldmVudEhhbmRsZXJzOiB7XG4gICAgW0V2ZW50VHlwZSBpbiBXU0V2ZW50Wyd0eXBlJ11dOlxuICAgICAgfCAoKGV2ZW50OiBFeHRyYWN0PFdTRXZlbnQsIHsgdHlwZTogRXZlbnRUeXBlIH0+KSA9PiB2b2lkKVxuICAgICAgfCB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENhbGxTdGF0ZSBjbGFzcy5cbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnQ2FsbFN0YXRlJ10pO1xuICAgIHRoaXMucGFydGljaXBhbnRzJCA9IHRoaXMucGFydGljaXBhbnRzU3ViamVjdC5hc09ic2VydmFibGUoKS5waXBlKFxuICAgICAgLy8gbWFpbnRhaW4gc3RhYmxlLXNvcnQgYnkgbXV0YXRpbmcgdGhlIHBhcnRpY2lwYW50cyBzdG9yZWRcbiAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBzdWJqZWN0XG4gICAgICBtYXAoKHBzKSA9PiBwcy5zb3J0KHRoaXMuc29ydFBhcnRpY2lwYW50c0J5KSksXG4gICAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQkID0gdGhpcy5wYXJ0aWNpcGFudHMkLnBpcGUoXG4gICAgICBtYXAoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbmQoKHApID0+IHAuaXNMb2NhbFBhcnRpY2lwYW50KSksXG4gICAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cyQgPSB0aGlzLnBhcnRpY2lwYW50cyQucGlwZShcbiAgICAgIG1hcCgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmlsdGVyKChwKSA9PiAhcC5pc0xvY2FsUGFydGljaXBhbnQpKSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSksXG4gICAgKTtcblxuICAgIHRoaXMucGlubmVkUGFydGljaXBhbnRzJCA9IHRoaXMucGFydGljaXBhbnRzJC5waXBlKFxuICAgICAgbWFwKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maWx0ZXIoKHApID0+ICEhcC5waW4pKSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSksXG4gICAgKTtcblxuICAgIHRoaXMuZG9taW5hbnRTcGVha2VyJCA9IHRoaXMucGFydGljaXBhbnRzJC5waXBlKFxuICAgICAgbWFwKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maW5kKChwKSA9PiBwLmlzRG9taW5hbnRTcGVha2VyKSksXG4gICAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLmhhc09uZ29pbmdTY3JlZW5TaGFyZSQgPSB0aGlzLnBhcnRpY2lwYW50cyQucGlwZShcbiAgICAgIG1hcCgocGFydGljaXBhbnRzKSA9PlxuICAgICAgICBwYXJ0aWNpcGFudHMuc29tZSgocCkgPT5cbiAgICAgICAgICBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuU0NSRUVOX1NIQVJFKSxcbiAgICAgICAgKSxcbiAgICAgICksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSxcbiAgICApO1xuXG4gICAgdGhpcy5zdGFydGVkQXQkID0gdGhpcy5zdGFydGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMucGFydGljaXBhbnRDb3VudCQgPSB0aGlzLnBhcnRpY2lwYW50Q291bnRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCQgPVxuICAgICAgdGhpcy5hbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50U3ViamVjdC5hc09ic2VydmFibGUoKTtcblxuICAgIHRoaXMuY2FsbFN0YXRzUmVwb3J0JCA9IHRoaXMuY2FsbFN0YXRzUmVwb3J0U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLm1lbWJlcnMkID0gdGhpcy5tZW1iZXJzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLm93bkNhcGFiaWxpdGllcyQgPSB0aGlzLm93bkNhcGFiaWxpdGllc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5jYWxsaW5nU3RhdGUkID0gdGhpcy5jYWxsaW5nU3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuXG4gICAgdGhpcy5iYWNrc3RhZ2UkID0gdGhpcy5iYWNrc3RhZ2VTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuYmxvY2tlZFVzZXJJZHMkID0gdGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5jcmVhdGVkQXQkID0gdGhpcy5jcmVhdGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuZW5kZWRBdCQgPSB0aGlzLmVuZGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuc3RhcnRzQXQkID0gdGhpcy5zdGFydHNBdFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy51cGRhdGVkQXQkID0gdGhpcy51cGRhdGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuY3JlYXRlZEJ5JCA9IHRoaXMuY3JlYXRlZEJ5U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLmN1c3RvbSQgPSB0aGlzLmN1c3RvbVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5lZ3Jlc3MkID0gdGhpcy5lZ3Jlc3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuaW5ncmVzcyQgPSB0aGlzLmluZ3Jlc3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMucmVjb3JkaW5nJCA9IHRoaXMucmVjb3JkaW5nU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLnNlc3Npb24kID0gdGhpcy5zZXNzaW9uU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLnNldHRpbmdzJCA9IHRoaXMuc2V0dGluZ3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMudHJhbnNjcmliaW5nJCA9IHRoaXMudHJhbnNjcmliaW5nU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLmVuZGVkQnkkID0gdGhpcy5lbmRlZEJ5U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLnRodW1ibmFpbHMkID0gdGhpcy50aHVtYm5haWxzU3ViamVjdC5hc09ic2VydmFibGUoKTtcblxuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IHtcbiAgICAgIC8vIHRoZXNlIGV2ZW50cyBhcmUgbm90IHVwZGF0aW5nIHRoZSBjYWxsIHN0YXRlOlxuICAgICAgJ2NhbGwuY2xvc2VkX2NhcHRpb24nOiB1bmRlZmluZWQsXG4gICAgICAnY2FsbC5wZXJtaXNzaW9uX3JlcXVlc3QnOiB1bmRlZmluZWQsXG4gICAgICAnY2FsbC5yZWNvcmRpbmdfZmFpbGVkJzogdW5kZWZpbmVkLFxuICAgICAgJ2NhbGwucmVjb3JkaW5nX3JlYWR5JzogdW5kZWZpbmVkLFxuICAgICAgJ2NhbGwudHJhbnNjcmlwdGlvbl9zdGFydGVkJzogdW5kZWZpbmVkLFxuICAgICAgJ2NhbGwudHJhbnNjcmlwdGlvbl9zdG9wcGVkJzogdW5kZWZpbmVkLFxuICAgICAgJ2NhbGwudHJhbnNjcmlwdGlvbl9yZWFkeSc6IHVuZGVmaW5lZCxcbiAgICAgICdjYWxsLnRyYW5zY3JpcHRpb25fZmFpbGVkJzogdW5kZWZpbmVkLFxuICAgICAgJ2NhbGwudXNlcl9tdXRlZCc6IHVuZGVmaW5lZCxcbiAgICAgICdjb25uZWN0aW9uLmVycm9yJzogdW5kZWZpbmVkLFxuICAgICAgJ2Nvbm5lY3Rpb24ub2snOiB1bmRlZmluZWQsXG4gICAgICAnaGVhbHRoLmNoZWNrJzogdW5kZWZpbmVkLFxuICAgICAgY3VzdG9tOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIGV2ZW50cyB0aGF0IHVwZGF0ZSBjYWxsIHN0YXRlOlxuICAgICAgJ2NhbGwuYWNjZXB0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAnY2FsbC5ibG9ja2VkX3VzZXInOiB0aGlzLmJsb2NrVXNlcixcbiAgICAgICdjYWxsLmNyZWF0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAnY2FsbC5lbmRlZCc6IChlKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpO1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmVuZGVkQnlTdWJqZWN0LCBlLnVzZXIpO1xuICAgICAgfSxcbiAgICAgICdjYWxsLmhsc19icm9hZGNhc3RpbmdfZmFpbGVkJzogdGhpcy51cGRhdGVGcm9tSExTQnJvYWRjYXN0aW5nRmFpbGVkLFxuICAgICAgJ2NhbGwuaGxzX2Jyb2FkY2FzdGluZ19zdGFydGVkJzogdGhpcy51cGRhdGVGcm9tSExTQnJvYWRjYXN0U3RhcnRlZCxcbiAgICAgICdjYWxsLmhsc19icm9hZGNhc3Rpbmdfc3RvcHBlZCc6IHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0b3BwZWQsXG4gICAgICAnY2FsbC5saXZlX3N0YXJ0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAnY2FsbC5tZW1iZXJfYWRkZWQnOiB0aGlzLnVwZGF0ZUZyb21NZW1iZXJBZGRlZCxcbiAgICAgICdjYWxsLm1lbWJlcl9yZW1vdmVkJzogdGhpcy51cGRhdGVGcm9tTWVtYmVyUmVtb3ZlZCxcbiAgICAgICdjYWxsLm1lbWJlcl91cGRhdGVkX3Blcm1pc3Npb24nOiB0aGlzLnVwZGF0ZU1lbWJlcnMsXG4gICAgICAnY2FsbC5tZW1iZXJfdXBkYXRlZCc6IHRoaXMudXBkYXRlTWVtYmVycyxcbiAgICAgICdjYWxsLm5vdGlmaWNhdGlvbic6IChlKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpO1xuICAgICAgICB0aGlzLnNldE1lbWJlcnMoZS5tZW1iZXJzKTtcbiAgICAgIH0sXG4gICAgICAnY2FsbC5wZXJtaXNzaW9uc191cGRhdGVkJzogdGhpcy51cGRhdGVPd25DYXBhYmlsaXRpZXMsXG4gICAgICAnY2FsbC5yZWFjdGlvbl9uZXcnOiB0aGlzLnVwZGF0ZVBhcnRpY2lwYW50UmVhY3Rpb24sXG4gICAgICAnY2FsbC5yZWNvcmRpbmdfc3RhcnRlZCc6ICgpID0+XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucmVjb3JkaW5nU3ViamVjdCwgdHJ1ZSksXG4gICAgICAnY2FsbC5yZWNvcmRpbmdfc3RvcHBlZCc6ICgpID0+XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucmVjb3JkaW5nU3ViamVjdCwgZmFsc2UpLFxuICAgICAgJ2NhbGwucmVqZWN0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAnY2FsbC5yaW5nJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgJ2NhbGwuc2Vzc2lvbl9lbmRlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICdjYWxsLnNlc3Npb25fcGFydGljaXBhbnRfam9pbmVkJzpcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkLFxuICAgICAgJ2NhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9sZWZ0JzogdGhpcy51cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50TGVmdCxcbiAgICAgICdjYWxsLnNlc3Npb25fc3RhcnRlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICdjYWxsLnVuYmxvY2tlZF91c2VyJzogdGhpcy51bmJsb2NrVXNlcixcbiAgICAgICdjYWxsLnVwZGF0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAnY2FsbC5kZWxldGVkJzogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGlzdCBvZiBjcml0ZXJpYSB0aGF0IGFyZSB1c2VkIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cy5cbiAgICogVG8gZGlzYWJsZSBzb3J0aW5nLCB5b3UgY2FuIHBhc3MgYG5vb3BDb21wYXJhdG9yKClgLlxuICAgKlxuICAgKiBAcGFyYW0gY29tcGFyYXRvciB0aGUgY29tcGFyYXRvciB0byB1c2UgdG8gc29ydCB0aGUgcGFydGljaXBhbnRzLlxuICAgKi9cbiAgc2V0U29ydFBhcnRpY2lwYW50c0J5ID0gKGNvbXBhcmF0b3I6IENvbXBhcmF0b3I8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudD4pID0+IHtcbiAgICB0aGlzLnNvcnRQYXJ0aWNpcGFudHNCeSA9IGNvbXBhcmF0b3I7XG4gICAgLy8gdHJpZ2dlciByZS1zb3J0aW5nIG9mIHBhcnRpY2lwYW50c1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRzU3ViamVjdCwgKHBzKSA9PiBwcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICAgKiBub3QgZW1pdHRlZCBhIHZhbHVlIHlldC5cbiAgICpcbiAgICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICovXG4gIGdldEN1cnJlbnRWYWx1ZSA9IFJ4VXRpbHMuZ2V0Q3VycmVudFZhbHVlO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAgICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gICAqIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gICAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAqL1xuICBzZXRDdXJyZW50VmFsdWUgPSBSeFV0aWxzLnNldEN1cnJlbnRWYWx1ZTtcblxuICAvKipcbiAgICogVGhlIHNlcnZlci1zaWRlIGNvdW50ZWQgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyBjb25uZWN0ZWQgdG8gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICogVGhpcyBudW1iZXIgaW5jbHVkZXMgdGhlIGFub255bW91cyBwYXJ0aWNpcGFudHMgYXMgd2VsbC5cbiAgICovXG4gIGdldCBwYXJ0aWNpcGFudENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnBhcnRpY2lwYW50Q291bnQkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBwYXJ0aWNpcGFudHMuXG4gICAqL1xuICBzZXRQYXJ0aWNpcGFudENvdW50ID0gKGNvdW50OiBQYXRjaDxudW1iZXI+KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRDb3VudFN1YmplY3QsIGNvdW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIGNhbGwgc2Vzc2lvbiBhY3R1YWxseSBzdGFydGVkLlxuICAgKiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcgdGhlIGNhbGwgZHVyYXRpb24uXG4gICAqL1xuICBnZXQgc3RhcnRlZEF0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXJ0ZWRBdCQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpbWUgdGhlIGNhbGwgc2Vzc2lvbiBhY3R1YWxseSBzdGFydGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHN0YXJ0ZWRBdCB0aGUgdGltZSB0aGUgY2FsbCBzZXNzaW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAqL1xuICBzZXRTdGFydGVkQXQgPSAoc3RhcnRlZEF0OiBQYXRjaDxEYXRlIHwgdW5kZWZpbmVkPikgPT4ge1xuICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXJ0ZWRBdFN1YmplY3QsIHN0YXJ0ZWRBdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJ2ZXItc2lkZSBjb3VudGVkIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGNvbm5lY3RlZCB0byB0aGUgY3VycmVudCBjYWxsLlxuICAgKiBUaGlzIG51bWJlciBpbmNsdWRlcyB0aGUgYW5vbnltb3VzIHBhcnRpY2lwYW50cyBhcyB3ZWxsLlxuICAgKi9cbiAgZ2V0IGFub255bW91c1BhcnRpY2lwYW50Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzLlxuICAgKi9cbiAgc2V0QW5vbnltb3VzUGFydGljaXBhbnRDb3VudCA9IChjb3VudDogUGF0Y2g8bnVtYmVyPikgPT4ge1xuICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmFub255bW91c1BhcnRpY2lwYW50Q291bnRTdWJqZWN0LCBjb3VudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgKi9cbiAgZ2V0IHBhcnRpY2lwYW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5wYXJ0aWNpcGFudHMkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQHBhcmFtIHBhcnRpY2lwYW50cyB0aGUgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXG4gICAqL1xuICBzZXRQYXJ0aWNpcGFudHMgPSAocGFydGljaXBhbnRzOiBQYXRjaDxTdHJlYW1WaWRlb1BhcnRpY2lwYW50W10+KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRzU3ViamVjdCwgcGFydGljaXBhbnRzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGxvY2FsIHBhcnRpY2lwYW50IGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqL1xuICBnZXQgbG9jYWxQYXJ0aWNpcGFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5sb2NhbFBhcnRpY2lwYW50JCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgcmVtb3RlIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgKi9cbiAgZ2V0IHJlbW90ZVBhcnRpY2lwYW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZG9taW5hbnQgc3BlYWtlciBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgKi9cbiAgZ2V0IGRvbWluYW50U3BlYWtlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kb21pbmFudFNwZWFrZXIkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBwaW5uZWQgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqL1xuICBnZXQgcGlubmVkUGFydGljaXBhbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnBpbm5lZFBhcnRpY2lwYW50cyQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlbGwgaWYgdGhlcmUgaXMgYW4gb25nb2luZyBzY3JlZW4gc2hhcmUgaW4gdGhpcyBjYWxsLlxuICAgKi9cbiAgZ2V0IGhhc09uZ29pbmdTY3JlZW5TaGFyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5oYXNPbmdvaW5nU2NyZWVuU2hhcmUkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FsbGluZyBzdGF0ZS5cbiAgICovXG4gIGdldCBjYWxsaW5nU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbGluZ1N0YXRlJCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FsbGluZyBzdGF0ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBzdGF0ZSB0aGUgbmV3IGNhbGxpbmcgc3RhdGUuXG4gICAqL1xuICBzZXRDYWxsaW5nU3RhdGUgPSAoc3RhdGU6IFBhdGNoPENhbGxpbmdTdGF0ZT4pID0+IHtcbiAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsaW5nU3RhdGVTdWJqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsIHN0YXRzIHJlcG9ydC5cbiAgICovXG4gIGdldCBjYWxsU3RhdHNSZXBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbFN0YXRzUmVwb3J0JCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FsbCBzdGF0cyByZXBvcnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gcmVwb3J0IHRoZSByZXBvcnQgdG8gc2V0LlxuICAgKi9cbiAgc2V0Q2FsbFN0YXRzUmVwb3J0ID0gKHJlcG9ydDogUGF0Y2g8Q2FsbFN0YXRzUmVwb3J0IHwgdW5kZWZpbmVkPikgPT4ge1xuICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmNhbGxTdGF0c1JlcG9ydFN1YmplY3QsIHJlcG9ydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBtZW1iZXJzIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqL1xuICBnZXQgbWVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5tZW1iZXJzJCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWVtYmVycyBvZiB0aGUgY3VycmVudCBjYWxsLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIG1lbWJlcnMgdGhlIG1lbWJlcnMgdG8gc2V0LlxuICAgKi9cbiAgc2V0TWVtYmVycyA9IChtZW1iZXJzOiBQYXRjaDxNZW1iZXJSZXNwb25zZVtdPikgPT4ge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVyc1N1YmplY3QsIG1lbWJlcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBjdXJyZW50IHVzZXIgZm9yIHRoZSBjdXJyZW50IGNhbGwuXG4gICAqL1xuICBnZXQgb3duQ2FwYWJpbGl0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLm93bkNhcGFiaWxpdGllcyQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG93biBjYXBhYmlsaXRpZXMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gY2FwYWJpbGl0aWVzIHRoZSBjYXBhYmlsaXRpZXMgdG8gc2V0LlxuICAgKi9cbiAgc2V0T3duQ2FwYWJpbGl0aWVzID0gKGNhcGFiaWxpdGllczogUGF0Y2g8T3duQ2FwYWJpbGl0eVtdPikgPT4ge1xuICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm93bkNhcGFiaWxpdGllc1N1YmplY3QsIGNhcGFiaWxpdGllcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBiYWNrc3RhZ2Ugc3RhdGUuXG4gICAqL1xuICBnZXQgYmFja3N0YWdlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmJhY2tzdGFnZSQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgbGlzdCBvZiBibG9ja2VkIHVzZXIgSURzLlxuICAgKi9cbiAgZ2V0IGJsb2NrZWRVc2VySWRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmJsb2NrZWRVc2VySWRzJCk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSB0aW1lIHdoZW4gdGhpcyBjYWxsIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAqL1xuICBnZXQgY3JlYXRlZEF0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNyZWF0ZWRBdCQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgdGltZSB3aGVuIHRoaXMgY2FsbCBoYXMgYmVlbiBlbmRlZC5cbiAgICovXG4gIGdldCBlbmRlZEF0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmVuZGVkQXQkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRpbWUgd2hlbiB0aGlzIGNhbGwgaGFzIGJlZW4gc2NoZWR1bGVkIHRvIHN0YXJ0LlxuICAgKi9cbiAgZ2V0IHN0YXJ0c0F0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXJ0c0F0JCk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSB0aW1lIHdoZW4gdGhpcyBjYWxsIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqL1xuICBnZXQgdXBkYXRlZEF0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnVwZGF0ZWRBdCQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGlzIGNhbGwuXG4gICAqL1xuICBnZXQgY3JlYXRlZEJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNyZWF0ZWRCeSQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgY3VzdG9tIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgZ2V0IGN1c3RvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5jdXN0b20kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIGVncmVzcyBkYXRhIG9mIHRoaXMgY2FsbC5cbiAgICovXG4gIGdldCBlZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzJCk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSBpbmdyZXNzIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgZ2V0IGluZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuaW5ncmVzcyQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgcmVjb3JkaW5nIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICovXG4gIGdldCByZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMucmVjb3JkaW5nJCk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSBzZXNzaW9uIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgZ2V0IHNlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2Vzc2lvbiQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcHJvdmlkZSB0aGUgc2V0dGluZ3Mgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgZ2V0IHNldHRpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnNldHRpbmdzJCk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBwcm92aWRlIHRoZSB0cmFuc2NyaWJpbmcgc3RhdGUgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgZ2V0IHRyYW5zY3JpYmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy50cmFuc2NyaWJpbmckKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIHVzZXIgd2hvIGVuZGVkIHRoaXMgY2FsbC5cbiAgICovXG4gIGdldCBlbmRlZEJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmVuZGVkQnkkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRodW1ibmFpbHMgb2YgdGhpcyBjYWxsLCBpZiBlbmFibGVkIGluIHRoZSBjYWxsIHNldHRpbmdzLlxuICAgKi9cbiAgZ2V0IHRodW1ibmFpbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMudGh1bWJuYWlscyQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgdHJ5IHRvIGZpbmQgdGhlIHBhcnRpY2lwYW50IHdpdGggdGhlIGdpdmVuIHNlc3Npb25JZCBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uSWQgb2YgdGhlIHBhcnRpY2lwYW50IHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHRoZSBwYXJ0aWNpcGFudCB3aXRoIHRoZSBnaXZlbiBzZXNzaW9uSWQgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGZpbmRQYXJ0aWNpcGFudEJ5U2Vzc2lvbklkID0gKFxuICAgIHNlc3Npb25JZDogc3RyaW5nLFxuICApOiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50IHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0aWNpcGFudHMuZmluZCgocCkgPT4gcC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgbG9va3VwIHRhYmxlIG9mIHBhcnRpY2lwYW50cyBpbmRleGVkIGJ5IHRoZWlyIHNlc3Npb24gSUQuXG4gICAqL1xuICBnZXRQYXJ0aWNpcGFudExvb2t1cEJ5U2Vzc2lvbklkID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5yZWR1Y2U8e1xuICAgICAgW3Nlc3Npb25JZDogc3RyaW5nXTogU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCB8IHVuZGVmaW5lZDtcbiAgICB9PigobG9va3VwVGFibGUsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICBsb29rdXBUYWJsZVtwYXJ0aWNpcGFudC5zZXNzaW9uSWRdID0gcGFydGljaXBhbnQ7XG4gICAgICByZXR1cm4gbG9va3VwVGFibGU7XG4gICAgfSwge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgcGFydGljaXBhbnQgaW4gdGhlIGN1cnJlbnQgY2FsbCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBgc2Vzc2lvbklkYC5cbiAgICogSWYgdGhlIHBhcnRpY2lwYW50IGNhbid0IGJlIGZvdW5kLCB0aGlzIG9wZXJhdGlvbiBpcyBuby1vcC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gSUQgb2YgdGhlIHBhcnRpY2lwYW50IHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHBhdGNoIHRoZSBwYXRjaCB0byBhcHBseSB0byB0aGUgcGFydGljaXBhbnQuXG4gICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIHBhcnRpY2lwYW50IG9yIGB1bmRlZmluZWRgIGlmIHRoZSBwYXJ0aWNpcGFudCBjb3VsZG4ndCBiZSBmb3VuZC5cbiAgICovXG4gIHVwZGF0ZVBhcnRpY2lwYW50ID0gKFxuICAgIHNlc3Npb25JZDogc3RyaW5nLFxuICAgIHBhdGNoOlxuICAgICAgfCBTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2hcbiAgICAgIHwgKChwOiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50KSA9PiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2gpLFxuICApID0+IHtcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQoc2Vzc2lvbklkKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBQYXJ0aWNpcGFudCB3aXRoIHNlc3Npb25JZCAke3Nlc3Npb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGhlUGF0Y2ggPSB0eXBlb2YgcGF0Y2ggPT09ICdmdW5jdGlvbicgPyBwYXRjaChwYXJ0aWNpcGFudCkgOiBwYXRjaDtcbiAgICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnQ6IFN0cmVhbVZpZGVvUGFydGljaXBhbnQgPSB7XG4gICAgICAvLyBGSVhNRSBPTDogdGhpcyBpcyBub3QgYSBkZWVwIG1lcmdlLCB3ZSBtaWdodCB3YW50IHRvIHJldmlzaXQgdGhpc1xuICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAuLi50aGVQYXRjaCxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PlxuICAgICAgcGFydGljaXBhbnRzLm1hcCgocCkgPT5cbiAgICAgICAgcC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCA/IHVwZGF0ZWRQYXJ0aWNpcGFudCA6IHAsXG4gICAgICApLFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBwYXJ0aWNpcGFudCBpbiB0aGUgY3VycmVudCBjYWxsIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIGBzZXNzaW9uSWRgLlxuICAgKiBJZiBhIHBhcnRpY2lwYW50IHdpdGggbWF0Y2hpbmcgYHNlc3Npb25JZGAgY2FuJ3QgYmUgZm91bmQsIHRoZSBwcm92aWRlZFxuICAgKiBgcGFydGljaXBhbnRgIGlzIGFkZGVkIHRvIHRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cbiAgICpcbiAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBJRCBvZiB0aGUgcGFydGljaXBhbnQgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gcGFydGljaXBhbnQgdGhlIHBhcnRpY2lwYW50IHRvIHVwZGF0ZSBvciBhZGQuXG4gICAqL1xuICB1cGRhdGVPckFkZFBhcnRpY2lwYW50ID0gKFxuICAgIHNlc3Npb25JZDogc3RyaW5nLFxuICAgIHBhcnRpY2lwYW50OiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50LFxuICApID0+IHtcbiAgICBpZiAoIXRoaXMuZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQoc2Vzc2lvbklkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+IFtcbiAgICAgICAgLi4ucGFydGljaXBhbnRzLFxuICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT5cbiAgICAgIHBhcnRpY2lwYW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgaWYgKHAuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KSxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbCB3aG9zZSBzZXNzaW9uIElEIGlzIGluIHRoZSBnaXZlbiBgc2Vzc2lvbklkc2AuXG4gICAqIElmIG5vIHBhdGNoZXMgYXJlIHByb3ZpZGVkLCB0aGlzIG9wZXJhdGlvbiBpcyBuby1vcC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBwYXJhbSBwYXRjaCB0aGUgcGF0Y2ggdG8gYXBwbHkgdG8gdGhlIHBhcnRpY2lwYW50cy5cbiAgICogQHJldHVybnMgYWxsIHBhcnRpY2lwYW50cywgd2l0aCBhbGwgcGF0Y2ggYXBwbGllZC5cbiAgICovXG4gIHVwZGF0ZVBhcnRpY2lwYW50cyA9IChwYXRjaDogU3RyZWFtVmlkZW9QYXJ0aWNpcGFudFBhdGNoZXMpID0+IHtcbiAgICBpZiAoT2JqZWN0LmtleXMocGF0Y2gpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PlxuICAgICAgcGFydGljaXBhbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICBjb25zdCB0aGVQYXRjaCA9IHBhdGNoW3Auc2Vzc2lvbklkXTtcbiAgICAgICAgaWYgKHRoZVBhdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgICAuLi50aGVQYXRjaCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSksXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2FsbCBzdGF0ZSB3aXRoIHRoZSBkYXRhIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCB0aGUgdmlkZW8gZXZlbnQgdGhhdCBvdXIgYmFja2VuZCBzZW50IHVzLlxuICAgKi9cbiAgdXBkYXRlRnJvbUV2ZW50ID0gKGV2ZW50OiBXU0V2ZW50KSA9PiB7XG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy5ldmVudEhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHVwZGF0ZShldmVudCBhcyBhbnkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGFydGljaXBhbnQgcGlubmVkIHN0YXRlIHdpdGggc2VydmVyIHNpZGUgcGlubmluZyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gcGlucyB0aGUgbGF0ZXN0IHBpbnMgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgc2V0U2VydmVyU2lkZVBpbnMgPSAocGluczogUGluW10pID0+IHtcbiAgICBjb25zdCBwaW5zTG9va3VwID0gcGlucy5yZWR1Y2U8eyBbc2Vzc2lvbklkOiBzdHJpbmddOiBudW1iZXIgfCB1bmRlZmluZWQgfT4oXG4gICAgICAobG9va3VwLCBwaW4pID0+IHtcbiAgICAgICAgbG9va3VwW3Bpbi5zZXNzaW9uSWRdID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICAgIH0sXG4gICAgICB7fSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+XG4gICAgICBwYXJ0aWNpcGFudHMubWFwKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBjb25zdCBzZXJ2ZXJTaWRlUGlubmVkQXQgPSBwaW5zTG9va3VwW3BhcnRpY2lwYW50LnNlc3Npb25JZF07XG4gICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudCBpcyBuZXdseSBwaW5uZWRcbiAgICAgICAgaWYgKHNlcnZlclNpZGVQaW5uZWRBdCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgIHBpbjoge1xuICAgICAgICAgICAgICBpc0xvY2FsUGluOiBmYWxzZSxcbiAgICAgICAgICAgICAgcGlubmVkQXQ6IHNlcnZlclNpZGVQaW5uZWRBdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgcGFydGljaXBhbnQgaXMgbm8gbG9uZ2VyIHBpbm5lZCBzZXJ2ZXIgc2lkZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBwaW5cbiAgICAgICAgaWYgKHBhcnRpY2lwYW50LnBpbiAmJiAhcGFydGljaXBhbnQucGluLmlzTG9jYWxQaW4pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICBwaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIGNoYW5nZXMgdG8gYmUgYXBwbGllZFxuICAgICAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gICAgICB9KSxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYWxsIHN0YXRlIHdpdGggdGhlIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgdXBkYXRlRnJvbUNhbGxSZXNwb25zZSA9IChjYWxsOiBDYWxsUmVzcG9uc2UpID0+IHtcbiAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmJhY2tzdGFnZVN1YmplY3QsIGNhbGwuYmFja3N0YWdlKTtcbiAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmJsb2NrZWRVc2VySWRzU3ViamVjdCwgY2FsbC5ibG9ja2VkX3VzZXJfaWRzKTtcbiAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmNyZWF0ZWRBdFN1YmplY3QsIG5ldyBEYXRlKGNhbGwuY3JlYXRlZF9hdCkpO1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMudXBkYXRlZEF0U3ViamVjdCwgbmV3IERhdGUoY2FsbC51cGRhdGVkX2F0KSk7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUoXG4gICAgICB0aGlzLnN0YXJ0c0F0U3ViamVjdCxcbiAgICAgIGNhbGwuc3RhcnRzX2F0ID8gbmV3IERhdGUoY2FsbC5zdGFydHNfYXQpIDogdW5kZWZpbmVkLFxuICAgICk7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUoXG4gICAgICB0aGlzLmVuZGVkQXRTdWJqZWN0LFxuICAgICAgY2FsbC5lbmRlZF9hdCA/IG5ldyBEYXRlKGNhbGwuZW5kZWRfYXQpIDogdW5kZWZpbmVkLFxuICAgICk7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jcmVhdGVkQnlTdWJqZWN0LCBjYWxsLmNyZWF0ZWRfYnkpO1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY3VzdG9tU3ViamVjdCwgY2FsbC5jdXN0b20pO1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgY2FsbC5lZ3Jlc3MpO1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuaW5ncmVzc1N1YmplY3QsIGNhbGwuaW5ncmVzcyk7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmdTdWJqZWN0LCBjYWxsLnJlY29yZGluZyk7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXNzaW9uU3ViamVjdCwgY2FsbC5zZXNzaW9uKTtcbiAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNldHRpbmdzU3ViamVjdCwgY2FsbC5zZXR0aW5ncyk7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy50cmFuc2NyaWJpbmdTdWJqZWN0LCBjYWxsLnRyYW5zY3JpYmluZyk7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy50aHVtYm5haWxzU3ViamVjdCwgY2FsbC50aHVtYm5haWxzKTtcbiAgfTtcblxuICBwcml2YXRlIHVwZGF0ZUZyb21NZW1iZXJSZW1vdmVkID0gKGV2ZW50OiBDYWxsTWVtYmVyUmVtb3ZlZEV2ZW50KSA9PiB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZW1iZXJzU3ViamVjdCwgKG1lbWJlcnMpID0+XG4gICAgICBtZW1iZXJzLmZpbHRlcigobSkgPT4gZXZlbnQubWVtYmVycy5pbmRleE9mKG0udXNlcl9pZCkgPT09IC0xKSxcbiAgICApO1xuICB9O1xuXG4gIHByaXZhdGUgdXBkYXRlRnJvbU1lbWJlckFkZGVkID0gKGV2ZW50OiBDYWxsTWVtYmVyQWRkZWRFdmVudCkgPT4ge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVyc1N1YmplY3QsIChtZW1iZXJzKSA9PiBbXG4gICAgICAuLi5tZW1iZXJzLFxuICAgICAgLi4uZXZlbnQubWVtYmVycyxcbiAgICBdKTtcbiAgfTtcblxuICBwcml2YXRlIHVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdG9wcGVkID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgKGVncmVzcyA9IGRlZmF1bHRFZ3Jlc3MpID0+ICh7XG4gICAgICAuLi5lZ3Jlc3MsXG4gICAgICBicm9hZGNhc3Rpbmc6IGZhbHNlLFxuICAgIH0pKTtcbiAgfTtcblxuICBwcml2YXRlIHVwZGF0ZUZyb21ITFNCcm9hZGNhc3RpbmdGYWlsZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3NTdWJqZWN0LCAoZWdyZXNzID0gZGVmYXVsdEVncmVzcykgPT4gKHtcbiAgICAgIC4uLmVncmVzcyxcbiAgICAgIGJyb2FkY2FzdGluZzogZmFsc2UsXG4gICAgfSkpO1xuICB9O1xuXG4gIHByaXZhdGUgdXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0YXJ0ZWQgPSAoXG4gICAgZXZlbnQ6IENhbGxITFNCcm9hZGNhc3RpbmdTdGFydGVkRXZlbnQsXG4gICkgPT4ge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgKGVncmVzcyA9IGRlZmF1bHRFZ3Jlc3MpID0+ICh7XG4gICAgICAuLi5lZ3Jlc3MsXG4gICAgICBicm9hZGNhc3Rpbmc6IHRydWUsXG4gICAgICBobHM6IHtcbiAgICAgICAgLi4uZWdyZXNzLmhscyxcbiAgICAgICAgcGxheWxpc3RfdXJsOiBldmVudC5obHNfcGxheWxpc3RfdXJsLFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH07XG5cbiAgcHJpdmF0ZSB1cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50TGVmdCA9IChcbiAgICBldmVudDogQ2FsbFNlc3Npb25QYXJ0aWNpcGFudExlZnRFdmVudCxcbiAgKSA9PiB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXNzaW9uU3ViamVjdCwgKHNlc3Npb24pID0+IHtcbiAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAnd2FybicsXG4gICAgICAgICAgYFJlY2VpdmVkIGNhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9sZWZ0IGV2ZW50IGJ1dCBubyBzZXNzaW9uIGlzIGF2YWlsYWJsZS5gLFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcGFydGljaXBhbnRzLCBwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZSB9ID0gc2Vzc2lvbjtcbiAgICAgIGNvbnN0IHsgdXNlciwgdXNlcl9zZXNzaW9uX2lkIH0gPSBldmVudC5wYXJ0aWNpcGFudDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNlc3Npb24sXG4gICAgICAgIHBhcnRpY2lwYW50czogcGFydGljaXBhbnRzLmZpbHRlcihcbiAgICAgICAgICAocCkgPT4gcC51c2VyX3Nlc3Npb25faWQgIT09IHVzZXJfc2Vzc2lvbl9pZCxcbiAgICAgICAgKSxcbiAgICAgICAgcGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGU6IHtcbiAgICAgICAgICAuLi5wYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZSxcbiAgICAgICAgICBbdXNlci5yb2xlXTogTWF0aC5tYXgoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgKHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlW3VzZXIucm9sZV0gfHwgMCkgLSAxLFxuICAgICAgICAgICksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgdXBkYXRlRnJvbVNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZCA9IChcbiAgICBldmVudDogQ2FsbFNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZEV2ZW50LFxuICApID0+IHtcbiAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNlc3Npb25TdWJqZWN0LCAoc2Vzc2lvbikgPT4ge1xuICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICd3YXJuJyxcbiAgICAgICAgICBgUmVjZWl2ZWQgY2FsbC5zZXNzaW9uX3BhcnRpY2lwYW50X2pvaW5lZCBldmVudCBidXQgbm8gc2Vzc2lvbiBpcyBhdmFpbGFibGUuYCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICB9XG4gICAgICBjb25zdCB7IHBhcnRpY2lwYW50cywgcGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUgfSA9IHNlc3Npb247XG4gICAgICBjb25zdCB7IHVzZXIsIHVzZXJfc2Vzc2lvbl9pZCB9ID0gZXZlbnQucGFydGljaXBhbnQ7XG4gICAgICAvLyBJdCBjb3VsZCBoYXBwZW4gdGhhdCB0aGUgYmFja2VuZCBkZWxpdmVycyB0aGUgc2FtZSBwYXJ0aWNpcGFudCBtb3JlIHRoYW4gb25jZS5cbiAgICAgIC8vIE9uY2Ugd2l0aCB0aGUgY2FsbC5zZXNzaW9uX3N0YXJ0ZWQgZXZlbnQgYW5kIG9uY2UgYWdhaW4gd2l0aCB0aGVcbiAgICAgIC8vIGNhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9qb2luZWQgZXZlbnQuIEluIHRoaXMgY2FzZSxcbiAgICAgIC8vIHdlIHNob3VsZCB1cGRhdGUgdGhlIGV4aXN0aW5nIHBhcnRpY2lwYW50IGFuZCBwcmV2ZW50IGR1cGxpY2F0aW5nIGl0LlxuICAgICAgbGV0IHNob3VsZEluc2VydFBhcnRpY2lwYW50ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRQYXJ0aWNpcGFudHMgPSBwYXJ0aWNpcGFudHMubWFwKChwKSA9PiB7XG4gICAgICAgIGlmIChwLnVzZXJfc2Vzc2lvbl9pZCA9PT0gdXNlcl9zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgc2hvdWxkSW5zZXJ0UGFydGljaXBhbnQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQucGFydGljaXBhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG91bGRJbnNlcnRQYXJ0aWNpcGFudCkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IGFycmF5LCB3ZSBjYW4gc2FmZWx5IHB1c2ggdGhlIG5ldyBwYXJ0aWNpcGFudFxuICAgICAgICB1cGRhdGVkUGFydGljaXBhbnRzLnB1c2goZXZlbnQucGFydGljaXBhbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBhcmUgdXBkYXRpbmcgYW4gZXhpc3RpbmcgcGFydGljaXBhbnQsIHdlIGRvbid0IHdhbnQgdG8gaW5jcmVtZW50XG4gICAgICAvLyB0aGUgcGFydGljaXBhbnRfYnlfcm9sZSBjb3VudC5cbiAgICAgIGNvbnN0IGluY3JlbWVudCA9IHNob3VsZEluc2VydFBhcnRpY2lwYW50ID8gMSA6IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICBwYXJ0aWNpcGFudHM6IHVwZGF0ZWRQYXJ0aWNpcGFudHMsXG4gICAgICAgIHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlOiB7XG4gICAgICAgICAgLi4ucGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUsXG4gICAgICAgICAgW3VzZXIucm9sZV06IChwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZVt1c2VyLnJvbGVdIHx8IDApICsgaW5jcmVtZW50LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICBwcml2YXRlIHVwZGF0ZU1lbWJlcnMgPSAoXG4gICAgZXZlbnQ6IENhbGxNZW1iZXJVcGRhdGVkRXZlbnQgfCBDYWxsTWVtYmVyVXBkYXRlZFBlcm1pc3Npb25FdmVudCxcbiAgKSA9PiB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZW1iZXJzU3ViamVjdCwgKG1lbWJlcnMpID0+XG4gICAgICBtZW1iZXJzLm1hcCgobWVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lbWJlclVwZGF0ZSA9IGV2ZW50Lm1lbWJlcnMuZmluZChcbiAgICAgICAgICAobSkgPT4gbS51c2VyX2lkID09PSBtZW1iZXIudXNlcl9pZCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1lbWJlclVwZGF0ZSA/IG1lbWJlclVwZGF0ZSA6IG1lbWJlcjtcbiAgICAgIH0pLFxuICAgICk7XG4gIH07XG5cbiAgcHJpdmF0ZSB1cGRhdGVQYXJ0aWNpcGFudFJlYWN0aW9uID0gKGV2ZW50OiBDYWxsUmVhY3Rpb25FdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgdXNlciwgY3VzdG9tLCB0eXBlLCBlbW9qaV9jb2RlIH0gPSBldmVudC5yZWFjdGlvbjtcbiAgICB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiB7XG4gICAgICByZXR1cm4gcGFydGljaXBhbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICAvLyBza2lwIGlmIHRoZSByZWFjdGlvbiBpcyBub3QgZm9yIHRoaXMgcGFydGljaXBhbnRcbiAgICAgICAgaWYgKHAudXNlcklkICE9PSB1c2VyLmlkKSByZXR1cm4gcDtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwYXJ0aWNpcGFudCB3aXRoIHRoZSBuZXcgcmVhY3Rpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5wLFxuICAgICAgICAgIHJlYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZW1vamlfY29kZSxcbiAgICAgICAgICAgIGN1c3RvbSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSB1bmJsb2NrVXNlciA9IChldmVudDogVW5ibG9ja2VkVXNlckV2ZW50KSA9PiB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QsIChjdXJyZW50KSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnQpIHJldHVybiBjdXJyZW50O1xuICAgICAgcmV0dXJuIGN1cnJlbnQuZmlsdGVyKChpZCkgPT4gaWQgIT09IGV2ZW50LnVzZXIuaWQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgYmxvY2tVc2VyID0gKGV2ZW50OiBCbG9ja2VkVXNlckV2ZW50KSA9PiB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QsIChjdXJyZW50KSA9PiBbXG4gICAgICAuLi4oY3VycmVudCB8fCBbXSksXG4gICAgICBldmVudC51c2VyLmlkLFxuICAgIF0pO1xuICB9O1xuXG4gIHByaXZhdGUgdXBkYXRlT3duQ2FwYWJpbGl0aWVzID0gKGV2ZW50OiBVcGRhdGVkQ2FsbFBlcm1pc3Npb25zRXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQudXNlci5pZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50Py51c2VySWQpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMub3duQ2FwYWJpbGl0aWVzU3ViamVjdCwgZXZlbnQub3duX2NhcGFiaWxpdGllcyk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgdHlwZSB7IFBhdGNoIH0gZnJvbSAnLi9yeFV0aWxzJztcbmltcG9ydCAqIGFzIFJ4VXRpbHMgZnJvbSAnLi9yeFV0aWxzJztcbmltcG9ydCB7IENhbGwgfSBmcm9tICcuLi9DYWxsJztcbmltcG9ydCB7IENhbGxpbmdTdGF0ZSB9IGZyb20gJy4vQ2FsbFN0YXRlJztcbmltcG9ydCB0eXBlIHsgT3duVXNlclJlc3BvbnNlIH0gZnJvbSAnLi4vZ2VuL2Nvb3JkaW5hdG9yJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5cbmV4cG9ydCBjbGFzcyBTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUge1xuICAvKipcbiAgICogQSBzdG9yZSBrZWVwaW5nIGRhdGEgb2YgYSBzdWNjZXNzZnVsbHkgY29ubmVjdGVkIHVzZXIgb3ZlciBXUyB0byB0aGUgY29vcmRpbmF0b3Igc2VydmVyLlxuICAgKi9cbiAgY29ubmVjdGVkVXNlclN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE93blVzZXJSZXNwb25zZSB8IHVuZGVmaW5lZD4oXG4gICAgdW5kZWZpbmVkLFxuICApO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgKi9cbiAgY2FsbHNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDYWxsW10+KFtdKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbm5lY3RlZFVzZXJTdWJqZWN0LnN1YnNjcmliZShhc3luYyAodXNlcikgPT4ge1xuICAgICAgLy8gbGVhdmUgYWxsIGNhbGxzIHdoZW4gdGhlIHVzZXIgZGlzY29ubmVjdHMuXG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnY2xpZW50LXN0YXRlJ10pO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy5jYWxscykge1xuICAgICAgICAgIGlmIChjYWxsLnN0YXRlLmNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkxFRlQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgbG9nZ2VyKCdpbmZvJywgYFVzZXIgZGlzY29ubmVjdGVkLCBsZWF2aW5nIGNhbGw6ICR7Y2FsbC5jaWR9YCk7XG4gICAgICAgICAgYXdhaXQgY2FsbFxuICAgICAgICAgICAgLmxlYXZlKHsgcmVhc29uOiAnY2xpZW50LmRpc2Nvbm5lY3RVc2VyKCkgY2FsbGVkJyB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsIGBFcnJvciBsZWF2aW5nIGNhbGw6ICR7Y2FsbC5jaWR9YCwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBvYnNlcnZhYmxlLCBvciB1bmRlZmluZWQgaWYgdGhlIG9ic2VydmFibGUgaGFzXG4gICAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICAgKlxuICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSQgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRDdXJyZW50VmFsdWUgPSBSeFV0aWxzLmdldEN1cnJlbnRWYWx1ZTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIFN1YmplY3QuXG4gICAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICAgKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gICAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAqL1xuICBwcml2YXRlIHNldEN1cnJlbnRWYWx1ZSA9IFJ4VXRpbHMuc2V0Q3VycmVudFZhbHVlO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IGNvbm5lY3RlZCB1c2VyLlxuICAgKi9cbiAgZ2V0IGNvbm5lY3RlZFVzZXIoKTogT3duVXNlclJlc3BvbnNlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5jb25uZWN0ZWRVc2VyU3ViamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCB1c2VyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHVzZXIgdGhlIHVzZXIgdG8gc2V0IGFzIGNvbm5lY3RlZC5cbiAgICovXG4gIHNldENvbm5lY3RlZFVzZXIgPSAodXNlcjogUGF0Y2g8T3duVXNlclJlc3BvbnNlIHwgdW5kZWZpbmVkPikgPT4ge1xuICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmNvbm5lY3RlZFVzZXJTdWJqZWN0LCB1c2VyKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICovXG4gIGdldCBjYWxscygpOiBDYWxsW10ge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNhbGxzU3ViamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAqIEBwYXJhbSBjYWxsc1xuICAgKi9cbiAgc2V0Q2FsbHMgPSAoY2FsbHM6IFBhdGNoPENhbGxbXT4pID0+IHtcbiAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsc1N1YmplY3QsIGNhbGxzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIHtAbGluayBDYWxsfSBvYmplY3QgdG8gdGhlIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbCB0aGUgY2FsbCB0byBhZGQuXG4gICAqL1xuICByZWdpc3RlckNhbGwgPSAoY2FsbDogQ2FsbCkgPT4ge1xuICAgIGlmICghdGhpcy5jYWxscy5maW5kKChjKSA9PiBjLmNpZCA9PT0gY2FsbC5jaWQpKSB7XG4gICAgICB0aGlzLnNldENhbGxzKChjYWxscykgPT4gWy4uLmNhbGxzLCBjYWxsXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEge0BsaW5rIENhbGx9IG9iamVjdCBmcm9tIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gcmVtb3ZlXG4gICAqL1xuICB1bnJlZ2lzdGVyQ2FsbCA9IChjYWxsOiBDYWxsKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Q2FsbHMoKGNhbGxzKSA9PiBjYWxscy5maWx0ZXIoKGMpID0+IGMgIT09IGNhbGwpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYSB7QGxpbmsgQ2FsbH0gb2JqZWN0IGluIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgY2FsbCB0byBmaW5kLlxuICAgKiBAcGFyYW0gaWQgdGhlIGlkIG9mIHRoZSBjYWxsIHRvIGZpbmQuXG4gICAqL1xuICBmaW5kQ2FsbCA9ICh0eXBlOiBzdHJpbmcsIGlkOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jYWxscy5maW5kKChjKSA9PiBjLnR5cGUgPT09IHR5cGUgJiYgYy5pZCA9PT0gaWQpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgcmVhY3RpdmUgc3RvcmUgdGhhdCBleHBvc2VzIHN0YXRlIHZhcmlhYmxlcyBpbiBhIHJlYWN0aXZlIG1hbm5lci5cbiAqIFlvdSBjYW4gc3Vic2NyaWJlIHRvIGNoYW5nZXMgb2YgdGhlIGRpZmZlcmVudCBzdGF0ZSB2YXJpYWJsZXMuXG4gKiBUaGlzIGNlbnRyYWwgc3RvcmUgY29udGFpbnMgYWxsIHRoZSBzdGF0ZSB2YXJpYWJsZXMgcmVsYXRlZCB0byBbYFN0cmVhbVZpZGVvQ2xpZW50YF0oLi9TdHJlYW1WaWRlQ2xpZW50Lm1kKSBhbmQgW2BDYWxsYF0oLi9DYWxsLm1kKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbVZpZGVvUmVhZE9ubHlTdGF0ZVN0b3JlIHtcbiAgLyoqXG4gICAqIERhdGEgZGVzY3JpYmluZyBhIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCBvdmVyIFdTIHRvIGNvb3JkaW5hdG9yIHNlcnZlci5cbiAgICovXG4gIGNvbm5lY3RlZFVzZXIkOiBPYnNlcnZhYmxlPE93blVzZXJSZXNwb25zZSB8IHVuZGVmaW5lZD47XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAqL1xuICBjYWxscyQ6IE9ic2VydmFibGU8Q2FsbFtdPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0aGUgZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgc3RhdGUgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSBvYnNlcnZhYmxlIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZi5cbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG9ic2VydmFibGUuXG4gICAqL1xuICBnZXRDdXJyZW50VmFsdWUgPSBSeFV0aWxzLmdldEN1cnJlbnRWYWx1ZTtcblxuICBjb25zdHJ1Y3RvcihzdG9yZTogU3RyZWFtVmlkZW9Xcml0ZWFibGVTdGF0ZVN0b3JlKSB7XG4gICAgLy8gY29udmVydCBhbmQgZXhwb3NlIHN1YmplY3RzIGFzIG9ic2VydmFibGVzXG4gICAgdGhpcy5jb25uZWN0ZWRVc2VyJCA9IHN0b3JlLmNvbm5lY3RlZFVzZXJTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuY2FsbHMkID0gc3RvcmUuY2FsbHNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHVzZXIgY29ubmVjdGVkIG92ZXIgV1MgdG8gdGhlIGJhY2tlbmQuXG4gICAqL1xuICBnZXQgY29ubmVjdGVkVXNlcigpOiBPd25Vc2VyUmVzcG9uc2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBSeFV0aWxzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNvbm5lY3RlZFVzZXIkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgKi9cbiAgZ2V0IGNhbGxzKCk6IENhbGxbXSB7XG4gICAgcmV0dXJuIFJ4VXRpbHMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbHMkKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgU0RQIGZyb20gJ3NkcC10cmFuc2Zvcm0nO1xuXG50eXBlIE1lZGlhID0ge1xuICBvcmlnaW5hbDogc3RyaW5nO1xuICBtZWRpYVdpdGhQb3J0czogc3RyaW5nO1xuICBjb2RlY09yZGVyOiBzdHJpbmc7XG59O1xuXG50eXBlIFJ0cE1hcCA9IHtcbiAgb3JpZ2luYWw6IHN0cmluZztcbiAgcGF5bG9hZDogc3RyaW5nO1xuICBjb2RlYzogc3RyaW5nO1xufTtcblxudHlwZSBGbXRwID0ge1xuICBvcmlnaW5hbDogc3RyaW5nO1xuICBwYXlsb2FkOiBzdHJpbmc7XG4gIGNvbmZpZzogc3RyaW5nO1xufTtcblxuY29uc3QgZ2V0UnRwTWFwID0gKGxpbmU6IHN0cmluZyk6IFJ0cE1hcCB8IHVuZGVmaW5lZCA9PiB7XG4gIC8vIEV4YW1wbGU6IGE9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcbiAgY29uc3QgcnRwUmVnZXggPSAvXmE9cnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vO1xuICAvLyBUaGUgZmlyc3QgY2FwdHVyZWQgZ3JvdXAgaXMgdGhlIHBheWxvYWQgdHlwZSBudW1iZXIsIHRoZSBzZWNvbmQgY2FwdHVyZWQgZ3JvdXAgaXMgdGhlIGVuY29kaW5nIG5hbWUsIHRoZSB0aGlyZCBjYXB0dXJlZCBncm91cCBpcyB0aGUgY2xvY2sgcmF0ZSwgYW5kIHRoZSBmb3VydGggY2FwdHVyZWQgZ3JvdXAgaXMgYW55IGFkZGl0aW9uYWwgcGFyYW1ldGVycy5cbiAgY29uc3QgcnRwTWF0Y2ggPSBydHBSZWdleC5leGVjKGxpbmUpO1xuICBpZiAocnRwTWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ2luYWw6IHJ0cE1hdGNoWzBdLFxuICAgICAgcGF5bG9hZDogcnRwTWF0Y2hbMV0sXG4gICAgICBjb2RlYzogcnRwTWF0Y2hbMl0sXG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgZ2V0Rm10cCA9IChsaW5lOiBzdHJpbmcpOiBGbXRwIHwgdW5kZWZpbmVkID0+IHtcbiAgLy8gRXhhbXBsZTogYT1mbXRwOjExMSBtaW5wdGltZT0xMDsgdXNlaW5iYW5kZmVjPTFcbiAgY29uc3QgZm10cFJlZ2V4ID0gL15hPWZtdHA6KFxcZCopICguKikvO1xuICBjb25zdCBmbXRwTWF0Y2ggPSBmbXRwUmVnZXguZXhlYyhsaW5lKTtcbiAgLy8gVGhlIGZpcnN0IGNhcHR1cmVkIGdyb3VwIGlzIHRoZSBwYXlsb2FkIHR5cGUgbnVtYmVyLCB0aGUgc2Vjb25kIGNhcHR1cmVkIGdyb3VwIGlzIGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuXG4gIGlmIChmbXRwTWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ2luYWw6IGZtdHBNYXRjaFswXSxcbiAgICAgIHBheWxvYWQ6IGZtdHBNYXRjaFsxXSxcbiAgICAgIGNvbmZpZzogZm10cE1hdGNoWzJdLFxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0cyB0aGUgbWVkaWEgc2VjdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBtZWRpYSB0eXBlLlxuICogVGhlIG1lZGlhIHNlY3Rpb24gY29udGFpbnMgdGhlIG1lZGlhIHR5cGUsIHBvcnQsIGNvZGVjLCBhbmQgcGF5bG9hZCB0eXBlLlxuICogRXhhbXBsZTogbT12aWRlbyA5IFVEUC9UTFMvUlRQL1NBVlBGIDEwMCAxMDEgOTYgOTcgMzUgMzYgMTAyIDEyNSAxMjdcbiAqL1xuY29uc3QgZ2V0TWVkaWEgPSAobGluZTogc3RyaW5nLCBtZWRpYVR5cGU6IHN0cmluZyk6IE1lZGlhIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAobT0ke21lZGlhVHlwZX0gXFxcXGQrIFtcXFxcdy9dKykgKFtcXFxcZFxcXFxzXSspYCk7XG4gIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhsaW5lKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9yaWdpbmFsOiBtYXRjaFswXSxcbiAgICAgIG1lZGlhV2l0aFBvcnRzOiBtYXRjaFsxXSxcbiAgICAgIGNvZGVjT3JkZXI6IG1hdGNoWzJdLFxuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGdldE1lZGlhU2VjdGlvbiA9IChzZHA6IHN0cmluZywgbWVkaWFUeXBlOiAndmlkZW8nIHwgJ2F1ZGlvJykgPT4ge1xuICBsZXQgbWVkaWE6IE1lZGlhIHwgdW5kZWZpbmVkO1xuICBjb25zdCBydHBNYXA6IFJ0cE1hcFtdID0gW107XG4gIGNvbnN0IGZtdHA6IEZtdHBbXSA9IFtdO1xuICBsZXQgaXNUaGVSZXF1aXJlZE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgY29uc3QgaXNWYWxpZExpbmUgPSAvXihbYS16XSk9KC4qKS8udGVzdChsaW5lKTtcbiAgICBpZiAoIWlzVmFsaWRMaW5lKSByZXR1cm47XG4gICAgLypcbiAgICAgIE5PVEU6IGFjY29yZGluZyB0byBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjODg2Ni5wZGZcbiAgICAgIEVhY2ggbWVkaWEgZGVzY3JpcHRpb24gc3RhcnRzIHdpdGggYW4gXCJtPVwiIGxpbmUgYW5kIGNvbnRpbnVlcyB0byB0aGUgbmV4dCBtZWRpYSBkZXNjcmlwdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB3aG9sZSBzZXNzaW9uIGRlc2NyaXB0aW9uLCB3aGljaGV2ZXIgY29tZXMgZmlyc3RcbiAgICAqL1xuICAgIGNvbnN0IHR5cGUgPSBsaW5lWzBdO1xuICAgIGlmICh0eXBlID09PSAnbScpIHtcbiAgICAgIGNvbnN0IF9tZWRpYSA9IGdldE1lZGlhKGxpbmUsIG1lZGlhVHlwZSk7XG4gICAgICBpc1RoZVJlcXVpcmVkTWVkaWFTZWN0aW9uID0gISFfbWVkaWE7XG4gICAgICBpZiAoX21lZGlhKSB7XG4gICAgICAgIG1lZGlhID0gX21lZGlhO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUaGVSZXF1aXJlZE1lZGlhU2VjdGlvbiAmJiB0eXBlID09PSAnYScpIHtcbiAgICAgIGNvbnN0IHJ0cE1hcExpbmUgPSBnZXRSdHBNYXAobGluZSk7XG4gICAgICBjb25zdCBmbXRwTGluZSA9IGdldEZtdHAobGluZSk7XG4gICAgICBpZiAocnRwTWFwTGluZSkge1xuICAgICAgICBydHBNYXAucHVzaChydHBNYXBMaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAoZm10cExpbmUpIHtcbiAgICAgICAgZm10cC5wdXNoKGZtdHBMaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAobWVkaWEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWEsXG4gICAgICBydHBNYXAsXG4gICAgICBmbXRwLFxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyBvZiBjb2RlYyBJRHMgd2l0aCB0aGUgcHJlZmVycmVkIGNvZGVjIElEIGluIGZyb250IG9mIHRoZSBvdGhlciBjb2RlYyBJRHMuXG4gKiBJdCBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGEgcHJlZmVycmVkIGNvZGVjIGlzIHVzZWQgd2hlbiBkZWNvZGluZyBhIG1lZGlhIHN0cmVhbS5cbiAqIEV4YW1wbGU6IFN1cHBvc2Ugd2Ugd2FudCB0byBwcmVmZXIgVlA4IHdoaWNoIGhhcyBpZCA5NlxuICogMS4gSWYgY29kZWMgb3JkZXIgaXMgMTAwIDEwMSA5NiA5NyAzNSAzNiAxMDIgMTI1IDEyN1xuICogMi4gVGhlIGZ1bmN0aW9uIHJldHVybnMgOTYgMTAwIDEwMSA5NyAzNSAzNiAxMDIgMTI1IDEyN1xuICovXG5jb25zdCBtb3ZlQ29kZWNUb0Zyb250ID0gKGNvZGVjT3JkZXI6IHN0cmluZywgcHJlZmVycmVkQ29kZWNJZDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNvZGVjSWRzID0gY29kZWNPcmRlci5zcGxpdCgnICcpO1xuICBjb25zdCBpbmRleCA9IGNvZGVjSWRzLmluZGV4T2YocHJlZmVycmVkQ29kZWNJZCk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgY29kZWNJZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBjb2RlY0lkcy51bnNoaWZ0KHByZWZlcnJlZENvZGVjSWQpO1xuICB9XG4gIHJldHVybiBjb2RlY0lkcy5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgb2YgY29kZWMgSURzIHdpdGggdGhlIGdpdmVuIGNvZGVjIElEIHJlbW92ZWRcbiAqIEl0IGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYSBjb2RlYyBpcyBkaXNhYmxlZCB3aGVuIHByb2Nlc3NpbmcgYSBtZWRpYSBzdHJlYW0uXG4gKiBFeGFtcGxlOiBTdXBwb3NlIHdlIHdhbnQgdG8gcHJlZmVyIFJFRCB3aGljaCBoYXMgaWQgNjNcbiAqIDEuIElmIGNvZGVjIG9yZGVyIGlzIDExMSA2MyAxMDMgMTA0IDkgMTAyIDAgOCAxMDYgMTA1IDEzIDExMCAxMTIgMTEzIDEyNlxuICogMi4gVGhlIGZ1bmN0aW9uIHJldHVybnMgMTExIDEwMyAxMDQgOSAxMDIgMCA4IDEwNiAxMDUgMTMgMTEwIDExMiAxMTMgMTI2XG4gKi9cbmNvbnN0IHJlbW92ZUNvZGVjRnJvbU9yZGVyID0gKGNvZGVjT3JkZXI6IHN0cmluZywgY29kZWNJZFRvUmVtb3ZlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgY29kZWNJZHMgPSBjb2RlY09yZGVyLnNwbGl0KCcgJyk7XG4gIHJldHVybiBjb2RlY0lkcy5maWx0ZXIoKGNvZGVjSUQpID0+IGNvZGVjSUQgIT09IGNvZGVjSWRUb1JlbW92ZSkuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIFNEUCB3aXRoIHRoZSBwcmVmZXJyZWQgY29kZWMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNvZGVjcy5cbiAqIEV4YW1wbGU6IFN1cHBvc2Ugd2Ugd2FudCB0byBwcmVmZXIgVlA4XG4gKiAxLiBmaW5kIHZpZGVvIG1lZGlhIHNwZWNpZmljYXRpb24gbT12aWRlbyA5IFVEUC9UTFMvUlRQL1NBVlBGIDEwMCAxMDEgOTYgOTcgMzUgMzYgMTAyIDEyNSAxMjdcbiAqIDIuIGxvb2sgZm9yIHNwZWNpZmllZCBjb2RlYyAoVlA4KSAgYT1ydHBtYXA6OTYgVlA4LzkwMDAwXG4gKiAzLiBleHRyYWN0IDk2IGFzIGFuIGlkZW50aWZpZXIgb2YgVlA4XG4gKiA0LiBtb3ZlIDk2IHRvIHRoZSBmcm9udFxuICogNS4gbm93IG1lZGlhIGxvb2tzIGxpa2UgdGhpczogbT12aWRlbyA5IFVEUC9UTFMvUlRQL1NBVlBGIDk2IDEwMCAxMDEgOTcgMzUgMzYgMTAyIDEyNSAxMjdcbiAqL1xuZXhwb3J0IGNvbnN0IHNldFByZWZlcnJlZENvZGVjID0gKFxuICBzZHA6IHN0cmluZyxcbiAgbWVkaWFUeXBlOiAndmlkZW8nIHwgJ2F1ZGlvJyxcbiAgcHJlZmVycmVkQ29kZWM6IHN0cmluZyxcbikgPT4ge1xuICBjb25zdCBzZWN0aW9uID0gZ2V0TWVkaWFTZWN0aW9uKHNkcCwgbWVkaWFUeXBlKTtcbiAgaWYgKCFzZWN0aW9uKSByZXR1cm4gc2RwO1xuICBjb25zdCBydHBNYXAgPSBzZWN0aW9uLnJ0cE1hcC5maW5kKFxuICAgIChyKSA9PiByLmNvZGVjLnRvTG93ZXJDYXNlKCkgPT09IHByZWZlcnJlZENvZGVjLnRvTG93ZXJDYXNlKCksXG4gICk7XG4gIGNvbnN0IGNvZGVjSWQgPSBydHBNYXA/LnBheWxvYWQ7XG4gIGlmICghY29kZWNJZCkgcmV0dXJuIHNkcDtcbiAgY29uc3QgbmV3Q29kZWNPcmRlciA9IG1vdmVDb2RlY1RvRnJvbnQoc2VjdGlvbi5tZWRpYS5jb2RlY09yZGVyLCBjb2RlY0lkKTtcbiAgcmV0dXJuIHNkcC5yZXBsYWNlKFxuICAgIHNlY3Rpb24ubWVkaWEub3JpZ2luYWwsXG4gICAgYCR7c2VjdGlvbi5tZWRpYS5tZWRpYVdpdGhQb3J0c30gJHtuZXdDb2RlY09yZGVyfWAsXG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gU0RQIHdpdGggdGhlIHNwZWNpZmllZCBjb2RlYyByZW1vdmVkLlxuICogRXhhbXBsZTogU3VwcG9zZSB3ZSB3YW50IHRvIHJlbW92ZSBSRURcbiAqICAxLiBmaW5kIGF1ZGlvIG1lZGlhIHNwZWNpZmljYXRpb24gbT12aWRlbyA5IFVEUC9UTFMvUlRQL1NBVlBGIDEwMCAxMDEgOTYgOTcgMzUgMzYgMTAyIDEyNSAxMjdcbiAqICAyLiBsb29rIGZvciBzcGVjaWZpZWQgY29kZWMgKFJFRCkgIGE9cnRwbWFwOjEyNyByZWQvOTAwMDBcbiAqICAzLiBleHRyYWN0IDEyNyBhcyBhbiBpZGVudGlmaWVyIG9mIFJFRFxuICogIDQuIHJlbW92ZSAxMjcgZnJvbSB0aGUgY29kZWMgb3JkZXJcbiAqICA1LiByZW1vdmUgYT1ydHBtYXA6MTI3IHJlZC85MDAwMFxuICogIDYuIHJlbW92ZSBhPWZtdHA6MTI3IC4uLlxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQ29kZWMgPSAoXG4gIHNkcDogc3RyaW5nLFxuICBtZWRpYVR5cGU6ICd2aWRlbycgfCAnYXVkaW8nLFxuICBjb2RlY1RvUmVtb3ZlOiBzdHJpbmcsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBzZWN0aW9uID0gZ2V0TWVkaWFTZWN0aW9uKHNkcCwgbWVkaWFUeXBlKTtcbiAgY29uc3QgbWVkaWFTZWN0aW9uID0gc2VjdGlvbj8ubWVkaWE7XG4gIGlmICghbWVkaWFTZWN0aW9uKSB7XG4gICAgcmV0dXJuIHNkcDtcbiAgfVxuICBjb25zdCBydHBNYXAgPSBzZWN0aW9uPy5ydHBNYXAuZmluZChcbiAgICAocikgPT4gci5jb2RlYy50b0xvd2VyQ2FzZSgpID09PSBjb2RlY1RvUmVtb3ZlLnRvTG93ZXJDYXNlKCksXG4gICk7XG4gIGNvbnN0IGNvZGVjSWQgPSBydHBNYXA/LnBheWxvYWQ7XG4gIGlmICghY29kZWNJZCkge1xuICAgIHJldHVybiBzZHA7XG4gIH1cbiAgY29uc3QgbmV3Q29kZWNPcmRlciA9IHJlbW92ZUNvZGVjRnJvbU9yZGVyKG1lZGlhU2VjdGlvbi5jb2RlY09yZGVyLCBjb2RlY0lkKTtcbiAgY29uc3QgZm10cCA9IHNlY3Rpb24/LmZtdHAuZmluZCgoZikgPT4gZi5wYXlsb2FkID09PSBjb2RlY0lkKTtcbiAgcmV0dXJuIHNkcFxuICAgIC5yZXBsYWNlKFxuICAgICAgbWVkaWFTZWN0aW9uLm9yaWdpbmFsLFxuICAgICAgYCR7bWVkaWFTZWN0aW9uLm1lZGlhV2l0aFBvcnRzfSAke25ld0NvZGVjT3JkZXJ9YCxcbiAgICApXG4gICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtydHBNYXAub3JpZ2luYWx9W1xcclxcbl0rYCksICcnKSAvLyByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgcnRwbWFwIGxpbmVcbiAgICAucmVwbGFjZShmbXRwPy5vcmlnaW5hbCA/IG5ldyBSZWdFeHAoYCR7Zm10cD8ub3JpZ2luYWx9W1xcclxcbl0rYCkgOiAnJywgJycpOyAvLyByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgZm10cCBsaW5lXG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGZtdHAgbGluZSBjb3JyZXNwb25kaW5nIHRvIG9wdXNcbiAqL1xuY29uc3QgZ2V0T3B1c0ZtdHAgPSAoc2RwOiBzdHJpbmcpOiBGbXRwIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3Qgc2VjdGlvbiA9IGdldE1lZGlhU2VjdGlvbihzZHAsICdhdWRpbycpO1xuICBjb25zdCBydHBNYXAgPSBzZWN0aW9uPy5ydHBNYXAuZmluZCgocikgPT4gci5jb2RlYy50b0xvd2VyQ2FzZSgpID09PSAnb3B1cycpO1xuICBjb25zdCBjb2RlY0lkID0gcnRwTWFwPy5wYXlsb2FkO1xuICBpZiAoY29kZWNJZCkge1xuICAgIHJldHVybiBzZWN0aW9uPy5mbXRwLmZpbmQoKGYpID0+IGYucGF5bG9hZCA9PT0gY29kZWNJZCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBTRFAgd2l0aCBEVFggZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUR0eCA9IChzZHA6IHN0cmluZywgZW5hYmxlOiBib29sZWFuKTogc3RyaW5nID0+IHtcbiAgY29uc3Qgb3B1c0ZtdHAgPSBnZXRPcHVzRm10cChzZHApO1xuICBpZiAob3B1c0ZtdHApIHtcbiAgICBjb25zdCBtYXRjaER0eCA9IC91c2VkdHg9KFxcZCkvLmV4ZWMob3B1c0ZtdHAuY29uZmlnKTtcbiAgICBjb25zdCByZXF1aXJlZER0eENvbmZpZyA9IGB1c2VkdHg9JHtlbmFibGUgPyAnMScgOiAnMCd9YDtcbiAgICBpZiAobWF0Y2hEdHgpIHtcbiAgICAgIGNvbnN0IG5ld0ZtdHAgPSBvcHVzRm10cC5vcmlnaW5hbC5yZXBsYWNlKFxuICAgICAgICAvdXNlZHR4PShcXGQpLyxcbiAgICAgICAgcmVxdWlyZWREdHhDb25maWcsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNkcC5yZXBsYWNlKG9wdXNGbXRwLm9yaWdpbmFsLCBuZXdGbXRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV3Rm10cCA9IGAke29wdXNGbXRwLm9yaWdpbmFsfTske3JlcXVpcmVkRHR4Q29uZmlnfWA7XG4gICAgICByZXR1cm4gc2RwLnJlcGxhY2Uob3B1c0ZtdHAub3JpZ2luYWwsIG5ld0ZtdHApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIGhpZ2gtcXVhbGl0eSBhdWRpbyB0aHJvdWdoIFNEUCBtdW5naW5nIGZvciB0aGUgZ2l2ZW4gdHJhY2tNaWQuXG4gKlxuICogQHBhcmFtIHNkcCB0aGUgU0RQIHRvIG11bmdlLlxuICogQHBhcmFtIHRyYWNrTWlkIHRoZSB0cmFja01pZC5cbiAqIEBwYXJhbSBtYXhCaXRyYXRlIHRoZSBtYXggYml0cmF0ZSB0byBzZXQuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVIaWdoUXVhbGl0eUF1ZGlvID0gKFxuICBzZHA6IHN0cmluZyxcbiAgdHJhY2tNaWQ6IHN0cmluZyxcbiAgbWF4Qml0cmF0ZTogbnVtYmVyID0gNTEwMDAwLFxuKTogc3RyaW5nID0+IHtcbiAgbWF4Qml0cmF0ZSA9IE1hdGgubWF4KE1hdGgubWluKG1heEJpdHJhdGUsIDUxMDAwMCksIDk2MDAwKTtcblxuICBjb25zdCBwYXJzZWRTZHAgPSBTRFAucGFyc2Uoc2RwKTtcbiAgY29uc3QgYXVkaW9NZWRpYSA9IHBhcnNlZFNkcC5tZWRpYS5maW5kKFxuICAgIChtKSA9PiBtLnR5cGUgPT09ICdhdWRpbycgJiYgU3RyaW5nKG0ubWlkKSA9PT0gdHJhY2tNaWQsXG4gICk7XG5cbiAgaWYgKCFhdWRpb01lZGlhKSByZXR1cm4gc2RwO1xuXG4gIGNvbnN0IG9wdXNSdHAgPSBhdWRpb01lZGlhLnJ0cC5maW5kKChyKSA9PiByLmNvZGVjID09PSAnb3B1cycpO1xuICBpZiAoIW9wdXNSdHApIHJldHVybiBzZHA7XG5cbiAgY29uc3Qgb3B1c0ZtdHAgPSBhdWRpb01lZGlhLmZtdHAuZmluZCgoZikgPT4gZi5wYXlsb2FkID09PSBvcHVzUnRwLnBheWxvYWQpO1xuICBpZiAoIW9wdXNGbXRwKSByZXR1cm4gc2RwO1xuXG4gIC8vIGVuYWJsZSBzdGVyZW8sIGlmIG5vdCBhbHJlYWR5IGVuYWJsZWRcbiAgaWYgKG9wdXNGbXRwLmNvbmZpZy5tYXRjaCgvc3RlcmVvPShcXGQpLykpIHtcbiAgICBvcHVzRm10cC5jb25maWcgPSBvcHVzRm10cC5jb25maWcucmVwbGFjZSgvc3RlcmVvPShcXGQpLywgJ3N0ZXJlbz0xJyk7XG4gIH0gZWxzZSB7XG4gICAgb3B1c0ZtdHAuY29uZmlnID0gYCR7b3B1c0ZtdHAuY29uZmlnfTtzdGVyZW89MWA7XG4gIH1cblxuICAvLyBzZXQgbWF4YXZlcmFnZWJpdHJhdGUsIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICBpZiAob3B1c0ZtdHAuY29uZmlnLm1hdGNoKC9tYXhhdmVyYWdlYml0cmF0ZT0oXFxkKikvKSkge1xuICAgIG9wdXNGbXRwLmNvbmZpZyA9IG9wdXNGbXRwLmNvbmZpZy5yZXBsYWNlKFxuICAgICAgL21heGF2ZXJhZ2ViaXRyYXRlPShcXGQqKS8sXG4gICAgICBgbWF4YXZlcmFnZWJpdHJhdGU9JHttYXhCaXRyYXRlfWAsXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBvcHVzRm10cC5jb25maWcgPSBgJHtvcHVzRm10cC5jb25maWd9O21heGF2ZXJhZ2ViaXRyYXRlPSR7bWF4Qml0cmF0ZX1gO1xuICB9XG5cbiAgcmV0dXJuIFNEUC53cml0ZShwYXJzZWRTZHApO1xufTtcbiIsImltcG9ydCAqIGFzIFNEUCBmcm9tICdzZHAtdHJhbnNmb3JtJztcbmltcG9ydCB7IFN0cmVhbVNmdUNsaWVudCB9IGZyb20gJy4uL1N0cmVhbVNmdUNsaWVudCc7XG5pbXBvcnQge1xuICBQZWVyVHlwZSxcbiAgVHJhY2tJbmZvLFxuICBUcmFja1R5cGUsXG4gIFZpZGVvTGF5ZXIsXG4gIFZpZGVvUXVhbGl0eSxcbn0gZnJvbSAnLi4vZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzJztcbmltcG9ydCB7IGdldEljZUNhbmRpZGF0ZSB9IGZyb20gJy4vaGVscGVycy9pY2VDYW5kaWRhdGUnO1xuaW1wb3J0IHtcbiAgZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzLFxuICBmaW5kT3B0aW1hbFZpZGVvTGF5ZXJzLFxuICBPcHRpbWFsVmlkZW9MYXllcixcbn0gZnJvbSAnLi92aWRlb0xheWVycyc7XG5pbXBvcnQgeyBnZXRQcmVmZXJyZWRDb2RlY3MgfSBmcm9tICcuL2NvZGVjcyc7XG5pbXBvcnQgeyB0cmFja1R5cGVUb1BhcnRpY2lwYW50U3RyZWFtS2V5IH0gZnJvbSAnLi9oZWxwZXJzL3RyYWNrcyc7XG5pbXBvcnQgeyBDYWxsaW5nU3RhdGUsIENhbGxTdGF0ZSB9IGZyb20gJy4uL3N0b3JlJztcbmltcG9ydCB7IFB1Ymxpc2hPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNSZWFjdE5hdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvcGxhdGZvcm1zJztcbmltcG9ydCB7IGVuYWJsZUhpZ2hRdWFsaXR5QXVkaW8sIHRvZ2dsZUR0eCB9IGZyb20gJy4uL2hlbHBlcnMvc2RwLW11bmdpbmcnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vY29vcmRpbmF0b3IvY29ubmVjdGlvbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgRGlzcGF0Y2hlciB9IGZyb20gJy4vRGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBnZXRPU0luZm8gfSBmcm9tICcuLi9jbGllbnQtZGV0YWlscyc7XG5pbXBvcnQgeyBWaWRlb0xheWVyU2V0dGluZyB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvZXZlbnQvZXZlbnRzJztcblxuY29uc3QgbG9nZ2VyOiBMb2dnZXIgPSBnZXRMb2dnZXIoWydQdWJsaXNoZXInXSk7XG5cbmV4cG9ydCB0eXBlIFB1Ymxpc2hlckNvbnN0cnVjdG9yT3B0cyA9IHtcbiAgc2Z1Q2xpZW50OiBTdHJlYW1TZnVDbGllbnQ7XG4gIHN0YXRlOiBDYWxsU3RhdGU7XG4gIGRpc3BhdGNoZXI6IERpc3BhdGNoZXI7XG4gIGNvbm5lY3Rpb25Db25maWc/OiBSVENDb25maWd1cmF0aW9uO1xuICBpc0R0eEVuYWJsZWQ6IGJvb2xlYW47XG4gIGlzUmVkRW5hYmxlZDogYm9vbGVhbjtcbiAgaWNlUmVzdGFydERlbGF5PzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBUaGUgYFB1Ymxpc2hlcmAgaXMgcmVzcG9uc2libGUgZm9yIHB1Ymxpc2hpbmcvdW5wdWJsaXNoaW5nIG1lZGlhIHN0cmVhbXMgdG8vZnJvbSB0aGUgU0ZVXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFB1Ymxpc2hlciB7XG4gIHByaXZhdGUgcGM6IFJUQ1BlZXJDb25uZWN0aW9uO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YXRlOiBDYWxsU3RhdGU7XG5cbiAgcHJpdmF0ZSByZWFkb25seSB0cmFuc2NlaXZlclJlZ2lzdHJ5OiB7XG4gICAgW2tleSBpbiBUcmFja1R5cGVdOiBSVENSdHBUcmFuc2NlaXZlciB8IHVuZGVmaW5lZDtcbiAgfSA9IHtcbiAgICBbVHJhY2tUeXBlLkFVRElPXTogdW5kZWZpbmVkLFxuICAgIFtUcmFja1R5cGUuVklERU9dOiB1bmRlZmluZWQsXG4gICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVdOiB1bmRlZmluZWQsXG4gICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU9dOiB1bmRlZmluZWQsXG4gICAgW1RyYWNrVHlwZS5VTlNQRUNJRklFRF06IHVuZGVmaW5lZCxcbiAgfTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHB1Ymxpc2hPcHRpb25zUGVyVHJhY2tUeXBlID0gbmV3IE1hcDxcbiAgICBUcmFja1R5cGUsXG4gICAgUHVibGlzaE9wdGlvbnNcbiAgPigpO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBtYWludGFpbmluZyB0aGUgb3JkZXIgaG93IHRyYW5zY2VpdmVycyB3ZXJlIGFkZGVkIHRvIHRoZSBwZWVyIGNvbm5lY3Rpb24uXG4gICAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugc29tZSBicm93c2VycyAoRmlyZWZveCkgZG9uJ3QgcmVsaWFibHkgcmVwb3J0XG4gICAqIHRyYWNrSWQgYW5kIGBtaWRgIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHRyYW5zY2VpdmVySW5pdE9yZGVyOiBUcmFja1R5cGVbXSA9IFtdO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgdHJhY2tLaW5kTWFwcGluZzoge1xuICAgIFtrZXkgaW4gVHJhY2tUeXBlXTogJ3ZpZGVvJyB8ICdhdWRpbycgfCB1bmRlZmluZWQ7XG4gIH0gPSB7XG4gICAgW1RyYWNrVHlwZS5BVURJT106ICdhdWRpbycsXG4gICAgW1RyYWNrVHlwZS5WSURFT106ICd2aWRlbycsXG4gICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVdOiAndmlkZW8nLFxuICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPXTogJ2F1ZGlvJyxcbiAgICBbVHJhY2tUeXBlLlVOU1BFQ0lGSUVEXTogdW5kZWZpbmVkLFxuICB9O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgdHJhY2tMYXllcnNDYWNoZToge1xuICAgIFtrZXkgaW4gVHJhY2tUeXBlXTogT3B0aW1hbFZpZGVvTGF5ZXJbXSB8IHVuZGVmaW5lZDtcbiAgfSA9IHtcbiAgICBbVHJhY2tUeXBlLkFVRElPXTogdW5kZWZpbmVkLFxuICAgIFtUcmFja1R5cGUuVklERU9dOiB1bmRlZmluZWQsXG4gICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVdOiB1bmRlZmluZWQsXG4gICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU9dOiB1bmRlZmluZWQsXG4gICAgW1RyYWNrVHlwZS5VTlNQRUNJRklFRF06IHVuZGVmaW5lZCxcbiAgfTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGlzRHR4RW5hYmxlZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBpc1JlZEVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSByZWFkb25seSB1bnN1YnNjcmliZU9uSWNlUmVzdGFydDogKCkgPT4gdm9pZDtcblxuICBwcml2YXRlIHJlYWRvbmx5IGljZVJlc3RhcnREZWxheTogbnVtYmVyO1xuICBwcml2YXRlIGlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICBwcml2YXRlIGljZVJlc3RhcnRUaW1lb3V0PzogTm9kZUpTLlRpbWVvdXQ7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgdGhlIGxhY2sgb2YgUlRDUGVlckNvbm5lY3Rpb24uZ2V0Q29uZmlndXJhdGlvbigpIG1ldGhvZCBpbiByZWFjdC1uYXRpdmUtd2VicnRjXG4gIHByaXZhdGUgX2Nvbm5lY3Rpb25Db25maWd1cmF0aW9uOiBSVENDb25maWd1cmF0aW9uIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbikgcmV0dXJuIHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgU0ZVIGNsaWVudCBpbnN0YW5jZSB0byB1c2UgZm9yIHB1Ymxpc2hpbmcgYW5kIHNpZ25hbGluZy5cbiAgICovXG4gIHNmdUNsaWVudDogU3RyZWFtU2Z1Q2xpZW50O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBQdWJsaXNoZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZyB0aGUgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHNmdUNsaWVudCB0aGUgU0ZVIGNsaWVudCB0byB1c2UuXG4gICAqIEBwYXJhbSBzdGF0ZSB0aGUgY2FsbCBzdGF0ZSB0byB1c2UuXG4gICAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBkaXNwYXRjaGVyIHRvIHVzZS5cbiAgICogQHBhcmFtIGlzRHR4RW5hYmxlZCB3aGV0aGVyIERUWCBpcyBlbmFibGVkLlxuICAgKiBAcGFyYW0gaXNSZWRFbmFibGVkIHdoZXRoZXIgUkVEIGlzIGVuYWJsZWQuXG4gICAqIEBwYXJhbSBpY2VSZXN0YXJ0RGVsYXkgdGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXN0YXJ0aW5nIElDRSBvbmNlIGNvbm5lY3Rpb24gZ29lcyB0byBgZGlzY29ubmVjdGVkYCBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgIHNmdUNsaWVudCxcbiAgICBkaXNwYXRjaGVyLFxuICAgIHN0YXRlLFxuICAgIGlzRHR4RW5hYmxlZCxcbiAgICBpc1JlZEVuYWJsZWQsXG4gICAgaWNlUmVzdGFydERlbGF5ID0gMjUwMCxcbiAgfTogUHVibGlzaGVyQ29uc3RydWN0b3JPcHRzKSB7XG4gICAgdGhpcy5wYyA9IHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuaXNEdHhFbmFibGVkID0gaXNEdHhFbmFibGVkO1xuICAgIHRoaXMuaXNSZWRFbmFibGVkID0gaXNSZWRFbmFibGVkO1xuICAgIHRoaXMuaWNlUmVzdGFydERlbGF5ID0gaWNlUmVzdGFydERlbGF5O1xuXG4gICAgdGhpcy51bnN1YnNjcmliZU9uSWNlUmVzdGFydCA9IGRpc3BhdGNoZXIub24oXG4gICAgICAnaWNlUmVzdGFydCcsXG4gICAgICBhc3luYyAoaWNlUmVzdGFydCkgPT4ge1xuICAgICAgICBpZiAoaWNlUmVzdGFydC5wZWVyVHlwZSAhPT0gUGVlclR5cGUuUFVCTElTSEVSX1VOU1BFQ0lGSUVEKSByZXR1cm47XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydEljZSgpO1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQZWVyQ29ubmVjdGlvbiA9IChjb25uZWN0aW9uQ29uZmlnPzogUlRDQ29uZmlndXJhdGlvbikgPT4ge1xuICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25Db25maWd1cmF0aW9uID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCB0aGlzLm9uSWNlQ2FuZGlkYXRlKTtcbiAgICBwYy5hZGRFdmVudExpc3RlbmVyKCduZWdvdGlhdGlvbm5lZWRlZCcsIHRoaXMub25OZWdvdGlhdGlvbk5lZWRlZCk7XG5cbiAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGVlcnJvcicsIHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcik7XG4gICAgcGMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLFxuICAgICAgdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSxcbiAgICApO1xuICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLFxuICAgICAgdGhpcy5vbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlLFxuICAgICk7XG4gICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignc2lnbmFsaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLm9uU2lnbmFsaW5nU3RhdGVDaGFuZ2UpO1xuICAgIHJldHVybiBwYztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBwdWJsaXNoZXIgUGVlckNvbm5lY3Rpb24gYW5kIGNsZWFucyB1cCB0aGUgcmVzb3VyY2VzLlxuICAgKi9cbiAgY2xvc2UgPSAoeyBzdG9wVHJhY2tzID0gdHJ1ZSB9ID0ge30pID0+IHtcbiAgICBpZiAoc3RvcFRyYWNrcykge1xuICAgICAgdGhpcy5zdG9wUHVibGlzaGluZygpO1xuICAgICAgT2JqZWN0LmtleXModGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5KS5mb3JFYWNoKCh0cmFja1R5cGUpID0+IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmtleXModGhpcy50cmFja0xheWVyc0NhY2hlKS5mb3JFYWNoKCh0cmFja1R5cGUpID0+IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnRyYWNrTGF5ZXJzQ2FjaGVbdHJhY2tUeXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmljZVJlc3RhcnRUaW1lb3V0KTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlT25JY2VSZXN0YXJ0KCk7XG4gICAgdGhpcy5wYy5yZW1vdmVFdmVudExpc3RlbmVyKCduZWdvdGlhdGlvbm5lZWRlZCcsIHRoaXMub25OZWdvdGlhdGlvbk5lZWRlZCk7XG4gICAgdGhpcy5wYy5jbG9zZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gdHJhY2sgb2YgdGhlIGdpdmVuIG1lZGlhIHN0cmVhbS5cbiAgICpcbiAgICogQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXBsYWNlIHRoZSBzdHJlYW0uXG4gICAqIFRoZSBwcmV2aW91cyBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFTdHJlYW0gdGhlIG1lZGlhIHN0cmVhbSB0byBwdWJsaXNoLlxuICAgKiBAcGFyYW0gdHJhY2sgdGhlIHRyYWNrIHRvIHB1Ymxpc2guXG4gICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gcHVibGlzaC5cbiAgICogQHBhcmFtIG9wdHMgdGhlIG9wdGlvbmFsIHB1Ymxpc2ggb3B0aW9ucyB0byB1c2UuXG4gICAqL1xuICBwdWJsaXNoU3RyZWFtID0gYXN5bmMgKFxuICAgIG1lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgICB0cmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICB0cmFja1R5cGU6IFRyYWNrVHlwZSxcbiAgICBvcHRzOiBQdWJsaXNoT3B0aW9ucyA9IHt9LFxuICApID0+IHtcbiAgICBpZiAodHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBwdWJsaXNoIGEgdHJhY2sgdGhhdCBoYXMgZW5kZWQgYWxyZWFkeS5gKTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNjZWl2ZXIgPSB0aGlzLnBjXG4gICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgIC5maW5kKFxuICAgICAgICAodCkgPT5cbiAgICAgICAgICB0ID09PSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSAmJlxuICAgICAgICAgIHQuc2VuZGVyLnRyYWNrICYmXG4gICAgICAgICAgdC5zZW5kZXIudHJhY2s/LmtpbmQgPT09IHRoaXMudHJhY2tLaW5kTWFwcGluZ1t0cmFja1R5cGVdLFxuICAgICAgKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGhhbmRsZXIgd2hpY2ggbGlzdGVucyBmb3IgdGhlICdlbmRlZCcgZXZlbnQgb24gdGhlIHRyYWNrLlxuICAgICAqIE9uY2UgdGhlIHRyYWNrIGhhcyBlbmRlZCwgaXQgd2lsbCBub3RpZnkgdGhlIFNGVSBhbmQgdXBkYXRlIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBjb25zdCBoYW5kbGVUcmFja0VuZGVkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICAnaW5mbycsXG4gICAgICAgIGBUcmFjayAke1RyYWNrVHlwZVt0cmFja1R5cGVdfSBoYXMgZW5kZWQsIG5vdGlmeWluZyB0aGUgU0ZVYCxcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZChtZWRpYVN0cmVhbSwgdHJhY2tUeXBlLCB0cnVlKTtcbiAgICAgIC8vIGNsZWFuLXVwLCB0aGlzIGV2ZW50IGxpc3RlbmVyIG5lZWRzIHRvIHJ1biBvbmx5IG9uY2UuXG4gICAgICB0cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH07XG5cbiAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICBjb25zdCB7IHNldHRpbmdzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHNldHRpbmdzPy52aWRlby50YXJnZXRfcmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHZpZGVvRW5jb2RpbmdzID1cbiAgICAgICAgdHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU9cbiAgICAgICAgICA/IGZpbmRPcHRpbWFsVmlkZW9MYXllcnModHJhY2ssIHRhcmdldFJlc29sdXRpb24pXG4gICAgICAgICAgOiB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVcbiAgICAgICAgICA/IGZpbmRPcHRpbWFsU2NyZWVuU2hhcmluZ0xheWVycyh0cmFjaywgb3B0cy5zY3JlZW5TaGFyZVNldHRpbmdzKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBsZXQgcHJlZmVycmVkQ29kZWMgPSBvcHRzLnByZWZlcnJlZENvZGVjO1xuICAgICAgaWYgKCFwcmVmZXJyZWRDb2RlYyAmJiB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTykge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgY29uc3Qgb3NOYW1lID0gZ2V0T1NJbmZvKCk/Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAob3NOYW1lID09PSAnaXBhZG9zJykge1xuICAgICAgICAgICAgLy8gaW4gaXBhZHMgaXQgd2FzIG5vdGljZWQgdGhhdCBpZiB2cDggY29kZWMgaXMgdXNlZFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgYnl0ZXMgc2VudCBpcyAwIGluIHRoZSBvdXRib3VuZC1ydHBcbiAgICAgICAgICAgIC8vIHNvIHdlIGFyZSBmb3JjaW5nIGgyNjQgY29kZWMgZm9yIGlwYWRzXG4gICAgICAgICAgICBwcmVmZXJyZWRDb2RlYyA9ICdIMjY0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9zTmFtZSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICAgICAgICBwcmVmZXJyZWRDb2RlYyA9ICdWUDgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29kZWNQcmVmZXJlbmNlcyA9IHRoaXMuZ2V0Q29kZWNQcmVmZXJlbmNlcyhcbiAgICAgICAgdHJhY2tUeXBlLFxuICAgICAgICBwcmVmZXJyZWRDb2RlYyxcbiAgICAgICk7XG5cbiAgICAgIC8vIGxpc3RlbiBmb3IgJ2VuZGVkJyBldmVudCBvbiB0aGUgdHJhY2sgYXMgaXQgbWlnaHQgYmUgZW5kZWQgYWJydXB0bHlcbiAgICAgIC8vIGJ5IGFuIGV4dGVybmFsIGZhY3RvciBhcyBwZXJtaXNzaW9uIHJldm9rZXMsIGRldmljZSBkaXNjb25uZWN0ZWQsIGV0Yy5cbiAgICAgIC8vIGtlZXAgaW4gbWluZCB0aGF0IGB0cmFjay5zdG9wKClgIGRvZXNuJ3QgdHJpZ2dlciB0aGlzIGV2ZW50LlxuICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIGlmICghdHJhY2suZW5hYmxlZCkge1xuICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNjZWl2ZXIgPSB0aGlzLnBjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgc3RyZWFtczpcbiAgICAgICAgICB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTyB8fCB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVcbiAgICAgICAgICAgID8gW21lZGlhU3RyZWFtXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIHNlbmRFbmNvZGluZ3M6IHZpZGVvRW5jb2RpbmdzLFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ2dlcignZGVidWcnLCBgQWRkZWQgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gdHJhbnNjZWl2ZXJgKTtcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJJbml0T3JkZXIucHVzaCh0cmFja1R5cGUpO1xuICAgICAgdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W3RyYWNrVHlwZV0gPSB0cmFuc2NlaXZlcjtcbiAgICAgIHRoaXMucHVibGlzaE9wdGlvbnNQZXJUcmFja1R5cGUuc2V0KHRyYWNrVHlwZSwgb3B0cyk7XG5cbiAgICAgIGlmICgnc2V0Q29kZWNQcmVmZXJlbmNlcycgaW4gdHJhbnNjZWl2ZXIgJiYgY29kZWNQcmVmZXJlbmNlcykge1xuICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgIGBTZXR0aW5nICR7VHJhY2tUeXBlW3RyYWNrVHlwZV19IGNvZGVjIHByZWZlcmVuY2VzYCxcbiAgICAgICAgICBjb2RlY1ByZWZlcmVuY2VzLFxuICAgICAgICApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNldENvZGVjUHJlZmVyZW5jZXMoY29kZWNQcmVmZXJlbmNlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlcignd2FybicsIGBDb3VsZG4ndCBzZXQgY29kZWMgcHJlZmVyZW5jZXNgLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVHJhY2sgPSB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2s7XG4gICAgICAvLyBkb24ndCBzdG9wIHRoZSB0cmFjayBpZiB3ZSBhcmUgcmUtcHVibGlzaGluZyB0aGUgc2FtZSB0cmFja1xuICAgICAgaWYgKHByZXZpb3VzVHJhY2sgJiYgcHJldmlvdXNUcmFjayAhPT0gdHJhY2spIHtcbiAgICAgICAgcHJldmlvdXNUcmFjay5zdG9wKCk7XG4gICAgICAgIHByZXZpb3VzVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suZW5hYmxlZCkge1xuICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMubm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkKG1lZGlhU3RyZWFtLCB0cmFja1R5cGUsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gdHJhY2sgdHlwZSB0byB0aGUgU0ZVLCBpZiBpdCBpcyBjdXJyZW50bHkgYmVpbmcgcHVibGlzaGVkLlxuICAgKiBVbmRlcmx5aW5nIHRyYWNrIHdpbGwgYmUgc3RvcHBlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBwdWJsaXNoZXIuXG4gICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gdW5wdWJsaXNoLlxuICAgKiBAcGFyYW0gc3RvcFRyYWNrIHNwZWNpZmllcyB3aGV0aGVyIHRyYWNrIHNob3VsZCBiZSBzdG9wcGVkIG9yIGp1c3QgZGlzYWJsZWRcbiAgICovXG4gIHVucHVibGlzaFN0cmVhbSA9IGFzeW5jICh0cmFja1R5cGU6IFRyYWNrVHlwZSwgc3RvcFRyYWNrOiBib29sZWFuKSA9PiB7XG4gICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLnBjXG4gICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgIC5maW5kKCh0KSA9PiB0ID09PSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSAmJiB0LnNlbmRlci50cmFjayk7XG4gICAgaWYgKFxuICAgICAgdHJhbnNjZWl2ZXIgJiZcbiAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayAmJlxuICAgICAgKHN0b3BUcmFja1xuICAgICAgICA/IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5yZWFkeVN0YXRlID09PSAnbGl2ZSdcbiAgICAgICAgOiB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2suZW5hYmxlZClcbiAgICApIHtcbiAgICAgIHN0b3BUcmFja1xuICAgICAgICA/IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5zdG9wKClcbiAgICAgICAgOiAodHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmVuYWJsZWQgPSBmYWxzZSk7XG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIG5vdGlmeSBTRlUgaWYgdW5wdWJsaXNoaW5nIGluIHJlc3BvbnNlIHRvIHJlbW90ZSBzb2Z0IG11dGVcbiAgICAgIGlmICh0aGlzLnN0YXRlLmxvY2FsUGFydGljaXBhbnQ/LnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyh0cmFja1R5cGUpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkKHVuZGVmaW5lZCwgdHJhY2tUeXBlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdHJhY2sgdHlwZSBpcyBjdXJyZW50bHkgYmVpbmcgcHVibGlzaGVkIHRvIHRoZSBTRlUuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gY2hlY2suXG4gICAqL1xuICBpc1B1Ymxpc2hpbmcgPSAodHJhY2tUeXBlOiBUcmFja1R5cGUpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCB0cmFuc2NlaXZlckZvclRyYWNrVHlwZSA9IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVt0cmFja1R5cGVdO1xuICAgIGlmICh0cmFuc2NlaXZlckZvclRyYWNrVHlwZSAmJiB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXIpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlLnNlbmRlcjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICEhc2VuZGVyLnRyYWNrICYmXG4gICAgICAgIHNlbmRlci50cmFjay5yZWFkeVN0YXRlID09PSAnbGl2ZScgJiZcbiAgICAgICAgc2VuZGVyLnRyYWNrLmVuYWJsZWRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB0cmFjayB0eXBlIGlzIGN1cnJlbnRseSBsaXZlXG4gICAqXG4gICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gY2hlY2suXG4gICAqL1xuICBpc0xpdmUgPSAodHJhY2tUeXBlOiBUcmFja1R5cGUpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCB0cmFuc2NlaXZlckZvclRyYWNrVHlwZSA9IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVt0cmFja1R5cGVdO1xuICAgIGlmICh0cmFuc2NlaXZlckZvclRyYWNrVHlwZSAmJiB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXIpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlLnNlbmRlcjtcbiAgICAgIHJldHVybiAhIXNlbmRlci50cmFjayAmJiBzZW5kZXIudHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBub3RpZnlUcmFja011dGVTdGF0ZUNoYW5nZWQgPSBhc3luYyAoXG4gICAgbWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrVHlwZTogVHJhY2tUeXBlLFxuICAgIGlzTXV0ZWQ6IGJvb2xlYW4sXG4gICkgPT4ge1xuICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LnVwZGF0ZU11dGVTdGF0ZSh0cmFja1R5cGUsIGlzTXV0ZWQpO1xuXG4gICAgY29uc3QgYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbSA9XG4gICAgICB0cmFja1R5cGVUb1BhcnRpY2lwYW50U3RyZWFtS2V5KHRyYWNrVHlwZSk7XG4gICAgaWYgKGlzTXV0ZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUudXBkYXRlUGFydGljaXBhbnQodGhpcy5zZnVDbGllbnQuc2Vzc2lvbklkLCAocCkgPT4gKHtcbiAgICAgICAgcHVibGlzaGVkVHJhY2tzOiBwLnB1Ymxpc2hlZFRyYWNrcy5maWx0ZXIoKHQpID0+IHQgIT09IHRyYWNrVHlwZSksXG4gICAgICAgIFthdWRpb09yVmlkZW9PclNjcmVlblNoYXJlU3RyZWFtXTogdW5kZWZpbmVkLFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHRoaXMuc2Z1Q2xpZW50LnNlc3Npb25JZCwgKHApID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwdWJsaXNoZWRUcmFja3M6IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKHRyYWNrVHlwZSlcbiAgICAgICAgICAgID8gcC5wdWJsaXNoZWRUcmFja3NcbiAgICAgICAgICAgIDogWy4uLnAucHVibGlzaGVkVHJhY2tzLCB0cmFja1R5cGVdLFxuICAgICAgICAgIFthdWRpb09yVmlkZW9PclNjcmVlblNoYXJlU3RyZWFtXTogbWVkaWFTdHJlYW0sXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3BzIHB1Ymxpc2hpbmcgYWxsIHRyYWNrcyBhbmQgc3RvcCBhbGwgdHJhY2tzLlxuICAgKi9cbiAgc3RvcFB1Ymxpc2hpbmcgPSAoKSA9PiB7XG4gICAgbG9nZ2VyKCdkZWJ1ZycsICdTdG9wcGluZyBwdWJsaXNoaW5nIGFsbCB0cmFja3MnKTtcbiAgICB0aGlzLnBjLmdldFNlbmRlcnMoKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBzLnRyYWNrPy5zdG9wKCk7XG4gICAgICBpZiAodGhpcy5wYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgdGhpcy5wYy5yZW1vdmVUcmFjayhzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB1cGRhdGVWaWRlb1B1Ymxpc2hRdWFsaXR5ID0gYXN5bmMgKGVuYWJsZWRMYXllcnM6IFZpZGVvTGF5ZXJTZXR0aW5nW10pID0+IHtcbiAgICBsb2dnZXIoXG4gICAgICAnaW5mbycsXG4gICAgICAnVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgcmVxdWVzdGVkIGxheWVycyBieSBTRlU6JyxcbiAgICAgIGVuYWJsZWRMYXllcnMsXG4gICAgKTtcblxuICAgIGNvbnN0IHZpZGVvU2VuZGVyID0gdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W1RyYWNrVHlwZS5WSURFT10/LnNlbmRlcjtcbiAgICBpZiAoIXZpZGVvU2VuZGVyKSB7XG4gICAgICBsb2dnZXIoJ3dhcm4nLCAnVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgbm8gdmlkZW8gc2VuZGVyIGZvdW5kLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtcyA9IHZpZGVvU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICBpZiAocGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZ2dlcihcbiAgICAgICAgJ3dhcm4nLFxuICAgICAgICAnVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgTm8gc3VpdGFibGUgdmlkZW8gZW5jb2RpbmcgcXVhbGl0eSBmb3VuZCcsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IGVuYWJsZWRSaWRzID0gZW5hYmxlZExheWVyc1xuICAgICAgLmZpbHRlcigobHkpID0+IGx5LmFjdGl2ZSlcbiAgICAgIC5tYXAoKGx5KSA9PiBseS5uYW1lKTtcbiAgICBwYXJhbXMuZW5jb2RpbmdzLmZvckVhY2goKGVuYykgPT4ge1xuICAgICAgLy8gZmxpcCAnYWN0aXZlJyBmbGFnIG9ubHkgd2hlbiBuZWNlc3NhcnlcbiAgICAgIGNvbnN0IHNob3VsZEVuYWJsZSA9IGVuYWJsZWRSaWRzLmluY2x1ZGVzKGVuYy5yaWQhKTtcbiAgICAgIGlmIChzaG91bGRFbmFibGUgIT09IGVuYy5hY3RpdmUpIHtcbiAgICAgICAgZW5jLmFjdGl2ZSA9IHNob3VsZEVuYWJsZTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkRW5hYmxlKSB7XG4gICAgICAgIGxldCBsYXllciA9IGVuYWJsZWRMYXllcnMuZmluZCgodmxzKSA9PiB2bHMubmFtZSA9PT0gZW5jLnJpZCk7XG4gICAgICAgIGlmIChsYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGF5ZXIuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID49IDEgJiZcbiAgICAgICAgICAgIGxheWVyLnNjYWxlUmVzb2x1dGlvbkRvd25CeSAhPT0gZW5jLnNjYWxlUmVzb2x1dGlvbkRvd25CeVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgICAnZGVidWcnLFxuICAgICAgICAgICAgICAnW2R5bmFzY2FsZV06IHNldHRpbmcgc2NhbGVSZXNvbHV0aW9uRG93bkJ5IGZyb20gc2VydmVyJyxcbiAgICAgICAgICAgICAgJ2xheWVyJyxcbiAgICAgICAgICAgICAgbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICAgJ3NjYWxlLXJlc29sdXRpb24tZG93bi1ieScsXG4gICAgICAgICAgICAgIGxheWVyLnNjYWxlUmVzb2x1dGlvbkRvd25CeSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbmMuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gbGF5ZXIuc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxheWVyLm1heEJpdHJhdGUgPiAwICYmIGxheWVyLm1heEJpdHJhdGUgIT09IGVuYy5tYXhCaXRyYXRlKSB7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICdkZWJ1ZycsXG4gICAgICAgICAgICAgICdbZHluYXNjYWxlXSBzZXR0aW5nIG1heC1iaXRyYXRlIGZyb20gdGhlIHNlcnZlcicsXG4gICAgICAgICAgICAgICdsYXllcicsXG4gICAgICAgICAgICAgIGxheWVyLm5hbWUsXG4gICAgICAgICAgICAgICdtYXgtYml0cmF0ZScsXG4gICAgICAgICAgICAgIGxheWVyLm1heEJpdHJhdGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZW5jLm1heEJpdHJhdGUgPSBsYXllci5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGF5ZXIubWF4RnJhbWVyYXRlID4gMCAmJlxuICAgICAgICAgICAgbGF5ZXIubWF4RnJhbWVyYXRlICE9PSBlbmMubWF4RnJhbWVyYXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICdkZWJ1ZycsXG4gICAgICAgICAgICAgICdbZHluYXNjYWxlXTogc2V0dGluZyBtYXhGcmFtZXJhdGUgZnJvbSBzZXJ2ZXInLFxuICAgICAgICAgICAgICAnbGF5ZXInLFxuICAgICAgICAgICAgICBsYXllci5uYW1lLFxuICAgICAgICAgICAgICAnbWF4LWZyYW1lcmF0ZScsXG4gICAgICAgICAgICAgIGxheWVyLm1heEZyYW1lcmF0ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbmMubWF4RnJhbWVyYXRlID0gbGF5ZXIubWF4RnJhbWVyYXRlO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBhY3RpdmVMYXllcnMgPSBwYXJhbXMuZW5jb2RpbmdzLmZpbHRlcigoZSkgPT4gZS5hY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICBhd2FpdCB2aWRlb1NlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICBsb2dnZXIoJ2luZm8nLCBgVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgZW5hYmxlZCByaWRzOiBgLCBhY3RpdmVMYXllcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIoJ2luZm8nLCBgVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgbm8gY2hhbmdlOiBgLCBhY3RpdmVMYXllcnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBgUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMoKWAgbWV0aG9kXG4gICAqIEBwYXJhbSBzZWxlY3RvclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0U3RhdHMgPSAoc2VsZWN0b3I/OiBNZWRpYVN0cmVhbVRyYWNrIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgfTtcblxuICBwcml2YXRlIGdldENvZGVjUHJlZmVyZW5jZXMgPSAoXG4gICAgdHJhY2tUeXBlOiBUcmFja1R5cGUsXG4gICAgcHJlZmVycmVkQ29kZWM/OiBzdHJpbmcgfCBudWxsLFxuICApID0+IHtcbiAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8pIHtcbiAgICAgIHJldHVybiBnZXRQcmVmZXJyZWRDb2RlY3MoJ3ZpZGVvJywgcHJlZmVycmVkQ29kZWMgfHwgJ3ZwOCcpO1xuICAgIH1cbiAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8pIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRBdWRpb0NvZGVjID0gdGhpcy5pc1JlZEVuYWJsZWQgPyAncmVkJyA6ICdvcHVzJztcbiAgICAgIGNvbnN0IGNvZGVjVG9SZW1vdmUgPSAhdGhpcy5pc1JlZEVuYWJsZWQgPyAncmVkJyA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBnZXRQcmVmZXJyZWRDb2RlY3MoXG4gICAgICAgICdhdWRpbycsXG4gICAgICAgIHByZWZlcnJlZENvZGVjID8/IGRlZmF1bHRBdWRpb0NvZGVjLFxuICAgICAgICBjb2RlY1RvUmVtb3ZlLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkljZUNhbmRpZGF0ZSA9IGFzeW5jIChlOiBSVENQZWVyQ29ubmVjdGlvbkljZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBjYW5kaWRhdGUgfSA9IGU7XG4gICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgIGxvZ2dlcignZGVidWcnLCAnbnVsbCBpY2UgY2FuZGlkYXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LmljZVRyaWNrbGUoe1xuICAgICAgaWNlQ2FuZGlkYXRlOiBnZXRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSxcbiAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5QVUJMSVNIRVJfVU5TUEVDSUZJRUQsXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgKlxuICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICovXG4gIHNldFNmdUNsaWVudCA9IChzZnVDbGllbnQ6IFN0cmVhbVNmdUNsaWVudCkgPT4ge1xuICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIG1pZ3JhdGlvbiBvZiB0aGlzIHB1Ymxpc2hlciBpbnN0YW5jZSB0byBhIG5ldyBTRlUuXG4gICAqXG4gICAqIEluaXRpYXRlcyBhIG5ldyBgaWNlUmVzdGFydGAgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlIHdpdGggdGhlIG5ldyBTRlUuXG4gICAqXG4gICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIG5ldyBTRlUgY2xpZW50IHRvIG1pZ3JhdGUgdG8uXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBuZXcgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICovXG4gIG1pZ3JhdGVUbyA9IGFzeW5jIChcbiAgICBzZnVDbGllbnQ6IFN0cmVhbVNmdUNsaWVudCxcbiAgICBjb25uZWN0aW9uQ29uZmlnPzogUlRDQ29uZmlndXJhdGlvbixcbiAgKSA9PiB7XG4gICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgdGhpcy5wYy5zZXRDb25maWd1cmF0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25Db25maWd1cmF0aW9uID0gY29ubmVjdGlvbkNvbmZpZztcblxuICAgIGNvbnN0IHNob3VsZFJlc3RhcnRJY2UgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG4gICAgaWYgKHNob3VsZFJlc3RhcnRJY2UpIHtcbiAgICAgIC8vIG5lZ290aWF0ZSBvbmx5IGlmIHRoZXJlIGFyZSB0cmFja3MgdG8gcHVibGlzaFxuICAgICAgYXdhaXQgdGhpcy5uZWdvdGlhdGUoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzdGFydHMgdGhlIElDRSBjb25uZWN0aW9uIGFuZCByZW5lZ290aWF0ZXMgd2l0aCB0aGUgU0ZVLlxuICAgKi9cbiAgcmVzdGFydEljZSA9IGFzeW5jICgpID0+IHtcbiAgICBsb2dnZXIoJ2RlYnVnJywgJ1Jlc3RhcnRpbmcgSUNFIGNvbm5lY3Rpb24nKTtcbiAgICBjb25zdCBzaWduYWxpbmdTdGF0ZSA9IHRoaXMucGMuc2lnbmFsaW5nU3RhdGU7XG4gICAgaWYgKHRoaXMuaXNJY2VSZXN0YXJ0aW5nIHx8IHNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgIGxvZ2dlcignZGVidWcnLCAnSUNFIHJlc3RhcnQgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm5lZ290aWF0ZSh7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbk5lZ290aWF0aW9uTmVlZGVkID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHRoaXMubmVnb3RpYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIG5ldyBvZmZlci9hbnN3ZXIgZXhjaGFuZ2Ugd2l0aCB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTRlUuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25hbCBvZmZlciBvcHRpb25zIHRvIHVzZS5cbiAgICovXG4gIHByaXZhdGUgbmVnb3RpYXRlID0gYXN5bmMgKG9wdGlvbnM/OiBSVENPZmZlck9wdGlvbnMpID0+IHtcbiAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IG9wdGlvbnM/LmljZVJlc3RhcnQgPz8gZmFsc2U7XG5cbiAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgbGV0IHNkcCA9IHRoaXMubXVuZ2VDb2RlY3Mob2ZmZXIuc2RwKTtcbiAgICBpZiAoc2RwICYmIHRoaXMuaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pKSB7XG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9XG4gICAgICAgIHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVtUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPXTtcbiAgICAgIGlmICh0cmFuc2NlaXZlciAmJiB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2spIHtcbiAgICAgICAgY29uc3QgbWlkID1cbiAgICAgICAgICB0cmFuc2NlaXZlci5taWQgPz9cbiAgICAgICAgICB0aGlzLmV4dHJhY3RNaWQoXG4gICAgICAgICAgICBzZHAsXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2ssXG4gICAgICAgICAgICBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPLFxuICAgICAgICAgICk7XG4gICAgICAgIHNkcCA9IGVuYWJsZUhpZ2hRdWFsaXR5QXVkaW8oc2RwLCBtaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbXVuZ2VkIFNEUCBiYWNrIHRvIHRoZSBvZmZlclxuICAgIG9mZmVyLnNkcCA9IHNkcDtcblxuICAgIGNvbnN0IHRyYWNrSW5mb3MgPSB0aGlzLmdldEN1cnJlbnRUcmFja0luZm9zKG9mZmVyLnNkcCk7XG4gICAgaWYgKHRyYWNrSW5mb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW4ndCBpbml0aWF0ZSBuZWdvdGlhdGlvbiB3aXRob3V0IGFubm91bmNpbmcgYW55IHRyYWNrc2AsXG4gICAgICApO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cbiAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnNmdUNsaWVudC5zZXRQdWJsaXNoZXIoe1xuICAgICAgc2RwOiBvZmZlci5zZHAgfHwgJycsXG4gICAgICB0cmFja3M6IHRyYWNrSW5mb3MsXG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbih7XG4gICAgICAgIHR5cGU6ICdhbnN3ZXInLFxuICAgICAgICBzZHA6IHJlc3BvbnNlLnNkcCxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcignZXJyb3InLCBgc2V0UmVtb3RlRGVzY3JpcHRpb24gZXJyb3JgLCB7XG4gICAgICAgIHNkcDogcmVzcG9uc2Uuc2RwLFxuICAgICAgICBlcnJvcjogZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlQnVmZmVyLnB1Ymxpc2hlckNhbmRpZGF0ZXMuc3Vic2NyaWJlKFxuICAgICAgYXN5bmMgKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGljZUNhbmRpZGF0ZSA9IEpTT04ucGFyc2UoY2FuZGlkYXRlLmljZUNhbmRpZGF0ZSk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlcignd2FybicsIGBJQ0UgY2FuZGlkYXRlIGVycm9yYCwgW2UsIGNhbmRpZGF0ZV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICk7XG4gIH07XG5cbiAgcHJpdmF0ZSBtdW5nZUNvZGVjcyA9IChzZHA/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoc2RwKSB7XG4gICAgICBzZHAgPSB0b2dnbGVEdHgoc2RwLCB0aGlzLmlzRHR4RW5hYmxlZCk7XG4gICAgfVxuICAgIHJldHVybiBzZHA7XG4gIH07XG5cbiAgcHJpdmF0ZSBleHRyYWN0TWlkID0gKFxuICAgIHNkcDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHRyYWNrVHlwZTogVHJhY2tUeXBlLFxuICApOiBzdHJpbmcgPT4ge1xuICAgIGlmICghc2RwKSB7XG4gICAgICBsb2dnZXIoJ3dhcm4nLCAnTm8gU0RQIGZvdW5kLiBSZXR1cm5pbmcgZW1wdHkgbWlkJyk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbG9nZ2VyKFxuICAgICAgJ2RlYnVnJyxcbiAgICAgIGBObyAnbWlkJyBmb3VuZCBmb3IgdHJhY2suIFRyeWluZyB0byBmaW5kIGl0IGZyb20gdGhlIE9mZmVyIFNEUGAsXG4gICAgKTtcblxuICAgIGNvbnN0IHBhcnNlZFNkcCA9IFNEUC5wYXJzZShzZHApO1xuICAgIGNvbnN0IG1lZGlhID0gcGFyc2VkU2RwLm1lZGlhLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG0udHlwZSA9PT0gdHJhY2sua2luZCAmJlxuICAgICAgICAvLyBpZiBgbXNpZGAgaXMgbm90IHByZXNlbnQsIHdlIGFzc3VtZSB0aGF0IHRoZSB0cmFjayBpcyB0aGUgZmlyc3Qgb25lXG4gICAgICAgIChtLm1zaWQ/LmluY2x1ZGVzKHRyYWNrLmlkKSA/PyB0cnVlKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG1lZGlhPy5taWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgICdkZWJ1ZycsXG4gICAgICAgIGBObyBtaWQgZm91bmQgaW4gU0RQIGZvciB0cmFjayB0eXBlICR7dHJhY2sua2luZH0gYW5kIGlkICR7dHJhY2suaWR9LiBBdHRlbXB0aW5nIHRvIGZpbmQgYSBoZXVyaXN0aWMgbWlkYCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGhldXJpc3RpY01pZCA9IHRoaXMudHJhbnNjZWl2ZXJJbml0T3JkZXIuaW5kZXhPZih0cmFja1R5cGUpO1xuICAgICAgaWYgKGhldXJpc3RpY01pZCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhoZXVyaXN0aWNNaWQpO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIoJ2RlYnVnJywgJ05vIGhldXJpc3RpYyBtaWQgZm91bmQuIFJldHVybmluZyBlbXB0eSBtaWQnKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhtZWRpYS5taWQpO1xuICB9O1xuXG4gIGdldEN1cnJlbnRUcmFja0luZm9zID0gKHNkcD86IHN0cmluZykgPT4ge1xuICAgIHNkcCA9IHNkcCB8fCB0aGlzLnBjLmxvY2FsRGVzY3JpcHRpb24/LnNkcDtcblxuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHNldHRpbmdzPy52aWRlby50YXJnZXRfcmVzb2x1dGlvbjtcbiAgICByZXR1cm4gdGhpcy5wY1xuICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAuZmlsdGVyKCh0KSA9PiB0LmRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5JyAmJiB0LnNlbmRlci50cmFjaylcbiAgICAgIC5tYXA8VHJhY2tJbmZvPigodHJhbnNjZWl2ZXIpID0+IHtcbiAgICAgICAgY29uc3QgdHJhY2tUeXBlOiBUcmFja1R5cGUgPSBOdW1iZXIoXG4gICAgICAgICAgT2JqZWN0LmtleXModGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5KS5maW5kKFxuICAgICAgICAgICAgKGtleSkgPT5cbiAgICAgICAgICAgICAgdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W2tleSBhcyBhbnkgYXMgVHJhY2tUeXBlXSA9PT0gdHJhbnNjZWl2ZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2shO1xuICAgICAgICBsZXQgb3B0aW1hbExheWVyczogT3B0aW1hbFZpZGVvTGF5ZXJbXTtcbiAgICAgICAgaWYgKHRyYWNrLnJlYWR5U3RhdGUgPT09ICdsaXZlJykge1xuICAgICAgICAgIGNvbnN0IHB1Ymxpc2hPcHRzID0gdGhpcy5wdWJsaXNoT3B0aW9uc1BlclRyYWNrVHlwZS5nZXQodHJhY2tUeXBlKTtcbiAgICAgICAgICBvcHRpbWFsTGF5ZXJzID1cbiAgICAgICAgICAgIHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPXG4gICAgICAgICAgICAgID8gZmluZE9wdGltYWxWaWRlb0xheWVycyh0cmFjaywgdGFyZ2V0UmVzb2x1dGlvbilcbiAgICAgICAgICAgICAgOiB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVcbiAgICAgICAgICAgICAgPyBmaW5kT3B0aW1hbFNjcmVlblNoYXJpbmdMYXllcnMoXG4gICAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICAgIHB1Ymxpc2hPcHRzPy5zY3JlZW5TaGFyZVNldHRpbmdzLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICB0aGlzLnRyYWNrTGF5ZXJzQ2FjaGVbdHJhY2tUeXBlXSA9IG9wdGltYWxMYXllcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2UgcmVwb3J0IHRoZSBsYXN0IGtub3duIG9wdGltYWwgbGF5ZXJzIGZvciBlbmRlZCB0cmFja3NcbiAgICAgICAgICBvcHRpbWFsTGF5ZXJzID0gdGhpcy50cmFja0xheWVyc0NhY2hlW3RyYWNrVHlwZV0gfHwgW107XG4gICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgJ2RlYnVnJyxcbiAgICAgICAgICAgIGBUcmFjayAke1RyYWNrVHlwZVt0cmFja1R5cGVdfSBpcyBlbmRlZC4gQW5ub3VuY2luZyBsYXN0IGtub3duIG9wdGltYWwgbGF5ZXJzYCxcbiAgICAgICAgICAgIG9wdGltYWxMYXllcnMsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxheWVycyA9IG9wdGltYWxMYXllcnMubWFwPFZpZGVvTGF5ZXI+KChvcHRpbWFsTGF5ZXIpID0+ICh7XG4gICAgICAgICAgcmlkOiBvcHRpbWFsTGF5ZXIucmlkIHx8ICcnLFxuICAgICAgICAgIGJpdHJhdGU6IG9wdGltYWxMYXllci5tYXhCaXRyYXRlIHx8IDAsXG4gICAgICAgICAgZnBzOiBvcHRpbWFsTGF5ZXIubWF4RnJhbWVyYXRlIHx8IDAsXG4gICAgICAgICAgcXVhbGl0eTogdGhpcy5yaWRUb1ZpZGVvUXVhbGl0eShvcHRpbWFsTGF5ZXIucmlkIHx8ICcnKSxcbiAgICAgICAgICB2aWRlb0RpbWVuc2lvbjoge1xuICAgICAgICAgICAgd2lkdGg6IG9wdGltYWxMYXllci53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogb3B0aW1hbExheWVyLmhlaWdodCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc3QgaXNBdWRpb1RyYWNrID0gW1xuICAgICAgICAgIFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgICBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPLFxuICAgICAgICBdLmluY2x1ZGVzKHRyYWNrVHlwZSk7XG5cbiAgICAgICAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgIGNvbnN0IGlzU3RlcmVvID0gaXNBdWRpb1RyYWNrICYmIHRyYWNrU2V0dGluZ3MuY2hhbm5lbENvdW50ID09PSAyO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhY2tJZDogdHJhY2suaWQsXG4gICAgICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICAgICAgdHJhY2tUeXBlLFxuICAgICAgICAgIG1pZDogdHJhbnNjZWl2ZXIubWlkID8/IHRoaXMuZXh0cmFjdE1pZChzZHAsIHRyYWNrLCB0cmFja1R5cGUpLFxuXG4gICAgICAgICAgc3RlcmVvOiBpc1N0ZXJlbyxcbiAgICAgICAgICBkdHg6IGlzQXVkaW9UcmFjayAmJiB0aGlzLmlzRHR4RW5hYmxlZCxcbiAgICAgICAgICByZWQ6IGlzQXVkaW9UcmFjayAmJiB0aGlzLmlzUmVkRW5hYmxlZCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgb25JY2VDYW5kaWRhdGVFcnJvciA9IChlOiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICBlIGluc3RhbmNlb2YgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50ICYmXG4gICAgICBgJHtlLmVycm9yQ29kZX06ICR7ZS5lcnJvclRleHR9YDtcbiAgICBjb25zdCBpY2VTdGF0ZSA9IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIGNvbnN0IGxvZ0xldmVsID1cbiAgICAgIGljZVN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VTdGF0ZSA9PT0gJ2NoZWNraW5nJyA/ICdkZWJ1ZycgOiAnd2Fybic7XG4gICAgbG9nZ2VyKGxvZ0xldmVsLCBgSUNFIENhbmRpZGF0ZSBlcnJvcmAsIGVycm9yTWVzc2FnZSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIGxvZ2dlcignZGVidWcnLCBgSUNFIENvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0b2AsIHN0YXRlKTtcblxuICAgIGNvbnN0IGhhc05ldHdvcmtDb25uZWN0aW9uID1cbiAgICAgIHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlICE9PSBDYWxsaW5nU3RhdGUuT0ZGTElORTtcblxuICAgIGlmIChzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgIGxvZ2dlcignd2FybicsIGBBdHRlbXB0aW5nIHRvIHJlc3RhcnQgSUNFYCk7XG4gICAgICB0aGlzLnJlc3RhcnRJY2UoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2Vycm9yJywgYElDRSByZXN0YXJ0IGVycm9yYCwgZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiBoYXNOZXR3b3JrQ29ubmVjdGlvbikge1xuICAgICAgLy8gd2hlbiBpbiBgZGlzY29ubmVjdGVkYCBzdGF0ZSwgdGhlIGJyb3dzZXIgbWF5IHJlY292ZXIgYXV0b21hdGljYWxseSxcbiAgICAgIC8vIGhlbmNlLCB3ZSBkZWxheSB0aGUgSUNFIHJlc3RhcnRcbiAgICAgIGxvZ2dlcignd2FybicsIGBTY2hlZHVsaW5nIElDRSByZXN0YXJ0IGluICR7dGhpcy5pY2VSZXN0YXJ0RGVsYXl9IG1zLmApO1xuICAgICAgdGhpcy5pY2VSZXN0YXJ0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgc3RhdGUgaXMgc3RpbGwgYGRpc2Nvbm5lY3RlZGAgb3IgYGZhaWxlZGBcbiAgICAgICAgLy8gYXMgdGhlIGNvbm5lY3Rpb24gbWF5IGhhdmUgcmVjb3ZlcmVkIChvciBmYWlsZWQpIGluIHRoZSBtZWFudGltZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8XG4gICAgICAgICAgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIoJ2Vycm9yJywgYElDRSByZXN0YXJ0IGVycm9yYCwgZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgJ2RlYnVnJyxcbiAgICAgICAgICAgIGBTY2hlZHVsZWQgSUNFIHJlc3RhcnQ6IGNvbm5lY3Rpb24gcmVjb3ZlcmVkLCBjYW5jZWxlZC5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuaWNlUmVzdGFydERlbGF5KTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgIGxvZ2dlcignZGVidWcnLCBgSUNFIEdhdGhlcmluZyBTdGF0ZWAsIHRoaXMucGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICB9O1xuXG4gIHByaXZhdGUgb25TaWduYWxpbmdTdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICBsb2dnZXIoJ2RlYnVnJywgYFNpZ25hbGluZyBzdGF0ZSBjaGFuZ2VkYCwgdGhpcy5wYy5zaWduYWxpbmdTdGF0ZSk7XG4gIH07XG5cbiAgcHJpdmF0ZSByaWRUb1ZpZGVvUXVhbGl0eSA9IChyaWQ6IHN0cmluZyk6IFZpZGVvUXVhbGl0eSA9PiB7XG4gICAgcmV0dXJuIHJpZCA9PT0gJ3EnXG4gICAgICA/IFZpZGVvUXVhbGl0eS5MT1dfVU5TUEVDSUZJRURcbiAgICAgIDogcmlkID09PSAnaCdcbiAgICAgID8gVmlkZW9RdWFsaXR5Lk1JRFxuICAgICAgOiBWaWRlb1F1YWxpdHkuSElHSDsgLy8gZGVmYXVsdCB0byBISUdIXG4gIH07XG59XG4iLCJpbXBvcnQgeyBTdHJlYW1TZnVDbGllbnQgfSBmcm9tICcuLi9TdHJlYW1TZnVDbGllbnQnO1xuaW1wb3J0IHsgZ2V0SWNlQ2FuZGlkYXRlIH0gZnJvbSAnLi9oZWxwZXJzL2ljZUNhbmRpZGF0ZSc7XG5pbXBvcnQgeyBQZWVyVHlwZSB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvbW9kZWxzL21vZGVscyc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyT2ZmZXIgfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L2V2ZW50L2V2ZW50cyc7XG5pbXBvcnQgeyBEaXNwYXRjaGVyIH0gZnJvbSAnLi9EaXNwYXRjaGVyJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBDYWxsaW5nU3RhdGUsIENhbGxTdGF0ZSB9IGZyb20gJy4uL3N0b3JlJztcblxuZXhwb3J0IHR5cGUgU3Vic2NyaWJlck9wdHMgPSB7XG4gIHNmdUNsaWVudDogU3RyZWFtU2Z1Q2xpZW50O1xuICBkaXNwYXRjaGVyOiBEaXNwYXRjaGVyO1xuICBzdGF0ZTogQ2FsbFN0YXRlO1xuICBjb25uZWN0aW9uQ29uZmlnPzogUlRDQ29uZmlndXJhdGlvbjtcbiAgaWNlUmVzdGFydERlbGF5PzogbnVtYmVyO1xufTtcblxuY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnU3Vic2NyaWJlciddKTtcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBgUlRDUGVlckNvbm5lY3Rpb25gIHRoYXQgaGFuZGxlcyB0aGUgaW5jb21pbmdcbiAqIG1lZGlhIHN0cmVhbXMgZnJvbSB0aGUgU0ZVLlxuICovXG5leHBvcnQgY2xhc3MgU3Vic2NyaWJlciB7XG4gIHByaXZhdGUgcGM6IFJUQ1BlZXJDb25uZWN0aW9uO1xuICBwcml2YXRlIHNmdUNsaWVudDogU3RyZWFtU2Z1Q2xpZW50O1xuICBwcml2YXRlIHN0YXRlOiBDYWxsU3RhdGU7XG5cbiAgcHJpdmF0ZSByZWFkb25seSB1bnJlZ2lzdGVyT25TdWJzY3JpYmVyT2ZmZXI6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgdW5yZWdpc3Rlck9uSWNlUmVzdGFydDogKCkgPT4gdm9pZDtcblxuICBwcml2YXRlIHJlYWRvbmx5IGljZVJlc3RhcnREZWxheTogbnVtYmVyO1xuICBwcml2YXRlIGlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICBwcml2YXRlIGljZVJlc3RhcnRUaW1lb3V0PzogTm9kZUpTLlRpbWVvdXQ7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgdGhlIGxhY2sgb2YgUlRDUGVlckNvbm5lY3Rpb24uZ2V0Q29uZmlndXJhdGlvbigpIG1ldGhvZCBpbiByZWFjdC1uYXRpdmUtd2VicnRjXG4gIHByaXZhdGUgX2Nvbm5lY3Rpb25Db25maWd1cmF0aW9uOiBSVENDb25maWd1cmF0aW9uIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbikgcmV0dXJuIHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBTdWJzY3JpYmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHNmdUNsaWVudCB0aGUgU0ZVIGNsaWVudCB0byB1c2UuXG4gICAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBkaXNwYXRjaGVyIHRvIHVzZS5cbiAgICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSBvZiB0aGUgY2FsbC5cbiAgICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWcgdGhlIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAqIEBwYXJhbSBpY2VSZXN0YXJ0RGVsYXkgdGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXN0YXJ0aW5nIElDRSB3aGVuIGNvbm5lY3Rpb24gZ29lcyB0byBgZGlzY29ubmVjdGVkYCBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzZnVDbGllbnQsXG4gICAgZGlzcGF0Y2hlcixcbiAgICBzdGF0ZSxcbiAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgIGljZVJlc3RhcnREZWxheSA9IDI1MDAsXG4gIH06IFN1YnNjcmliZXJPcHRzKSB7XG4gICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuaWNlUmVzdGFydERlbGF5ID0gaWNlUmVzdGFydERlbGF5O1xuXG4gICAgdGhpcy5wYyA9IHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG5cbiAgICB0aGlzLnVucmVnaXN0ZXJPblN1YnNjcmliZXJPZmZlciA9IGRpc3BhdGNoZXIub24oXG4gICAgICAnc3Vic2NyaWJlck9mZmVyJyxcbiAgICAgIGFzeW5jIChzdWJzY3JpYmVyT2ZmZXIpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5uZWdvdGlhdGUoc3Vic2NyaWJlck9mZmVyKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMudW5yZWdpc3Rlck9uSWNlUmVzdGFydCA9IGRpc3BhdGNoZXIub24oXG4gICAgICAnaWNlUmVzdGFydCcsXG4gICAgICBhc3luYyAoaWNlUmVzdGFydCkgPT4ge1xuICAgICAgICBpZiAoaWNlUmVzdGFydC5wZWVyVHlwZSAhPT0gUGVlclR5cGUuU1VCU0NSSUJFUikgcmV0dXJuO1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRJY2UoKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBSVENQZWVyQ29ubmVjdGlvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWcgdGhlIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVBlZXJDb25uZWN0aW9uID0gKGNvbm5lY3Rpb25Db25maWc/OiBSVENDb25maWd1cmF0aW9uKSA9PiB7XG4gICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgdGhpcy5fY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24gPSBjb25uZWN0aW9uQ29uZmlnO1xuICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIHRoaXMub25JY2VDYW5kaWRhdGUpO1xuICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5oYW5kbGVPblRyYWNrKTtcblxuICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZWVycm9yJywgdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yKTtcbiAgICBwYy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsXG4gICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlLFxuICAgICk7XG4gICAgcGMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsXG4gICAgICB0aGlzLm9uSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UsXG4gICAgKTtcblxuICAgIHJldHVybiBwYztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBgUlRDUGVlckNvbm5lY3Rpb25gIGFuZCB1bnN1YnNjcmliZXMgZnJvbSB0aGUgZGlzcGF0Y2hlci5cbiAgICovXG4gIGNsb3NlID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmljZVJlc3RhcnRUaW1lb3V0KTtcbiAgICB0aGlzLnVucmVnaXN0ZXJPblN1YnNjcmliZXJPZmZlcigpO1xuICAgIHRoaXMudW5yZWdpc3Rlck9uSWNlUmVzdGFydCgpO1xuICAgIHRoaXMucGMuY2xvc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBgUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMoKWAgbWV0aG9kXG4gICAqIEBwYXJhbSBzZWxlY3RvclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0U3RhdHMgPSAoc2VsZWN0b3I/OiBNZWRpYVN0cmVhbVRyYWNrIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgU0ZVIGNsaWVudCB0byB1c2UuXG4gICAqXG4gICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgKi9cbiAgc2V0U2Z1Q2xpZW50ID0gKHNmdUNsaWVudDogU3RyZWFtU2Z1Q2xpZW50KSA9PiB7XG4gICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1pZ3JhdGVzIHRoZSBzdWJzY3JpYmVyIHRvIGEgbmV3IFNGVSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIG5ldyBTRlUgY2xpZW50IHRvIG1pZ3JhdGUgdG8uXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBuZXcgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICovXG4gIG1pZ3JhdGVUbyA9IChcbiAgICBzZnVDbGllbnQ6IFN0cmVhbVNmdUNsaWVudCxcbiAgICBjb25uZWN0aW9uQ29uZmlnPzogUlRDQ29uZmlndXJhdGlvbixcbiAgKSA9PiB7XG4gICAgdGhpcy5zZXRTZnVDbGllbnQoc2Z1Q2xpZW50KTtcblxuICAgIC8vIHdoZW4gbWlncmF0aW5nLCB3ZSB3YW50IHRvIGtlZXAgdGhlIHByZXZpb3VzIHN1YnNjcmliZXIgb3BlblxuICAgIC8vIHVudGlsIHRoZSBuZXcgb25lIGlzIGNvbm5lY3RlZFxuICAgIGNvbnN0IHByZXZpb3VzUEMgPSB0aGlzLnBjO1xuXG4gICAgLy8gd2Uga2VlcCBhIHJlY29yZCBvZiBwcmV2aW91c2x5IGF2YWlsYWJsZSB2aWRlbyB0cmFja3NcbiAgICAvLyBzbyB0aGF0IHdlIGNhbiBtb25pdG9yIHdoZW4gdGhleSBiZWNvbWUgYXZhaWxhYmxlIG9uIHRoZSBuZXdcbiAgICAvLyBzdWJzY3JpYmVyIGFuZCBjbG9zZSB0aGUgcHJldmlvdXMgb25lLlxuICAgIGNvbnN0IHRyYWNrSWRzVG9NaWdyYXRlID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgcHJldmlvdXNQQy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBpZiAoci50cmFjay5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgIHRyYWNrSWRzVG9NaWdyYXRlLmFkZChyLnRyYWNrLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHNldCB1cCBhIG5ldyBzdWJzY3JpYmVyIHBlZXIgY29ubmVjdGlvbiwgY29uZmlndXJlZCB0byBjb25uZWN0XG4gICAgLy8gdG8gdGhlIG5ldyBTRlUgbm9kZVxuICAgIGNvbnN0IHBjID0gdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcblxuICAgIGxldCBtaWdyYXRpb25UaW1lb3V0SWQ6IE5vZGVKUy5UaW1lb3V0O1xuICAgIGNvbnN0IGNsZWFudXBNaWdyYXRpb24gPSAoKSA9PiB7XG4gICAgICBwcmV2aW91c1BDLmNsb3NlKCk7XG4gICAgICBjbGVhclRpbWVvdXQobWlncmF0aW9uVGltZW91dElkKTtcbiAgICB9O1xuXG4gICAgLy8gV2hlbiBtaWdyYXRpbmcsIHdlIHdhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgdmlkZW8gdHJhY2tzXG4gICAgLy8gdGhhdCBhcmUgbWlncmF0aW5nIHRvIHRoZSBuZXcgc3Vic2NyaWJlci5cbiAgICAvLyBPbmNlIGFsbCBvZiB0aGVtIGFyZSBhdmFpbGFibGUsIHdlIGNhbiBjbG9zZSB0aGUgcHJldmlvdXMgc3Vic2NyaWJlci5cbiAgICBjb25zdCBoYW5kbGVUcmFja01pZ3JhdGlvbiA9IChlOiBSVENUcmFja0V2ZW50KSA9PiB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgICdkZWJ1ZycsXG4gICAgICAgIGBbTWlncmF0aW9uXTogTWlncmF0ZWQgdHJhY2s6ICR7ZS50cmFjay5pZH0sICR7ZS50cmFjay5raW5kfWAsXG4gICAgICApO1xuICAgICAgdHJhY2tJZHNUb01pZ3JhdGUuZGVsZXRlKGUudHJhY2suaWQpO1xuICAgICAgaWYgKHRyYWNrSWRzVG9NaWdyYXRlLnNpemUgPT09IDApIHtcbiAgICAgICAgbG9nZ2VyKCdkZWJ1ZycsIGBbTWlncmF0aW9uXTogTWlncmF0aW9uIGNvbXBsZXRlYCk7XG4gICAgICAgIHBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgaGFuZGxlVHJhY2tNaWdyYXRpb24pO1xuICAgICAgICBjbGVhbnVwTWlncmF0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdoZW4gbWlncmF0aW5nLCB3ZSB3YW50IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNvbm5lY3Rpb24gc3RhdGVcbiAgICAvLyBvZiB0aGUgbmV3IHN1YnNjcmliZXIuXG4gICAgLy8gT25jZSBpdCBpcyBjb25uZWN0ZWQsIHdlIGdpdmUgaXQgYSAyLXNlY29uZCBncmFjZSBwZXJpb2QgdG8gcmVjZWl2ZVxuICAgIC8vIGFsbCB0aGUgdmlkZW8gdHJhY2tzIHRoYXQgYXJlIG1pZ3JhdGluZyBmcm9tIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyLlxuICAgIC8vIEFmdGVyIHRoaXMgdGhyZXNob2xkLCB3ZSBhYnJ1cHRseSBjbG9zZSB0aGUgcHJldmlvdXMgc3Vic2NyaWJlci5cbiAgICBjb25zdCBoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAocGMuY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICBtaWdyYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIGhhbmRsZVRyYWNrTWlncmF0aW9uKTtcbiAgICAgICAgICBjbGVhbnVwTWlncmF0aW9uKCk7XG4gICAgICAgIH0sIDIwMDApO1xuXG4gICAgICAgIHBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsXG4gICAgICAgICAgaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwYy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIGhhbmRsZVRyYWNrTWlncmF0aW9uKTtcbiAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuXG4gICAgLy8gcmVwbGFjZSB0aGUgUGVlckNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICB0aGlzLnBjID0gcGM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc3RhcnRzIHRoZSBJQ0UgY29ubmVjdGlvbiBhbmQgcmVuZWdvdGlhdGVzIHdpdGggdGhlIFNGVS5cbiAgICovXG4gIHJlc3RhcnRJY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgbG9nZ2VyKCdkZWJ1ZycsICdSZXN0YXJ0aW5nIElDRSBjb25uZWN0aW9uJyk7XG4gICAgaWYgKHRoaXMucGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLXJlbW90ZS1vZmZlcicpIHtcbiAgICAgIGxvZ2dlcignZGVidWcnLCAnSUNFIHJlc3RhcnQgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0lzSWNlUmVzdGFydGluZyA9IHRoaXMuaXNJY2VSZXN0YXJ0aW5nO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IHRydWU7XG4gICAgICBhd2FpdCB0aGlzLnNmdUNsaWVudC5pY2VSZXN0YXJ0KHtcbiAgICAgICAgcGVlclR5cGU6IFBlZXJUeXBlLlNVQlNDUklCRVIsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSwgYXMgb3VyIGludGVudCBmb3IgcmVzdGFydGluZyBJQ0UgZmFpbGVkXG4gICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IHByZXZpb3VzSXNJY2VSZXN0YXJ0aW5nO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVPblRyYWNrID0gKGU6IFJUQ1RyYWNrRXZlbnQpID0+IHtcbiAgICBjb25zdCBbcHJpbWFyeVN0cmVhbV0gPSBlLnN0cmVhbXM7XG4gICAgLy8gZXhhbXBsZTogYGUzZjZhYWY4LWIwM2QtNDkxMS1iZTM2LTgzZjQ3ZDM3YTc2YTpUUkFDS19UWVBFX1ZJREVPYFxuICAgIGNvbnN0IFt0cmFja0lkLCB0cmFja1R5cGVdID0gcHJpbWFyeVN0cmVhbS5pZC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50VG9VcGRhdGUgPSB0aGlzLnN0YXRlLnBhcnRpY2lwYW50cy5maW5kKFxuICAgICAgKHApID0+IHAudHJhY2tMb29rdXBQcmVmaXggPT09IHRyYWNrSWQsXG4gICAgKTtcbiAgICBsb2dnZXIoXG4gICAgICAnZGVidWcnLFxuICAgICAgYFtvblRyYWNrXTogR290IHJlbW90ZSAke3RyYWNrVHlwZX0gdHJhY2sgZm9yIHVzZXJJZDogJHtwYXJ0aWNpcGFudFRvVXBkYXRlPy51c2VySWR9YCxcbiAgICAgIGUudHJhY2suaWQsXG4gICAgICBlLnRyYWNrLFxuICAgICk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudFRvVXBkYXRlKSB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIGBbb25UcmFja106IFJlY2VpdmVkIHRyYWNrIGZvciB1bmtub3duIHBhcnRpY2lwYW50OiAke3RyYWNrSWR9YCxcbiAgICAgICAgZSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS50cmFjay5hZGRFdmVudExpc3RlbmVyKCdtdXRlJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICAnaW5mbycsXG4gICAgICAgIGBbb25UcmFja106IFRyYWNrIG11dGVkOiAke3BhcnRpY2lwYW50VG9VcGRhdGUudXNlcklkfSAke3RyYWNrVHlwZX06JHt0cmFja0lkfWAsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgZS50cmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCAoKSA9PiB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgICdpbmZvJyxcbiAgICAgICAgYFtvblRyYWNrXTogVHJhY2sgdW5tdXRlZDogJHtwYXJ0aWNpcGFudFRvVXBkYXRlLnVzZXJJZH0gJHt0cmFja1R5cGV9OiR7dHJhY2tJZH1gLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGUudHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCAoKSA9PiB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgICdpbmZvJyxcbiAgICAgICAgYFtvblRyYWNrXTogVHJhY2sgZW5kZWQ6ICR7cGFydGljaXBhbnRUb1VwZGF0ZS51c2VySWR9ICR7dHJhY2tUeXBlfToke3RyYWNrSWR9YCxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzdHJlYW1LaW5kUHJvcCA9IChcbiAgICAgIHtcbiAgICAgICAgVFJBQ0tfVFlQRV9BVURJTzogJ2F1ZGlvU3RyZWFtJyxcbiAgICAgICAgVFJBQ0tfVFlQRV9WSURFTzogJ3ZpZGVvU3RyZWFtJyxcbiAgICAgICAgVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkU6ICdzY3JlZW5TaGFyZVN0cmVhbScsXG4gICAgICAgIFRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFX0FVRElPOiAnc2NyZWVuU2hhcmVBdWRpb1N0cmVhbScsXG4gICAgICB9IGFzIGNvbnN0XG4gICAgKVt0cmFja1R5cGVdO1xuXG4gICAgaWYgKCFzdHJlYW1LaW5kUHJvcCkge1xuICAgICAgbG9nZ2VyKCdlcnJvcicsIGBVbmtub3duIHRyYWNrIHR5cGU6ICR7dHJhY2tUeXBlfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1N0cmVhbSA9IHBhcnRpY2lwYW50VG9VcGRhdGVbc3RyZWFtS2luZFByb3BdO1xuICAgIGlmIChwcmV2aW91c1N0cmVhbSkge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICAnaW5mbycsXG4gICAgICAgIGBbb25UcmFja106IENsZWFuaW5nIHVwIHByZXZpb3VzIHJlbW90ZSAke2UudHJhY2sua2luZH0gdHJhY2tzIGZvciB1c2VySWQ6ICR7cGFydGljaXBhbnRUb1VwZGF0ZS51c2VySWR9YCxcbiAgICAgICk7XG4gICAgICBwcmV2aW91c1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIHQuc3RvcCgpO1xuICAgICAgICBwcmV2aW91c1N0cmVhbS5yZW1vdmVUcmFjayh0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHBhcnRpY2lwYW50VG9VcGRhdGUuc2Vzc2lvbklkLCB7XG4gICAgICBbc3RyZWFtS2luZFByb3BdOiBwcmltYXJ5U3RyZWFtLFxuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgb25JY2VDYW5kaWRhdGUgPSBhc3luYyAoZTogUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgY2FuZGlkYXRlIH0gPSBlO1xuICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICBsb2dnZXIoJ2RlYnVnJywgJ251bGwgaWNlIGNhbmRpZGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LmljZVRyaWNrbGUoe1xuICAgICAgaWNlQ2FuZGlkYXRlOiBnZXRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSxcbiAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5TVUJTQ1JJQkVSLFxuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgbmVnb3RpYXRlID0gYXN5bmMgKHN1YnNjcmliZXJPZmZlcjogU3Vic2NyaWJlck9mZmVyKSA9PiB7XG4gICAgbG9nZ2VyKCdpbmZvJywgYFJlY2VpdmVkIHN1YnNjcmliZXJPZmZlcmAsIHN1YnNjcmliZXJPZmZlcik7XG5cbiAgICBhd2FpdCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICBzZHA6IHN1YnNjcmliZXJPZmZlci5zZHAsXG4gICAgfSk7XG5cbiAgICB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlQnVmZmVyLnN1YnNjcmliZXJDYW5kaWRhdGVzLnN1YnNjcmliZShcbiAgICAgIGFzeW5jIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpY2VDYW5kaWRhdGUgPSBKU09OLnBhcnNlKGNhbmRpZGF0ZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIoJ3dhcm4nLCBgSUNFIGNhbmRpZGF0ZSBlcnJvcmAsIFtlLCBjYW5kaWRhdGVdKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICBhd2FpdCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblxuICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LnNlbmRBbnN3ZXIoe1xuICAgICAgcGVlclR5cGU6IFBlZXJUeXBlLlNVQlNDUklCRVIsXG4gICAgICBzZHA6IGFuc3dlci5zZHAgfHwgJycsXG4gICAgfSk7XG5cbiAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHByaXZhdGUgb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICBsb2dnZXIoJ2RlYnVnJywgYElDRSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZWRgLCBzdGF0ZSk7XG5cbiAgICAvLyBkbyBub3RoaW5nIHdoZW4gSUNFIGlzIHJlc3RhcnRpbmdcbiAgICBpZiAodGhpcy5pc0ljZVJlc3RhcnRpbmcpIHJldHVybjtcblxuICAgIGNvbnN0IGhhc05ldHdvcmtDb25uZWN0aW9uID1cbiAgICAgIHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlICE9PSBDYWxsaW5nU3RhdGUuT0ZGTElORTtcblxuICAgIGlmIChzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgIGxvZ2dlcignd2FybicsIGBBdHRlbXB0aW5nIHRvIHJlc3RhcnQgSUNFYCk7XG4gICAgICB0aGlzLnJlc3RhcnRJY2UoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2Vycm9yJywgYElDRSByZXN0YXJ0IGZhaWxlZGAsIGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgaGFzTmV0d29ya0Nvbm5lY3Rpb24pIHtcbiAgICAgIC8vIHdoZW4gaW4gYGRpc2Nvbm5lY3RlZGAgc3RhdGUsIHRoZSBicm93c2VyIG1heSByZWNvdmVyIGF1dG9tYXRpY2FsbHksXG4gICAgICAvLyBoZW5jZSwgd2UgZGVsYXkgdGhlIElDRSByZXN0YXJ0XG4gICAgICBsb2dnZXIoJ3dhcm4nLCBgU2NoZWR1bGluZyBJQ0UgcmVzdGFydCBpbiAke3RoaXMuaWNlUmVzdGFydERlbGF5fSBtcy5gKTtcbiAgICAgIHRoaXMuaWNlUmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHN0YXRlIGlzIHN0aWxsIGBkaXNjb25uZWN0ZWRgIG9yIGBmYWlsZWRgXG4gICAgICAgIC8vIGFzIHRoZSBjb25uZWN0aW9uIG1heSBoYXZlIHJlY292ZXJlZCAob3IgZmFpbGVkKSBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fFxuICAgICAgICAgIHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJ1xuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnJlc3RhcnRJY2UoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsIGBJQ0UgcmVzdGFydCBmYWlsZWRgLCBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAnZGVidWcnLFxuICAgICAgICAgICAgYFNjaGVkdWxlZCBJQ0UgcmVzdGFydDogY29ubmVjdGlvbiByZWNvdmVyZWQsIGNhbmNlbGVkLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwgNTAwMCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgb25JY2VHYXRoZXJpbmdTdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICBsb2dnZXIoJ2RlYnVnJywgYElDRSBnYXRoZXJpbmcgc3RhdGUgY2hhbmdlZGAsIHRoaXMucGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICB9O1xuXG4gIHByaXZhdGUgb25JY2VDYW5kaWRhdGVFcnJvciA9IChlOiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICBlIGluc3RhbmNlb2YgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50ICYmXG4gICAgICBgJHtlLmVycm9yQ29kZX06ICR7ZS5lcnJvclRleHR9YDtcbiAgICBjb25zdCBpY2VTdGF0ZSA9IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIGNvbnN0IGxvZ0xldmVsID1cbiAgICAgIGljZVN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VTdGF0ZSA9PT0gJ2NoZWNraW5nJyA/ICdkZWJ1ZycgOiAnd2Fybic7XG4gICAgbG9nZ2VyKGxvZ0xldmVsLCBgSUNFIENhbmRpZGF0ZSBlcnJvcmAsIGVycm9yTWVzc2FnZSk7XG4gIH07XG59XG4iLCJpbXBvcnQgV2ViU29ja2V0IGZyb20gJ2lzb21vcnBoaWMtd3MnO1xuaW1wb3J0IHsgU2Z1RXZlbnQgfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L2V2ZW50L2V2ZW50cyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgRGlzcGF0Y2hhYmxlTWVzc2FnZSwgU2Z1RXZlbnRLaW5kcyB9IGZyb20gJy4vRGlzcGF0Y2hlcic7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVXZWJTb2NrZXRTaWduYWxDaGFubmVsID0gKG9wdHM6IHtcbiAgZW5kcG9pbnQ6IHN0cmluZztcbiAgb25NZXNzYWdlOiA8SyBleHRlbmRzIFNmdUV2ZW50S2luZHM+KG1lc3NhZ2U6IERpc3BhdGNoYWJsZU1lc3NhZ2U8Sz4pID0+IHZvaWQ7XG59KSA9PiB7XG4gIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ3NmdS1jbGllbnQnXSk7XG4gIGNvbnN0IHsgZW5kcG9pbnQsIG9uTWVzc2FnZSB9ID0gb3B0cztcbiAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KGVuZHBvaW50KTtcbiAgd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7IC8vIGRvIHdlIG5lZWQgdGhpcz9cblxuICB3cy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChlKSA9PiB7XG4gICAgbG9nZ2VyKCdlcnJvcicsICdTaWduYWxpbmcgV1MgY2hhbm5lbCBlcnJvcicsIGUpO1xuICB9KTtcblxuICB3cy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIChlKSA9PiB7XG4gICAgbG9nZ2VyKCdpbmZvJywgJ1NpZ25hbGluZyBXUyBjaGFubmVsIGlzIGNsb3NlZCcsIGUpO1xuICB9KTtcblxuICB3cy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgKGUpID0+IHtcbiAgICBsb2dnZXIoJ2luZm8nLCAnU2lnbmFsaW5nIFdTIGNoYW5uZWwgaXMgb3BlbicsIGUpO1xuICB9KTtcblxuICB3cy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGUpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgIGUuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgICAgPyBTZnVFdmVudC5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGUuZGF0YSkpXG4gICAgICAgICAgOiBTZnVFdmVudC5mcm9tSnNvblN0cmluZyhlLmRhdGEudG9TdHJpbmcoKSk7XG5cbiAgICAgIG9uTWVzc2FnZShtZXNzYWdlIGFzIERpc3BhdGNoYWJsZU1lc3NhZ2U8U2Z1RXZlbnRLaW5kcz4pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICAnZXJyb3InLFxuICAgICAgICAnRmFpbGVkIHRvIGRlY29kZSBhIG1lc3NhZ2UuIENoZWNrIHdoZXRoZXIgdGhlIFByb3RvIG1vZGVscyBtYXRjaC4nLFxuICAgICAgICB7IGV2ZW50OiBlLCBlcnJvcjogZXJyIH0sXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB3cztcbn07XG4iLCJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IHNsZWVwID0gKG06IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT5cbiAgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgbSkpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbjxUPih2YWx1ZTogRnVuY3Rpb24gfCBUKTogdmFsdWUgaXMgRnVuY3Rpb24ge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICYmXG4gICAgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAgICdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgKTtcbn1cblxuLyoqXG4gKiBBIG1hcCBvZiBrbm93biBlcnJvciBjb2Rlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEtub3duQ29kZXMgPSB7XG4gIFRPS0VOX0VYUElSRUQ6IDQwLFxuICBXU19DTE9TRURfU1VDQ0VTUzogMTAwMCxcbiAgV1NfQ0xPU0VEX0FCUlVQVExZOiAxMDA2LFxuICBXU19QT0xJQ1lfVklPTEFUSU9OOiAxMDA4LFxufTtcblxuLyoqXG4gKiByZXRyeUludGVydmFsIC0gQSByZXRyeSBpbnRlcnZhbCB3aGljaCBpbmNyZWFzZXMgYWNjIHRvIG51bWJlciBvZiBmYWlsdXJlc1xuICpcbiAqIEByZXR1cm4ge251bWJlcn0gRHVyYXRpb24gdG8gd2FpdCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5SW50ZXJ2YWwobnVtYmVyT2ZGYWlsdXJlczogbnVtYmVyKSB7XG4gIC8vIHRyeSB0byByZWNvbm5lY3QgaW4gMC4yNS01IHNlY29uZHMgKHJhbmRvbSB0byBzcHJlYWQgb3V0IHRoZSBsb2FkIGZyb20gZmFpbHVyZXMpXG4gIGNvbnN0IG1heCA9IE1hdGgubWluKDUwMCArIG51bWJlck9mRmFpbHVyZXMgKiAyMDAwLCA1MDAwKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oTWF0aC5tYXgoMjUwLCAobnVtYmVyT2ZGYWlsdXJlcyAtIDEpICogMjAwMCksIDUwMDApO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSWQoKSB7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUR2NCgpO1xufVxuXG5mdW5jdGlvbiBoZXgoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICBsZXQgcyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcyArPSBieXRlc1tpXS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVVVSUR2NCgpIHtcbiAgY29uc3QgYnl0ZXMgPSBnZXRSYW5kb21CeXRlcygxNik7XG4gIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwOyAvLyB2ZXJzaW9uXG4gIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHhiZikgfCAweDgwOyAvLyB2YXJpYW50XG5cbiAgcmV0dXJuIChcbiAgICBoZXgoYnl0ZXMuc3ViYXJyYXkoMCwgNCkpICtcbiAgICAnLScgK1xuICAgIGhleChieXRlcy5zdWJhcnJheSg0LCA2KSkgK1xuICAgICctJyArXG4gICAgaGV4KGJ5dGVzLnN1YmFycmF5KDYsIDgpKSArXG4gICAgJy0nICtcbiAgICBoZXgoYnl0ZXMuc3ViYXJyYXkoOCwgMTApKSArXG4gICAgJy0nICtcbiAgICBoZXgoYnl0ZXMuc3ViYXJyYXkoMTAsIDE2KSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzV2l0aE1hdGhSYW5kb20oYnl0ZXM6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgY29uc3QgbWF4ID0gTWF0aC5wb3coMiwgKDggKiBieXRlcy5ieXRlTGVuZ3RoKSAvIGJ5dGVzLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IE1hdGgucmFuZG9tKCkgKiBtYXg7XG4gIH1cbn1cbmRlY2xhcmUgY29uc3QgbXNDcnlwdG86IENyeXB0bztcblxuY29uc3QgZ2V0UmFuZG9tVmFsdWVzID0gKCgpID0+IHtcbiAgaWYgKFxuICAgIHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNyeXB0bz8uZ2V0UmFuZG9tVmFsdWVzICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldFJhbmRvbVZhbHVlc1dpdGhNYXRoUmFuZG9tO1xuICB9XG59KSgpO1xuXG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhsZW5ndGg6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRFcnJvclRvSnNvbihlcnI6IEVycm9yKSB7XG4gIGNvbnN0IGpzb25PYmogPSB7fSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICBpZiAoIWVycikgcmV0dXJuIGpzb25PYmo7XG5cbiAgdHJ5IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAganNvbk9ialtrZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlcnIsIGtleSk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICdmYWlsZWQgdG8gc2VyaWFsaXplIHRoZSBlcnJvcicsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBqc29uT2JqO1xufVxuXG4vKipcbiAqIGlzT25saW5lIHNhZmVseSByZXR1cm4gdGhlIG5hdmlnYXRvci5vbmxpbmUgdmFsdWUgZm9yIGJyb3dzZXIgZW52XG4gKiBpZiBuYXZpZ2F0b3IgaXMgbm90IGluIGdsb2JhbCBvYmplY3QsIGl0IGFsd2F5cyByZXR1cm4gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPbmxpbmUobG9nZ2VyOiBMb2dnZXIpIHtcbiAgY29uc3QgbmF2ID1cbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBuYXZpZ2F0b3JcbiAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvclxuICAgICAgPyB3aW5kb3cubmF2aWdhdG9yXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICBpZiAoIW5hdikge1xuICAgIGxvZ2dlcihcbiAgICAgICd3YXJuJyxcbiAgICAgICdpc09ubGluZSBmYWlsZWQgdG8gYWNjZXNzIHdpbmRvdy5uYXZpZ2F0b3IgYW5kIGFzc3VtZSBicm93c2VyIGlzIG9ubGluZScsXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFJOIG5hdmlnYXRvciBoYXMgdW5kZWZpbmVkIGZvciBvbkxpbmVcbiAgaWYgKHR5cGVvZiBuYXYub25MaW5lICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBuYXYub25MaW5lO1xufVxuXG4vKipcbiAqIGxpc3RlbkZvckNvbm5lY3Rpb25DaGFuZ2VzIC0gQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmaXJlZCBvbiBicm93c2VyIGdvaW5nIG9ubGluZSBvciBvZmZsaW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMoY2I6IChlOiBFdmVudCkgPT4gdm9pZCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGNiKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgY2IpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMoY2I6IChlOiBFdmVudCkgPT4gdm9pZCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGNiKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgY2IpO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFdlYlNvY2tldCB9IGZyb20gJ3dzJztcbmltcG9ydCB0eXBlIHtcbiAgRmluaXNoZWRVbmFyeUNhbGwsXG4gIE1ldGhvZEluZm8sXG4gIE5leHRVbmFyeUZuLFxuICBScGNJbnRlcmNlcHRvcixcbiAgUnBjT3B0aW9ucyxcbiAgVW5hcnlDYWxsLFxufSBmcm9tICdAcHJvdG9idWYtdHMvcnVudGltZS1ycGMnO1xuaW1wb3J0IHsgU2lnbmFsU2VydmVyQ2xpZW50IH0gZnJvbSAnLi9nZW4vdmlkZW8vc2Z1L3NpZ25hbF9ycGMvc2lnbmFsLmNsaWVudCc7XG5pbXBvcnQgeyBjcmVhdGVTaWduYWxDbGllbnQsIHdpdGhIZWFkZXJzIH0gZnJvbSAnLi9ycGMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlV2ViU29ja2V0U2lnbmFsQ2hhbm5lbCxcbiAgRGlzcGF0Y2hlcixcbiAgSWNlVHJpY2tsZUJ1ZmZlcixcbn0gZnJvbSAnLi9ydGMnO1xuaW1wb3J0IHsgSm9pblJlcXVlc3QsIFNmdVJlcXVlc3QgfSBmcm9tICcuL2dlbi92aWRlby9zZnUvZXZlbnQvZXZlbnRzJztcbmltcG9ydCB7XG4gIElDRVJlc3RhcnRSZXF1ZXN0LFxuICBTZW5kQW5zd2VyUmVxdWVzdCxcbiAgU2VuZFN0YXRzUmVxdWVzdCxcbiAgU2V0UHVibGlzaGVyUmVxdWVzdCxcbiAgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICBVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCxcbn0gZnJvbSAnLi9nZW4vdmlkZW8vc2Z1L3NpZ25hbF9ycGMvc2lnbmFsJztcbmltcG9ydCB7XG4gIEVycm9yIGFzIFNmdUVycm9yLFxuICBJQ0VUcmlja2xlLFxuICBUcmFja1R5cGUsXG59IGZyb20gJy4vZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzJztcbmltcG9ydCB7XG4gIGdlbmVyYXRlVVVJRHY0LFxuICByZXRyeUludGVydmFsLFxuICBzbGVlcCxcbn0gZnJvbSAnLi9jb29yZGluYXRvci9jb25uZWN0aW9uL3V0aWxzJztcbmltcG9ydCB7IFNGVVJlc3BvbnNlIH0gZnJvbSAnLi9nZW4vY29vcmRpbmF0b3InO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi9jb29yZGluYXRvci9jb25uZWN0aW9uL3R5cGVzJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IHR5cGUgU3RyZWFtU2Z1Q2xpZW50Q29uc3RydWN0b3IgPSB7XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBpbnN0YW5jZSB0byB1c2UuXG4gICAqL1xuICBkaXNwYXRjaGVyOiBEaXNwYXRjaGVyO1xuXG4gIC8qKlxuICAgKiBUaGUgU0ZVIHNlcnZlciB0byBjb25uZWN0IHRvLlxuICAgKi9cbiAgc2Z1U2VydmVyOiBTRlVSZXNwb25zZTtcblxuICAvKipcbiAgICogVGhlIEpXVCB0b2tlbiB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgKi9cbiAgdG9rZW46IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgYHNlc3Npb25JZGAgdG8gdXNlIGZvciB0aGUgY29ubmVjdGlvbi5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBhIHJhbmRvbSBVVUlEdjQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICBzZXNzaW9uSWQ/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFRoZSBjbGllbnQgdXNlZCBmb3IgZXhjaGFuZ2luZyBpbmZvcm1hdGlvbiB3aXRoIHRoZSBTRlUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1TZnVDbGllbnQge1xuICAvKipcbiAgICogQSBidWZmZXIgZm9yIElDRSBDYW5kaWRhdGVzIHRoYXQgYXJlIHJlY2VpdmVkIGJlZm9yZVxuICAgKiB0aGUgUGVlckNvbm5lY3Rpb25zIGFyZSByZWFkeSB0byBoYW5kbGUgdGhlbS5cbiAgICovXG4gIHJlYWRvbmx5IGljZVRyaWNrbGVCdWZmZXIgPSBuZXcgSWNlVHJpY2tsZUJ1ZmZlcigpO1xuICAvKipcbiAgICogVGhlIGBzZXNzaW9uSWRgIG9mIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIHBhcnRpY2lwYW50LlxuICAgKi9cbiAgcmVhZG9ubHkgc2Vzc2lvbklkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBgZWRnZU5hbWVgIHJlcHJlc2VudGluZyB0aGUgZWRnZSB0aGUgY2xpZW50IGlzIGNvbm5lY3RlZCB0by5cbiAgICovXG4gIHJlYWRvbmx5IGVkZ2VOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRva2VuIHVzZWQgZm9yIGF1dGhlbnRpY2F0aW5nIGFnYWluc3QgdGhlIFNGVS5cbiAgICovXG4gIHJlYWRvbmx5IHRva2VuOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBTRlUgc2VydmVyIGRldGFpbHMgdGhlIGN1cnJlbnQgY2xpZW50IGlzIGNvbm5lY3RlZCB0by5cbiAgICovXG4gIHJlYWRvbmx5IHNmdVNlcnZlcjogU0ZVUmVzcG9uc2U7XG5cbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBTRlUuXG4gICAqL1xuICBzaWduYWxXczogV2ViU29ja2V0O1xuXG4gIC8qKlxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgcmVhZHkgKG9wZW4pLlxuICAgKi9cbiAgc2lnbmFsUmVhZHk6IFByb21pc2U8V2ViU29ja2V0PjtcblxuICAvKipcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSBtaWdyYXRpbmcgYXdheVxuICAgKiBmcm9tIHRoaXMgU0ZVLlxuICAgKi9cbiAgaXNNaWdyYXRpbmdBd2F5ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhlIGNsaWVudCBjb25uZWN0aW9uIGlzIGJyb2tlbiBmb3IgdGhlIGN1cnJlbnRcbiAgICogY2xpZW50IGFuZCB0aGF0IGEgZmFzdC1yZWNvbm5lY3Qgd2l0aCBhIG5ldyBjbGllbnQgc2hvdWxkIGJlIGF0dGVtcHRlZC5cbiAgICovXG4gIGlzRmFzdFJlY29ubmVjdGluZyA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgcnBjOiBTaWduYWxTZXJ2ZXJDbGllbnQ7XG4gIHByaXZhdGUga2VlcEFsaXZlSW50ZXJ2YWw/OiBOb2RlSlMuVGltZW91dDtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uQ2hlY2tUaW1lb3V0PzogTm9kZUpTLlRpbWVvdXQ7XG4gIHByaXZhdGUgcGluZ0ludGVydmFsSW5NcyA9IDEwICogMTAwMDtcbiAgcHJpdmF0ZSB1bmhlYWx0aHlUaW1lb3V0SW5NcyA9IHRoaXMucGluZ0ludGVydmFsSW5NcyArIDUgKiAxMDAwO1xuICBwcml2YXRlIGxhc3RNZXNzYWdlVGltZXN0YW1wPzogRGF0ZTtcbiAgcHJpdmF0ZSByZWFkb25seSB1bnN1YnNjcmliZUljZVRyaWNrbGU6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgY2xvc3VyZSBjb2RlLiBVc2VkIGZvciBjb250cm9sbGVkIHNodXRkb3ducy5cbiAgICovXG4gIHN0YXRpYyBOT1JNQUxfQ0xPU1VSRSA9IDEwMDA7XG4gIC8qKlxuICAgKiBUaGUgZXJyb3IgY29kZSB1c2VkIHdoZW4gdGhlIFNGVSBjb25uZWN0aW9uIGlzIHVuaGVhbHRoeS5cbiAgICogVXN1YWxseSwgdGhpcyBtZWFucyB0aGF0IG5vIG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQgZnJvbSB0aGUgU0ZVIGZvclxuICAgKiBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUgKGBjb25uZWN0aW9uQ2hlY2tUaW1lb3V0YCkuXG4gICAqL1xuICBzdGF0aWMgRVJST1JfQ09OTkVDVElPTl9VTkhFQUxUSFkgPSA0MDAxO1xuXG4gIC8qKlxuICAgKiBUaGUgZXJyb3IgY29kZSB1c2VkIHdoZW4gdGhlIFNGVSBjb25uZWN0aW9uIGlzIGJyb2tlbi5cbiAgICogVXN1YWxseSwgdGhpcyBtZWFucyB0aGF0IHRoZSBXUyBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCB1bmV4cGVjdGVkbHkuXG4gICAqIFRoaXMgZXJyb3IgY29kZSBpcyB1c2VkIHRvIGFubm91bmNlIGEgZmFzdC1yZWNvbm5lY3QuXG4gICAqL1xuICBzdGF0aWMgRVJST1JfQ09OTkVDVElPTl9CUk9LRU4gPSA0MDAyOyAvLyB1c2VkIGluIGZhc3QtcmVjb25uZWN0c1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNGVSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBldmVudCBkaXNwYXRjaGVyIHRvIHVzZS5cbiAgICogQHBhcmFtIHNmdVNlcnZlciB0aGUgU0ZVIHNlcnZlciB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0gdG9rZW4gdGhlIEpXVCB0b2tlbiB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBgc2Vzc2lvbklkYCBvZiB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBwYXJ0aWNpcGFudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXNwYXRjaGVyLFxuICAgIHNmdVNlcnZlcixcbiAgICB0b2tlbixcbiAgICBzZXNzaW9uSWQsXG4gIH06IFN0cmVhbVNmdUNsaWVudENvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQgfHwgZ2VuZXJhdGVVVUlEdjQoKTtcbiAgICB0aGlzLnNmdVNlcnZlciA9IHNmdVNlcnZlcjtcbiAgICB0aGlzLmVkZ2VOYW1lID0gc2Z1U2VydmVyLmVkZ2VfbmFtZTtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydzZnUtY2xpZW50J10pO1xuICAgIGNvbnN0IGxvZ0ludGVyY2VwdG9yOiBScGNJbnRlcmNlcHRvciA9IHtcbiAgICAgIGludGVyY2VwdFVuYXJ5OiAoXG4gICAgICAgIG5leHQ6IE5leHRVbmFyeUZuLFxuICAgICAgICBtZXRob2Q6IE1ldGhvZEluZm8sXG4gICAgICAgIGlucHV0OiBvYmplY3QsXG4gICAgICAgIG9wdGlvbnM6IFJwY09wdGlvbnMsXG4gICAgICApOiBVbmFyeUNhbGwgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlcigndHJhY2UnLCBgQ2FsbGluZyBTRlUgUlBDIG1ldGhvZCAke21ldGhvZC5uYW1lfWAsIHtcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5leHQobWV0aG9kLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy5ycGMgPSBjcmVhdGVTaWduYWxDbGllbnQoe1xuICAgICAgYmFzZVVybDogc2Z1U2VydmVyLnVybCxcbiAgICAgIGludGVyY2VwdG9yczogW1xuICAgICAgICB3aXRoSGVhZGVycyh7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIH0pLFxuICAgICAgICBsb2dJbnRlcmNlcHRvcixcbiAgICAgIF0sXG4gICAgfSk7XG5cbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0aGUgSUNFVHJpY2tsZSBraW5kIG9mIGV2ZW50cy5cbiAgICAvLyBUaGVzZSBldmVudHMgbWlnaHQgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBTRlUgYmVmb3JlIHRoZSBpbml0aWFsIFJUQ1xuICAgIC8vIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuIEluIHRoYXQgY2FzZSwgdGhvc2UgZXZlbnRzIChJQ0UgY2FuZGlkYXRlcylcbiAgICAvLyBuZWVkIHRvIGJlIGJ1ZmZlcmVkIGFuZCBsYXRlciBhZGRlZCB0byB0aGUgYXBwcm9wcmlhdGUgUGVlckNvbm5lY3Rpb25cbiAgICAvLyBvbmNlIHRoZSByZW1vdGVEZXNjcmlwdGlvbiBpcyBrbm93biBhbmQgc2V0LlxuICAgIHRoaXMudW5zdWJzY3JpYmVJY2VUcmlja2xlID0gZGlzcGF0Y2hlci5vbignaWNlVHJpY2tsZScsIChpY2VUcmlja2xlKSA9PiB7XG4gICAgICB0aGlzLmljZVRyaWNrbGVCdWZmZXIucHVzaChpY2VUcmlja2xlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuc2lnbmFsV3MgPSBjcmVhdGVXZWJTb2NrZXRTaWduYWxDaGFubmVsKHtcbiAgICAgIGVuZHBvaW50OiBzZnVTZXJ2ZXIud3NfZW5kcG9pbnQsXG4gICAgICBvbk1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrKCk7XG4gICAgICAgIGRpc3BhdGNoZXIuZGlzcGF0Y2gobWVzc2FnZSk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5zaWduYWxSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBvbk9wZW4gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2lnbmFsV3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIG9uT3Blbik7XG4gICAgICAgIHRoaXMua2VlcEFsaXZlKCk7XG4gICAgICAgIHJlc29sdmUodGhpcy5zaWduYWxXcyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zaWduYWxXcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgb25PcGVuKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlID0gKGNvZGU6IG51bWJlciwgcmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgQ2xvc2luZyBTRlUgV1MgY29ubmVjdGlvbjogJHtjb2RlfSAtICR7cmVhc29ufWApO1xuICAgIGlmICh0aGlzLnNpZ25hbFdzLnJlYWR5U3RhdGUgIT09IHRoaXMuc2lnbmFsV3MuQ0xPU0VEKSB7XG4gICAgICB0aGlzLnNpZ25hbFdzLmNsb3NlKGNvZGUsIGBqcy1jbGllbnQ6ICR7cmVhc29ufWApO1xuICAgIH1cblxuICAgIHRoaXMudW5zdWJzY3JpYmVJY2VUcmlja2xlKCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0KTtcbiAgfTtcblxuICB1cGRhdGVTdWJzY3JpcHRpb25zID0gYXN5bmMgKHN1YnNjcmlwdGlvbnM6IFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1tdKSA9PiB7XG4gICAgcmV0dXJuIHJldHJ5YWJsZShcbiAgICAgICgpID0+XG4gICAgICAgIHRoaXMucnBjLnVwZGF0ZVN1YnNjcmlwdGlvbnMoe1xuICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgdHJhY2tzOiBzdWJzY3JpcHRpb25zLFxuICAgICAgICB9KSxcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICk7XG4gIH07XG5cbiAgc2V0UHVibGlzaGVyID0gYXN5bmMgKGRhdGE6IE9taXQ8U2V0UHVibGlzaGVyUmVxdWVzdCwgJ3Nlc3Npb25JZCc+KSA9PiB7XG4gICAgcmV0dXJuIHJldHJ5YWJsZShcbiAgICAgICgpID0+XG4gICAgICAgIHRoaXMucnBjLnNldFB1Ymxpc2hlcih7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICB9KSxcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICk7XG4gIH07XG5cbiAgc2VuZEFuc3dlciA9IGFzeW5jIChkYXRhOiBPbWl0PFNlbmRBbnN3ZXJSZXF1ZXN0LCAnc2Vzc2lvbklkJz4pID0+IHtcbiAgICByZXR1cm4gcmV0cnlhYmxlKFxuICAgICAgKCkgPT5cbiAgICAgICAgdGhpcy5ycGMuc2VuZEFuc3dlcih7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICB9KSxcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICk7XG4gIH07XG5cbiAgaWNlVHJpY2tsZSA9IGFzeW5jIChkYXRhOiBPbWl0PElDRVRyaWNrbGUsICdzZXNzaW9uSWQnPikgPT4ge1xuICAgIHJldHVybiByZXRyeWFibGUoXG4gICAgICAoKSA9PlxuICAgICAgICB0aGlzLnJwYy5pY2VUcmlja2xlKHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgIH0pLFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgKTtcbiAgfTtcblxuICBpY2VSZXN0YXJ0ID0gYXN5bmMgKGRhdGE6IE9taXQ8SUNFUmVzdGFydFJlcXVlc3QsICdzZXNzaW9uSWQnPikgPT4ge1xuICAgIHJldHVybiByZXRyeWFibGUoXG4gICAgICAoKSA9PlxuICAgICAgICB0aGlzLnJwYy5pY2VSZXN0YXJ0KHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgIH0pLFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgKTtcbiAgfTtcblxuICB1cGRhdGVNdXRlU3RhdGUgPSBhc3luYyAodHJhY2tUeXBlOiBUcmFja1R5cGUsIG11dGVkOiBib29sZWFuKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlTXV0ZVN0YXRlcyh7XG4gICAgICBtdXRlU3RhdGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0cmFja1R5cGUsXG4gICAgICAgICAgbXV0ZWQsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pO1xuICB9O1xuXG4gIHVwZGF0ZU11dGVTdGF0ZXMgPSBhc3luYyAoXG4gICAgZGF0YTogT21pdDxVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCwgJ3Nlc3Npb25JZCc+LFxuICApID0+IHtcbiAgICByZXR1cm4gcmV0cnlhYmxlKFxuICAgICAgKCkgPT5cbiAgICAgICAgdGhpcy5ycGMudXBkYXRlTXV0ZVN0YXRlcyh7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICB9KSxcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICk7XG4gIH07XG5cbiAgc2VuZFN0YXRzID0gYXN5bmMgKHN0YXRzOiBPbWl0PFNlbmRTdGF0c1JlcXVlc3QsICdzZXNzaW9uSWQnPikgPT4ge1xuICAgIHJldHVybiByZXRyeWFibGUoXG4gICAgICAoKSA9PlxuICAgICAgICB0aGlzLnJwYy5zZW5kU3RhdHMoe1xuICAgICAgICAgIC4uLnN0YXRzLFxuICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgIH0pLFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgKTtcbiAgfTtcblxuICBqb2luID0gYXN5bmMgKGRhdGE6IE9taXQ8Sm9pblJlcXVlc3QsICdzZXNzaW9uSWQnIHwgJ3Rva2VuJz4pID0+IHtcbiAgICBjb25zdCBqb2luUmVxdWVzdCA9IEpvaW5SZXF1ZXN0LmNyZWF0ZSh7XG4gICAgICAuLi5kYXRhLFxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgIHRva2VuOiB0aGlzLnRva2VuLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmQoXG4gICAgICBTZnVSZXF1ZXN0LmNyZWF0ZSh7XG4gICAgICAgIHJlcXVlc3RQYXlsb2FkOiB7XG4gICAgICAgICAgb25lb2ZLaW5kOiAnam9pblJlcXVlc3QnLFxuICAgICAgICAgIGpvaW5SZXF1ZXN0LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgfTtcblxuICBzZW5kID0gYXN5bmMgKG1lc3NhZ2U6IFNmdVJlcXVlc3QpID0+IHtcbiAgICByZXR1cm4gdGhpcy5zaWduYWxSZWFkeS50aGVuKChzaWduYWwpID0+IHtcbiAgICAgIGlmIChzaWduYWwucmVhZHlTdGF0ZSAhPT0gc2lnbmFsLk9QRU4pIHJldHVybjtcbiAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAnZGVidWcnLFxuICAgICAgICBgU2VuZGluZyBtZXNzYWdlIHRvOiAke3RoaXMuZWRnZU5hbWV9YCxcbiAgICAgICAgU2Z1UmVxdWVzdC50b0pzb24obWVzc2FnZSksXG4gICAgICApO1xuICAgICAgc2lnbmFsLnNlbmQoU2Z1UmVxdWVzdC50b0JpbmFyeShtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBrZWVwQWxpdmUgPSAoKSA9PiB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICB0aGlzLmtlZXBBbGl2ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIoJ3RyYWNlJywgJ1NlbmRpbmcgaGVhbHRoQ2hlY2tSZXF1ZXN0IHRvIFNGVScpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFNmdVJlcXVlc3QuY3JlYXRlKHtcbiAgICAgICAgcmVxdWVzdFBheWxvYWQ6IHtcbiAgICAgICAgICBvbmVvZktpbmQ6ICdoZWFsdGhDaGVja1JlcXVlc3QnLFxuICAgICAgICAgIGhlYWx0aENoZWNrUmVxdWVzdDoge30sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VuZChtZXNzYWdlKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnRXJyb3Igc2VuZGluZyBoZWFsdGhDaGVja1JlcXVlc3QgdG8gU0ZVJywgZSk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbEluTXMpO1xuICB9O1xuXG4gIHByaXZhdGUgc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2sgPSAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCk7XG4gICAgdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5sYXN0TWVzc2FnZVRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0TWVzc2FnZSA9XG4gICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RNZXNzYWdlVGltZXN0YW1wLmdldFRpbWUoKTtcblxuICAgICAgICBpZiAodGltZVNpbmNlTGFzdE1lc3NhZ2UgPiB0aGlzLnVuaGVhbHRoeVRpbWVvdXRJbk1zKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZShcbiAgICAgICAgICAgIFN0cmVhbVNmdUNsaWVudC5FUlJPUl9DT05ORUNUSU9OX1VOSEVBTFRIWSxcbiAgICAgICAgICAgIGBTRlUgY29ubmVjdGlvbiB1bmhlYWx0aHkuIERpZG4ndCByZWNlaXZlIGFueSBtZXNzYWdlIGZvciAke3RoaXMudW5oZWFsdGh5VGltZW91dEluTXN9bXNgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzLnVuaGVhbHRoeVRpbWVvdXRJbk1zKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBbiBpbnRlcm5hbCBpbnRlcmZhY2Ugd2hpY2ggYXNzZXJ0cyB0aGF0IFwicmV0cnlhYmxlXCIgU0ZVIHJlc3BvbnNlc1xuICogY29udGFpbiBhIGZpZWxkIGNhbGxlZCBcImVycm9yXCIuXG4gKiBJZGVhbGx5LCB0aGlzIHNob3VsZCBiZSBjb21pbmcgZnJvbSB0aGUgUHJvdG9idWYgZGVmaW5pdGlvbnMuXG4gKi9cbmludGVyZmFjZSBTZnVSZXNwb25zZVdpdGhFcnJvciB7XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBlcnJvciBmaWVsZCB3aGljaCBzaG91bGQgYmUgcHJlc2VudCBpbiBhbGwgU0ZVIHJlc3BvbnNlcy5cbiAgICovXG4gIGVycm9yPzogU2Z1RXJyb3I7XG59XG5cbmNvbnN0IE1BWF9SRVRSSUVTID0gNTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvc3VyZSB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gUlBDIGNhbGwgYW5kIHJldHJpZXMgaW52b2tpbmdcbiAqIHRoZSBSUEMgdW50aWwgaXQgc3VjY2VlZHMgb3IgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgaXMgcmVhY2hlZC5cbiAqXG4gKiBCZXR3ZWVuIGVhY2ggcmV0cnksIHRoZXJlIHdvdWxkIGJlIGEgcmFuZG9tIGRlbGF5IGluIG9yZGVyIHRvIGF2b2lkXG4gKiByZXF1ZXN0IGJ1cnN0cyB0b3dhcmRzIHRoZSBTRlUuXG4gKlxuICogQHBhcmFtIHJwYyB0aGUgY2xvc3VyZSBhcm91bmQgdGhlIFJQQyBjYWxsIHRvIGV4ZWN1dGUuXG4gKiBAcGFyYW0gbG9nZ2VyIGEgbG9nZ2VyIGluc3RhbmNlIHRvIHVzZS5cbiAqIEBwYXJhbSA8ST4gdGhlIHR5cGUgb2YgdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIDxPPiB0aGUgdHlwZSBvZiB0aGUgcmVzcG9uc2Ugb2JqZWN0LlxuICovXG5jb25zdCByZXRyeWFibGUgPSBhc3luYyA8SSBleHRlbmRzIG9iamVjdCwgTyBleHRlbmRzIFNmdVJlc3BvbnNlV2l0aEVycm9yPihcbiAgcnBjOiAoKSA9PiBVbmFyeUNhbGw8SSwgTz4sXG4gIGxvZ2dlcjogTG9nZ2VyLFxuKSA9PiB7XG4gIGxldCByZXRyeUF0dGVtcHQgPSAwO1xuICBsZXQgcnBjQ2FsbFJlc3VsdDogRmluaXNoZWRVbmFyeUNhbGw8SSwgTz47XG4gIGRvIHtcbiAgICAvLyBkb24ndCBkZWxheSB0aGUgZmlyc3QgaW52b2NhdGlvblxuICAgIGlmIChyZXRyeUF0dGVtcHQgPiAwKSB7XG4gICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHJldHJ5QXR0ZW1wdCkpO1xuICAgIH1cblxuICAgIHJwY0NhbGxSZXN1bHQgPSBhd2FpdCBycGMoKTtcbiAgICBsb2dnZXIoXG4gICAgICAndHJhY2UnLFxuICAgICAgYFNGVSBSUEMgcmVzcG9uc2UgcmVjZWl2ZWQgZm9yICR7cnBjQ2FsbFJlc3VsdC5tZXRob2QubmFtZX1gLFxuICAgICAgcnBjQ2FsbFJlc3VsdCxcbiAgICApO1xuXG4gICAgLy8gaWYgdGhlIFJQQyBjYWxsIGZhaWxlZCwgbG9nIHRoZSBlcnJvciBhbmQgcmV0cnlcbiAgICBpZiAocnBjQ2FsbFJlc3VsdC5yZXNwb25zZS5lcnJvcikge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICAnZXJyb3InLFxuICAgICAgICBgU0ZVIFJQQyBFcnJvciAoJHtycGNDYWxsUmVzdWx0Lm1ldGhvZC5uYW1lfSk6YCxcbiAgICAgICAgcnBjQ2FsbFJlc3VsdC5yZXNwb25zZS5lcnJvcixcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHJ5QXR0ZW1wdCsrO1xuICB9IHdoaWxlIChcbiAgICBycGNDYWxsUmVzdWx0LnJlc3BvbnNlLmVycm9yPy5zaG91bGRSZXRyeSAmJlxuICAgIHJldHJ5QXR0ZW1wdCA8IE1BWF9SRVRSSUVTXG4gICk7XG5cbiAgaWYgKHJwY0NhbGxSZXN1bHQucmVzcG9uc2UuZXJyb3IpIHtcbiAgICB0aHJvdyBycGNDYWxsUmVzdWx0LnJlc3BvbnNlLmVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJwY0NhbGxSZXN1bHQ7XG59O1xuIiwiaW1wb3J0IHsgQ2FsbGluZ1N0YXRlIH0gZnJvbSAnLi4vc3RvcmUnO1xuaW1wb3J0IHsgQ2FsbCB9IGZyb20gJy4uL0NhbGwnO1xuaW1wb3J0IHR5cGUgeyBDYWxsQWNjZXB0ZWRFdmVudCwgQ2FsbFJlamVjdGVkRXZlbnQgfSBmcm9tICcuLi9nZW4vY29vcmRpbmF0b3InO1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgdGhhdCB3YXRjaGVkIHRoZSBkZWxpdmVyeSBvZiBgY2FsbC5hY2NlcHRlZGAuXG4gKiBPbmNlIHRoZSBldmVudCBpcyByZWNlaXZlZCwgdGhlIGNhbGwgaXMgam9pbmVkLlxuICovXG5leHBvcnQgY29uc3Qgd2F0Y2hDYWxsQWNjZXB0ZWQgPSAoY2FsbDogQ2FsbCkgPT4ge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gb25DYWxsQWNjZXB0ZWQoZXZlbnQ6IENhbGxBY2NlcHRlZEV2ZW50KSB7XG4gICAgLy8gV2Ugd2FudCB0byBkaXNjYXJkIHRoZSBldmVudCBpZiBpdCdzIGZyb20gdGhlIGN1cnJlbnQgdXNlclxuICAgIGlmIChldmVudC51c2VyLmlkID09PSBjYWxsLmN1cnJlbnRVc2VySWQpIHJldHVybjtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjYWxsO1xuICAgIGlmIChcbiAgICAgIGV2ZW50LmNhbGwuY3JlYXRlZF9ieS5pZCA9PT0gY2FsbC5jdXJyZW50VXNlcklkICYmXG4gICAgICBzdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HXG4gICAgKSB7XG4gICAgICBhd2FpdCBjYWxsLmpvaW4oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgdGhhdCB3YXRjaGVzIGRlbGl2ZXJ5IG9mIGBjYWxsLnJlamVjdGVkYCBXZWJzb2NrZXQgZXZlbnQuXG4gKiBPbmNlIHRoZSBldmVudCBpcyByZWNlaXZlZCwgdGhlIGNhbGwgaXMgbGVmdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdhdGNoQ2FsbFJlamVjdGVkID0gKGNhbGw6IENhbGwpID0+IHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIG9uQ2FsbFJlamVjdGVkKGV2ZW50OiBDYWxsUmVqZWN0ZWRFdmVudCkge1xuICAgIC8vIFdlIHdhbnQgdG8gZGlzY2FyZCB0aGUgZXZlbnQgaWYgaXQncyBmcm9tIHRoZSBjdXJyZW50IHVzZXJcbiAgICBpZiAoZXZlbnQudXNlci5pZCA9PT0gY2FsbC5jdXJyZW50VXNlcklkKSByZXR1cm47XG4gICAgY29uc3QgeyBjYWxsOiBldmVudENhbGwgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgc2Vzc2lvbjogY2FsbFNlc3Npb24gfSA9IGV2ZW50Q2FsbDtcblxuICAgIGlmICghY2FsbFNlc3Npb24pIHtcbiAgICAgIGNhbGwubG9nZ2VyKFxuICAgICAgICAnd2FybicsXG4gICAgICAgICdObyBjYWxsIHNlc3Npb24gcHJvdmlkZWQuIElnbm9yaW5nIGNhbGwucmVqZWN0ZWQgZXZlbnQuJyxcbiAgICAgICAgZXZlbnQsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlamVjdGVkQnkgPSBjYWxsU2Vzc2lvbi5yZWplY3RlZF9ieTtcbiAgICBjb25zdCB7IG1lbWJlcnMsIGNhbGxpbmdTdGF0ZSB9ID0gY2FsbC5zdGF0ZTtcbiAgICBpZiAoY2FsbGluZ1N0YXRlICE9PSBDYWxsaW5nU3RhdGUuUklOR0lORykge1xuICAgICAgY2FsbC5sb2dnZXIoXG4gICAgICAgICdpbmZvJyxcbiAgICAgICAgJ0NhbGwgaXMgbm90IGluIHJpbmdpbmcgbW9kZSAoaXQgaXMgZWl0aGVyIGFjY2VwdGVkIG9yIHJlamVjdGVkIGFscmVhZHkpLiBJZ25vcmluZyBjYWxsLnJlamVjdGVkIGV2ZW50LicsXG4gICAgICAgIGV2ZW50LFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbGwuaXNDcmVhdGVkQnlNZSkge1xuICAgICAgY29uc3QgZXZlcnlvbmVFbHNlUmVqZWN0ZWQgPSBtZW1iZXJzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+IG0udXNlcl9pZCAhPT0gY2FsbC5jdXJyZW50VXNlcklkKVxuICAgICAgICAuZXZlcnkoKG0pID0+IHJlamVjdGVkQnlbbS51c2VyX2lkXSk7XG4gICAgICBpZiAoZXZlcnlvbmVFbHNlUmVqZWN0ZWQpIHtcbiAgICAgICAgY2FsbC5sb2dnZXIoJ2luZm8nLCAnZXZlcnlvbmUgcmVqZWN0ZWQsIGxlYXZpbmcgdGhlIGNhbGwnKTtcbiAgICAgICAgYXdhaXQgY2FsbC5sZWF2ZSh7IHJlYXNvbjogJ3Jpbmc6IGV2ZXJ5b25lIHJlamVjdGVkJyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlamVjdGVkQnlbZXZlbnRDYWxsLmNyZWF0ZWRfYnkuaWRdKSB7XG4gICAgICAgIGNhbGwubG9nZ2VyKCdpbmZvJywgJ2NhbGwgY3JlYXRvciByZWplY3RlZCwgbGVhdmluZyBjYWxsJyk7XG4gICAgICAgIGF3YWl0IGNhbGwubGVhdmUoeyByZWFzb246ICdyaW5nOiBjcmVhdG9yIHJlamVjdGVkJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgdGhhdCB3YXRjaGVzIHRoZSBkZWxpdmVyeSBvZiBgY2FsbC5lbmRlZGAgV2Vic29ja2V0IGV2ZW50LlxuICovXG5leHBvcnQgY29uc3Qgd2F0Y2hDYWxsRW5kZWQgPSAoY2FsbDogQ2FsbCkgPT4ge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gb25DYWxsRW5kZWQoKSB7XG4gICAgY29uc3QgeyBjYWxsaW5nU3RhdGUgfSA9IGNhbGwuc3RhdGU7XG4gICAgaWYgKFxuICAgICAgY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUklOR0lORyB8fFxuICAgICAgY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEIHx8XG4gICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lOSU5HXG4gICAgKSB7XG4gICAgICBhd2FpdCBjYWxsLmxlYXZlKHsgcmVhc29uOiAnY2FsbC5lbmRlZCBldmVudCByZWNlaXZlZCcgfSk7XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCB7IENhbGxTdGF0ZSB9IGZyb20gJy4uL3N0b3JlJztcbmltcG9ydCB0eXBlIHsgQ2FsbEdyYW50c1VwZGF0ZWQgfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L2V2ZW50L2V2ZW50cyc7XG5pbXBvcnQgeyBPd25DYXBhYmlsaXR5IH0gZnJvbSAnLi4vZ2VuL2Nvb3JkaW5hdG9yJztcblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyIHRoYXQgd2F0Y2hlcyBmb3IgYGNhbGxHcmFudHNVcGRhdGVkYCBldmVudHMuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjYWxsIHN0YXRlIHRvIHVwZGF0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHdhdGNoQ2FsbEdyYW50c1VwZGF0ZWQgPSAoc3RhdGU6IENhbGxTdGF0ZSkgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gb25DYWxsR3JhbnRzVXBkYXRlZChldmVudDogQ2FsbEdyYW50c1VwZGF0ZWQpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRHcmFudHMgfSA9IGV2ZW50O1xuICAgIGlmIChjdXJyZW50R3JhbnRzKSB7XG4gICAgICBjb25zdCB7IGNhblB1Ymxpc2hBdWRpbywgY2FuUHVibGlzaFZpZGVvLCBjYW5TY3JlZW5zaGFyZSB9ID1cbiAgICAgICAgY3VycmVudEdyYW50cztcblxuICAgICAgY29uc3QgdXBkYXRlOiBQYXJ0aWFsPFJlY29yZDxPd25DYXBhYmlsaXR5LCBib29sZWFuPj4gPSB7XG4gICAgICAgIFtPd25DYXBhYmlsaXR5LlNFTkRfQVVESU9dOiBjYW5QdWJsaXNoQXVkaW8sXG4gICAgICAgIFtPd25DYXBhYmlsaXR5LlNFTkRfVklERU9dOiBjYW5QdWJsaXNoVmlkZW8sXG4gICAgICAgIFtPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFXTogY2FuU2NyZWVuc2hhcmUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXh0Q2FwYWJpbGl0aWVzID0gc3RhdGUub3duQ2FwYWJpbGl0aWVzLmZpbHRlcihcbiAgICAgICAgKGNhcGFiaWxpdHkpID0+IHVwZGF0ZVtjYXBhYmlsaXR5XSAhPT0gZmFsc2UsXG4gICAgICApO1xuICAgICAgT2JqZWN0LmVudHJpZXModXBkYXRlKS5mb3JFYWNoKChbY2FwYWJpbGl0eSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbmV4dENhcGFiaWxpdGllcy5pbmNsdWRlcyhjYXBhYmlsaXR5IGFzIE93bkNhcGFiaWxpdHkpKSB7XG4gICAgICAgICAgbmV4dENhcGFiaWxpdGllcy5wdXNoKGNhcGFiaWxpdHkgYXMgT3duQ2FwYWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMobmV4dENhcGFiaWxpdGllcyk7XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCB7IERpc3BhdGNoZXIgfSBmcm9tICcuLi9ydGMnO1xuaW1wb3J0IHsgQ2FsbCB9IGZyb20gJy4uL0NhbGwnO1xuaW1wb3J0IHsgQ2FsbFN0YXRlIH0gZnJvbSAnLi4vc3RvcmUnO1xuaW1wb3J0IHsgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudFBhdGNoZXMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBQaW5zQ2hhbmdlZCB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvZXZlbnQvZXZlbnRzJztcbmltcG9ydCB7IEVycm9yQ29kZSB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvbW9kZWxzL21vZGVscyc7XG5pbXBvcnQgeyBPd25DYXBhYmlsaXR5IH0gZnJvbSAnLi4vZ2VuL2Nvb3JkaW5hdG9yJztcblxuY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnZXZlbnRzJ10pO1xuXG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgY2hhbmdlUHVibGlzaFF1YWxpdHlgIGV2ZW50LlxuICovXG5leHBvcnQgY29uc3Qgd2F0Y2hDaGFuZ2VQdWJsaXNoUXVhbGl0eSA9IChcbiAgZGlzcGF0Y2hlcjogRGlzcGF0Y2hlcixcbiAgY2FsbDogQ2FsbCxcbikgPT4ge1xuICByZXR1cm4gZGlzcGF0Y2hlci5vbignY2hhbmdlUHVibGlzaFF1YWxpdHknLCAoZSkgPT4ge1xuICAgIGNvbnN0IHsgdmlkZW9TZW5kZXJzIH0gPSBlO1xuICAgIHZpZGVvU2VuZGVycy5mb3JFYWNoKCh2aWRlb1NlbmRlcikgPT4ge1xuICAgICAgY29uc3QgeyBsYXllcnMgfSA9IHZpZGVvU2VuZGVyO1xuICAgICAgY2FsbC51cGRhdGVQdWJsaXNoUXVhbGl0eShsYXllcnMuZmlsdGVyKChsKSA9PiBsLmFjdGl2ZSkpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCB3YXRjaENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IChcbiAgZGlzcGF0Y2hlcjogRGlzcGF0Y2hlcixcbiAgc3RhdGU6IENhbGxTdGF0ZSxcbikgPT4ge1xuICByZXR1cm4gZGlzcGF0Y2hlci5vbignY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJywgKGUpID0+IHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcyB9ID0gZTtcbiAgICBpZiAoIWNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcykgcmV0dXJuO1xuICAgIHN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50cyhcbiAgICAgIGNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcy5yZWR1Y2U8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudFBhdGNoZXM+KFxuICAgICAgICAocGF0Y2hlcywgdXBkYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQsIGNvbm5lY3Rpb25RdWFsaXR5IH0gPSB1cGRhdGU7XG4gICAgICAgICAgcGF0Y2hlc1tzZXNzaW9uSWRdID0ge1xuICAgICAgICAgICAgY29ubmVjdGlvblF1YWxpdHksXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICAgICAgfSxcbiAgICAgICAge30sXG4gICAgICApLFxuICAgICk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjYWxsIGJ5IHBlZWtpbmcgYXQgdGhlXG4gKiBoZWFsdGggY2hlY2sgZXZlbnRzIHRoYXQgb3VyIFNGVSBzZW5kcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHdhdGNoUGFydGljaXBhbnRDb3VudENoYW5nZWQgPSAoXG4gIGRpc3BhdGNoZXI6IERpc3BhdGNoZXIsXG4gIHN0YXRlOiBDYWxsU3RhdGUsXG4pID0+IHtcbiAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2hlYWx0aENoZWNrUmVzcG9uc2UnLCAoZSkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnRDb3VudCB9ID0gZTtcbiAgICBpZiAocGFydGljaXBhbnRDb3VudCkge1xuICAgICAgc3RhdGUuc2V0UGFydGljaXBhbnRDb3VudChwYXJ0aWNpcGFudENvdW50LnRvdGFsKTtcbiAgICAgIHN0YXRlLnNldEFub255bW91c1BhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudC5hbm9ueW1vdXMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3Qgd2F0Y2hMaXZlRW5kZWQgPSAoZGlzcGF0Y2hlcjogRGlzcGF0Y2hlciwgY2FsbDogQ2FsbCkgPT4ge1xuICByZXR1cm4gZGlzcGF0Y2hlci5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgIGlmIChlLmVycm9yICYmIGUuZXJyb3IuY29kZSAhPT0gRXJyb3JDb2RlLkxJVkVfRU5ERUQpIHJldHVybjtcblxuICAgIGlmICghY2FsbC5wZXJtaXNzaW9uc0NvbnRleHQuaGFzUGVybWlzc2lvbihPd25DYXBhYmlsaXR5LkpPSU5fQkFDS1NUQUdFKSkge1xuICAgICAgY2FsbC5sZWF2ZSh7IHJlYXNvbjogJ2xpdmUgZW5kZWQnIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gbGVhdmUgY2FsbCBhZnRlciBsaXZlIGVuZGVkJywgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFdhdGNoZXMgYW5kIGxvZ3MgdGhlIGVycm9ycyByZXBvcnRlZCBieSB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTRlUuXG4gKi9cbmV4cG9ydCBjb25zdCB3YXRjaFNmdUVycm9yUmVwb3J0cyA9IChkaXNwYXRjaGVyOiBEaXNwYXRjaGVyKSA9PiB7XG4gIHJldHVybiBkaXNwYXRjaGVyLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgaWYgKCFlLmVycm9yKSByZXR1cm47XG4gICAgY29uc3QgeyBlcnJvciB9ID0gZTtcbiAgICBsb2dnZXIoJ2Vycm9yJywgJ1NGVSByZXBvcnRlZCBlcnJvcicsIHtcbiAgICAgIGNvZGU6IEVycm9yQ29kZVtlcnJvci5jb2RlXSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBzaG91bGRSZXRyeTogZXJyb3Iuc2hvdWxkUmV0cnksXG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXYXRjaGVzIGZvciBgcGluc1VwZGF0ZWRgIGV2ZW50cyBhbmQgdXBkYXRlcyB0aGUgcGlubmVkIHN0YXRlIG9mIHBhcnRpY2lwYW50c1xuICogaW4gdGhlIGNhbGwuXG4gKi9cbmV4cG9ydCBjb25zdCB3YXRjaFBpbnNVcGRhdGVkID0gKHN0YXRlOiBDYWxsU3RhdGUpID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uUGluc1VwZGF0ZWQoZTogUGluc0NoYW5nZWQpIHtcbiAgICBjb25zdCB7IHBpbnMgfSA9IGU7XG4gICAgc3RhdGUuc2V0U2VydmVyU2lkZVBpbnMocGlucyk7XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQ2FsbCB9IGZyb20gJy4uL0NhbGwnO1xuaW1wb3J0IHtcbiAgVHJhY2tUeXBlLFxuICBUcmFja1VucHVibGlzaFJlYXNvbixcbn0gZnJvbSAnLi4vZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzJztcblxuLyoqXG4gKiBBbiBldmVudCBoYW5kbGVyIHRoYXQgaGFuZGxlcyBzb2Z0IG11dGVzLlxuICpcbiAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsLlxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlUmVtb3RlU29mdE11dGUgPSAoY2FsbDogQ2FsbCkgPT4ge1xuICByZXR1cm4gY2FsbC5vbigndHJhY2tVbnB1Ymxpc2hlZCcsIGFzeW5jIChldmVudCkgPT4ge1xuICAgIGNvbnN0IHsgY2F1c2UsIHR5cGUsIHNlc3Npb25JZCB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyBsb2NhbFBhcnRpY2lwYW50IH0gPSBjYWxsLnN0YXRlO1xuICAgIGlmIChcbiAgICAgIGNhdXNlID09PSBUcmFja1VucHVibGlzaFJlYXNvbi5NT0RFUkFUSU9OICYmXG4gICAgICBzZXNzaW9uSWQgPT09IGxvY2FsUGFydGljaXBhbnQ/LnNlc3Npb25JZFxuICAgICkge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY2FsbC5sb2dnZXI7XG4gICAgICBsb2dnZXIoXG4gICAgICAgICdpbmZvJyxcbiAgICAgICAgYExvY2FsIHBhcnRpY2lwYW50J3MgJHtUcmFja1R5cGVbdHlwZV19IHRyYWNrIGlzIG11dGVkIHJlbW90ZWx5YCxcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbC5jYW1lcmEuZGlzYWJsZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRyYWNrVHlwZS5BVURJTykge1xuICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5kaXNhYmxlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgJ3dhcm4nLFxuICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIHRyYWNrIHR5cGUgdG8gc29mdCBtdXRlJyxcbiAgICAgICAgICAgIFRyYWNrVHlwZVt0eXBlXSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKHR5cGUpKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbC5zdG9wUHVibGlzaCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gc3RvcCBwdWJsaXNoaW5nJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuIiwiaW1wb3J0IHR5cGUge1xuICBQYXJ0aWNpcGFudEpvaW5lZCxcbiAgUGFydGljaXBhbnRMZWZ0LFxuICBUcmFja1B1Ymxpc2hlZCxcbiAgVHJhY2tVbnB1Ymxpc2hlZCxcbn0gZnJvbSAnLi4vZ2VuL3ZpZGVvL3NmdS9ldmVudC9ldmVudHMnO1xuaW1wb3J0IHsgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCwgVmlzaWJpbGl0eVN0YXRlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgQ2FsbFN0YXRlIH0gZnJvbSAnLi4vc3RvcmUnO1xuXG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgcGFydGljaXBhbnRKb2luZWRgIGV2ZW50LlxuICovXG5leHBvcnQgY29uc3Qgd2F0Y2hQYXJ0aWNpcGFudEpvaW5lZCA9IChzdGF0ZTogQ2FsbFN0YXRlKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBvblBhcnRpY2lwYW50Sm9pbmVkKGU6IFBhcnRpY2lwYW50Sm9pbmVkKSB7XG4gICAgY29uc3QgeyBwYXJ0aWNpcGFudCB9ID0gZTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSByZXR1cm47XG4gICAgLy8gYHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnRgIGFjdHMgYXMgYSBzYWZlZ3VhcmQgYWdhaW5zdFxuICAgIC8vIHBvdGVudGlhbCBkdXBsaWNhdGUgZXZlbnRzIGZyb20gdGhlIFNGVS5cbiAgICAvL1xuICAgIC8vIEFsdGhvdWdoIHRoZSBTRlUgc2hvdWxkIG5vdCBzZW5kIGR1cGxpY2F0ZSBldmVudHMsIHdlIGhhdmUgc2VlblxuICAgIC8vIHNvbWUgcmFjZSBjb25kaXRpb25zIGluIHRoZSBwYXN0IGR1cmluZyB0aGUgYGpvaW4tZmxvd2Agd2hlcmVcbiAgICAvLyB0aGUgU0ZVIHdvdWxkIHNlbmQgcGFydGljaXBhbnQgaW5mbyBhcyBwYXJ0IG9mIHRoZSBgam9pbmBcbiAgICAvLyByZXNwb25zZSBhbmQgdGhlbiBmb2xsb3cgdXAgd2l0aCBhIGBwYXJ0aWNpcGFudEpvaW5lZGAgZXZlbnQgZm9yXG4gICAgLy8gYWxyZWFkeSBhbm5vdW5jZWQgcGFydGljaXBhbnRzLlxuICAgIHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnQoXG4gICAgICBwYXJ0aWNpcGFudC5zZXNzaW9uSWQsXG4gICAgICBPYmplY3QuYXNzaWduPFN0cmVhbVZpZGVvUGFydGljaXBhbnQsIFBhcnRpYWw8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudD4+KFxuICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAge1xuICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlOiB7XG4gICAgICAgICAgICB2aWRlb1RyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbiAgICAgICAgICAgIHNjcmVlblNoYXJlVHJhY2s6IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH07XG59O1xuXG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgcGFydGljaXBhbnRMZWZ0YCBldmVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdhdGNoUGFydGljaXBhbnRMZWZ0ID0gKHN0YXRlOiBDYWxsU3RhdGUpID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uUGFydGljaXBhbnRMZWZ0KGU6IFBhcnRpY2lwYW50TGVmdCkge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQgfSA9IGU7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkgcmV0dXJuO1xuXG4gICAgc3RhdGUuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+XG4gICAgICBwYXJ0aWNpcGFudHMuZmlsdGVyKChwKSA9PiBwLnNlc3Npb25JZCAhPT0gcGFydGljaXBhbnQuc2Vzc2lvbklkKSxcbiAgICApO1xuICB9O1xufTtcblxuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYHRyYWNrUHVibGlzaGVkYCBldmVudC5cbiAqIFRoZSBTRlUgd2lsbCBzZW5kIHRoaXMgZXZlbnQgd2hlbiBhIHBhcnRpY2lwYW50IHB1Ymxpc2hlcyBhIHRyYWNrLlxuICovXG5leHBvcnQgY29uc3Qgd2F0Y2hUcmFja1B1Ymxpc2hlZCA9IChzdGF0ZTogQ2FsbFN0YXRlKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBvblRyYWNrUHVibGlzaGVkKGU6IFRyYWNrUHVibGlzaGVkKSB7XG4gICAgY29uc3QgeyB0eXBlLCBzZXNzaW9uSWQsIHBhcnRpY2lwYW50IH0gPSBlO1xuICAgIC8vIEFuIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgY2FsbHMuXG4gICAgLy8gQWZ0ZXIgYSBjZXJ0YWluIHRocmVzaG9sZCwgdGhlIFNGVSB3b3VsZCBzdG9wIGVtaXR0aW5nIGBwYXJ0aWNpcGFudEpvaW5lZGBcbiAgICAvLyBldmVudHMsIGFuZCBpbnN0ZWFkLCBpdCB3b3VsZCBvbmx5IHByb3ZpZGUgdGhlIHBhcnRpY2lwYW50J3MgaW5mb3JtYXRpb25cbiAgICAvLyBvbmNlIHRoZXkgc3RhcnQgcHVibGlzaGluZyBhIHRyYWNrLlxuICAgIGlmIChwYXJ0aWNpcGFudCkge1xuICAgICAgc3RhdGUudXBkYXRlT3JBZGRQYXJ0aWNpcGFudChzZXNzaW9uSWQsIHBhcnRpY2lwYW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCAocCkgPT4gKHtcbiAgICAgICAgcHVibGlzaGVkVHJhY2tzOiBbLi4ucC5wdWJsaXNoZWRUcmFja3MsIHR5cGVdLmZpbHRlcih1bmlxdWUpLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQW4gZXZlbnQgcmVzcG9uZGVyIHdoaWNoIGhhbmRsZXMgdGhlIGB0cmFja1VucHVibGlzaGVkYCBldmVudC5cbiAqIFRoZSBTRlUgd2lsbCBzZW5kIHRoaXMgZXZlbnQgd2hlbiBhIHBhcnRpY2lwYW50IHVucHVibGlzaGVzIGEgdHJhY2suXG4gKi9cbmV4cG9ydCBjb25zdCB3YXRjaFRyYWNrVW5wdWJsaXNoZWQgPSAoc3RhdGU6IENhbGxTdGF0ZSkgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gb25UcmFja1VucHVibGlzaGVkKGU6IFRyYWNrVW5wdWJsaXNoZWQpIHtcbiAgICBjb25zdCB7IHR5cGUsIHNlc3Npb25JZCwgcGFydGljaXBhbnQgfSA9IGU7XG4gICAgLy8gQW4gb3B0aW1pemF0aW9uIGZvciBsYXJnZSBjYWxscy4gU2VlIGB3YXRjaFRyYWNrUHVibGlzaGVkYC5cbiAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgIHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnQoc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwgKHApID0+ICh7XG4gICAgICAgIHB1Ymxpc2hlZFRyYWNrczogcC5wdWJsaXNoZWRUcmFja3MuZmlsdGVyKCh0KSA9PiB0ICE9PSB0eXBlKSxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCB1bmlxdWUgPSA8VD4odjogVCwgaTogbnVtYmVyLCBhcnI6IFRbXSkgPT4gYXJyLmluZGV4T2YodikgPT09IGk7XG4iLCJpbXBvcnQgeyBEaXNwYXRjaGVyIH0gZnJvbSAnLi4vcnRjJztcbmltcG9ydCB7IENhbGxTdGF0ZSB9IGZyb20gJy4uL3N0b3JlJztcbmltcG9ydCB7IFN0cmVhbVZpZGVvUGFydGljaXBhbnRQYXRjaGVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIFdhdGNoZXMgZm9yIGBkb21pbmFudFNwZWFrZXJDaGFuZ2VkYCBldmVudHMuXG4gKi9cbmV4cG9ydCBjb25zdCB3YXRjaERvbWluYW50U3BlYWtlckNoYW5nZWQgPSAoXG4gIGRpc3BhdGNoZXI6IERpc3BhdGNoZXIsXG4gIHN0YXRlOiBDYWxsU3RhdGUsXG4pID0+IHtcbiAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2RvbWluYW50U3BlYWtlckNoYW5nZWQnLCAoZSkgPT4ge1xuICAgIGNvbnN0IHsgc2Vzc2lvbklkIH0gPSBlO1xuICAgIGlmIChzZXNzaW9uSWQgPT09IHN0YXRlLmRvbWluYW50U3BlYWtlcj8uc2Vzc2lvbklkKSByZXR1cm47XG4gICAgc3RhdGUuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+XG4gICAgICBwYXJ0aWNpcGFudHMubWFwKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAvLyBtYXJrIHRoZSBuZXcgZG9taW5hbnQgc3BlYWtlclxuICAgICAgICBpZiAocGFydGljaXBhbnQuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICBpc0RvbWluYW50U3BlYWtlcjogdHJ1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVubWFyayB0aGUgb2xkIGRvbWluYW50IHNwZWFrZXJcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50LmlzRG9taW5hbnRTcGVha2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgaXNEb21pbmFudFNwZWFrZXI6IGZhbHNlLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50OyAvLyBubyBjaGFuZ2VcbiAgICAgIH0pLFxuICAgICk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXYXRjaGVzIGZvciBgYXVkaW9MZXZlbENoYW5nZWRgIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IHdhdGNoQXVkaW9MZXZlbENoYW5nZWQgPSAoXG4gIGRpc3BhdGNoZXI6IERpc3BhdGNoZXIsXG4gIHN0YXRlOiBDYWxsU3RhdGUsXG4pID0+IHtcbiAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2F1ZGlvTGV2ZWxDaGFuZ2VkJywgKGUpID0+IHtcbiAgICBjb25zdCB7IGF1ZGlvTGV2ZWxzIH0gPSBlO1xuICAgIHN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50cyhcbiAgICAgIGF1ZGlvTGV2ZWxzLnJlZHVjZTxTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2hlcz4oKHBhdGNoZXMsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgcGF0Y2hlc1tjdXJyZW50LnNlc3Npb25JZF0gPSB7XG4gICAgICAgICAgYXVkaW9MZXZlbDogY3VycmVudC5sZXZlbCxcbiAgICAgICAgICBpc1NwZWFraW5nOiBjdXJyZW50LmlzU3BlYWtpbmcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgICAgfSwge30pLFxuICAgICk7XG4gIH0pO1xufTtcbiIsImltcG9ydCB7IENhbGwgfSBmcm9tICcuLi9DYWxsJztcbmltcG9ydCB7IERpc3BhdGNoZXIgfSBmcm9tICcuLi9ydGMnO1xuaW1wb3J0IHsgQ2FsbFN0YXRlIH0gZnJvbSAnLi4vc3RvcmUnO1xuaW1wb3J0IHtcbiAgaGFuZGxlUmVtb3RlU29mdE11dGUsXG4gIHdhdGNoQXVkaW9MZXZlbENoYW5nZWQsXG4gIHdhdGNoQ2FsbEFjY2VwdGVkLFxuICB3YXRjaENhbGxFbmRlZCxcbiAgd2F0Y2hDYWxsR3JhbnRzVXBkYXRlZCxcbiAgd2F0Y2hDYWxsUmVqZWN0ZWQsXG4gIHdhdGNoQ2hhbmdlUHVibGlzaFF1YWxpdHksXG4gIHdhdGNoQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLFxuICB3YXRjaERvbWluYW50U3BlYWtlckNoYW5nZWQsXG4gIHdhdGNoTGl2ZUVuZGVkLFxuICB3YXRjaFBhcnRpY2lwYW50Q291bnRDaGFuZ2VkLFxuICB3YXRjaFBhcnRpY2lwYW50Sm9pbmVkLFxuICB3YXRjaFBhcnRpY2lwYW50TGVmdCxcbiAgd2F0Y2hQaW5zVXBkYXRlZCxcbiAgd2F0Y2hTZnVFcnJvclJlcG9ydHMsXG4gIHdhdGNoVHJhY2tQdWJsaXNoZWQsXG4gIHdhdGNoVHJhY2tVbnB1Ymxpc2hlZCxcbn0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7XG4gIEFsbENhbGxFdmVudHMsXG4gIEFsbENsaWVudENhbGxFdmVudHMsXG4gIENhbGxFdmVudExpc3RlbmVyLFxufSBmcm9tICcuLi9jb29yZGluYXRvci9jb25uZWN0aW9uL3R5cGVzJztcblxudHlwZSBSaW5nQ2FsbEV2ZW50cyA9IEV4dHJhY3Q8XG4gIEFsbENsaWVudENhbGxFdmVudHMsXG4gICdjYWxsLmFjY2VwdGVkJyB8ICdjYWxsLnJlamVjdGVkJ1xuPjtcblxuLyoqXG4gKiBSZWdpc3RlcnMgdGhlIGRlZmF1bHQgZXZlbnQgaGFuZGxlcnMgZm9yIGEgY2FsbCBkdXJpbmcgaXRzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0gY2FsbCB0aGUgY2FsbCB0byByZWdpc3RlciBldmVudCBoYW5kbGVycyBmb3IuXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGNhbGwgc3RhdGUuXG4gKiBAcGFyYW0gZGlzcGF0Y2hlciB0aGUgZGlzcGF0Y2hlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IChcbiAgY2FsbDogQ2FsbCxcbiAgc3RhdGU6IENhbGxTdGF0ZSxcbiAgZGlzcGF0Y2hlcjogRGlzcGF0Y2hlcixcbikgPT4ge1xuICBjb25zdCBldmVudEhhbmRsZXJzID0gW1xuICAgIGNhbGwub24oJ2NhbGwuZW5kZWQnLCB3YXRjaENhbGxFbmRlZChjYWxsKSksXG5cbiAgICB3YXRjaExpdmVFbmRlZChkaXNwYXRjaGVyLCBjYWxsKSxcbiAgICB3YXRjaFNmdUVycm9yUmVwb3J0cyhkaXNwYXRjaGVyKSxcbiAgICB3YXRjaENoYW5nZVB1Ymxpc2hRdWFsaXR5KGRpc3BhdGNoZXIsIGNhbGwpLFxuICAgIHdhdGNoQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICB3YXRjaFBhcnRpY2lwYW50Q291bnRDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcblxuICAgIGNhbGwub24oJ3BhcnRpY2lwYW50Sm9pbmVkJywgd2F0Y2hQYXJ0aWNpcGFudEpvaW5lZChzdGF0ZSkpLFxuICAgIGNhbGwub24oJ3BhcnRpY2lwYW50TGVmdCcsIHdhdGNoUGFydGljaXBhbnRMZWZ0KHN0YXRlKSksXG5cbiAgICBjYWxsLm9uKCd0cmFja1B1Ymxpc2hlZCcsIHdhdGNoVHJhY2tQdWJsaXNoZWQoc3RhdGUpKSxcbiAgICBjYWxsLm9uKCd0cmFja1VucHVibGlzaGVkJywgd2F0Y2hUcmFja1VucHVibGlzaGVkKHN0YXRlKSksXG5cbiAgICB3YXRjaEF1ZGlvTGV2ZWxDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICB3YXRjaERvbWluYW50U3BlYWtlckNoYW5nZWQoZGlzcGF0Y2hlciwgc3RhdGUpLFxuXG4gICAgY2FsbC5vbignY2FsbEdyYW50c1VwZGF0ZWQnLCB3YXRjaENhbGxHcmFudHNVcGRhdGVkKHN0YXRlKSksXG4gICAgY2FsbC5vbigncGluc1VwZGF0ZWQnLCB3YXRjaFBpbnNVcGRhdGVkKHN0YXRlKSksXG5cbiAgICBoYW5kbGVSZW1vdGVTb2Z0TXV0ZShjYWxsKSxcbiAgXTtcblxuICBpZiAoY2FsbC5yaW5naW5nKSB7XG4gICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBvbmx5IHJlbGV2YW50IHdoZW4gdGhlIGNhbGwgaXMgcmluZ2luZ1xuICAgIGV2ZW50SGFuZGxlcnMucHVzaChyZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyhjYWxsKSk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgZXZlbnQgaGFuZGxlcnMgZm9yIGEgY2FsbCB0aGF0IGlzIG9mIHJpbmdpbmcgdHlwZS5cbiAqXG4gKiBAcGFyYW0gY2FsbCB0aGUgY2FsbCB0byByZWdpc3RlciBldmVudCBoYW5kbGVycyBmb3IuXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyA9IChjYWxsOiBDYWxsKSA9PiB7XG4gIGNvbnN0IGNvb3JkaW5hdG9yUmluZ0V2ZW50czoge1xuICAgIFtrZXkgaW4gUmluZ0NhbGxFdmVudHNdOiAoXG4gICAgICBjYWxsOiBDYWxsLFxuICAgICkgPT4gQ2FsbEV2ZW50TGlzdGVuZXI8QWxsQ2FsbEV2ZW50c1trZXldPjtcbiAgfSA9IHtcbiAgICAnY2FsbC5hY2NlcHRlZCc6IHdhdGNoQ2FsbEFjY2VwdGVkKGNhbGwpLFxuICAgICdjYWxsLnJlamVjdGVkJzogd2F0Y2hDYWxsUmVqZWN0ZWQoY2FsbCksXG4gIH07XG5cbiAgY29uc3QgZXZlbnRIYW5kbGVycyA9IE9iamVjdC5rZXlzKGNvb3JkaW5hdG9yUmluZ0V2ZW50cykubWFwKChldmVudCkgPT4ge1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50IGFzIFJpbmdDYWxsRXZlbnRzO1xuICAgIHJldHVybiBjYWxsLm9uKGV2ZW50TmFtZSwgY29vcmRpbmF0b3JSaW5nRXZlbnRzW2V2ZW50TmFtZV0pO1xuICB9KTtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICB9O1xufTtcbiIsImltcG9ydCB7XG4gIElDRVNlcnZlcixcbiAgSm9pbkNhbGxSZXF1ZXN0LFxuICBKb2luQ2FsbFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi9nZW4vY29vcmRpbmF0b3InO1xuaW1wb3J0IHsgSm9pbkNhbGxEYXRhIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgU3RyZWFtQ2xpZW50IH0gZnJvbSAnLi4vLi4vY29vcmRpbmF0b3IvY29ubmVjdGlvbi9jbGllbnQnO1xuXG4vKipcbiAqIENvbGxlY3RzIGFsbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gam9pbiBhIGNhbGwsIHRhbGtzIHRvIHRoZSBjb29yZGluYXRvclxuICogYW5kIHJldHVybnMgdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBqb2luIHRoZSBjYWxsLlxuICpcbiAqIEBwYXJhbSBodHRwQ2xpZW50IHRoZSBodHRwIGNsaWVudCB0byB1c2UuXG4gKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgY2FsbC5cbiAqIEBwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIGNhbGwuXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGNhbGwuXG4gKi9cbmV4cG9ydCBjb25zdCBqb2luID0gYXN5bmMgKFxuICBodHRwQ2xpZW50OiBTdHJlYW1DbGllbnQsXG4gIHR5cGU6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyxcbiAgZGF0YT86IEpvaW5DYWxsRGF0YSxcbikgPT4ge1xuICBjb25zdCB7IGNhbGwsIGNyZWRlbnRpYWxzLCBtZW1iZXJzLCBvd25fY2FwYWJpbGl0aWVzLCBzdGF0c19vcHRpb25zIH0gPVxuICAgIGF3YWl0IGRvSm9pbihodHRwQ2xpZW50LCB0eXBlLCBpZCwgZGF0YSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0aW9uQ29uZmlnOiB0b1J0Y0NvbmZpZ3VyYXRpb24oY3JlZGVudGlhbHMuaWNlX3NlcnZlcnMpLFxuICAgIHNmdVNlcnZlcjogY3JlZGVudGlhbHMuc2VydmVyLFxuICAgIHRva2VuOiBjcmVkZW50aWFscy50b2tlbixcbiAgICBtZXRhZGF0YTogY2FsbCxcbiAgICBtZW1iZXJzLFxuICAgIG93bkNhcGFiaWxpdGllczogb3duX2NhcGFiaWxpdGllcyxcbiAgICBzdGF0c09wdGlvbnM6IHN0YXRzX29wdGlvbnMsXG4gIH07XG59O1xuXG5jb25zdCBkb0pvaW4gPSBhc3luYyAoXG4gIGh0dHBDbGllbnQ6IFN0cmVhbUNsaWVudCxcbiAgdHlwZTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBkYXRhPzogSm9pbkNhbGxEYXRhLFxuKSA9PiB7XG4gIGNvbnN0IGxvY2F0aW9uID0gYXdhaXQgaHR0cENsaWVudC5nZXRMb2NhdGlvbkhpbnQoKTtcbiAgY29uc3QgcmVxdWVzdDogSm9pbkNhbGxSZXF1ZXN0ID0ge1xuICAgIC4uLmRhdGEsXG4gICAgbG9jYXRpb24sXG4gIH07XG4gIHJldHVybiBodHRwQ2xpZW50LnBvc3Q8Sm9pbkNhbGxSZXNwb25zZSwgSm9pbkNhbGxSZXF1ZXN0PihcbiAgICBgL2NhbGwvJHt0eXBlfS8ke2lkfS9qb2luYCxcbiAgICByZXF1ZXN0LFxuICApO1xufTtcblxuY29uc3QgdG9SdGNDb25maWd1cmF0aW9uID0gKGNvbmZpZz86IElDRVNlcnZlcltdKSA9PiB7XG4gIGlmICghY29uZmlnIHx8IGNvbmZpZy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG4gIGNvbnN0IHJ0Y0NvbmZpZzogUlRDQ29uZmlndXJhdGlvbiA9IHtcbiAgICBpY2VTZXJ2ZXJzOiBjb25maWcubWFwKChpY2UpID0+ICh7XG4gICAgICB1cmxzOiBpY2UudXJscyxcbiAgICAgIHVzZXJuYW1lOiBpY2UudXNlcm5hbWUsXG4gICAgICBjcmVkZW50aWFsOiBpY2UucGFzc3dvcmQsXG4gICAgfSkpLFxuICB9O1xuICByZXR1cm4gcnRjQ29uZmlnO1xufTtcbiIsImltcG9ydCB7IExvY2FsQ2xpZW50RGV0YWlsc1R5cGUgfSBmcm9tICcuLi9jbGllbnQtZGV0YWlscyc7XG5pbXBvcnQgeyBTZGtUeXBlIH0gZnJvbSAnLi4vZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzJztcblxuLyoqXG4gKiBGbGF0dGVuIHRoZSBzdGF0cyByZXBvcnQgaW50byBhbiBhcnJheSBvZiBzdGF0cyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSByZXBvcnQgdGhlIHJlcG9ydCB0byBmbGF0dGVuLlxuICovXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IChyZXBvcnQ6IFJUQ1N0YXRzUmVwb3J0KSA9PiB7XG4gIGNvbnN0IHN0YXRzOiBSVENTdGF0c1tdID0gW107XG4gIHJlcG9ydC5mb3JFYWNoKChzKSA9PiB7XG4gICAgc3RhdHMucHVzaChzKTtcbiAgfSk7XG4gIHJldHVybiBzdGF0cztcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTZGtTaWduYXR1cmUgPSAoY2xpZW50RGV0YWlsczogTG9jYWxDbGllbnREZXRhaWxzVHlwZSkgPT4ge1xuICBjb25zdCB7IHNkaywgLi4ucGxhdGZvcm0gfSA9IGNsaWVudERldGFpbHM7XG4gIGNvbnN0IHNka05hbWUgPVxuICAgIHNkayAmJiBzZGsudHlwZSA9PT0gU2RrVHlwZS5SRUFDVFxuICAgICAgPyAnc3RyZWFtLXJlYWN0J1xuICAgICAgOiBzZGsgJiYgc2RrLnR5cGUgPT09IFNka1R5cGUuUkVBQ1RfTkFUSVZFXG4gICAgICA/ICdzdHJlYW0tcmVhY3QtbmF0aXZlJ1xuICAgICAgOiAnc3RyZWFtLWpzJztcblxuICBjb25zdCBzZGtWZXJzaW9uID0gc2RrXG4gICAgPyBgJHtzZGsubWFqb3J9LiR7c2RrLm1pbm9yfS4ke3Nkay5wYXRjaH1gXG4gICAgOiAnMC4wLjAtZGV2ZWxvcG1lbnQnO1xuXG4gIHJldHVybiB7XG4gICAgc2RrTmFtZSxcbiAgICBzZGtWZXJzaW9uLFxuICAgIC4uLnBsYXRmb3JtLFxuICB9O1xufTtcbiIsImltcG9ydCB0eXBlIHtcbiAgQWdncmVnYXRlZFN0YXRzUmVwb3J0LFxuICBCYXNlU3RhdHMsXG4gIFBhcnRpY2lwYW50c1N0YXRzUmVwb3J0LFxuICBTdGF0c1JlcG9ydCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBDYWxsU3RhdGUgfSBmcm9tICcuLi9zdG9yZSc7XG5pbXBvcnQgeyBQdWJsaXNoZXIsIFN1YnNjcmliZXIgfSBmcm9tICcuLi9ydGMnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IHR5cGUgU3RhdHNSZXBvcnRlck9wdHMgPSB7XG4gIHN1YnNjcmliZXI6IFN1YnNjcmliZXI7XG4gIHB1Ymxpc2hlcjogUHVibGlzaGVyO1xuICBzdGF0ZTogQ2FsbFN0YXRlO1xuICBwb2xsaW5nSW50ZXJ2YWxJbk1zPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgU3RhdHNSZXBvcnRlciA9IHtcbiAgLyoqXG4gICAqIFdpbGwgdHVybiBvbiBzdGF0cyByZXBvcnRpbmcgZm9yIGEgZ2l2ZW4gc2Vzc2lvbklkLlxuICAgKlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgKi9cbiAgc3RhcnRSZXBvcnRpbmdTdGF0c0ZvcjogKHNlc3Npb25JZDogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBXaWxsIHR1cm4gb2ZmIHN0YXRzIHJlcG9ydGluZyBmb3IgYSBnaXZlbiBzZXNzaW9uSWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAqL1xuICBzdG9wUmVwb3J0aW5nU3RhdHNGb3I6IChzZXNzaW9uSWQ6IHN0cmluZykgPT4gdm9pZDtcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgcmV0cmlldmluZyBzdGF0cyBmb3IgYSBnaXZlbiBwZWVyIGNvbm5lY3Rpb24ga2luZFxuICAgKiBhbmQgbWVkaWEgc3RyZWFtIGZsb3dpbmcgdGhyb3VnaCBpdC5cbiAgICpcbiAgICogQHBhcmFtIGtpbmQgdGhlIHBlZXIgY29ubmVjdGlvbiBraW5kIChzdWJzY3JpYmVyIG9yIHB1Ymxpc2hlcikuXG4gICAqIEBwYXJhbSBtZWRpYVN0cmVhbSB0aGUgbWVkaWEgc3RyZWFtLlxuICAgKi9cbiAgZ2V0U3RhdHNGb3JTdHJlYW06IChcbiAgICBraW5kOiAnc3Vic2NyaWJlcicgfCAncHVibGlzaGVyJyxcbiAgICBtZWRpYVN0cmVhbTogTWVkaWFTdHJlYW0sXG4gICkgPT4gUHJvbWlzZTxTdGF0c1JlcG9ydFtdPjtcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgcmV0cmlldmluZyByYXcgc3RhdHMgZm9yIGEgZ2l2ZW4gcGVlciBjb25uZWN0aW9uIGtpbmQuXG4gICAqXG4gICAqIEBwYXJhbSBraW5kIHRoZSBwZWVyIGNvbm5lY3Rpb24ga2luZCAoc3Vic2NyaWJlciBvciBwdWJsaXNoZXIpLlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgdGhlIHRyYWNrIHNlbGVjdG9yLiBJZiBub3QgcHJvdmlkZWQsIHN0YXRzIGZvciBhbGwgdHJhY2tzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRSYXdTdGF0c0ZvclRyYWNrOiAoXG4gICAga2luZDogJ3N1YnNjcmliZXInIHwgJ3B1Ymxpc2hlcicsXG4gICAgc2VsZWN0b3I/OiBNZWRpYVN0cmVhbVRyYWNrLFxuICApID0+IFByb21pc2U8UlRDU3RhdHNSZXBvcnQgfCB1bmRlZmluZWQ+O1xuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgc3RhdHMgcmVwb3J0ZXIgYW5kIHJlbGVhc2VzIGFsbCByZXNvdXJjZXMuXG4gICAqL1xuICBzdG9wOiAoKSA9PiB2b2lkO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN0YXRzUmVwb3J0ZXIgaW5zdGFuY2UgdGhhdCBjb2xsZWN0cyBtZXRyaWNzIGFib3V0IHRoZSBvbmdvaW5nIGNhbGwgYW5kIHJlcG9ydHMgdGhlbSB0byB0aGUgc3RhdGUgc3RvcmVcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YXRzUmVwb3J0ZXIgPSAoe1xuICBzdWJzY3JpYmVyLFxuICBwdWJsaXNoZXIsXG4gIHN0YXRlLFxuICBwb2xsaW5nSW50ZXJ2YWxJbk1zID0gMjAwMCxcbn06IFN0YXRzUmVwb3J0ZXJPcHRzKTogU3RhdHNSZXBvcnRlciA9PiB7XG4gIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ3N0YXRzJ10pO1xuICBjb25zdCBnZXRSYXdTdGF0c0ZvclRyYWNrID0gYXN5bmMgKFxuICAgIGtpbmQ6ICdzdWJzY3JpYmVyJyB8ICdwdWJsaXNoZXInLFxuICAgIHNlbGVjdG9yPzogTWVkaWFTdHJlYW1UcmFjayxcbiAgKSA9PiB7XG4gICAgaWYgKGtpbmQgPT09ICdzdWJzY3JpYmVyJyAmJiBzdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlci5nZXRTdGF0cyhzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSAncHVibGlzaGVyJyAmJiBwdWJsaXNoZXIpIHtcbiAgICAgIHJldHVybiBwdWJsaXNoZXIuZ2V0U3RhdHMoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIoJ3dhcm4nLCBgQ2FuJ3QgcmV0cmlldmUgUlRDIHN0YXRzIGZvciAke2tpbmR9YCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRTdGF0c0ZvclN0cmVhbSA9IGFzeW5jIChcbiAgICBraW5kOiAnc3Vic2NyaWJlcicgfCAncHVibGlzaGVyJyxcbiAgICBtZWRpYVN0cmVhbTogTWVkaWFTdHJlYW0sXG4gICkgPT4ge1xuICAgIGNvbnN0IHBjID0ga2luZCA9PT0gJ3N1YnNjcmliZXInID8gc3Vic2NyaWJlciA6IHB1Ymxpc2hlcjtcbiAgICBjb25zdCBzdGF0c0ZvclN0cmVhbTogU3RhdHNSZXBvcnRbXSA9IFtdO1xuICAgIGZvciAobGV0IHRyYWNrIG9mIG1lZGlhU3RyZWFtLmdldFRyYWNrcygpKSB7XG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBwYy5nZXRTdGF0cyh0cmFjayk7XG4gICAgICBjb25zdCBzdGF0cyA9IHRyYW5zZm9ybShyZXBvcnQsIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0cmFja0tpbmQ6IHRyYWNrLmtpbmQsXG4gICAgICAgIGtpbmQsXG4gICAgICB9KTtcbiAgICAgIHN0YXRzRm9yU3RyZWFtLnB1c2goc3RhdHMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHNGb3JTdHJlYW07XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRSZXBvcnRpbmdTdGF0c0ZvciA9IChzZXNzaW9uSWQ6IHN0cmluZykgPT4ge1xuICAgIHNlc3Npb25JZHNUb1RyYWNrLmFkZChzZXNzaW9uSWQpO1xuICAgIHZvaWQgcnVuKCk7XG4gIH07XG5cbiAgY29uc3Qgc3RvcFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgc2Vzc2lvbklkc1RvVHJhY2suZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgdm9pZCBydW4oKTtcbiAgfTtcblxuICBjb25zdCBzZXNzaW9uSWRzVG9UcmFjayA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBzdGF0cyByZXBvcnRpbmcgbG9vcC5cbiAgICovXG4gIGNvbnN0IHJ1biA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBwYXJ0aWNpcGFudFN0YXRzOiBQYXJ0aWNpcGFudHNTdGF0c1JlcG9ydCA9IHt9O1xuICAgIGNvbnN0IHNlc3Npb25JZHMgPSBuZXcgU2V0KHNlc3Npb25JZHNUb1RyYWNrKTtcbiAgICBpZiAoc2Vzc2lvbklkcy5zaXplID4gMCkge1xuICAgICAgZm9yIChsZXQgcGFydGljaXBhbnQgb2Ygc3RhdGUucGFydGljaXBhbnRzKSB7XG4gICAgICAgIGlmICghc2Vzc2lvbklkcy5oYXMocGFydGljaXBhbnQuc2Vzc2lvbklkKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGtpbmQgPSBwYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICA/ICdwdWJsaXNoZXInXG4gICAgICAgICAgOiAnc3Vic2NyaWJlcic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbWVyZ2VkU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtcbiAgICAgICAgICAgIC4uLihwYXJ0aWNpcGFudC52aWRlb1N0cmVhbT8uZ2V0VmlkZW9UcmFja3MoKSB8fCBbXSksXG4gICAgICAgICAgICAuLi4ocGFydGljaXBhbnQuYXVkaW9TdHJlYW0/LmdldEF1ZGlvVHJhY2tzKCkgfHwgW10pLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHBhcnRpY2lwYW50U3RhdHNbcGFydGljaXBhbnQuc2Vzc2lvbklkXSA9IGF3YWl0IGdldFN0YXRzRm9yU3RyZWFtKFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIG1lcmdlZFN0cmVhbSxcbiAgICAgICAgICApO1xuICAgICAgICAgIG1lcmdlZFN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICBtZXJnZWRTdHJlYW0ucmVtb3ZlVHJhY2sodCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgYEZhaWxlZCB0byBjb2xsZWN0IHN0YXRzIGZvciAke2tpbmR9IGlmICR7cGFydGljaXBhbnQudXNlcklkfWAsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbc3Vic2NyaWJlclN0YXRzLCBwdWJsaXNoZXJTdGF0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBzdWJzY3JpYmVyXG4gICAgICAgIC5nZXRTdGF0cygpXG4gICAgICAgIC50aGVuKChyZXBvcnQpID0+XG4gICAgICAgICAgdHJhbnNmb3JtKHJlcG9ydCwge1xuICAgICAgICAgICAga2luZDogJ3N1YnNjcmliZXInLFxuICAgICAgICAgICAgdHJhY2tLaW5kOiAndmlkZW8nLFxuICAgICAgICAgIH0pLFxuICAgICAgICApXG4gICAgICAgIC50aGVuKGFnZ3JlZ2F0ZSksXG4gICAgICBwdWJsaXNoZXJcbiAgICAgICAgLmdldFN0YXRzKClcbiAgICAgICAgLnRoZW4oKHJlcG9ydCkgPT5cbiAgICAgICAgICB0cmFuc2Zvcm0ocmVwb3J0LCB7XG4gICAgICAgICAgICBraW5kOiAncHVibGlzaGVyJyxcbiAgICAgICAgICAgIHRyYWNrS2luZDogJ3ZpZGVvJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKVxuICAgICAgICAudGhlbihhZ2dyZWdhdGUpLFxuICAgIF0pO1xuXG4gICAgY29uc3QgW3N1YnNjcmliZXJSYXdTdGF0cywgcHVibGlzaGVyUmF3U3RhdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgZ2V0UmF3U3RhdHNGb3JUcmFjaygnc3Vic2NyaWJlcicpLFxuICAgICAgZ2V0UmF3U3RhdHNGb3JUcmFjaygncHVibGlzaGVyJyksXG4gICAgXSk7XG5cbiAgICBzdGF0ZS5zZXRDYWxsU3RhdHNSZXBvcnQoe1xuICAgICAgZGF0YWNlbnRlcjogcHVibGlzaGVyLnNmdUNsaWVudC5lZGdlTmFtZSxcbiAgICAgIHB1Ymxpc2hlclN0YXRzLFxuICAgICAgc3Vic2NyaWJlclN0YXRzLFxuICAgICAgc3Vic2NyaWJlclJhd1N0YXRzLFxuICAgICAgcHVibGlzaGVyUmF3U3RhdHMsXG4gICAgICBwYXJ0aWNpcGFudHM6IHBhcnRpY2lwYW50U3RhdHMsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfSk7XG4gIH07XG5cbiAgbGV0IHRpbWVvdXRJZDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGlmIChwb2xsaW5nSW50ZXJ2YWxJbk1zID4gMCkge1xuICAgIGNvbnN0IGxvb3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBydW4oKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2RlYnVnJywgJ0ZhaWxlZCB0byBjb2xsZWN0IHN0YXRzJywgZSk7XG4gICAgICB9KTtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQobG9vcCwgcG9sbGluZ0ludGVydmFsSW5Ncyk7XG4gICAgfTtcbiAgICB2b2lkIGxvb3AoKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZ2V0UmF3U3RhdHNGb3JUcmFjayxcbiAgICBnZXRTdGF0c0ZvclN0cmVhbSxcbiAgICBzdGFydFJlcG9ydGluZ1N0YXRzRm9yLFxuICAgIHN0b3BSZXBvcnRpbmdTdGF0c0ZvcixcbiAgICBzdG9wLFxuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgU3RhdHNUcmFuc2Zvcm1PcHRzID0ge1xuICAvKipcbiAgICogVGhlIGtpbmQgb2YgdHJhY2sgd2UgYXJlIHRyYW5zZm9ybWluZyBzdGF0cyBmb3IuXG4gICAqL1xuICB0cmFja0tpbmQ6ICdhdWRpbycgfCAndmlkZW8nO1xuXG4gIC8qKlxuICAgKiBUaGUga2luZCBvZiBwZWVyIGNvbm5lY3Rpb24gd2UgYXJlIHRyYW5zZm9ybWluZyBzdGF0cyBmb3IuXG4gICAqL1xuICBraW5kOiAnc3Vic2NyaWJlcicgfCAncHVibGlzaGVyJztcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyByYXcgUlRDIHN0YXRzIGludG8gYSBzbGltbWVyIGFuZCB1bmlmb3JtIGFjcm9zcyBicm93c2VycyBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHJlcG9ydCB0aGUgcmVwb3J0IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSBvcHRzIHRoZSB0cmFuc2Zvcm0gb3B0aW9ucy5cbiAqL1xuY29uc3QgdHJhbnNmb3JtID0gKFxuICByZXBvcnQ6IFJUQ1N0YXRzUmVwb3J0LFxuICBvcHRzOiBTdGF0c1RyYW5zZm9ybU9wdHMsXG4pOiBTdGF0c1JlcG9ydCA9PiB7XG4gIGNvbnN0IHsgdHJhY2tLaW5kLCBraW5kIH0gPSBvcHRzO1xuICBjb25zdCBkaXJlY3Rpb24gPSBraW5kID09PSAnc3Vic2NyaWJlcicgPyAnaW5ib3VuZC1ydHAnIDogJ291dGJvdW5kLXJ0cCc7XG4gIGNvbnN0IHN0YXRzID0gZmxhdHRlbihyZXBvcnQpO1xuICBjb25zdCBzdHJlYW1zID0gc3RhdHNcbiAgICAuZmlsdGVyKFxuICAgICAgKHN0YXQpID0+XG4gICAgICAgIHN0YXQudHlwZSA9PT0gZGlyZWN0aW9uICYmXG4gICAgICAgIChzdGF0IGFzIFJUQ1J0cFN0cmVhbVN0YXRzKS5raW5kID09PSB0cmFja0tpbmQsXG4gICAgKVxuICAgIC5tYXAoKHN0YXQpOiBCYXNlU3RhdHMgPT4ge1xuICAgICAgY29uc3QgcnRjU3RyZWFtU3RhdHMgPSBzdGF0IGFzIFJUQ0luYm91bmRSdHBTdHJlYW1TdGF0cyAmXG4gICAgICAgIFJUQ091dGJvdW5kUnRwU3RyZWFtU3RhdHM7XG5cbiAgICAgIGNvbnN0IGNvZGVjID0gc3RhdHMuZmluZChcbiAgICAgICAgKHMpID0+IHMudHlwZSA9PT0gJ2NvZGVjJyAmJiBzLmlkID09PSBydGNTdHJlYW1TdGF0cy5jb2RlY0lkLFxuICAgICAgKSBhcyB7IG1pbWVUeXBlOiBzdHJpbmcgfSB8IHVuZGVmaW5lZDsgLy8gRklYTUUgT0w6IGluY29ycmVjdCB0eXBlIVxuXG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBzdGF0cy5maW5kKFxuICAgICAgICAocykgPT4gcy50eXBlID09PSAndHJhbnNwb3J0JyAmJiBzLmlkID09PSBydGNTdHJlYW1TdGF0cy50cmFuc3BvcnRJZCxcbiAgICAgICkgYXMgUlRDVHJhbnNwb3J0U3RhdHMgfCB1bmRlZmluZWQ7XG5cbiAgICAgIGxldCByb3VuZFRyaXBUaW1lOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAodHJhbnNwb3J0ICYmIHRyYW5zcG9ydC5kdGxzU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZVBhaXIgPSBzdGF0cy5maW5kKFxuICAgICAgICAgIChzKSA9PlxuICAgICAgICAgICAgcy50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInICYmXG4gICAgICAgICAgICBzLmlkID09PSB0cmFuc3BvcnQuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQsXG4gICAgICAgICkgYXMgUlRDSWNlQ2FuZGlkYXRlUGFpclN0YXRzIHwgdW5kZWZpbmVkO1xuICAgICAgICByb3VuZFRyaXBUaW1lID0gY2FuZGlkYXRlUGFpcj8uY3VycmVudFJvdW5kVHJpcFRpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5dGVzU2VudDogcnRjU3RyZWFtU3RhdHMuYnl0ZXNTZW50LFxuICAgICAgICBieXRlc1JlY2VpdmVkOiBydGNTdHJlYW1TdGF0cy5ieXRlc1JlY2VpdmVkLFxuICAgICAgICBjb2RlYzogY29kZWM/Lm1pbWVUeXBlLFxuICAgICAgICBjdXJyZW50Um91bmRUcmlwVGltZTogcm91bmRUcmlwVGltZSxcbiAgICAgICAgZnJhbWVIZWlnaHQ6IHJ0Y1N0cmVhbVN0YXRzLmZyYW1lSGVpZ2h0LFxuICAgICAgICBmcmFtZVdpZHRoOiBydGNTdHJlYW1TdGF0cy5mcmFtZVdpZHRoLFxuICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHJ0Y1N0cmVhbVN0YXRzLmZyYW1lc1BlclNlY29uZCxcbiAgICAgICAgaml0dGVyOiBydGNTdHJlYW1TdGF0cy5qaXR0ZXIsXG4gICAgICAgIGtpbmQ6IHJ0Y1N0cmVhbVN0YXRzLmtpbmQsXG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IGF2YWlsYWJsZSBpbiBDaHJvbWUgb25seSwgVFMgZG9lc24ndCByZWNvZ25pemUgdGhpc1xuICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogcnRjU3RyZWFtU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb24sXG4gICAgICAgIHJpZDogcnRjU3RyZWFtU3RhdHMucmlkLFxuICAgICAgICBzc3JjOiBydGNTdHJlYW1TdGF0cy5zc3JjLFxuICAgICAgfTtcbiAgICB9KTtcblxuICByZXR1cm4ge1xuICAgIHJhd1N0YXRzOiByZXBvcnQsXG4gICAgc3RyZWFtcyxcbiAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gIH07XG59O1xuXG4vKipcbiAqIEFnZ3JlZ2F0ZXMgZ2VuZXJpYyBzdGF0cy5cbiAqXG4gKiBAcGFyYW0gc3RhdHMgdGhlIHN0YXRzIHRvIGFnZ3JlZ2F0ZS5cbiAqL1xuY29uc3QgYWdncmVnYXRlID0gKHN0YXRzOiBTdGF0c1JlcG9ydCk6IEFnZ3JlZ2F0ZWRTdGF0c1JlcG9ydCA9PiB7XG4gIGNvbnN0IGFnZ3JlZ2F0ZWRTdGF0czogQWdncmVnYXRlZFN0YXRzUmVwb3J0ID0ge1xuICAgIHJhd1JlcG9ydDogc3RhdHMsXG4gICAgdG90YWxCeXRlc1NlbnQ6IDAsXG4gICAgdG90YWxCeXRlc1JlY2VpdmVkOiAwLFxuICAgIGF2ZXJhZ2VKaXR0ZXJJbk1zOiAwLFxuICAgIGF2ZXJhZ2VSb3VuZFRyaXBUaW1lSW5NczogMCxcbiAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnM6ICdub25lJyxcbiAgICBoaWdoZXN0RnJhbWVXaWR0aDogMCxcbiAgICBoaWdoZXN0RnJhbWVIZWlnaHQ6IDAsXG4gICAgaGlnaGVzdEZyYW1lc1BlclNlY29uZDogMCxcbiAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gIH07XG5cbiAgbGV0IG1heEFyZWEgPSAtMTtcbiAgY29uc3QgYXJlYSA9ICh3OiBudW1iZXIsIGg6IG51bWJlcikgPT4gdyAqIGg7XG5cbiAgY29uc3QgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHN0cmVhbXMgPSBzdGF0cy5zdHJlYW1zO1xuICBjb25zdCByZXBvcnQgPSBzdHJlYW1zLnJlZHVjZSgoYWNjLCBzdHJlYW0pID0+IHtcbiAgICBhY2MudG90YWxCeXRlc1NlbnQgKz0gc3RyZWFtLmJ5dGVzU2VudCB8fCAwO1xuICAgIGFjYy50b3RhbEJ5dGVzUmVjZWl2ZWQgKz0gc3RyZWFtLmJ5dGVzUmVjZWl2ZWQgfHwgMDtcbiAgICBhY2MuYXZlcmFnZUppdHRlckluTXMgKz0gc3RyZWFtLmppdHRlciB8fCAwO1xuICAgIGFjYy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgKz0gc3RyZWFtLmN1cnJlbnRSb3VuZFRyaXBUaW1lIHx8IDA7XG5cbiAgICAvLyBuYWl2ZSBjYWxjdWxhdGlvbiBvZiB0aGUgaGlnaGVzdCByZXNvbHV0aW9uXG4gICAgY29uc3Qgc3RyZWFtQXJlYSA9IGFyZWEoc3RyZWFtLmZyYW1lV2lkdGggfHwgMCwgc3RyZWFtLmZyYW1lSGVpZ2h0IHx8IDApO1xuICAgIGlmIChzdHJlYW1BcmVhID4gbWF4QXJlYSkge1xuICAgICAgYWNjLmhpZ2hlc3RGcmFtZVdpZHRoID0gc3RyZWFtLmZyYW1lV2lkdGggfHwgMDtcbiAgICAgIGFjYy5oaWdoZXN0RnJhbWVIZWlnaHQgPSBzdHJlYW0uZnJhbWVIZWlnaHQgfHwgMDtcbiAgICAgIGFjYy5oaWdoZXN0RnJhbWVzUGVyU2Vjb25kID0gc3RyZWFtLmZyYW1lc1BlclNlY29uZCB8fCAwO1xuICAgICAgbWF4QXJlYSA9IHN0cmVhbUFyZWE7XG4gICAgfVxuXG4gICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zLmFkZChzdHJlYW0ucXVhbGl0eUxpbWl0YXRpb25SZWFzb24gfHwgJycpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIGFnZ3JlZ2F0ZWRTdGF0cyk7XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoID4gMCkge1xuICAgIHJlcG9ydC5hdmVyYWdlSml0dGVySW5NcyA9IE1hdGgucm91bmQoXG4gICAgICAocmVwb3J0LmF2ZXJhZ2VKaXR0ZXJJbk1zIC8gc3RyZWFtcy5sZW5ndGgpICogMTAwMCxcbiAgICApO1xuICAgIHJlcG9ydC5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgPSBNYXRoLnJvdW5kKFxuICAgICAgKHJlcG9ydC5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgLyBzdHJlYW1zLmxlbmd0aCkgKiAxMDAwLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBxdWFsaXR5TGltaXRhdGlvblJlYXNvbiA9IFtcbiAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMuaGFzKCdjcHUnKSAmJiAnY3B1JyxcbiAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMuaGFzKCdiYW5kd2lkdGgnKSAmJiAnYmFuZHdpZHRoJyxcbiAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMuaGFzKCdvdGhlcicpICYmICdvdGhlcicsXG4gIF1cbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmpvaW4oJywgJyk7XG4gIGlmIChxdWFsaXR5TGltaXRhdGlvblJlYXNvbikge1xuICAgIHJlcG9ydC5xdWFsaXR5TGltaXRhdGlvblJlYXNvbnMgPSBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjtcbiAgfVxuXG4gIHJldHVybiByZXBvcnQ7XG59O1xuIiwiaW1wb3J0IHsgU3RyZWFtU2Z1Q2xpZW50IH0gZnJvbSAnLi4vU3RyZWFtU2Z1Q2xpZW50JztcbmltcG9ydCB7IFN0YXRzT3B0aW9ucyB9IGZyb20gJy4uL2dlbi9jb29yZGluYXRvcic7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgUHVibGlzaGVyLCBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vcnRjJztcbmltcG9ydCB7IFNka1R5cGUgfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0V2ViUlRDSW5mbywgTG9jYWxDbGllbnREZXRhaWxzVHlwZSB9IGZyb20gJy4uL2NsaWVudC1kZXRhaWxzJztcblxuZXhwb3J0IHR5cGUgU2Z1U3RhdHNSZXBvcnRlck9wdGlvbnMgPSB7XG4gIG9wdGlvbnM6IFN0YXRzT3B0aW9ucztcbiAgY2xpZW50RGV0YWlsczogTG9jYWxDbGllbnREZXRhaWxzVHlwZTtcbiAgc3Vic2NyaWJlcjogU3Vic2NyaWJlcjtcbiAgcHVibGlzaGVyOiBQdWJsaXNoZXI7XG59O1xuXG5leHBvcnQgY2xhc3MgU2Z1U3RhdHNSZXBvcnRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnU2Z1U3RhdHNSZXBvcnRlciddKTtcblxuICByZWFkb25seSBvcHRpb25zOiBTdGF0c09wdGlvbnM7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBzZnVDbGllbnQ6IFN0cmVhbVNmdUNsaWVudDtcbiAgcHJpdmF0ZSByZWFkb25seSBzdWJzY3JpYmVyOiBTdWJzY3JpYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IHB1Ymxpc2hlcjogUHVibGlzaGVyO1xuXG4gIHByaXZhdGUgaW50ZXJ2YWxJZDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2RrTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHNka1ZlcnNpb246IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSB3ZWJSVENWZXJzaW9uOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc2Z1Q2xpZW50OiBTdHJlYW1TZnVDbGllbnQsXG4gICAgeyBvcHRpb25zLCBjbGllbnREZXRhaWxzLCBzdWJzY3JpYmVyLCBwdWJsaXNoZXIgfTogU2Z1U3RhdHNSZXBvcnRlck9wdGlvbnMsXG4gICkge1xuICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IHB1Ymxpc2hlcjtcbiAgICBjb25zdCB3ZWJSVENJbmZvID0gZ2V0V2ViUlRDSW5mbygpO1xuXG4gICAgY29uc3QgeyBzZGssIGJyb3dzZXIgfSA9IGNsaWVudERldGFpbHM7XG5cbiAgICB0aGlzLnNka05hbWUgPVxuICAgICAgc2RrICYmIHNkay50eXBlID09PSBTZGtUeXBlLlJFQUNUXG4gICAgICAgID8gJ3N0cmVhbS1yZWFjdCdcbiAgICAgICAgOiBzZGsgJiYgc2RrLnR5cGUgPT09IFNka1R5cGUuUkVBQ1RfTkFUSVZFXG4gICAgICAgID8gJ3N0cmVhbS1yZWFjdC1uYXRpdmUnXG4gICAgICAgIDogJ3N0cmVhbS1qcyc7XG5cbiAgICB0aGlzLnNka1ZlcnNpb24gPSBzZGtcbiAgICAgID8gYCR7c2RrLm1ham9yfS4ke3Nkay5taW5vcn0uJHtzZGsucGF0Y2h9YFxuICAgICAgOiAnMC4wLjAtZGV2ZWxvcG1lbnQnO1xuXG4gICAgLy8gVGhlIFdlYlJUQyB2ZXJzaW9uIGlmIHBhc3NlZCBmcm9tIHRoZSBTREssIGl0IGlzIHRha2VuIGVsc2UgdGhlIGJyb3dzZXIgaW5mbyBpcyBzZW50LlxuICAgIHRoaXMud2ViUlRDVmVyc2lvbiA9XG4gICAgICB3ZWJSVENJbmZvPy52ZXJzaW9uIHx8XG4gICAgICBgJHticm93c2VyPy5uYW1lIHx8ICcnfS0ke2Jyb3dzZXI/LnZlcnNpb24gfHwgJyd9YCB8fFxuICAgICAgJ04vQSc7XG4gIH1cblxuICBwcml2YXRlIHJ1biA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBbc3Vic2NyaWJlclN0YXRzLCBwdWJsaXNoZXJTdGF0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnN1YnNjcmliZXIuZ2V0U3RhdHMoKS50aGVuKGZsYXR0ZW4pLnRoZW4oSlNPTi5zdHJpbmdpZnkpLFxuICAgICAgdGhpcy5wdWJsaXNoZXIuZ2V0U3RhdHMoKS50aGVuKGZsYXR0ZW4pLnRoZW4oSlNPTi5zdHJpbmdpZnkpLFxuICAgIF0pO1xuXG4gICAgYXdhaXQgdGhpcy5zZnVDbGllbnQuc2VuZFN0YXRzKHtcbiAgICAgIHNkazogdGhpcy5zZGtOYW1lLFxuICAgICAgc2RrVmVyc2lvbjogdGhpcy5zZGtWZXJzaW9uLFxuICAgICAgd2VicnRjVmVyc2lvbjogdGhpcy53ZWJSVENWZXJzaW9uLFxuICAgICAgc3Vic2NyaWJlclN0YXRzLFxuICAgICAgcHVibGlzaGVyU3RhdHMsXG4gICAgfSk7XG4gIH07XG5cbiAgc3RhcnQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXBvcnRpbmdfaW50ZXJ2YWxfbXMgPD0gMCkgcmV0dXJuO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMucnVuKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsICdGYWlsZWQgdG8gcmVwb3J0IHN0YXRzJywgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMub3B0aW9ucy5yZXBvcnRpbmdfaW50ZXJ2YWxfbXMpO1xuICB9O1xuXG4gIHN0b3AgPSAoKSA9PiB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgfTtcbn1cbiIsImNvbnN0IERFRkFVTFRfVEhSRVNIT0xEID0gMC4zNTtcblxuZXhwb3J0IHR5cGUgRW50cnlIYW5kbGVyID0gKGVudHJ5OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBVbm9ic2VydmUgPSAoKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBPYnNlcnZlID0gKFxuICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgZW50cnlIYW5kbGVyOiBFbnRyeUhhbmRsZXIsXG4pID0+IFVub2JzZXJ2ZTtcblxuZXhwb3J0IGNsYXNzIFZpZXdwb3J0VHJhY2tlciB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBlbGVtZW50SGFuZGxlck1hcDogTWFwPFxuICAgIEhUTUxFbGVtZW50LFxuICAgIChlbnRyeTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkgPT4gdm9pZFxuICA+ID0gbmV3IE1hcCgpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyIHwgbnVsbCA9IG51bGw7XG4gIC8vIGluIFJlYWN0IGNoaWxkcmVuIHJlbmRlciBiZWZvcmUgdmlld3BvcnQgaXMgc2V0LCBhZGRcbiAgLy8gdGhlbSB0byB0aGUgcXVldWUgYW5kIG9ic2VydmUgdGhlbSBvbmNlIHRoZSBvYnNlcnZlciBpcyByZWFkeVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcXVldWVTZXQ6IFNldDxyZWFkb25seSBbSFRNTEVsZW1lbnQsIEVudHJ5SGFuZGxlcl0+ID0gbmV3IFNldCgpO1xuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gc2V0IHNjcm9sbGFibGUgdmlld3BvcnQgYXMgcm9vdCBmb3IgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLCByZXR1cm5zXG4gICAqIGNsZWFudXAgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB1cG9uIGRpc3Bvc2luZyBvZiB0aGUgRE9NIGVsZW1lbnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICpcbiAgICogQHBhcmFtIHZpZXdwb3J0RWxlbWVudFxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyBVbm9ic2VydmVcbiAgICovXG4gIHB1YmxpYyBzZXRWaWV3cG9ydCA9IChcbiAgICB2aWV3cG9ydEVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAgIG9wdGlvbnM/OiBQaWNrPEludGVyc2VjdGlvbk9ic2VydmVySW5pdCwgJ3RocmVzaG9sZCcgfCAncm9vdE1hcmdpbic+LFxuICApID0+IHtcbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgdGhpcy5vYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLmNsZWFyKCk7XG4gICAgfTtcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuZ2V0KFxuICAgICAgICAgICAgZW50cnkudGFyZ2V0IGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgICk7XG4gICAgICAgICAgaGFuZGxlcj8uKGVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByb290OiB2aWV3cG9ydEVsZW1lbnQsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRocmVzaG9sZDogb3B0aW9ucz8udGhyZXNob2xkID8/IERFRkFVTFRfVEhSRVNIT0xELFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMucXVldWVTZXQuc2l6ZSkge1xuICAgICAgdGhpcy5xdWV1ZVNldC5mb3JFYWNoKChbcXVldWVFbGVtZW50LCBxdWV1ZUhhbmRsZXJdKSA9PiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGVsZW1lbnQgd2hpY2ggcmVxdWVzdGVkIG9ic2VydmF0aW9uIGlzXG4gICAgICAgIC8vIGEgY2hpbGQgb2YgYSB2aWV3cG9ydCBlbGVtZW50LCBza2lwIGlmIGlzbid0XG4gICAgICAgIGlmICghdmlld3BvcnRFbGVtZW50LmNvbnRhaW5zKHF1ZXVlRWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICB0aGlzLm9ic2VydmVyIS5vYnNlcnZlKHF1ZXVlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuc2V0KHF1ZXVlRWxlbWVudCwgcXVldWVIYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWV1ZVNldC5jbGVhcigpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGVhbnVwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gc2V0IGVsZW1lbnQgdG8gb2JzZXJ2ZSBhbmQgaGFuZGxlciB0byBiZSB0cmlnZ2VyZWQgd2hlbmV2ZXIgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICogZGV0ZWN0cyBhIHBvc3NpYmxlIGNoYW5nZSBpbiBlbGVtZW50J3MgdmlzaWJpbGl0eSB3aXRoaW4gc3BlY2lmaWVkIHZpZXdwb3J0LCByZXR1cm5zXG4gICAqIGNsZWFudXAgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB1cG9uIGRpc3Bvc2luZyBvZiB0aGUgRE9NIGVsZW1lbnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnRcbiAgICogQHBhcmFtIGhhbmRsZXJcbiAgICogQHJldHVybnMgVW5vYnNlcnZlXG4gICAqL1xuICBwdWJsaWMgb2JzZXJ2ZTogT2JzZXJ2ZSA9IChlbGVtZW50LCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgcXVldWVJdGVtID0gW2VsZW1lbnQsIGhhbmRsZXJdIGFzIGNvbnN0O1xuXG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vYnNlcnZlcj8udW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgdGhpcy5xdWV1ZVNldC5kZWxldGUocXVldWVJdGVtKTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuaGFzKGVsZW1lbnQpKSByZXR1cm4gY2xlYW51cDtcblxuICAgIGlmICghdGhpcy5vYnNlcnZlcikge1xuICAgICAgdGhpcy5xdWV1ZVNldC5hZGQocXVldWVJdGVtKTtcbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9ic2VydmVyLnJvb3QhLmNvbnRhaW5zKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLnNldChlbGVtZW50LCBoYW5kbGVyKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xlYW51cDtcbiAgfTtcbn1cbiIsIi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmkuXG4gKi9cbmV4cG9ydCBjb25zdCBpc1NhZmFyaSA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIGlzIEZpcmVmb3guXG4gKi9cbmV4cG9ydCBjb25zdCBpc0ZpcmVmb3ggPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudD8uaW5jbHVkZXMoJ0ZpcmVmb3gnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBHb29nbGUgQ2hyb21lLlxuICovXG5leHBvcnQgY29uc3QgaXNDaHJvbWUgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudD8uaW5jbHVkZXMoJ0Nocm9tZScpO1xufTtcbiIsImltcG9ydCB7IENhbGwgfSBmcm9tICcuLi9DYWxsJztcbmltcG9ydCB7XG4gIEF1ZGlvVHJhY2tUeXBlLFxuICBEZWJvdW5jZVR5cGUsXG4gIFN0cmVhbVZpZGVvUGFydGljaXBhbnQsXG4gIFZpZGVvVHJhY2tUeXBlLFxuICBWaXNpYmlsaXR5U3RhdGUsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFRyYWNrVHlwZSwgVmlkZW9EaW1lbnNpb24gfSBmcm9tICcuLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHtcbiAgY29tYmluZUxhdGVzdCxcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXG4gIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLFxuICBtYXAsXG4gIHNoYXJlUmVwbGF5LFxuICB0YWtlV2hpbGUsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVmlld3BvcnRUcmFja2VyIH0gZnJvbSAnLi9WaWV3cG9ydFRyYWNrZXInO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGlzRmlyZWZveCwgaXNTYWZhcmkgfSBmcm9tICcuL2Jyb3dzZXJzJztcblxuY29uc3QgREVGQVVMVF9WSUVXUE9SVF9WSVNJQklMSVRZX1NUQVRFOiBSZWNvcmQ8XG4gIFZpZGVvVHJhY2tUeXBlLFxuICBWaXNpYmlsaXR5U3RhdGVcbj4gPSB7XG4gIHZpZGVvVHJhY2s6IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxuICBzY3JlZW5TaGFyZVRyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogQSBtYW5hZ2VyIGNsYXNzIHRoYXQgaGFuZGxlcyBkeW5hc2NhbGUgcmVsYXRlZCB0YXNrcyBsaWtlOlxuICpcbiAqIC0gYmluZGluZyB2aWRlbyBlbGVtZW50cyB0byBzZXNzaW9uIGlkc1xuICogLSBiaW5kaW5nIGF1ZGlvIGVsZW1lbnRzIHRvIHNlc3Npb24gaWRzXG4gKiAtIHRyYWNraW5nIGVsZW1lbnQgdmlzaWJpbGl0eVxuICogLSB1cGRhdGluZyBzdWJzY3JpcHRpb25zIGJhc2VkIG9uIHZpZXdwb3J0IHZpc2liaWxpdHlcbiAqIC0gdXBkYXRpbmcgc3Vic2NyaXB0aW9ucyBiYXNlZCBvbiB2aWRlbyBlbGVtZW50IGRpbWVuc2lvbnNcbiAqIC0gdXBkYXRpbmcgc3Vic2NyaXB0aW9ucyBiYXNlZCBvbiBwdWJsaXNoZWQgdHJhY2tzXG4gKi9cbmV4cG9ydCBjbGFzcyBEeW5hc2NhbGVNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIFRoZSB2aWV3cG9ydCB0cmFja2VyIGluc3RhbmNlLlxuICAgKi9cbiAgcmVhZG9ubHkgdmlld3BvcnRUcmFja2VyID0gbmV3IFZpZXdwb3J0VHJhY2tlcigpO1xuXG4gIHByaXZhdGUgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnRHluYXNjYWxlTWFuYWdlciddKTtcbiAgcHJpdmF0ZSBjYWxsOiBDYWxsO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IER5bmFzY2FsZU1hbmFnZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsIHRvIG1hbmFnZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbGw6IENhbGwpIHtcbiAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgYmVnaW4gdHJhY2tpbmcgdGhlIGdpdmVuIGVsZW1lbnQgZm9yIHZpc2liaWxpdHkgY2hhbmdlcyB3aXRoaW4gdGhlXG4gICAqIGNvbmZpZ3VyZWQgdmlld3BvcnQgZWxlbWVudCAoYGNhbGwuc2V0Vmlld3BvcnRgKS5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gdHJhY2suXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIGtpbmQgb2YgdmlkZW8uXG4gICAqIEByZXR1cm5zIFVudHJhY2suXG4gICAqL1xuICB0cmFja0VsZW1lbnRWaXNpYmlsaXR5ID0gPFQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oXG4gICAgZWxlbWVudDogVCxcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICB0cmFja1R5cGU6IFZpZGVvVHJhY2tUeXBlLFxuICApID0+IHtcbiAgICBjb25zdCBjbGVhbnVwID0gdGhpcy52aWV3cG9ydFRyYWNrZXIub2JzZXJ2ZShlbGVtZW50LCAoZW50cnkpID0+IHtcbiAgICAgIHRoaXMuY2FsbC5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91c1Zpc2liaWxpdHlTdGF0ZSA9XG4gICAgICAgICAgcGFydGljaXBhbnQudmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPz9cbiAgICAgICAgICBERUZBVUxUX1ZJRVdQT1JUX1ZJU0lCSUxJVFlfU1RBVEU7XG5cbiAgICAgICAgLy8gb2JzZXJ2ZXIgdHJpZ2dlcnMgd2hlbiB0aGUgZWxlbWVudCBpcyBcIm1vdmVkXCIgdG8gYmUgYSBmdWxsc2NyZWVuIGVsZW1lbnRcbiAgICAgICAgLy8ga2VlcCBpdCBWSVNJQkxFIGlmIHRoYXQgaGFwcGVucyB0byBwcmV2ZW50IGZ1bGxzY3JlZW4gd2l0aCBwbGFjZWhvbGRlclxuICAgICAgICBjb25zdCBpc1Zpc2libGUgPVxuICAgICAgICAgIGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ID09PSBlbGVtZW50XG4gICAgICAgICAgICA/IFZpc2liaWxpdHlTdGF0ZS5WSVNJQkxFXG4gICAgICAgICAgICA6IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU6IHtcbiAgICAgICAgICAgIC4uLnByZXZpb3VzVmlzaWJpbGl0eVN0YXRlLFxuICAgICAgICAgICAgW3RyYWNrVHlwZV06IGlzVmlzaWJsZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgLy8gcmVzZXQgdmlzaWJpbGl0eSBzdGF0ZSB0byBVTktOT1dOIHVwb24gY2xlYW51cFxuICAgICAgLy8gc28gdGhhdCB0aGUgbGF5b3V0cyB0aGF0IGFyZSBub3QgYWN0aXZlbHkgb2JzZXJ2ZWRcbiAgICAgIC8vIGNhbiBzdGlsbCBmdW5jdGlvbiBub3JtYWxseSAocnVudGltZSBsYXlvdXQgc3dpdGNoaW5nKVxuICAgICAgdGhpcy5jYWxsLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwgKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmlzaWJpbGl0eVN0YXRlID1cbiAgICAgICAgICBwYXJ0aWNpcGFudC52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA/P1xuICAgICAgICAgIERFRkFVTFRfVklFV1BPUlRfVklTSUJJTElUWV9TVEFURTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZToge1xuICAgICAgICAgICAgLi4ucHJldmlvdXNWaXNpYmlsaXR5U3RhdGUsXG4gICAgICAgICAgICBbdHJhY2tUeXBlXTogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gdHJhY2sgYm91bmQgdmlkZW8gZWxlbWVudHMgZm9yIHZpc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICAgKi9cbiAgc2V0Vmlld3BvcnQgPSA8VCBleHRlbmRzIEhUTUxFbGVtZW50PihlbGVtZW50OiBUKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMudmlld3BvcnRUcmFja2VyLnNldFZpZXdwb3J0KGVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kcyBhIERPTSA8dmlkZW8+IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIHZpZGVvIGVsZW1lbnQgd2lsbCBwbGF5XG4gICAqIHRoZSBjb3JyZWN0IHZpZGVvIHN0cmVhbSBmb3IgdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAqXG4gICAqIFVuZGVyIHRoZSBob29kLCBpdCB3b3VsZCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHZpZGVvIGVsZW1lbnQgZGltZW5zaW9uc1xuICAgKiBhbmQgdXBkYXRlIHRoZSBzdWJzY3JpcHRpb24gYWNjb3JkaW5nbHkgaW4gb3JkZXIgdG8gb3B0aW1pemUgdGhlIGJhbmR3aWR0aC5cbiAgICpcbiAgICogSWYgYSBcInZpZXdwb3J0XCIgaXMgY29uZmlndXJlZCwgdGhlIHZpZGVvIGVsZW1lbnQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gICAqIHRyYWNrZWQgZm9yIHZpc2liaWxpdHkgYW5kIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50IHRoZSB2aWRlbyBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIGtpbmQgb2YgdmlkZW8uXG4gICAqL1xuICBiaW5kVmlkZW9FbGVtZW50ID0gKFxuICAgIHZpZGVvRWxlbWVudDogSFRNTFZpZGVvRWxlbWVudCxcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICB0cmFja1R5cGU6IFZpZGVvVHJhY2tUeXBlLFxuICApID0+IHtcbiAgICBjb25zdCBib3VuZFBhcnRpY2lwYW50ID1cbiAgICAgIHRoaXMuY2FsbC5zdGF0ZS5maW5kUGFydGljaXBhbnRCeVNlc3Npb25JZChzZXNzaW9uSWQpO1xuICAgIGlmICghYm91bmRQYXJ0aWNpcGFudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMgPSAoXG4gICAgICBkZWJvdW5jZVR5cGU6IERlYm91bmNlVHlwZSxcbiAgICAgIGRpbWVuc2lvbjogVmlkZW9EaW1lbnNpb24gfCB1bmRlZmluZWQsXG4gICAgKSA9PiB7XG4gICAgICBpZiAoZGltZW5zaW9uICYmIChkaW1lbnNpb24ud2lkdGggPT09IDAgfHwgZGltZW5zaW9uLmhlaWdodCA9PT0gMCkpIHtcbiAgICAgICAgLy8gaWdub3JlIDB4MCBkaW1lbnNpb25zLiB0aGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgdmlkZW8gZWxlbWVudFxuICAgICAgICAvLyBpcyBub3QgdmlzaWJsZSAoZS5nLiwgaGFzIGRpc3BsYXk6IG5vbmUpLlxuICAgICAgICAvLyB3ZSB0cmVhdCB0aGlzIGFzIFwidW5zdWJzY3JpcHRpb25cIiBhcyB3ZSBkb24ndCB3YW50IHRvIGtlZXBcbiAgICAgICAgLy8gY29uc3VtaW5nIGJhbmR3aWR0aCBmb3IgYSB2aWRlbyB0aGF0IGlzIG5vdCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBJZ25vcmluZyAweDAgZGltZW5zaW9uYCwgYm91bmRQYXJ0aWNpcGFudCk7XG4gICAgICAgIGRpbWVuc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbC51cGRhdGVTdWJzY3JpcHRpb25zUGFydGlhbChcbiAgICAgICAgdHJhY2tUeXBlLFxuICAgICAgICB7IFtzZXNzaW9uSWRdOiB7IGRpbWVuc2lvbiB9IH0sXG4gICAgICAgIGRlYm91bmNlVHlwZSxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGNvbnN0IHBhcnRpY2lwYW50JCA9IHRoaXMuY2FsbC5zdGF0ZS5wYXJ0aWNpcGFudHMkLnBpcGUoXG4gICAgICBtYXAoXG4gICAgICAgIChwYXJ0aWNpcGFudHMpID0+XG4gICAgICAgICAgcGFydGljaXBhbnRzLmZpbmQoXG4gICAgICAgICAgICAocGFydGljaXBhbnQpID0+IHBhcnRpY2lwYW50LnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkLFxuICAgICAgICAgICkgYXMgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCxcbiAgICAgICksXG4gICAgICB0YWtlV2hpbGUoKHBhcnRpY2lwYW50KSA9PiAhIXBhcnRpY2lwYW50KSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pLFxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB0aGUgdmlkZW8gZWxlbWVudHMgYXJlIG5vdyBiZWluZyByZW1vdmVkIGZyb20gdGhlIERPTSAoUmVhY3QgU0RLKSB1cG9uXG4gICAgICogdmlzaWJpbGl0eSBjaGFuZ2UsIHRoaXMgc3Vic2NyaXB0aW9uIGlzIG5vdCBpbiB1c2UgYW4gc3RheXMgaGVyZSBvbmx5IGZvciB0aGVcbiAgICAgKiBwbGFpbiBKUyBpbnRlZ3JhdGlvbnMgd2hlcmUgaW50ZWdyYXRvcnMgbWlnaHQgY2hvb3NlIG5vdCB0byByZW1vdmUgdGhlIHZpZGVvXG4gICAgICogZWxlbWVudHMgZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuICAgIC8vIGtlZXAgY29weSBmb3IgcmVzaXplIG9ic2VydmVyIGhhbmRsZXJcbiAgICBsZXQgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU6IFZpc2liaWxpdHlTdGF0ZSB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZVN1YnNjcmlwdGlvbiA9XG4gICAgICBib3VuZFBhcnRpY2lwYW50LmlzTG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBwYXJ0aWNpcGFudCRcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICBtYXAoKHApID0+IHAudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/Llt0cmFja1R5cGVdKSxcbiAgICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKG5leHRWaWV3cG9ydFZpc2liaWxpdHlTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAvLyBza2lwIGluaXRpYWwgdHJpZ2dlclxuICAgICAgICAgICAgICBpZiAoIXZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPVxuICAgICAgICAgICAgICAgICAgbmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID8/IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA9XG4gICAgICAgICAgICAgICAgbmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID8/IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOO1xuXG4gICAgICAgICAgICAgIGlmIChuZXh0Vmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoXG4gICAgICAgICAgICAgICAgICBEZWJvdW5jZVR5cGUuTUVESVVNLFxuICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuTUVESVVNLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHZpZGVvRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZGVvRWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICBsZXQgbGFzdERpbWVuc2lvbnM6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IGJvdW5kUGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50XG4gICAgICA/IG51bGxcbiAgICAgIDogbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50RGltZW5zaW9ucyA9IGAke3ZpZGVvRWxlbWVudC5jbGllbnRXaWR0aH0sJHt2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0fWA7XG5cbiAgICAgICAgICAvLyBza2lwIGluaXRpYWwgdHJpZ2dlclxuICAgICAgICAgIGlmICghbGFzdERpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIGxhc3REaW1lbnNpb25zID0gY3VycmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGFzdERpbWVuc2lvbnMgPT09IGN1cnJlbnREaW1lbnNpb25zIHx8XG4gICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA9PT0gVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5TTE9XLCB7XG4gICAgICAgICAgICB3aWR0aDogdmlkZW9FbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3REaW1lbnNpb25zID0gY3VycmVudERpbWVuc2lvbnM7XG4gICAgICAgIH0pO1xuICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKHZpZGVvRWxlbWVudCk7XG5cbiAgICAvLyBlbGVtZW50IHJlbmRlcnMgYW5kIGdldHMgYm91bmQgLSB0cmFjayBzdWJzY3JpcHRpb24gZ2V0c1xuICAgIC8vIHRyaWdnZXJlZCBmaXJzdCBvdGhlciBvbmVzIGdldCBza2lwcGVkIG9uIGluaXRpYWwgc3Vic2NyaXB0aW9uc1xuICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrc1N1YnNjcmlwdGlvbiA9IGJvdW5kUGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50XG4gICAgICA/IG51bGxcbiAgICAgIDogcGFydGljaXBhbnQkXG4gICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgncHVibGlzaGVkVHJhY2tzJyksXG4gICAgICAgICAgICBtYXAoKHApID0+XG4gICAgICAgICAgICAgIHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgIHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snXG4gICAgICAgICAgICAgICAgICA/IFRyYWNrVHlwZS5WSURFT1xuICAgICAgICAgICAgICAgICAgOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgICAgKVxuICAgICAgICAgIC5zdWJzY3JpYmUoKGlzUHVibGlzaGluZykgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUHVibGlzaGluZykge1xuICAgICAgICAgICAgICAvLyB0aGUgcGFydGljaXBhbnQganVzdCBzdGFydGVkIHRvIHB1Ymxpc2ggYSB0cmFja1xuICAgICAgICAgICAgICByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuRkFTVCwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB2aWRlb0VsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudCBqdXN0IHN0b3BwZWQgcHVibGlzaGluZyBhIHRyYWNrXG4gICAgICAgICAgICAgIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5GQVNULCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgdmlkZW9FbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICB2aWRlb0VsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuXG4gICAgLy8gZXhwbGljaXRseSBtYXJraW5nIHRoZSBlbGVtZW50IGFzIG11dGVkIHdpbGwgYWxsb3cgYXV0b3BsYXkgdG8gd29ya1xuICAgIC8vIHdpdGhvdXQgcHJpb3IgdXNlciBpbnRlcmFjdGlvbjpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9NZWRpYS9BdXRvcGxheV9ndWlkZVxuICAgIHZpZGVvRWxlbWVudC5tdXRlZCA9IHRydWU7XG5cbiAgICBjb25zdCBzdHJlYW1TdWJzY3JpcHRpb24gPSBwYXJ0aWNpcGFudCRcbiAgICAgIC5waXBlKFxuICAgICAgICBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZChcbiAgICAgICAgICB0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJyA/ICd2aWRlb1N0cmVhbScgOiAnc2NyZWVuU2hhcmVTdHJlYW0nLFxuICAgICAgICApLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgocCkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2UgPVxuICAgICAgICAgIHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snID8gcC52aWRlb1N0cmVhbSA6IHAuc2NyZWVuU2hhcmVTdHJlYW07XG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID09PSBzb3VyY2UpIHJldHVybjtcbiAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHNvdXJjZSA/PyBudWxsO1xuICAgICAgICBpZiAoaXNTYWZhcmkoKSB8fCBpc0ZpcmVmb3goKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHNvdXJjZSA/PyBudWxsO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBsYXkoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBGYWlsZWQgdG8gcGxheSBzdHJlYW1gLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2UgYWRkIGV4dHJhIGRlbGF5IHVudGlsIHdlIGF0dGVtcHQgdG8gZm9yY2UtcGxheVxuICAgICAgICAgICAgLy8gdGhlIHBhcnRpY2lwYW50J3MgbWVkaWEgc3RyZWFtIGluIEZpcmVmb3ggYW5kIFNhZmFyaSxcbiAgICAgICAgICAgIC8vIGFzIHRoZXkgc2VlbSB0byBoYXZlIHNvbWUgdGltaW5nIGlzc3Vlc1xuICAgICAgICAgIH0sIDI1KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoRGVib3VuY2VUeXBlLkZBU1QsIHVuZGVmaW5lZCk7XG4gICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgIHB1Ymxpc2hlZFRyYWNrc1N1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgIHN0cmVhbVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgcmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kcyBhIERPTSA8YXVkaW8+IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGF1ZGlvIGVsZW1lbnQgd2lsbFxuICAgKiBwbGF5IHRoZSBjb3JyZWN0IGF1ZGlvIHN0cmVhbSBmb3IgdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAqXG4gICAqIEBwYXJhbSBhdWRpb0VsZW1lbnQgdGhlIGF1ZGlvIGVsZW1lbnQgdG8gYmluZCB0by5cbiAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiBhdWRpby5cbiAgICogQHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgd2lsbCB1bmJpbmQgdGhlIGF1ZGlvIGVsZW1lbnQuXG4gICAqL1xuICBiaW5kQXVkaW9FbGVtZW50ID0gKFxuICAgIGF1ZGlvRWxlbWVudDogSFRNTEF1ZGlvRWxlbWVudCxcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICB0cmFja1R5cGU6IEF1ZGlvVHJhY2tUeXBlLFxuICApID0+IHtcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY2FsbC5zdGF0ZS5maW5kUGFydGljaXBhbnRCeVNlc3Npb25JZChzZXNzaW9uSWQpO1xuICAgIGlmICghcGFydGljaXBhbnQgfHwgcGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50KSByZXR1cm47XG5cbiAgICBjb25zdCBwYXJ0aWNpcGFudCQgPSB0aGlzLmNhbGwuc3RhdGUucGFydGljaXBhbnRzJC5waXBlKFxuICAgICAgbWFwKFxuICAgICAgICAocGFydGljaXBhbnRzKSA9PlxuICAgICAgICAgIHBhcnRpY2lwYW50cy5maW5kKFxuICAgICAgICAgICAgKHApID0+IHAuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQsXG4gICAgICAgICAgKSBhcyBTdHJlYW1WaWRlb1BhcnRpY2lwYW50LFxuICAgICAgKSxcbiAgICAgIHRha2VXaGlsZSgocCkgPT4gISFwKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCB1cGRhdGVNZWRpYVN0cmVhbVN1YnNjcmlwdGlvbiA9IHBhcnRpY2lwYW50JFxuICAgICAgLnBpcGUoXG4gICAgICAgIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKFxuICAgICAgICAgIHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlQXVkaW9UcmFjaydcbiAgICAgICAgICAgID8gJ3NjcmVlblNoYXJlQXVkaW9TdHJlYW0nXG4gICAgICAgICAgICA6ICdhdWRpb1N0cmVhbScsXG4gICAgICAgICksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9XG4gICAgICAgICAgdHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVBdWRpb1RyYWNrJ1xuICAgICAgICAgICAgPyBwLnNjcmVlblNoYXJlQXVkaW9TdHJlYW1cbiAgICAgICAgICAgIDogcC5hdWRpb1N0cmVhbTtcbiAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5zcmNPYmplY3QgPT09IHNvdXJjZSkgcmV0dXJuO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGF1ZGlvRWxlbWVudC5zcmNPYmplY3QgPSBzb3VyY2UgPz8gbnVsbDtcbiAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgYXVkaW9FbGVtZW50LnBsYXkoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBGYWlsZWQgdG8gcGxheSBzdHJlYW1gLCBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhdWRpbyBvdXRwdXQgZGV2aWNlIHNoYWxsIGJlIHNldCBhZnRlciB0aGUgYXVkaW8gZWxlbWVudCBpcyBwbGF5ZWRcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIGJyb3dzZXIgd2lsbCBub3QgcGljayBpdCB1cCwgYW5kIHdpbGwgYWx3YXlzXG4gICAgICAgICAgICAvLyBwbGF5IGF1ZGlvIHRocm91Z2ggdGhlIHN5c3RlbSdzIGRlZmF1bHQgZGV2aWNlXG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkRGV2aWNlIH0gPSB0aGlzLmNhbGwuc3BlYWtlci5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZERldmljZSAmJiAnc2V0U2lua0lkJyBpbiBhdWRpb0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgYXVkaW9FbGVtZW50LnNldFNpbmtJZChzZWxlY3RlZERldmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc2lua0lkU3Vic2NyaXB0aW9uID0gISgnc2V0U2lua0lkJyBpbiBhdWRpb0VsZW1lbnQpXG4gICAgICA/IG51bGxcbiAgICAgIDogdGhpcy5jYWxsLnNwZWFrZXIuc3RhdGUuc2VsZWN0ZWREZXZpY2UkLnN1YnNjcmliZSgoZGV2aWNlSWQpID0+IHtcbiAgICAgICAgICBpZiAoZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIGF1ZGlvRWxlbWVudC5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCB2b2x1bWVTdWJzY3JpcHRpb24gPSBjb21iaW5lTGF0ZXN0KFtcbiAgICAgIHRoaXMuY2FsbC5zcGVha2VyLnN0YXRlLnZvbHVtZSQsXG4gICAgICBwYXJ0aWNpcGFudCQucGlwZShkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnYXVkaW9Wb2x1bWUnKSksXG4gICAgXSkuc3Vic2NyaWJlKChbdm9sdW1lLCBwXSkgPT4ge1xuICAgICAgYXVkaW9FbGVtZW50LnZvbHVtZSA9IHAuYXVkaW9Wb2x1bWUgPz8gdm9sdW1lO1xuICAgIH0pO1xuXG4gICAgYXVkaW9FbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzaW5rSWRTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICB2b2x1bWVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHVwZGF0ZU1lZGlhU3RyZWFtU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfTtcbn1cbiIsImltcG9ydCB7IENhbGxTZXR0aW5nc1Jlc3BvbnNlLCBPd25DYXBhYmlsaXR5IH0gZnJvbSAnLi4vZ2VuL2Nvb3JkaW5hdG9yJztcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudCB1c2VyIGFuZCBleHBvc2VzXG4gKiBhIGZldyBoZWxwZXIgbWV0aG9kcyB3aGljaCBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggcGVybWlzc2lvbnMuXG4gKlxuICogVGhpcyBpcyBhbiBpbnRlcm5hbCBjbGFzcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGhcbiAqIGEge0BsaW5rIENhbGx9IGluc3RhbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbnNDb250ZXh0IHtcbiAgcHJpdmF0ZSBwZXJtaXNzaW9uczogT3duQ2FwYWJpbGl0eVtdID0gW107XG4gIHByaXZhdGUgc2V0dGluZ3M/OiBDYWxsU2V0dGluZ3NSZXNwb25zZTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50IHVzZXIuXG4gICAqXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9ucyB0aGUgcGVybWlzc2lvbnMgdG8gc2V0LlxuICAgKi9cbiAgc2V0UGVybWlzc2lvbnMgPSAocGVybWlzc2lvbnM6IE93bkNhcGFiaWxpdHlbXSkgPT4ge1xuICAgIHRoaXMucGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucyB8fCBbXTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgc2V0dGluZ3MgZm9yIHRoZSBib3VuZCBjYWxsLlxuICAgKiBAcGFyYW0gc2V0dGluZ3NcbiAgICovXG4gIHNldENhbGxTZXR0aW5ncyA9IChzZXR0aW5nczogQ2FsbFNldHRpbmdzUmVzcG9uc2UpID0+IHtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyBhIHNwZWNpZmljIHBlcm1pc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9uIHRoZSBwZXJtaXNzaW9uIHRvIGNoZWNrIGZvci5cbiAgICovXG4gIGhhc1Blcm1pc3Npb24gPSAocGVybWlzc2lvbjogT3duQ2FwYWJpbGl0eSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zLmluY2x1ZGVzKHBlcm1pc3Npb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgdXNlciBjYW4gcmVxdWVzdCBhIHNwZWNpZmljIHBlcm1pc3Npb25cbiAgICogd2l0aGluIHRoZSBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gcGVybWlzc2lvbiB0aGUgcGVybWlzc2lvbiB0byBjaGVjayBmb3IuXG4gICAqIEBwYXJhbSBzZXR0aW5ncyB0aGUgY2FsbCBzZXR0aW5ncyB0byBjaGVjayBhZ2FpbnN0IChvcHRpb25hbCkuXG4gICAqL1xuICBjYW5SZXF1ZXN0ID0gKFxuICAgIHBlcm1pc3Npb246IE93bkNhcGFiaWxpdHksXG4gICAgc2V0dGluZ3M6IENhbGxTZXR0aW5nc1Jlc3BvbnNlIHwgdW5kZWZpbmVkID0gdGhpcy5zZXR0aW5ncyxcbiAgKSA9PiB7XG4gICAgaWYgKCFzZXR0aW5ncykgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgeyBhdWRpbywgdmlkZW8sIHNjcmVlbnNoYXJpbmcgfSA9IHNldHRpbmdzO1xuICAgIHN3aXRjaCAocGVybWlzc2lvbikge1xuICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNFTkRfQVVESU86XG4gICAgICAgIHJldHVybiBhdWRpby5hY2Nlc3NfcmVxdWVzdF9lbmFibGVkO1xuICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNFTkRfVklERU86XG4gICAgICAgIHJldHVybiB2aWRlby5hY2Nlc3NfcmVxdWVzdF9lbmFibGVkO1xuICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFOlxuICAgICAgICByZXR1cm4gc2NyZWVuc2hhcmluZy5hY2Nlc3NfcmVxdWVzdF9lbmFibGVkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IFN0cmVhbVZpZGVvUGFydGljaXBhbnQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIENvbXBhcmF0b3IsXG4gIGRlZmF1bHRTb3J0UHJlc2V0LFxuICBsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0LFxufSBmcm9tICcuL3NvcnRpbmcnO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGZvciBhIHtAbGluayBDYWxsVHlwZX0uXG4gKi9cbmV4cG9ydCB0eXBlIENhbGxUeXBlT3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIFRoZSB7QGxpbmsgQ29tcGFyYXRvcn0gdG8gdXNlIHRvIHNvcnRpbmcgdGhlIHBhcnRpY2lwYW50cyBpbiB0aGUgY2FsbC5cbiAgICovXG4gIHNvcnRQYXJ0aWNpcGFudHNCeT86IENvbXBhcmF0b3I8U3RyZWFtVmlkZW9QYXJ0aWNpcGFudD47XG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjYWxsIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsVHlwZSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgY2FsbCB0eXBlLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9ucyBmb3IgdGhlIGNhbGwgdHlwZS5cbiAgICovXG4gIG9wdGlvbnM6IENhbGxUeXBlT3B0aW9ucztcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBDYWxsVHlwZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGNhbGwgdHlwZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjYWxsIHR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9uczogQ2FsbFR5cGVPcHRpb25zID0ge1xuICAgICAgc29ydFBhcnRpY2lwYW50c0J5OiBkZWZhdWx0U29ydFByZXNldCxcbiAgICB9LFxuICApIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHJlZ2lzdHJ5IG9mIHtAbGluayBDYWxsVHlwZX1zLlxuICogWW91IGNhbiByZWdpc3RlciBhbmQgdW5yZWdpc3RlciBjYWxsIHR5cGVzLlxuICovXG5jbGFzcyBDYWxsVHlwZXNSZWdpc3RyeSB7XG4gIC8qKlxuICAgKiBUaGUgY2FsbCB0eXBlcyByZWdpc3RlcmVkIGluIHRoaXMgcmVnaXN0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGNhbGxUeXBlczogeyBba2V5OiBzdHJpbmddOiBDYWxsVHlwZSB9O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENhbGxUeXBlc1JlZ2lzdHJ5LlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbFR5cGVzIHRoZSBpbml0aWFsIGNhbGwgdHlwZXMgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYWxsVHlwZXM6IENhbGxUeXBlW10pIHtcbiAgICB0aGlzLmNhbGxUeXBlcyA9IGNhbGxUeXBlcy5yZWR1Y2U8eyBba2V5OiBzdHJpbmddOiBDYWxsVHlwZSB9PihcbiAgICAgIChhY2MsIGNhbGxUeXBlKSA9PiB7XG4gICAgICAgIGFjY1tjYWxsVHlwZS5uYW1lXSA9IGNhbGxUeXBlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbmV3IGNhbGwgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxUeXBlIHRoZSBjYWxsIHR5cGUgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICByZWdpc3RlciA9IChjYWxsVHlwZTogQ2FsbFR5cGUpID0+IHtcbiAgICB0aGlzLmNhbGxUeXBlc1tjYWxsVHlwZS5uYW1lXSA9IGNhbGxUeXBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVycyBhIGNhbGwgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGNhbGwgdHlwZSB0byB1bnJlZ2lzdGVyLlxuICAgKi9cbiAgdW5yZWdpc3RlciA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBkZWxldGUgdGhpcy5jYWxsVHlwZXNbbmFtZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBjYWxsIHR5cGUgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGNhbGwgdHlwZSB0byBnZXQuXG4gICAqL1xuICBnZXQgPSAobmFtZTogc3RyaW5nKTogQ2FsbFR5cGUgPT4ge1xuICAgIGlmICghdGhpcy5jYWxsVHlwZXNbbmFtZV0pIHtcbiAgICAgIHRoaXMucmVnaXN0ZXIobmV3IENhbGxUeXBlKG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsbFR5cGVzW25hbWVdO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNhbGwgdHlwZXMgcmVnaXN0cnkuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGluc3RhbmNlIHRvIGR5bmFtaWNhbGx5IHJlZ2lzdGVyIGFuZCB1bnJlZ2lzdGVyIGNhbGwgdHlwZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBDYWxsVHlwZXMgPSBuZXcgQ2FsbFR5cGVzUmVnaXN0cnkoW1xuICBuZXcgQ2FsbFR5cGUoJ2RlZmF1bHQnLCB7XG4gICAgc29ydFBhcnRpY2lwYW50c0J5OiBkZWZhdWx0U29ydFByZXNldCxcbiAgfSksXG4gIG5ldyBDYWxsVHlwZSgnZGV2ZWxvcG1lbnQnLCB7XG4gICAgc29ydFBhcnRpY2lwYW50c0J5OiBkZWZhdWx0U29ydFByZXNldCxcbiAgfSksXG4gIG5ldyBDYWxsVHlwZSgnbGl2ZXN0cmVhbScsIHtcbiAgICBzb3J0UGFydGljaXBhbnRzQnk6IGxpdmVzdHJlYW1PckF1ZGlvUm9vbVNvcnRQcmVzZXQsXG4gIH0pLFxuICBuZXcgQ2FsbFR5cGUoJ2F1ZGlvX3Jvb20nLCB7XG4gICAgc29ydFBhcnRpY2lwYW50c0J5OiBsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0LFxuICB9KSxcbl0pO1xuIiwiaW1wb3J0IHtcbiAgY29uY2F0TWFwLFxuICBkZWJvdW5jZVRpbWUsXG4gIGZyb20sXG4gIG1hcCxcbiAgbWVyZ2UsXG4gIE9ic2VydmFibGUsXG4gIHNoYXJlUmVwbGF5LFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGRldmljZXNcbiAqIHRoYXQgbWVldCB0aGUgZ2l2ZW4gY29uc3RyYWludHMuXG4gKlxuICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBkZXZpY2VzLlxuICogQHBhcmFtIGtpbmQgdGhlIGtpbmQgb2YgZGV2aWNlcyB0byBlbnVtZXJhdGUuXG4gKi9cbmNvbnN0IGdldERldmljZXMgPSAoXG4gIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzLFxuICBraW5kOiBNZWRpYURldmljZUtpbmQsXG4pID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlPE1lZGlhRGV2aWNlSW5mb1tdPigoc3Vic2NyaWJlcikgPT4ge1xuICAgIGNvbnN0IGVudW1lcmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBkZXZpY2VzID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAvLyBzb21lIGJyb3dzZXJzIHJlcG9ydCBlbXB0eSBkZXZpY2UgbGFiZWxzIChGaXJlZm94KS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byByZXF1ZXN0IHBlcm1pc3Npb25zICh2aWEgZ2V0VXNlck1lZGlhKVxuICAgICAgLy8gdG8gYmUgYWJsZSB0byBnZXQgdGhlIGRldmljZSBsYWJlbHNcbiAgICAgIGNvbnN0IG5lZWRzR2V0VXNlck1lZGlhID0gZGV2aWNlcy5zb21lKFxuICAgICAgICAoZGV2aWNlKSA9PiBkZXZpY2Uua2luZCA9PT0ga2luZCAmJiBkZXZpY2UubGFiZWwgPT09ICcnLFxuICAgICAgKTtcbiAgICAgIGlmIChuZWVkc0dldFVzZXJNZWRpYSkge1xuICAgICAgICBsZXQgbWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtIHwgdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1lZGlhU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgICAgIGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAobWVkaWFTdHJlYW0pIGRpc3Bvc2VPZk1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfTtcblxuICAgIGVudW1lcmF0ZSgpXG4gICAgICAudGhlbigoZGV2aWNlcykgPT4ge1xuICAgICAgICAvLyBub3RpZnkgc3Vic2NyaWJlcnMgYW5kIGNvbXBsZXRlXG4gICAgICAgIHN1YnNjcmliZXIubmV4dChkZXZpY2VzKTtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnZGV2aWNlcyddKTtcbiAgICAgICAgbG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gZW51bWVyYXRlIGRldmljZXMnLCBlcnJvcik7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBbVGVsbHMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gb3V0cHV0IGNoYW5nZSBvbiAnYXVkaW8nIGVsZW1lbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQpLlxuICpcbiAqICAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrSWZBdWRpb091dHB1dENoYW5nZVN1cHBvcnRlZCA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIHJldHVybiAnc2V0U2lua0lkJyBpbiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBjb25zdHJhaW50cyB1c2VkIHRvIHJlcXVlc3QgYXVkaW8gZGV2aWNlcy5cbiAqL1xuY29uc3QgYXVkaW9EZXZpY2VDb25zdHJhaW50cyA9IHtcbiAgYXVkaW86IHtcbiAgICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gICAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcbiAgICBlY2hvQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICB9LFxufSBzYXRpc2ZpZXMgTWVkaWFTdHJlYW1Db25zdHJhaW50cztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBjb25zdHJhaW50cyB1c2VkIHRvIHJlcXVlc3QgdmlkZW8gZGV2aWNlcy5cbiAqL1xuY29uc3QgdmlkZW9EZXZpY2VDb25zdHJhaW50cyA9IHtcbiAgdmlkZW86IHtcbiAgICB3aWR0aDogMTI4MCxcbiAgICBoZWlnaHQ6IDcyMCxcbiAgfSxcbn0gc2F0aXNmaWVzIE1lZGlhU3RyZWFtQ29uc3RyYWludHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1lbW9pemVkIG9ic2VydmFibGUgaW5zdGFuY2VcbiAqIHRoYXQgd2lsbCBiZSBjcmVhdGVkIG9ubHkgb25jZSBhbmQgc2hhcmVkIGJldHdlZW4gYWxsIGNhbGxlcnMuXG4gKlxuICogQHBhcmFtIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBPYnNlcnZhYmxlLlxuICovXG5jb25zdCBtZW1vaXplZE9ic2VydmFibGUgPSA8VD4oY3JlYXRlOiAoKSA9PiBPYnNlcnZhYmxlPFQ+KSA9PiB7XG4gIGxldCBtZW1vaXplZDogT2JzZXJ2YWJsZTxUPjtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoIW1lbW9pemVkKSBtZW1vaXplZCA9IGNyZWF0ZSgpO1xuICAgIHJldHVybiBtZW1vaXplZDtcbiAgfTtcbn07XG5cbmNvbnN0IGdldERldmljZUNoYW5nZU9ic2VydmVyID0gbWVtb2l6ZWRPYnNlcnZhYmxlKCgpID0+IHtcbiAgLy8gQXVkaW8gYW5kIHZpZGVvIGRldmljZXMgYXJlIHJlcXVlc3RlZCBpbiB0d28gc2VwYXJhdGUgcmVxdWVzdHMuXG4gIC8vIFRoYXQgd2F5LCB1c2VycyB3aWxsIGJlIHByZXNlbnRlZCB3aXRoIHR3byBzZXBhcmF0ZSBwcm9tcHRzXG4gIC8vIC0+IHRoZXkgY2FuIGdpdmUgYWNjZXNzIHRvIGp1c3QgY2FtZXJhLCBvciBqdXN0IG1pY3JvcGhvbmVcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgLy8gJ2FkZEV2ZW50TGlzdGVuZXInIGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgTmF0aXZlXG4gICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdGlmeSA9ICgpID0+IHN1YnNjcmliZXIubmV4dCgpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgbm90aWZ5KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCBub3RpZnkpO1xuICAgIH07XG4gIH0pLnBpcGUoXG4gICAgZGVib3VuY2VUaW1lKDUwMCksXG4gICAgY29uY2F0TWFwKCgpID0+IGZyb20obmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkpKSxcbiAgICBzaGFyZVJlcGxheSgxKSxcbiAgKTtcbn0pO1xuXG5jb25zdCBnZXRBdWRpb0RldmljZXNPYnNlcnZlciA9IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiB7XG4gIHJldHVybiBtZXJnZShcbiAgICBnZXREZXZpY2VzKGF1ZGlvRGV2aWNlQ29uc3RyYWludHMsICdhdWRpb2lucHV0JyksXG4gICAgZ2V0RGV2aWNlQ2hhbmdlT2JzZXJ2ZXIoKSxcbiAgKS5waXBlKHNoYXJlUmVwbGF5KDEpKTtcbn0pO1xuXG5jb25zdCBnZXRBdWRpb091dHB1dERldmljZXNPYnNlcnZlciA9IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiB7XG4gIHJldHVybiBtZXJnZShcbiAgICBnZXREZXZpY2VzKGF1ZGlvRGV2aWNlQ29uc3RyYWludHMsICdhdWRpb291dHB1dCcpLFxuICAgIGdldERldmljZUNoYW5nZU9ic2VydmVyKCksXG4gICkucGlwZShzaGFyZVJlcGxheSgxKSk7XG59KTtcblxuY29uc3QgZ2V0VmlkZW9EZXZpY2VzT2JzZXJ2ZXIgPSBtZW1vaXplZE9ic2VydmFibGUoKCkgPT4ge1xuICByZXR1cm4gbWVyZ2UoXG4gICAgZ2V0RGV2aWNlcyh2aWRlb0RldmljZUNvbnN0cmFpbnRzLCAndmlkZW9pbnB1dCcpLFxuICAgIGdldERldmljZUNoYW5nZU9ic2VydmVyKCksXG4gICkucGlwZShzaGFyZVJlcGxheSgxKSk7XG59KTtcblxuLyoqXG4gKiBQcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIGF1ZGlvIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpIGFuZCBsaXN0cyB0aGUgYXZhaWxhYmxlICdhdWRpb2lucHV0JyBkZXZpY2VzLCBpZiBkZXZpY2VzIGFyZSBhZGRlZC9yZW1vdmVkIHRoZSBsaXN0IGlzIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdWRpb0RldmljZXMgPSAoKSA9PiB7XG4gIHJldHVybiBnZXRBdWRpb0RldmljZXNPYnNlcnZlcigpLnBpcGUoXG4gICAgbWFwKCh2YWx1ZXMpID0+IHZhbHVlcy5maWx0ZXIoKGQpID0+IGQua2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSksXG4gICk7XG59O1xuXG4vKipcbiAqIFByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byB1c2UgdmlkZW8gZGV2aWNlcyAoaWYgbm90IGFscmVhZHkgZ3JhbnRlZCkgYW5kIGxpc3RzIHRoZSBhdmFpbGFibGUgJ3ZpZGVvaW5wdXQnIGRldmljZXMsIGlmIGRldmljZXMgYXJlIGFkZGVkL3JlbW92ZWQgdGhlIGxpc3QgaXMgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFZpZGVvRGV2aWNlcyA9ICgpID0+IHtcbiAgcmV0dXJuIGdldFZpZGVvRGV2aWNlc09ic2VydmVyKCkucGlwZShcbiAgICBtYXAoKHZhbHVlcykgPT4gdmFsdWVzLmZpbHRlcigoZCkgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpKSxcbiAgKTtcbn07XG5cbi8qKlxuICogUHJvbXB0cyB0aGUgdXNlciBmb3IgYSBwZXJtaXNzaW9uIHRvIHVzZSBhdWRpbyBkZXZpY2VzIChpZiBub3QgYWxyZWFkeSBncmFudGVkKSBhbmQgbGlzdHMgdGhlIGF2YWlsYWJsZSAnYXVkaW9vdXRwdXQnIGRldmljZXMsIGlmIGRldmljZXMgYXJlIGFkZGVkL3JlbW92ZWQgdGhlIGxpc3QgaXMgdXBkYXRlZC4gU2VsZWN0aW5nICdhdWRpb291dHB1dCcgZGV2aWNlIG9ubHkgbWFrZXMgc2Vuc2UgaWYgW3RoZSBicm93c2VyIGhhcyBzdXBwb3J0IGZvciBjaGFuZ2luZyBhdWRpbyBvdXRwdXQgb24gJ2F1ZGlvJyBlbGVtZW50c10oI2NoZWNraWZhdWRpb291dHB1dGNoYW5nZXN1cHBvcnRlZClcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF1ZGlvT3V0cHV0RGV2aWNlcyA9ICgpID0+IHtcbiAgcmV0dXJuIGdldEF1ZGlvT3V0cHV0RGV2aWNlc09ic2VydmVyKCkucGlwZShcbiAgICBtYXAoKHZhbHVlcykgPT4gdmFsdWVzLmZpbHRlcigoZCkgPT4gZC5raW5kID09PSAnYXVkaW9vdXRwdXQnKSksXG4gICk7XG59O1xuXG5jb25zdCBnZXRTdHJlYW0gPSBhc3luYyAoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZ2V0TG9nZ2VyKFsnZGV2aWNlcyddKSgnZXJyb3InLCBgRmFpbGVkIGdldCB1c2VyIG1lZGlhYCwge1xuICAgICAgZXJyb3I6IGUsXG4gICAgICBjb25zdHJhaW50czogY29uc3RyYWludHMsXG4gICAgfSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGF1ZGlvIG1lZGlhIHN0cmVhbSB0aGF0IGZ1bGZpbGxzIHRoZSBnaXZlbiBjb25zdHJhaW50cy5cbiAqIElmIG5vIGNvbnN0cmFpbnRzIGFyZSBwcm92aWRlZCwgaXQgdXNlcyB0aGUgYnJvd3NlcidzIGRlZmF1bHQgb25lcy5cbiAqXG4gKiBAYW5ndWxhciBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgW2BEZXZpY2VNYW5hZ2VyU2VydmljZWBdKC4vRGV2aWNlTWFuYWdlclNlcnZpY2UubWQpIGZvciBhIGhpZ2hlciBsZXZlbCBBUEksIHVzZSB0aGlzIGxvdy1sZXZlbCBtZXRob2Qgb25seSBpZiB0aGUgYERldmljZU1hbmFnZXJTZXJ2aWNlYCBkb2Vzbid0IHN1aXQgeW91ciByZXF1aXJlbWVudHMuXG4gKiBAcGFyYW0gdHJhY2tDb25zdHJhaW50cyB0aGUgY29uc3RyYWludHMgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgc3RyZWFtLlxuICogQHJldHVybnMgdGhlIG5ldyBgTWVkaWFTdHJlYW1gIGZ1bGZpbGxpbmcgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICovXG5leHBvcnQgY29uc3QgZ2V0QXVkaW9TdHJlYW0gPSBhc3luYyAoXG4gIHRyYWNrQ29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHMsXG4pID0+IHtcbiAgY29uc3QgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgYXVkaW86IHtcbiAgICAgIC4uLmF1ZGlvRGV2aWNlQ29uc3RyYWludHMuYXVkaW8sXG4gICAgICAuLi50cmFja0NvbnN0cmFpbnRzLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiBnZXRTdHJlYW0oY29uc3RyYWludHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgdmlkZW8gbWVkaWEgc3RyZWFtIHRoYXQgZnVsZmlsbHMgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICogSWYgbm8gY29uc3RyYWludHMgYXJlIHByb3ZpZGVkLCBpdCB1c2VzIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBvbmVzLlxuICpcbiAqIEBhbmd1bGFyIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBbYERldmljZU1hbmFnZXJTZXJ2aWNlYF0oLi9EZXZpY2VNYW5hZ2VyU2VydmljZS5tZCkgZm9yIGEgaGlnaGVyIGxldmVsIEFQSSwgdXNlIHRoaXMgbG93LWxldmVsIG1ldGhvZCBvbmx5IGlmIHRoZSBgRGV2aWNlTWFuYWdlclNlcnZpY2VgIGRvZXNuJ3Qgc3VpdCB5b3VyIHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSB0cmFja0NvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyBhIG5ldyBgTWVkaWFTdHJlYW1gIGZ1bGZpbGxpbmcgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICovXG5leHBvcnQgY29uc3QgZ2V0VmlkZW9TdHJlYW0gPSBhc3luYyAoXG4gIHRyYWNrQ29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHMsXG4pID0+IHtcbiAgY29uc3QgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgdmlkZW86IHtcbiAgICAgIC4uLnZpZGVvRGV2aWNlQ29uc3RyYWludHMudmlkZW8sXG4gICAgICAuLi50cmFja0NvbnN0cmFpbnRzLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiBnZXRTdHJlYW0oY29uc3RyYWludHMpO1xufTtcblxuLyoqXG4gKiBQcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gc2hhcmUgYSBzY3JlZW4uXG4gKiBJZiB0aGUgdXNlciBncmFudHMgdGhlIHBlcm1pc3Npb24sIGEgc2NyZWVuIHNoYXJpbmcgc3RyZWFtIGlzIHJldHVybmVkLiBUaHJvd3Mgb3RoZXJ3aXNlLlxuICpcbiAqIFRoZSBjYWxsZXJzIG9mIHRoaXMgQVBJIGFyZSByZXNwb25zaWJsZSB0byBoYW5kbGUgdGhlIHBvc3NpYmxlIGVycm9ycy5cbiAqXG4gKiBAYW5ndWxhciBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgW2BEZXZpY2VNYW5hZ2VyU2VydmljZWBdKC4vRGV2aWNlTWFuYWdlclNlcnZpY2UubWQpIGZvciBhIGhpZ2hlciBsZXZlbCBBUEksIHVzZSB0aGlzIGxvdy1sZXZlbCBtZXRob2Qgb25seSBpZiB0aGUgYERldmljZU1hbmFnZXJTZXJ2aWNlYCBkb2Vzbid0IHN1aXQgeW91ciByZXF1aXJlbWVudHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgYW55IGFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBbYGdldERpc3BsYXlNZWRpYWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0RGlzcGxheU1lZGlhKSBBUEkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTY3JlZW5TaGFyZVN0cmVhbSA9IGFzeW5jIChcbiAgb3B0aW9ucz86IERpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMsXG4pID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xuICAgICAgdmlkZW86IHRydWUsXG4gICAgICBhdWRpbzoge1xuICAgICAgICBjaGFubmVsQ291bnQ6IHtcbiAgICAgICAgICBpZGVhbDogMixcbiAgICAgICAgfSxcbiAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogZmFsc2UsXG4gICAgICAgIGF1dG9HYWluQ29udHJvbDogZmFsc2UsXG4gICAgICAgIG5vaXNlU3VwcHJlc3Npb246IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBub3QgcHJlc2VudCBpbiB0eXBlcyB5ZXRcbiAgICAgIHN5c3RlbUF1ZGlvOiAnaW5jbHVkZScsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZ2V0TG9nZ2VyKFsnZGV2aWNlcyddKSgnZXJyb3InLCAnRmFpbGVkIHRvIGdldCBzY3JlZW4gc2hhcmUgc3RyZWFtJywgZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRldmljZUlkcyQgPVxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PlxuICAgICAgICBtZXJnZShcbiAgICAgICAgICBmcm9tKG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpKSxcbiAgICAgICAgICBnZXREZXZpY2VDaGFuZ2VPYnNlcnZlcigpLFxuICAgICAgICApLnBpcGUoc2hhcmVSZXBsYXkoMSkpLFxuICAgICAgKSgpXG4gICAgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogRGVhY3RpdmF0ZXMgTWVkaWFTdHJlYW0gKHN0b3BzIGFuZCByZW1vdmVzIHRyYWNrcykgdG8gYmUgbGF0ZXIgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqXG4gKiBAcGFyYW0gc3RyZWFtIE1lZGlhU3RyZWFtXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cbmV4cG9ydCBjb25zdCBkaXNwb3NlT2ZNZWRpYVN0cmVhbSA9IChzdHJlYW06IE1lZGlhU3RyZWFtKSA9PiB7XG4gIGlmICghc3RyZWFtLmFjdGl2ZSkgcmV0dXJuO1xuICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICB0cmFjay5zdG9wKCk7XG4gICAgc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgfSk7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVsZWFzZSgpIGlzIHByZXNlbnQgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0YyBhbmQgbXVzdCBiZSBjYWxsZWQgdG8gZGlzcG9zZSB0aGUgc3RyZWFtXG4gIGlmICh0eXBlb2Ygc3RyZWFtLnJlbGVhc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgc3RyZWFtLnJlbGVhc2UoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIE9ic2VydmFibGUsIHBhaXJ3aXNlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDYWxsIH0gZnJvbSAnLi4vQ2FsbCc7XG5pbXBvcnQgeyBDYWxsaW5nU3RhdGUgfSBmcm9tICcuLi9zdG9yZSc7XG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9zdG9yZS9yeFV0aWxzJztcbmltcG9ydCB7IElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUgfSBmcm9tICcuL0lucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUnO1xuaW1wb3J0IHsgaXNSZWFjdE5hdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvcGxhdGZvcm1zJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IFRyYWNrVHlwZSB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvbW9kZWxzL21vZGVscyc7XG5pbXBvcnQgeyBkZXZpY2VJZHMkIH0gZnJvbSAnLi9kZXZpY2VzJztcblxuZXhwb3J0IHR5cGUgTWVkaWFTdHJlYW1GaWx0ZXIgPSAoc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4gUHJvbWlzZTxNZWRpYVN0cmVhbT47XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlcjxcbiAgVCBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGU8Qz4sXG4gIEMgPSBNZWRpYVRyYWNrQ29uc3RyYWludHMsXG4+IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5hYmxlUHJvbWlzZT86IFByb21pc2U8dm9pZD47XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRpc2FibGVQcm9taXNlPzogUHJvbWlzZTx2b2lkPjtcbiAgLyoqXG4gICAqIGlmIHRydWUsIHN0b3BzIHRoZSBtZWRpYSBzdHJlYW0gd2hlbiBjYWxsIGlzIGxlZnRcbiAgICovXG4gIHN0b3BPbkxlYXZlID0gdHJ1ZTtcbiAgbG9nZ2VyOiBMb2dnZXI7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogRnVuY3Rpb25bXSA9IFtdO1xuICBwcml2YXRlIGlzVHJhY2tTdG9wcGVkRHVlVG9UcmFja0VuZCA9IGZhbHNlO1xuICBwcml2YXRlIGZpbHRlcnM6IE1lZGlhU3RyZWFtRmlsdGVyW10gPSBbXTtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNhbGw6IENhbGwsXG4gICAgcHVibGljIHJlYWRvbmx5IHN0YXRlOiBULFxuICAgIHByb3RlY3RlZCByZWFkb25seSB0cmFja1R5cGU6IFRyYWNrVHlwZSxcbiAgKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoW2Ake1RyYWNrVHlwZVt0cmFja1R5cGVdLnRvTG93ZXJDYXNlKCl9IG1hbmFnZXJgXSk7XG4gICAgaWYgKFxuICAgICAgZGV2aWNlSWRzJCAmJlxuICAgICAgIWlzUmVhY3ROYXRpdmUoKSAmJlxuICAgICAgKHRoaXMudHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8gfHwgdGhpcy50cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTylcbiAgICApIHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdGVkT3JSZXBsYWNlZERldmljZXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgdGhlIGF2YWlsYWJsZSBhdWRpby92aWRlbyBkZXZpY2VzXG4gICAqXG4gICAqIE5vdGU6IEl0IHByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byB1c2UgZGV2aWNlcyAoaWYgbm90IGFscmVhZHkgZ3JhbnRlZClcbiAgICpcbiAgICogQHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHdpbGwgYmUgdXBkYXRlZCBpZiBhIGRldmljZSBpcyBjb25uZWN0ZWQgb3IgZGlzY29ubmVjdGVkXG4gICAqL1xuICBsaXN0RGV2aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREZXZpY2VzKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHN0cmVhbS5cbiAgICovXG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykgcmV0dXJuO1xuICAgIHRoaXMuZW5hYmxlUHJvbWlzZSA9IHRoaXMudW5tdXRlU3RyZWFtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZW5hYmxlUHJvbWlzZTtcbiAgICAgIHRoaXMuc3RhdGUuc2V0U3RhdHVzKCdlbmFibGVkJyk7XG4gICAgICB0aGlzLmVuYWJsZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZW5hYmxlUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBvciBwYXVzZXMgdGhlIHN0cmVhbSBiYXNlZCBvbiBzdGF0ZS5kaXNhYmxlTW9kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVN0b3A9ZmFsc2VdIHdoZW4gdHJ1ZSwgc3RvcHMgdGhlIHRyYWNrcyByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZS5kaXNhYmxlTW9kZVxuICAgKi9cbiAgYXN5bmMgZGlzYWJsZShmb3JjZVN0b3A6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIHRoaXMuc3RhdGUucHJldlN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuICAgIGlmICghZm9yY2VTdG9wICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnKSByZXR1cm47XG4gICAgY29uc3Qgc3RvcFRyYWNrcyA9IGZvcmNlU3RvcCB8fCB0aGlzLnN0YXRlLmRpc2FibGVNb2RlID09PSAnc3RvcC10cmFja3MnO1xuICAgIHRoaXMuZGlzYWJsZVByb21pc2UgPSB0aGlzLm11dGVTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZGlzYWJsZVByb21pc2U7XG4gICAgICB0aGlzLnN0YXRlLnNldFN0YXR1cygnZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuZGlzYWJsZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGlzYWJsZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgc3RhdHVzIHdhcyBwcmV2aW91c2x5IGVuYWJsZWQsIGl0IHdpbGwgcmUtZW5hYmxlIHRoZSBkZXZpY2UuXG4gICAqL1xuICBhc3luYyByZXN1bWUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5zdGF0ZS5wcmV2U3RhdHVzID09PSAnZW5hYmxlZCcgJiZcbiAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnXG4gICAgKSB7XG4gICAgICBhd2FpdCB0aGlzLmVuYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgY3VycmVudCBkZXZpY2Ugc3RhdHVzIGlzIGRpc2FibGVkLCBpdCB3aWxsIGVuYWJsZSB0aGUgZGV2aWNlLFxuICAgKiBlbHNlIGl0IHdpbGwgZGlzYWJsZSBpdC5cbiAgICovXG4gIGFzeW5jIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgZmlsdGVyIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBzdHJlYW0uXG4gICAqXG4gICAqIFRoZSByZWdpc3RlcmVkIGZpbHRlciB3aWxsIGdldCB0aGUgZXhpc3Rpbmcgc3RyZWFtLCBhbmQgaXQgc2hvdWxkIHJldHVyblxuICAgKiBhIG5ldyBzdHJlYW0gd2l0aCB0aGUgYXBwbGllZCBmaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXIgdGhlIGZpbHRlciB0byByZWdpc3Rlci5cbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgdW5yZWdpc3RlciB0aGUgZmlsdGVyLlxuICAgKi9cbiAgYXN5bmMgcmVnaXN0ZXJGaWx0ZXIoZmlsdGVyOiBNZWRpYVN0cmVhbUZpbHRlcikge1xuICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5maWx0ZXJzID0gdGhpcy5maWx0ZXJzLmZpbHRlcigoZikgPT4gZiAhPT0gZmlsdGVyKTtcbiAgICAgIGF3YWl0IHRoaXMuYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHNldCB0aGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byBzZXQuXG4gICAqL1xuICBzZXREZWZhdWx0Q29uc3RyYWludHMoY29uc3RyYWludHM6IEMpIHtcbiAgICB0aGlzLnN0YXRlLnNldERlZmF1bHRDb25zdHJhaW50cyhjb25zdHJhaW50cyk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyBhIGRldmljZS5cbiAgICpcbiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmVcbiAgICogQHBhcmFtIGRldmljZUlkIHRoZSBkZXZpY2UgaWQgdG8gc2VsZWN0LlxuICAgKi9cbiAgYXN5bmMgc2VsZWN0KGRldmljZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZS4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZ2V0c3RyZWFtLmlvL3ZpZGVvL2RvY3MvcmVhY3RuYXRpdmUvY29yZS9jYW1lcmEtYW5kLW1pY3JvcGhvbmUvI3NwZWFrZXItbWFuYWdlbWVudCBmb3IgcmVmZXJlbmNlLicsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGV2aWNlSWQgPT09IHRoaXMuc3RhdGUuc2VsZWN0ZWREZXZpY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5zZXREZXZpY2UoZGV2aWNlSWQpO1xuICAgIGF3YWl0IHRoaXMuYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhlIG1hbmFnZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGlzcG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgocykgPT4gcygpKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgYXN5bmMgYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICBhd2FpdCB0aGlzLm11dGVTdHJlYW0oKTtcbiAgICAgIGF3YWl0IHRoaXMudW5tdXRlU3RyZWFtKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldERldmljZXMoKTogT2JzZXJ2YWJsZTxNZWRpYURldmljZUluZm9bXSB8IHVuZGVmaW5lZD47XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldFN0cmVhbShjb25zdHJhaW50czogQyk6IFByb21pc2U8TWVkaWFTdHJlYW0+O1xuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBwdWJsaXNoU3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzdG9wUHVibGlzaFN0cmVhbShzdG9wVHJhY2tzOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcblxuICBwcm90ZWN0ZWQgZ2V0VHJhY2tzKCk6IE1lZGlhU3RyZWFtVHJhY2tbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubWVkaWFTdHJlYW0/LmdldFRyYWNrcygpID8/IFtdO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIG11dGVTdHJlYW0oc3RvcFRyYWNrczogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUubWVkaWFTdHJlYW0pIHJldHVybjtcbiAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgJHtzdG9wVHJhY2tzID8gJ1N0b3BwaW5nJyA6ICdEaXNhYmxpbmcnfSBzdHJlYW1gKTtcbiAgICBpZiAodGhpcy5jYWxsLnN0YXRlLmNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCkge1xuICAgICAgYXdhaXQgdGhpcy5zdG9wUHVibGlzaFN0cmVhbShzdG9wVHJhY2tzKTtcbiAgICB9XG4gICAgdGhpcy5tdXRlTG9jYWxTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgY29uc3QgYWxsRW5kZWQgPSB0aGlzLmdldFRyYWNrcygpLmV2ZXJ5KCh0KSA9PiB0LnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpO1xuICAgIGlmIChhbGxFbmRlZCkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnN0YXRlLm1lZGlhU3RyZWFtICYmXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVsZWFzZSgpIGlzIHByZXNlbnQgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0Y1xuICAgICAgICB0eXBlb2YgdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbS5yZWxlYXNlID09PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYWxsZWQgdG8gZGlzcG9zZSB0aGUgc3RyZWFtIGluIFJOXG4gICAgICAgIHRoaXMuc3RhdGUubWVkaWFTdHJlYW0ucmVsZWFzZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5zZXRNZWRpYVN0cmVhbSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbXV0ZVRyYWNrcygpIHtcbiAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICBpZiAodHJhY2suZW5hYmxlZCkgdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSB1bm11dGVUcmFja3MoKSB7XG4gICAgdGhpcy5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgaWYgKCF0cmFjay5lbmFibGVkKSB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc3RvcFRyYWNrcygpIHtcbiAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICBpZiAodHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnKSB0cmFjay5zdG9wKCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG11dGVMb2NhbFN0cmVhbShzdG9wVHJhY2tzOiBib29sZWFuKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLm1lZGlhU3RyZWFtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdG9wVHJhY2tzKSB7XG4gICAgICB0aGlzLnN0b3BUcmFja3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tdXRlVHJhY2tzKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIHVubXV0ZVN0cmVhbSgpIHtcbiAgICB0aGlzLmxvZ2dlcignZGVidWcnLCAnU3RhcnRpbmcgc3RyZWFtJyk7XG4gICAgbGV0IHN0cmVhbTogTWVkaWFTdHJlYW07XG4gICAgaWYgKFxuICAgICAgdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbSAmJlxuICAgICAgdGhpcy5nZXRUcmFja3MoKS5ldmVyeSgodCkgPT4gdC5yZWFkeVN0YXRlID09PSAnbGl2ZScpXG4gICAgKSB7XG4gICAgICBzdHJlYW0gPSB0aGlzLnN0YXRlLm1lZGlhU3RyZWFtO1xuICAgICAgdGhpcy51bm11dGVUcmFja3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdENvbnN0cmFpbnRzID0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29uc3RyYWludHM7XG4gICAgICBjb25zdCBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAuLi5kZWZhdWx0Q29uc3RyYWludHMsXG4gICAgICAgIGRldmljZUlkOiB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlLFxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDaGFpbnMgdHdvIG1lZGlhIHN0cmVhbXMgdG9nZXRoZXIuXG4gICAgICAgKlxuICAgICAgICogSW4gb3VyIGNhc2UsIGZpbHRlcnMgTWVkaWFTdHJlYW1zIGFyZSBkZXJpdmVkIGZyb20gdGhlaXIgcGFyZW50IE1lZGlhU3RyZWFtLlxuICAgICAgICogSG93ZXZlciwgb25jZSBhIGNoaWxkIGZpbHRlcidzIHRyYWNrIGlzIHN0b3BwZWQsXG4gICAgICAgKiB0aGUgdHJhY2tzIG9mIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0gYXJlbid0IGF1dG9tYXRpY2FsbHkgc3RvcHBlZC5cbiAgICAgICAqIFRoaXMgbGVhZHMgdG8gYSBzaXR1YXRpb24gd2hlcmUgdGhlIGNhbWVyYSBpbmRpY2F0b3IgbGlnaHQgaXMgc3RpbGwgb25cbiAgICAgICAqIGV2ZW4gdGhvdWdoIHRoZSB1c2VyIHN0b3BwZWQgcHVibGlzaGluZyB2aWRlby5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFyb3VuZCB0aGlzIGlzc3VlIGJ5IHN0b3BwaW5nIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0ncyB0cmFja3NcbiAgICAgICAqIGFzIHdlbGwgb25jZSB0aGUgY2hpbGQgZmlsdGVyJ3MgdHJhY2tzIGFyZSBzdG9wcGVkLlxuICAgICAgICpcbiAgICAgICAqIEl0IHdvcmtzIGJ5IHBhdGNoaW5nIHRoZSBzdG9wKCkgbWV0aG9kIG9mIHRoZSBjaGlsZCBmaWx0ZXIncyB0cmFja3MgdG8gYWxzbyBzdG9wXG4gICAgICAgKiB0aGUgcGFyZW50IE1lZGlhU3RyZWFtJ3MgdHJhY2tzIG9mIHRoZSBzYW1lIHR5cGUuIEhlcmUgd2UgYXNzdW1lIHRoYXRcbiAgICAgICAqIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0gaGFzIG9ubHkgb25lIHRyYWNrIG9mIGVhY2ggdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50U3RyZWFtIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0uIE9taXQgZm9yIHRoZSByb290IHN0cmVhbS5cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2hhaW5XaXRoID1cbiAgICAgICAgKHBhcmVudFN0cmVhbT86IFByb21pc2U8TWVkaWFTdHJlYW0+KSA9PlxuICAgICAgICBhc3luYyAoZmlsdGVyU3RyZWFtOiBNZWRpYVN0cmVhbSk6IFByb21pc2U8TWVkaWFTdHJlYW0+ID0+IHtcbiAgICAgICAgICBpZiAoIXBhcmVudFN0cmVhbSkgcmV0dXJuIGZpbHRlclN0cmVhbTtcbiAgICAgICAgICAvLyBUT0RPIE9MOiB0YWtlIGNhcmUgb2YgdHJhY2suZW5hYmxlZCBwcm9wZXJ0eSBhcyB3ZWxsXG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gYXdhaXQgcGFyZW50U3RyZWFtO1xuICAgICAgICAgIGZpbHRlclN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gdHJhY2suc3RvcDtcbiAgICAgICAgICAgIHRyYWNrLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbCh0cmFjayk7XG4gICAgICAgICAgICAgIHBhcmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKChwYXJlbnRUcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFjay5raW5kID09PSB0cmFjay5raW5kKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRUcmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBwYXJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCgocGFyZW50VHJhY2spID0+IHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhcmVudCBzdHJlYW0gYWJydXB0bHkgZW5kcywgd2UgcHJvcGFnYXRlIHRoZSBldmVudFxuICAgICAgICAgICAgLy8gdG8gdGhlIGZpbHRlciBzdHJlYW0uXG4gICAgICAgICAgICAvLyBUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuIHRoZSBjYW1lcmEvbWljcm9waG9uZSBwZXJtaXNzaW9uc1xuICAgICAgICAgICAgLy8gYXJlIHJldm9rZWQgb3Igd2hlbiB0aGUgZGV2aWNlIGlzIGRpc2Nvbm5lY3RlZC5cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVBhcmVudFRyYWNrRW5kZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGZpbHRlclN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFjay5raW5kICE9PSB0cmFjay5raW5kKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRyYWNrLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlbmRlZCcpKTsgLy8gcHJvcGFnYXRlIHRoZSBldmVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXJlbnRUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZVBhcmVudFRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICBwYXJlbnRUcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZVBhcmVudFRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gZmlsdGVyU3RyZWFtO1xuICAgICAgICB9O1xuXG4gICAgICAvLyB3ZSBwdWJsaXNoIHRoZSBsYXN0IE1lZGlhU3RyZWFtIG9mIHRoZSBjaGFpblxuICAgICAgc3RyZWFtID0gYXdhaXQgdGhpcy5maWx0ZXJzLnJlZHVjZShcbiAgICAgICAgKHBhcmVudCwgZmlsdGVyKSA9PiBwYXJlbnQudGhlbihmaWx0ZXIpLnRoZW4oY2hhaW5XaXRoKHBhcmVudCkpLFxuICAgICAgICB0aGlzLmdldFN0cmVhbShjb25zdHJhaW50cyBhcyBDKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhbGwuc3RhdGUuY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEKSB7XG4gICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hTdHJlYW0oc3RyZWFtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUubWVkaWFTdHJlYW0gIT09IHN0cmVhbSkge1xuICAgICAgdGhpcy5zdGF0ZS5zZXRNZWRpYVN0cmVhbShzdHJlYW0pO1xuICAgICAgdGhpcy5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGVQcm9taXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgdGhpcy5pc1RyYWNrU3RvcHBlZER1ZVRvVHJhY2tFbmQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCBtZWRpYURldmljZUtpbmQoKSB7XG4gICAgaWYgKHRoaXMudHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8pIHtcbiAgICAgIHJldHVybiAnYXVkaW9pbnB1dCc7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPKSB7XG4gICAgICByZXR1cm4gJ3ZpZGVvaW5wdXQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZURpc2Nvbm5lY3RlZE9yUmVwbGFjZWREZXZpY2VzKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgICBkZXZpY2VJZHMkIS5waXBlKHBhaXJ3aXNlKCkpLFxuICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0ZWREZXZpY2UkLFxuICAgICAgICBdKSxcbiAgICAgICAgYXN5bmMgKFtbcHJldkRldmljZXMsIGN1cnJlbnREZXZpY2VzXSwgZGV2aWNlSWRdKSA9PiB7XG4gICAgICAgICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGVQcm9taXNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBpc0RldmljZURpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGxldCBpc0RldmljZVJlcGxhY2VkID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgY3VycmVudERldmljZSA9IHRoaXMuZmluZERldmljZUluTGlzdChjdXJyZW50RGV2aWNlcywgZGV2aWNlSWQpO1xuICAgICAgICAgIGNvbnN0IHByZXZEZXZpY2UgPSB0aGlzLmZpbmREZXZpY2VJbkxpc3QocHJldkRldmljZXMsIGRldmljZUlkKTtcbiAgICAgICAgICBpZiAoIWN1cnJlbnREZXZpY2UgJiYgcHJldkRldmljZSkge1xuICAgICAgICAgICAgaXNEZXZpY2VEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBjdXJyZW50RGV2aWNlICYmXG4gICAgICAgICAgICBwcmV2RGV2aWNlICYmXG4gICAgICAgICAgICBjdXJyZW50RGV2aWNlLmRldmljZUlkID09PSBwcmV2RGV2aWNlLmRldmljZUlkICYmXG4gICAgICAgICAgICBjdXJyZW50RGV2aWNlLmdyb3VwSWQgIT09IHByZXZEZXZpY2UuZ3JvdXBJZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaXNEZXZpY2VSZXBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRGV2aWNlRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RldmljZVJlcGxhY2VkKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kICYmXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5pc1RyYWNrU3RvcHBlZER1ZVRvVHJhY2tFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kRGV2aWNlSW5MaXN0KGRldmljZXM6IE1lZGlhRGV2aWNlSW5mb1tdLCBkZXZpY2VJZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGRldmljZXMuZmluZChcbiAgICAgIChkKSA9PiBkLmRldmljZUlkID09PSBkZXZpY2VJZCAmJiBkLmtpbmQgPT09IHRoaXMubWVkaWFEZXZpY2VLaW5kLFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEJlaGF2aW9yU3ViamVjdCxcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXG4gIE9ic2VydmFibGUsXG4gIHNoYXJlUmVwbGF5LFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGlzUmVhY3ROYXRpdmUgfSBmcm9tICcuLi9oZWxwZXJzL3BsYXRmb3Jtcyc7XG5pbXBvcnQgeyBSeFV0aWxzIH0gZnJvbSAnLi4vc3RvcmUnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcblxuZXhwb3J0IHR5cGUgSW5wdXREZXZpY2VTdGF0dXMgPSAnZW5hYmxlZCcgfCAnZGlzYWJsZWQnIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZTxDID0gTWVkaWFUcmFja0NvbnN0cmFpbnRzPiB7XG4gIHByb3RlY3RlZCBzdGF0dXNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxJbnB1dERldmljZVN0YXR1cz4odW5kZWZpbmVkKTtcbiAgcHJvdGVjdGVkIG1lZGlhU3RyZWFtU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TWVkaWFTdHJlYW0gfCB1bmRlZmluZWQ+KFxuICAgIHVuZGVmaW5lZCxcbiAgKTtcbiAgcHJvdGVjdGVkIHNlbGVjdGVkRGV2aWNlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nIHwgdW5kZWZpbmVkPihcbiAgICB1bmRlZmluZWQsXG4gICk7XG4gIHByb3RlY3RlZCBkZWZhdWx0Q29uc3RyYWludHNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDIHwgdW5kZWZpbmVkPihcbiAgICB1bmRlZmluZWQsXG4gICk7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJldlN0YXR1czogSW5wdXREZXZpY2VTdGF0dXM7XG5cbiAgLyoqXG4gICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudCBtZWRpYSBzdHJlYW0sIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBkZXZpY2UgaXMgY3VycmVudGx5IGRpc2FibGVkLlxuICAgKlxuICAgKi9cbiAgbWVkaWFTdHJlYW0kID0gdGhpcy5tZWRpYVN0cmVhbVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG5cbiAgLyoqXG4gICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRldmljZVxuICAgKi9cbiAgc2VsZWN0ZWREZXZpY2UkID0gdGhpcy5zZWxlY3RlZERldmljZVN1YmplY3RcbiAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcblxuICAvKipcbiAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBkZXZpY2Ugc3RhdHVzXG4gICAqL1xuICBzdGF0dXMkID0gdGhpcy5zdGF0dXNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgKi9cbiAgZGVmYXVsdENvbnN0cmFpbnRzJCA9IHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzU3ViamVjdC5hc09ic2VydmFibGUoKTtcblxuICAvKipcbiAgICogQW4gb2JzZXJ2YWJsZSB0aGF0IHdpbGwgZW1pdCBgdHJ1ZWAgaWYgYnJvd3Nlci9zeXN0ZW0gcGVybWlzc2lvblxuICAgKiBpcyBncmFudGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0Jyb3dzZXJQZXJtaXNzaW9uJCA9IG5ldyBPYnNlcnZhYmxlPGJvb2xlYW4+KChzdWJzY3JpYmVyKSA9PiB7XG4gICAgY29uc3Qgbm90aWZ5R3JhbnRlZCA9ICgpID0+IHN1YnNjcmliZXIubmV4dCh0cnVlKTtcbiAgICBjb25zdCBwZXJtaXNzaW9uc0FQSUF2YWlsYWJsZSA9ICEhbmF2aWdhdG9yPy5wZXJtaXNzaW9ucz8ucXVlcnk7XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSB8fCAhdGhpcy5wZXJtaXNzaW9uTmFtZSB8fCAhcGVybWlzc2lvbnNBUElBdmFpbGFibGUpIHtcbiAgICAgIGdldExvZ2dlcihbJ2RldmljZXMnXSkoXG4gICAgICAgICd3YXJuJyxcbiAgICAgICAgYFBlcm1pc3Npb25zIGNhbid0IGJlIHF1ZXJpZWQuIEFzc3VtaW5nIGdyYW50ZWQuYCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gbm90aWZ5R3JhbnRlZCgpO1xuICAgIH1cblxuICAgIGxldCBwZXJtaXNzaW9uU3RhdGU6IFBlcm1pc3Npb25TdGF0dXM7XG4gICAgY29uc3Qgbm90aWZ5ID0gKCkgPT4ge1xuICAgICAgc3Vic2NyaWJlci5uZXh0KFxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0aGUgJ2NoYW5nZScgZXZlbnQgZG9lc24ndCByZWxpYWJseSBlbWl0IGFuZCBoZW5jZSxcbiAgICAgICAgLy8gcGVybWlzc2lvblN0YXRlIHN0YXlzIGluICdwcm9tcHQnIHN0YXRlIGZvcmV2ZXIuXG4gICAgICAgIC8vIFR5cGljYWxseSwgdGhpcyBoYXBwZW5zIHdoZW4gYSB1c2VyIGdyYW50cyBvbmUtdGltZSBwZXJtaXNzaW9uLlxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGNoZWNraW5nIGlmIGEgcGVybWlzc2lvbiBpcyBncmFudGVkLCB3ZSBjaGVjayBpZiBpdCBpc24ndCBkZW5pZWRcbiAgICAgICAgcGVybWlzc2lvblN0YXRlLnN0YXRlICE9PSAnZGVuaWVkJyxcbiAgICAgICk7XG4gICAgfTtcbiAgICBuYXZpZ2F0b3IucGVybWlzc2lvbnNcbiAgICAgIC5xdWVyeSh7IG5hbWU6IHRoaXMucGVybWlzc2lvbk5hbWUgfSlcbiAgICAgIC50aGVuKChwZXJtaXNzaW9uU3RhdHVzKSA9PiB7XG4gICAgICAgIHBlcm1pc3Npb25TdGF0ZSA9IHBlcm1pc3Npb25TdGF0dXM7XG4gICAgICAgIHBlcm1pc3Npb25TdGF0ZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBub3RpZnkpO1xuICAgICAgICBub3RpZnkoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBwZXJtaXNzaW9uIGRvZXNuJ3QgZXhpc3Qgb3IgY2FuJ3QgYmUgcXVlcmllZCAtPiBhc3N1bWUgaXQncyBncmFudGVkXG4gICAgICAgIC8vIGFuIGV4YW1wbGUgd291bGQgYmUgRmlyZWZveCxcbiAgICAgICAgLy8gd2hlcmUgbmVpdGhlciBjYW1lcmEgbWljcm9waG9uZSBwZXJtaXNzaW9uIGNhbiBiZSBxdWVyaWVkXG4gICAgICAgIG5vdGlmeUdyYW50ZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBlcm1pc3Npb25TdGF0ZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgbm90aWZ5KTtcbiAgICB9O1xuICB9KS5waXBlKHNoYXJlUmVwbGF5KDEpKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBuZXcgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIGRpc2FibGVNb2RlIHRoZSBkaXNhYmxlIG1vZGUgdG8gdXNlLlxuICAgKiBAcGFyYW0gcGVybWlzc2lvbk5hbWUgdGhlIHBlcm1pc3Npb24gbmFtZSB0byB1c2UgZm9yIHF1ZXJ5aW5nLlxuICAgKiBgdW5kZWZpbmVkYCBtZWFucyBubyBwZXJtaXNzaW9uIGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGRpc2FibGVNb2RlOlxuICAgICAgfCAnc3RvcC10cmFja3MnXG4gICAgICB8ICdkaXNhYmxlLXRyYWNrcycgPSAnc3RvcC10cmFja3MnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGVybWlzc2lvbk5hbWU6IFBlcm1pc3Npb25OYW1lIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFRoZSBkZXZpY2Ugc3RhdHVzXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXR1cyQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGV2aWNlXG4gICAqL1xuICBnZXQgc2VsZWN0ZWREZXZpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2VsZWN0ZWREZXZpY2UkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBtZWRpYSBzdHJlYW0sIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBkZXZpY2UgaXMgY3VycmVudGx5IGRpc2FibGVkLlxuICAgKi9cbiAgZ2V0IG1lZGlhU3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLm1lZGlhU3RyZWFtJCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBvYnNlcnZhYmxlLCBvciB1bmRlZmluZWQgaWYgdGhlIG9ic2VydmFibGUgaGFzXG4gICAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICAgKlxuICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSQgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgKi9cbiAgZ2V0Q3VycmVudFZhbHVlID0gUnhVdGlscy5nZXRDdXJyZW50VmFsdWU7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gc3RhdHVzXG4gICAqL1xuICBzZXRTdGF0dXMoc3RhdHVzOiBJbnB1dERldmljZVN0YXR1cykge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhdHVzU3ViamVjdCwgc3RhdHVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHN0cmVhbSB0aGUgc3RyZWFtIHRvIHNldC5cbiAgICovXG4gIHNldE1lZGlhU3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0gfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm1lZGlhU3RyZWFtU3ViamVjdCwgc3RyZWFtKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICB0aGlzLnNldERldmljZSh0aGlzLmdldERldmljZUlkRnJvbVN0cmVhbShzdHJlYW0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgZGV2aWNlIGlkIHRvIHNldC5cbiAgICovXG4gIHNldERldmljZShkZXZpY2VJZDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZWxlY3RlZERldmljZVN1YmplY3QsIGRldmljZUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgKi9cbiAgZ2V0IGRlZmF1bHRDb25zdHJhaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kZWZhdWx0Q29uc3RyYWludHMkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byBzZXQuXG4gICAqL1xuICBzZXREZWZhdWx0Q29uc3RyYWludHMoY29uc3RyYWludHM6IEMgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmRlZmF1bHRDb25zdHJhaW50c1N1YmplY3QsIGNvbnN0cmFpbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAgICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gICAqIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gICAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0Q3VycmVudFZhbHVlID0gUnhVdGlscy5zZXRDdXJyZW50VmFsdWU7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldERldmljZUlkRnJvbVN0cmVhbShcbiAgICBzdHJlYW06IE1lZGlhU3RyZWFtLFxuICApOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlIH0gZnJvbSAnLi9JbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlJztcbmltcG9ydCB7IGlzUmVhY3ROYXRpdmUgfSBmcm9tICcuLi9oZWxwZXJzL3BsYXRmb3Jtcyc7XG5cbmV4cG9ydCB0eXBlIENhbWVyYURpcmVjdGlvbiA9ICdmcm9udCcgfCAnYmFjaycgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBjbGFzcyBDYW1lcmFNYW5hZ2VyU3RhdGUgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlIHtcbiAgcHJpdmF0ZSBkaXJlY3Rpb25TdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDYW1lcmFEaXJlY3Rpb24+KHVuZGVmaW5lZCk7XG5cbiAgLyoqXG4gICAqIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcHJlZmVycmVkIGNhbWVyYSBkaXJlY3Rpb25cbiAgICogZnJvbnQgLSBtZWFucyB0aGUgY2FtZXJhIGZhY2luZyB0aGUgdXNlclxuICAgKiBiYWNrIC0gbWVhbnMgdGhlIGNhbWVyYSBmYWNpbmcgdGhlIGVudmlyb25tZW50XG4gICAqL1xuICBkaXJlY3Rpb24kOiBPYnNlcnZhYmxlPENhbWVyYURpcmVjdGlvbj47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXG4gICAgICAnc3RvcC10cmFja3MnLFxuICAgICAgLy8gYGNhbWVyYWAgaXMgbm90IGluIHRoZSBXM0Mgc3RhbmRhcmQgeWV0LFxuICAgICAgLy8gYnV0IGl0J3Mgc3VwcG9ydGVkIGJ5IENocm9tZSBhbmQgU2FmYXJpLlxuICAgICAgJ2NhbWVyYScgYXMgUGVybWlzc2lvbk5hbWUsXG4gICAgKTtcbiAgICB0aGlzLmRpcmVjdGlvbiQgPSB0aGlzLmRpcmVjdGlvblN1YmplY3RcbiAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHByZWZlcnJlZCBjYW1lcmEgZGlyZWN0aW9uXG4gICAqIGZyb250IC0gbWVhbnMgdGhlIGNhbWVyYSBmYWNpbmcgdGhlIHVzZXJcbiAgICogYmFjayAtIG1lYW5zIHRoZSBjYW1lcmEgZmFjaW5nIHRoZSBlbnZpcm9ubWVudFxuICAgKi9cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kaXJlY3Rpb24kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldERpcmVjdGlvbihkaXJlY3Rpb246IENhbWVyYURpcmVjdGlvbikge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZGlyZWN0aW9uU3ViamVjdCwgZGlyZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldE1lZGlhU3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0gfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBzdXBlci5zZXRNZWRpYVN0cmVhbShzdHJlYW0pO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIC8vIFJOIGdldFNldHRpbmdzKCkgZG9lc24ndCByZXR1cm4gZmFjaW5nTW9kZSwgc28gd2UgZG9uJ3QgdmVyaWZ5IGNhbWVyYSBkaXJlY3Rpb25cbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGlzUmVhY3ROYXRpdmUoKVxuICAgICAgICA/IHRoaXMuZGlyZWN0aW9uXG4gICAgICAgIDogc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0/LmdldFNldHRpbmdzKCkuZmFjaW5nTW9kZSA9PT0gJ2Vudmlyb25tZW50J1xuICAgICAgICA/ICdiYWNrJ1xuICAgICAgICA6ICdmcm9udCc7XG4gICAgICB0aGlzLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXREZXZpY2VJZEZyb21TdHJlYW0oc3RyZWFtOiBNZWRpYVN0cmVhbSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdPy5nZXRTZXR0aW5ncygpLmRldmljZUlkIGFzXG4gICAgICB8IHN0cmluZ1xuICAgICAgfCB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENhbGwgfSBmcm9tICcuLi9DYWxsJztcbmltcG9ydCB7IENhbWVyYURpcmVjdGlvbiwgQ2FtZXJhTWFuYWdlclN0YXRlIH0gZnJvbSAnLi9DYW1lcmFNYW5hZ2VyU3RhdGUnO1xuaW1wb3J0IHsgSW5wdXRNZWRpYURldmljZU1hbmFnZXIgfSBmcm9tICcuL0lucHV0TWVkaWFEZXZpY2VNYW5hZ2VyJztcbmltcG9ydCB7IGdldFZpZGVvRGV2aWNlcywgZ2V0VmlkZW9TdHJlYW0gfSBmcm9tICcuL2RldmljZXMnO1xuaW1wb3J0IHsgVHJhY2tUeXBlIH0gZnJvbSAnLi4vZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzJztcblxudHlwZSBQcmVmZXJyZWRDb2RlYyA9ICd2cDgnIHwgJ2gyNjQnIHwgc3RyaW5nO1xuXG5leHBvcnQgY2xhc3MgQ2FtZXJhTWFuYWdlciBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyPENhbWVyYU1hbmFnZXJTdGF0ZT4ge1xuICBwcml2YXRlIHRhcmdldFJlc29sdXRpb24gPSB7XG4gICAgd2lkdGg6IDEyODAsXG4gICAgaGVpZ2h0OiA3MjAsXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBwcmVmZXJyZWQgY29kZWMgZm9yIGVuY29kaW5nIHRoZSB2aWRlby5cbiAgICpcbiAgICogQGludGVybmFsIGludGVybmFsIHVzZSBvbmx5LCBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSS5cbiAgICovXG4gIHByZWZlcnJlZENvZGVjOiBQcmVmZXJyZWRDb2RlYyB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihjYWxsOiBDYWxsKSB7XG4gICAgc3VwZXIoY2FsbCwgbmV3IENhbWVyYU1hbmFnZXJTdGF0ZSgpLCBUcmFja1R5cGUuVklERU8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgY2FtZXJhIGRpcmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjYW1lcmEgdG8gc2VsZWN0LlxuICAgKi9cbiAgYXN5bmMgc2VsZWN0RGlyZWN0aW9uKGRpcmVjdGlvbjogRXhjbHVkZTxDYW1lcmFEaXJlY3Rpb24sIHVuZGVmaW5lZD4pIHtcbiAgICB0aGlzLnN0YXRlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIC8vIFByb3ZpZGluZyBib3RoIGRldmljZSBpZCBhbmQgZGlyZWN0aW9uIGRvZXNuJ3Qgd29yaywgc28gd2UgZGVzZWxlY3QgdGhlIGRldmljZVxuICAgIHRoaXMuc3RhdGUuc2V0RGV2aWNlKHVuZGVmaW5lZCk7XG4gICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGlwcyB0aGUgY2FtZXJhIGRpcmVjdGlvbjogaWYgaXQncyBmcm9udCBpdCB3aWxsIGNoYW5nZSB0byBiYWNrLCBpZiBpdCdzIGJhY2ssIGl0IHdpbGwgY2hhbmdlIHRvIGZyb250LlxuICAgKlxuICAgKiBOb3RlOiBpZiB0aGVyZSBpcyBubyBhdmFpbGFibGUgY2FtZXJhIHdpdGggdGhlIGRlc2lyZWQgZGlyZWN0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIGRvIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBmbGlwKCkge1xuICAgIGNvbnN0IG5ld0RpcmVjdGlvbiA9IHRoaXMuc3RhdGUuZGlyZWN0aW9uID09PSAnZnJvbnQnID8gJ2JhY2snIDogJ2Zyb250JztcbiAgICBhd2FpdCB0aGlzLnNlbGVjdERpcmVjdGlvbihuZXdEaXJlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgc2VsZWN0VGFyZ2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0pIHtcbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb24uaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICBpZiAodGhpcy5lbmFibGVQcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBjb3VsZG4ndCBlbmFibGUgZGV2aWNlLCB0YXJnZXQgcmVzb2x1dGlvbiB3aWxsIGJlIGFwcGxpZWQgdGhlIG5leHQgdGltZSB1c2VyIGF0dGVtcHRzIHRvIHN0YXJ0IHRoZSBkZXZpY2VcbiAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnY291bGQgbm90IGFwcGx5IHRhcmdldCByZXNvbHV0aW9uJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykge1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnN0YXRlXG4gICAgICAgIC5tZWRpYVN0cmVhbSEuZ2V0VmlkZW9UcmFja3MoKVswXVxuICAgICAgICA/LmdldFNldHRpbmdzKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHdpZHRoICE9PSB0aGlzLnRhcmdldFJlc29sdXRpb24ud2lkdGggfHxcbiAgICAgICAgaGVpZ2h0ICE9PSB0aGlzLnRhcmdldFJlc29sdXRpb24uaGVpZ2h0XG4gICAgICApIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgJ2RlYnVnJyxcbiAgICAgICAgICBgJHt3aWR0aH14JHtoZWlnaHR9IHRhcmdldCByZXNvbHV0aW9uIGFwcGxpZWQgdG8gbWVkaWEgc3RyZWFtYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZmVycmVkIGNvZGVjIGZvciBlbmNvZGluZyB0aGUgdmlkZW8uXG4gICAqXG4gICAqIEBpbnRlcm5hbCBpbnRlcm5hbCB1c2Ugb25seSwgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBwYXJhbSBjb2RlYyB0aGUgY29kZWMgdG8gdXNlIGZvciBlbmNvZGluZyB0aGUgdmlkZW8uXG4gICAqL1xuICBzZXRQcmVmZXJyZWRDb2RlYyhjb2RlYzogJ3ZwOCcgfCAnaDI2NCcgfCBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnByZWZlcnJlZENvZGVjID0gY29kZWM7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0RGV2aWNlcygpOiBPYnNlcnZhYmxlPE1lZGlhRGV2aWNlSW5mb1tdPiB7XG4gICAgcmV0dXJuIGdldFZpZGVvRGV2aWNlcygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFN0cmVhbShcbiAgICBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzLFxuICApOiBQcm9taXNlPE1lZGlhU3RyZWFtPiB7XG4gICAgY29uc3RyYWludHMud2lkdGggPSB0aGlzLnRhcmdldFJlc29sdXRpb24ud2lkdGg7XG4gICAgY29uc3RyYWludHMuaGVpZ2h0ID0gdGhpcy50YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcbiAgICAvLyBXZSBjYW4ndCBzZXQgYm90aCBkZXZpY2UgaWQgYW5kIGZhY2luZyBtb2RlXG4gICAgLy8gRGV2aWNlIGlkIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICBpZiAoIWNvbnN0cmFpbnRzLmRldmljZUlkICYmIHRoaXMuc3RhdGUuZGlyZWN0aW9uKSB7XG4gICAgICBjb25zdHJhaW50cy5mYWNpbmdNb2RlID1cbiAgICAgICAgdGhpcy5zdGF0ZS5kaXJlY3Rpb24gPT09ICdmcm9udCcgPyAndXNlcicgOiAnZW52aXJvbm1lbnQnO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VmlkZW9TdHJlYW0oY29uc3RyYWludHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHB1Ymxpc2hTdHJlYW0oc3RyZWFtOiBNZWRpYVN0cmVhbSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmNhbGwucHVibGlzaFZpZGVvU3RyZWFtKHN0cmVhbSwge1xuICAgICAgcHJlZmVycmVkQ29kZWM6IHRoaXMucHJlZmVycmVkQ29kZWMsXG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RvcFB1Ymxpc2hTdHJlYW0oc3RvcFRyYWNrczogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmNhbGwuc3RvcFB1Ymxpc2goVHJhY2tUeXBlLlZJREVPLCBzdG9wVHJhY2tzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSB9IGZyb20gJy4vSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSc7XG5cbmV4cG9ydCBjbGFzcyBNaWNyb3Bob25lTWFuYWdlclN0YXRlIGV4dGVuZHMgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSB7XG4gIHByaXZhdGUgc3BlYWtpbmdXaGlsZU11dGVkU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYHRydWVgIGlmIHRoZSB1c2VyJ3MgbWljcm9waG9uZSBpcyBtdXRlZCBidXQgdGhleSdhcmUgc3BlYWtpbmcuXG4gICAqXG4gICAqIFRoaXMgZmVhdHVyZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBSZWFjdCBOYXRpdmUgU0RLLlxuICAgKi9cbiAgc3BlYWtpbmdXaGlsZU11dGVkJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgICdkaXNhYmxlLXRyYWNrcycsXG4gICAgICAvLyBgbWljcm9waG9uZWAgaXMgbm90IGluIHRoZSBXM0Mgc3RhbmRhcmQgeWV0LFxuICAgICAgLy8gYnV0IGl0J3Mgc3VwcG9ydGVkIGJ5IENocm9tZSBhbmQgU2FmYXJpLlxuICAgICAgJ21pY3JvcGhvbmUnIGFzIFBlcm1pc3Npb25OYW1lLFxuICAgICk7XG5cbiAgICB0aGlzLnNwZWFraW5nV2hpbGVNdXRlZCQgPSB0aGlzLnNwZWFraW5nV2hpbGVNdXRlZFN1YmplY3RcbiAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogYHRydWVgIGlmIHRoZSB1c2VyJ3MgbWljcm9waG9uZSBpcyBtdXRlZCBidXQgdGhleSdhcmUgc3BlYWtpbmcuXG4gICAqXG4gICAqIFRoaXMgZmVhdHVyZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBSZWFjdCBOYXRpdmUgU0RLLlxuICAgKi9cbiAgZ2V0IHNwZWFraW5nV2hpbGVNdXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zcGVha2luZ1doaWxlTXV0ZWQkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldFNwZWFraW5nV2hpbGVNdXRlZChpc1NwZWFraW5nOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zcGVha2luZ1doaWxlTXV0ZWRTdWJqZWN0LCBpc1NwZWFraW5nKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXREZXZpY2VJZEZyb21TdHJlYW0oc3RyZWFtOiBNZWRpYVN0cmVhbSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdPy5nZXRTZXR0aW5ncygpLmRldmljZUlkIGFzXG4gICAgICB8IHN0cmluZ1xuICAgICAgfCB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsImV4cG9ydCB0eXBlIFNvdW5kRGV0ZWN0b3JPcHRpb25zID0ge1xuICAvKipcbiAgICogRGVmaW5lcyBob3cgb2Z0ZW4gdGhlIGRldGVjdG9yIHNob3VsZCBjaGVjayB3aGV0aGVyIGEgc291bmQgaXMgcHJlc2VudC5cbiAgICogRGVmYXVsdHMgdG8gNTAwbXMuXG4gICAqL1xuICBkZXRlY3Rpb25GcmVxdWVuY3lJbk1zPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBhdWRpbyBsZXZlbCB0aHJlc2hvbGQgYmVmb3JlIGEgXCJjaGFuZ2VcIiBpcyBlbWl0dGVkLlxuICAgKiBEZWZhdWx0cyB0byAxNTAuIFRoaXMgdmFsdWUgc2hvdWxkIGJlIGluIHRoZSByYW5nZSBvZiAwLTI1NS5cbiAgICovXG4gIGF1ZGlvTGV2ZWxUaHJlc2hvbGQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL3dlYi9hcGkvYW5hbHlzZXJub2RlL2ZmdHNpemVcbiAgICpcbiAgICogRGVmYXVsdHMgdG8gMTI4LlxuICAgKi9cbiAgZmZ0U2l6ZT86IG51bWJlcjtcblxuICAvKipcbiAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBhdWRpbyBzdHJlYW0gc2hvdWxkIGJlIHN0b3BwZWQgKGRlc3Ryb3llZClcbiAgICogd2hlbiB0aGUgc291bmQgZGV0ZWN0b3IgaXMgc3RvcHBlZC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgZGVzdHJveVN0cmVhbU9uU3RvcD86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBTb3VuZERldGVjdG9yU3RhdGUgPSB7XG4gIGlzU291bmREZXRlY3RlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFJlcHJlc2VudGVkIGFzIHBlcmNlbnRhZ2UgKDAtMTAwKSB3aGVyZSAxMDAlIGlzIGRlZmluZWQgYnkgYGF1ZGlvTGV2ZWxUaHJlc2hvbGRgIHByb3BlcnR5LlxuICAgKiBEZWNyZWFzZSB0aW1lIGJldHdlZW4gc2FtcGxlcyAodG8gNTAtMTAwbXMpIHdpdGggYGRldGVjdGlvbkZyZXF1ZW5jeUluTXNgIHByb3BlcnR5LlxuICAgKi9cbiAgYXVkaW9MZXZlbDogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgU291bmRTdGF0ZUNoYW5nZUhhbmRsZXIgPSAoc3RhdGU6IFNvdW5kRGV0ZWN0b3JTdGF0ZSkgPT4gdm9pZDtcblxuY29uc3QgREVURUNUSU9OX0ZSRVFVRU5DWV9JTl9NUyA9IDUwMDtcbmNvbnN0IEFVRElPX0xFVkVMX1RIUkVTSE9MRCA9IDE1MDtcbmNvbnN0IEZGVF9TSVpFID0gMTI4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc291bmQgZGV0ZWN0b3IuXG4gKlxuICogQHBhcmFtIGF1ZGlvU3RyZWFtIHRoZSBhdWRpbyBzdHJlYW0gdG8gb2JzZXJ2ZS4gRGVwZW5kaW5nIG9uIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLCB0aGlzIHN0cmVhbSBtaWdodCBiZSBkZXN0cm95ZWQgd2hlbiB0aGUgc291bmQgZGV0ZWN0b3IgaXMgc3RvcHBlZC5cbiAqIEBwYXJhbSBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQgYSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgc291bmQgc3RhdGUgY2hhbmdlcy5cbiAqIEBwYXJhbSBvcHRpb25zIGN1c3RvbSBvcHRpb25zIGZvciB0aGUgc291bmQgZGV0ZWN0b3IuXG4gKiBAcmV0dXJucyBhIGNsZWFuLXVwIGZ1bmN0aW9uIHdoaWNoIG9uY2UgaW52b2tlZCBzdG9wcyB0aGUgc291bmQgZGV0ZWN0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTb3VuZERldGVjdG9yID0gKFxuICBhdWRpb1N0cmVhbTogTWVkaWFTdHJlYW0sXG4gIG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZDogU291bmRTdGF0ZUNoYW5nZUhhbmRsZXIsXG4gIG9wdGlvbnM6IFNvdW5kRGV0ZWN0b3JPcHRpb25zID0ge30sXG4pID0+IHtcbiAgY29uc3Qge1xuICAgIGRldGVjdGlvbkZyZXF1ZW5jeUluTXMgPSBERVRFQ1RJT05fRlJFUVVFTkNZX0lOX01TLFxuICAgIGF1ZGlvTGV2ZWxUaHJlc2hvbGQgPSBBVURJT19MRVZFTF9USFJFU0hPTEQsXG4gICAgZmZ0U2l6ZSA9IEZGVF9TSVpFLFxuICAgIGRlc3Ryb3lTdHJlYW1PblN0b3AgPSB0cnVlLFxuICB9ID0gb3B0aW9ucztcblxuICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gIGFuYWx5c2VyLmZmdFNpemUgPSBmZnRTaXplO1xuXG4gIGNvbnN0IG1pY3JvcGhvbmUgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoYXVkaW9TdHJlYW0pO1xuICBtaWNyb3Bob25lLmNvbm5lY3QoYW5hbHlzZXIpO1xuXG4gIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcbiAgICBhbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhKTtcblxuICAgIGNvbnN0IGlzU291bmREZXRlY3RlZCA9IGRhdGEuc29tZSgodmFsdWUpID0+IHZhbHVlID49IGF1ZGlvTGV2ZWxUaHJlc2hvbGQpO1xuXG4gICAgY29uc3QgYXZlcmFnZWREYXRhVmFsdWUgPSBkYXRhLnJlZHVjZSgocHYsIGN2KSA9PiBwdiArIGN2LCAwKSAvIGRhdGEubGVuZ3RoO1xuXG4gICAgY29uc3QgcGVyY2VudGFnZSA9XG4gICAgICBhdmVyYWdlZERhdGFWYWx1ZSA+IGF1ZGlvTGV2ZWxUaHJlc2hvbGRcbiAgICAgICAgPyAxMDBcbiAgICAgICAgOiBNYXRoLnJvdW5kKChhdmVyYWdlZERhdGFWYWx1ZSAvIGF1ZGlvTGV2ZWxUaHJlc2hvbGQpICogMTAwKTtcblxuICAgIC8vIFdoZW4gdGhlIHRyYWNrIGlzIGRpc2FibGVkLCBpdCB0YWtlcyB0aW1lIGZvciB0aGUgYnVmZmVyIHRvIGVtcHR5XG4gICAgLy8gVGhpcyBjaGVjayB3aWxsIGVuc3VyZSB0aGF0IHdlIGRvbid0IHNlbmQgYW55dGhpbmcgaWYgdGhlIHRyYWNrIGlzIGRpc2FibGVkXG4gICAgaWYgKGF1ZGlvU3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0/LmVuYWJsZWQpIHtcbiAgICAgIG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCh7IGlzU291bmREZXRlY3RlZCwgYXVkaW9MZXZlbDogcGVyY2VudGFnZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHsgaXNTb3VuZERldGVjdGVkOiBmYWxzZSwgYXVkaW9MZXZlbDogMCB9KTtcbiAgICB9XG4gIH0sIGRldGVjdGlvbkZyZXF1ZW5jeUluTXMpO1xuXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG5cbiAgICAvLyBjbGVhbi11cCB0aGUgQXVkaW9Db250ZXh0IGVsZW1lbnRzXG4gICAgbWljcm9waG9uZS5kaXNjb25uZWN0KCk7XG4gICAgYW5hbHlzZXIuZGlzY29ubmVjdCgpO1xuICAgIGF3YWl0IGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuXG4gICAgLy8gc3RvcCB0aGUgc3RyZWFtXG4gICAgaWYgKGRlc3Ryb3lTdHJlYW1PblN0b3ApIHtcbiAgICAgIGF1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgYXVkaW9TdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCB7IEJhc2VTdGF0cyB9IGZyb20gJy4uL3N0YXRzJztcbmltcG9ydCB7IFNvdW5kU3RhdGVDaGFuZ2VIYW5kbGVyIH0gZnJvbSAnLi9zb3VuZC1kZXRlY3Rvcic7XG5cbi8qKlxuICogRmxhdHRlbiB0aGUgc3RhdHMgcmVwb3J0IGludG8gYW4gYXJyYXkgb2Ygc3RhdHMgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gcmVwb3J0IHRoZSByZXBvcnQgdG8gZmxhdHRlbi5cbiAqL1xuY29uc3QgZmxhdHRlbiA9IChyZXBvcnQ6IFJUQ1N0YXRzUmVwb3J0KSA9PiB7XG4gIGNvbnN0IHN0YXRzOiBSVENTdGF0c1tdID0gW107XG4gIHJlcG9ydC5mb3JFYWNoKChzKSA9PiB7XG4gICAgc3RhdHMucHVzaChzKTtcbiAgfSk7XG4gIHJldHVybiBzdGF0cztcbn07XG5cbmNvbnN0IEFVRElPX0xFVkVMX1RIUkVTSE9MRCA9IDAuMjtcblxuZXhwb3J0IGNsYXNzIFJOU3BlZWNoRGV0ZWN0b3Ige1xuICBwcml2YXRlIHBjMSA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7fSk7XG4gIHByaXZhdGUgcGMyID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHt9KTtcbiAgcHJpdmF0ZSBpbnRlcnZhbElkOiBOb2RlSlMuVGltZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgc3BlZWNoIGRldGVjdGlvbi5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzdGFydCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXVkaW9TdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucGMxLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMucGMyLmFkZEljZUNhbmRpZGF0ZShcbiAgICAgICAgICBlLmNhbmRpZGF0ZSBhcyBSVENJY2VDYW5kaWRhdGVJbml0IHwgdW5kZWZpbmVkLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBjMi5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLnBjMS5hZGRJY2VDYW5kaWRhdGUoXG4gICAgICAgICAgZS5jYW5kaWRhdGUgYXMgUlRDSWNlQ2FuZGlkYXRlSW5pdCB8IHVuZGVmaW5lZCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBhdWRpb1N0cmVhbVxuICAgICAgICAuZ2V0VHJhY2tzKClcbiAgICAgICAgLmZvckVhY2goKHRyYWNrKSA9PiB0aGlzLnBjMS5hZGRUcmFjayh0cmFjaywgYXVkaW9TdHJlYW0pKTtcbiAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5wYzEuY3JlYXRlT2ZmZXIoe30pO1xuICAgICAgYXdhaXQgdGhpcy5wYzIuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgYXdhaXQgdGhpcy5wYzEuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLnBjMi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgIGF3YWl0IHRoaXMucGMxLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICBhd2FpdCB0aGlzLnBjMi5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICBjb25zdCBhdWRpb1RyYWNrcyA9IGF1ZGlvU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgICAvLyBXZSBuZWVkIHRvIG11dGUgdGhlIGF1ZGlvIHRyYWNrIGZvciB0aGlzIHRlbXBvcmFyeSBzdHJlYW0sIG9yIGVsc2UgeW91IHdpbGwgaGVhciB5b3Vyc2VsZiB0d2ljZSB3aGlsZSBpbiB0aGUgY2FsbC5cbiAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiAodHJhY2suZW5hYmxlZCA9IGZhbHNlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdFcnJvciBjb25uZWN0aW5nIGFuZCBuZWdvdGlhdGluZyBiZXR3ZWVuIFBlZXJDb25uZWN0aW9uczonLFxuICAgICAgICBlcnJvcixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBzcGVlY2ggZGV0ZWN0aW9uIGFuZCByZWxlYXNlcyBhbGwgYWxsb2NhdGVkIHJlc291cmNlcy5cbiAgICovXG4gIHB1YmxpYyBzdG9wKCkge1xuICAgIHRoaXMucGMxLmNsb3NlKCk7XG4gICAgdGhpcy5wYzIuY2xvc2UoKTtcbiAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2QgdGhhdCBkZXRlY3RzIHRoZSBhdWRpbyBsZXZlbHMgYW5kIHJldHVybnMgdGhlIHN0YXR1cy5cbiAgICovXG4gIHB1YmxpYyBvblNwZWFraW5nRGV0ZWN0ZWRTdGF0ZUNoYW5nZShcbiAgICBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQ6IFNvdW5kU3RhdGVDaGFuZ2VIYW5kbGVyLFxuICApIHtcbiAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0cyA9IChhd2FpdCB0aGlzLnBjMS5nZXRTdGF0cygpKSBhcyBSVENTdGF0c1JlcG9ydDtcbiAgICAgIGNvbnN0IHJlcG9ydCA9IGZsYXR0ZW4oc3RhdHMpO1xuICAgICAgLy8gQXVkaW8gbGV2ZWxzIGFyZSBwcmVzZW50IGluc2lkZSBzdGF0cyBvZiB0eXBlIGBtZWRpYS1zb3VyY2VgIGFuZCBvZiBraW5kIGBhdWRpb2BcbiAgICAgIGNvbnN0IGF1ZGlvTWVkaWFTb3VyY2VTdGF0cyA9IHJlcG9ydC5maW5kKFxuICAgICAgICAoc3RhdCkgPT5cbiAgICAgICAgICBzdGF0LnR5cGUgPT09ICdtZWRpYS1zb3VyY2UnICYmXG4gICAgICAgICAgKHN0YXQgYXMgUlRDUnRwU3RyZWFtU3RhdHMpLmtpbmQgPT09ICdhdWRpbycsXG4gICAgICApIGFzIEJhc2VTdGF0cztcbiAgICAgIGlmIChhdWRpb01lZGlhU291cmNlU3RhdHMpIHtcbiAgICAgICAgY29uc3QgeyBhdWRpb0xldmVsIH0gPSBhdWRpb01lZGlhU291cmNlU3RhdHM7XG4gICAgICAgIGlmIChhdWRpb0xldmVsKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvTGV2ZWwgPj0gQVVESU9fTEVWRUxfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQoe1xuICAgICAgICAgICAgICBpc1NvdW5kRGV0ZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGF1ZGlvTGV2ZWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHtcbiAgICAgICAgICAgICAgaXNTb3VuZERldGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgYXVkaW9MZXZlbDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDYWxsIH0gZnJvbSAnLi4vQ2FsbCc7XG5pbXBvcnQgeyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlciB9IGZyb20gJy4vSW5wdXRNZWRpYURldmljZU1hbmFnZXInO1xuaW1wb3J0IHsgTWljcm9waG9uZU1hbmFnZXJTdGF0ZSB9IGZyb20gJy4vTWljcm9waG9uZU1hbmFnZXJTdGF0ZSc7XG5pbXBvcnQgeyBnZXRBdWRpb0RldmljZXMsIGdldEF1ZGlvU3RyZWFtIH0gZnJvbSAnLi9kZXZpY2VzJztcbmltcG9ydCB7IFRyYWNrVHlwZSB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvbW9kZWxzL21vZGVscyc7XG5pbXBvcnQgeyBjcmVhdGVTb3VuZERldGVjdG9yIH0gZnJvbSAnLi4vaGVscGVycy9zb3VuZC1kZXRlY3Rvcic7XG5pbXBvcnQgeyBpc1JlYWN0TmF0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9wbGF0Zm9ybXMnO1xuaW1wb3J0IHsgT3duQ2FwYWJpbGl0eSB9IGZyb20gJy4uL2dlbi9jb29yZGluYXRvcic7XG5pbXBvcnQgeyBDYWxsaW5nU3RhdGUgfSBmcm9tICcuLi9zdG9yZSc7XG5pbXBvcnQgeyBSTlNwZWVjaERldGVjdG9yIH0gZnJvbSAnLi4vaGVscGVycy9STlNwZWVjaERldGVjdG9yJztcblxuZXhwb3J0IGNsYXNzIE1pY3JvcGhvbmVNYW5hZ2VyIGV4dGVuZHMgSW5wdXRNZWRpYURldmljZU1hbmFnZXI8TWljcm9waG9uZU1hbmFnZXJTdGF0ZT4ge1xuICBwcml2YXRlIHNvdW5kRGV0ZWN0b3JDbGVhbnVwPzogRnVuY3Rpb247XG4gIHByaXZhdGUgcm5TcGVlY2hEZXRlY3RvcjogUk5TcGVlY2hEZXRlY3RvciB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihjYWxsOiBDYWxsKSB7XG4gICAgc3VwZXIoY2FsbCwgbmV3IE1pY3JvcGhvbmVNYW5hZ2VyU3RhdGUoKSwgVHJhY2tUeXBlLkFVRElPKTtcblxuICAgIGNvbWJpbmVMYXRlc3QoW1xuICAgICAgdGhpcy5jYWxsLnN0YXRlLmNhbGxpbmdTdGF0ZSQsXG4gICAgICB0aGlzLmNhbGwuc3RhdGUub3duQ2FwYWJpbGl0aWVzJCxcbiAgICAgIHRoaXMuc3RhdGUuc2VsZWN0ZWREZXZpY2UkLFxuICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMkLFxuICAgIF0pLnN1YnNjcmliZShhc3luYyAoW2NhbGxpbmdTdGF0ZSwgb3duQ2FwYWJpbGl0aWVzLCBkZXZpY2VJZCwgc3RhdHVzXSkgPT4ge1xuICAgICAgaWYgKGNhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCkge1xuICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuTEVGVCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvd25DYXBhYmlsaXRpZXMuaW5jbHVkZXMoT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPKSkge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbihkZXZpY2VJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zdG9wU3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldERldmljZXMoKTogT2JzZXJ2YWJsZTxNZWRpYURldmljZUluZm9bXT4ge1xuICAgIHJldHVybiBnZXRBdWRpb0RldmljZXMoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRTdHJlYW0oXG4gICAgY29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50cyxcbiAgKTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xuICAgIHJldHVybiBnZXRBdWRpb1N0cmVhbShjb25zdHJhaW50cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcHVibGlzaFN0cmVhbShzdHJlYW06IE1lZGlhU3RyZWFtKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbC5wdWJsaXNoQXVkaW9TdHJlYW0oc3RyZWFtKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdG9wUHVibGlzaFN0cmVhbShzdG9wVHJhY2tzOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuQVVESU8sIHN0b3BUcmFja3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbihkZXZpY2VJZD86IHN0cmluZykge1xuICAgIGF3YWl0IHRoaXMuc3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbigpO1xuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIHRoaXMucm5TcGVlY2hEZXRlY3RvciA9IG5ldyBSTlNwZWVjaERldGVjdG9yKCk7XG4gICAgICBhd2FpdCB0aGlzLnJuU3BlZWNoRGV0ZWN0b3Iuc3RhcnQoKTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5yblNwZWVjaERldGVjdG9yPy5vblNwZWFraW5nRGV0ZWN0ZWRTdGF0ZUNoYW5nZShcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTcGVha2luZ1doaWxlTXV0ZWQoZXZlbnQuaXNTb3VuZERldGVjdGVkKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICB0aGlzLnNvdW5kRGV0ZWN0b3JDbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJuU3BlZWNoRGV0ZWN0b3I/LnN0b3AoKTtcbiAgICAgICAgdGhpcy5yblNwZWVjaERldGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVlZCB0byBzdGFydCBhIG5ldyBzdHJlYW0gdGhhdCdzIG5vdCBjb25uZWN0ZWQgdG8gcHVibGlzaGVyXG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLmdldFN0cmVhbSh7XG4gICAgICAgIGRldmljZUlkLFxuICAgICAgfSk7XG4gICAgICB0aGlzLnNvdW5kRGV0ZWN0b3JDbGVhbnVwID0gY3JlYXRlU291bmREZXRlY3RvcihzdHJlYW0sIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLnNldFNwZWFraW5nV2hpbGVNdXRlZChldmVudC5pc1NvdW5kRGV0ZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzdG9wU3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnNldFNwZWFraW5nV2hpbGVNdXRlZChmYWxzZSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc291bmREZXRlY3RvckNsZWFudXAoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUgfSBmcm9tICcuL0lucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUnO1xuaW1wb3J0IHsgU2NyZWVuU2hhcmVTZXR0aW5ncyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFNjcmVlblNoYXJlU3RhdGUgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlPERpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnM+IHtcbiAgcHJpdmF0ZSBhdWRpb0VuYWJsZWRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0cnVlKTtcbiAgcHJpdmF0ZSBzZXR0aW5nc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFxuICAgIFNjcmVlblNoYXJlU2V0dGluZ3MgfCB1bmRlZmluZWRcbiAgPih1bmRlZmluZWQpO1xuXG4gIC8qKlxuICAgKiBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIGF1ZGlvIHN0YXR1cy5cbiAgICovXG4gIGF1ZGlvRW5hYmxlZCQgPSB0aGlzLmF1ZGlvRW5hYmxlZFN1YmplY3RcbiAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcblxuICAvKipcbiAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBzZXR0aW5ncy5cbiAgICovXG4gIHNldHRpbmdzJCA9IHRoaXMuc2V0dGluZ3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBnZXREZXZpY2VJZEZyb21TdHJlYW0gPSAoXG4gICAgc3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgICBjb25zdCBbdHJhY2tdID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgIHJldHVybiB0cmFjaz8uZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIGF1ZGlvIHN0YXR1cy5cbiAgICovXG4gIGdldCBhdWRpb0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYXVkaW9FbmFibGVkJCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBhdWRpbyBzdGF0dXMuXG4gICAqL1xuICBzZXRBdWRpb0VuYWJsZWQoaXNFbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5hdWRpb0VuYWJsZWRTdWJqZWN0LCBpc0VuYWJsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBzZXR0aW5ncy5cbiAgICovXG4gIGdldCBzZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zZXR0aW5ncyQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSBzZXR0aW5ncyB0aGUgc2NyZWVuIHNoYXJlIHNldHRpbmdzIHRvIHNldC5cbiAgICovXG4gIHNldFNldHRpbmdzKHNldHRpbmdzOiBTY3JlZW5TaGFyZVNldHRpbmdzIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXR0aW5nc1N1YmplY3QsIHNldHRpbmdzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIH0gZnJvbSAnLi9JbnB1dE1lZGlhRGV2aWNlTWFuYWdlcic7XG5pbXBvcnQgeyBTY3JlZW5TaGFyZVN0YXRlIH0gZnJvbSAnLi9TY3JlZW5TaGFyZVN0YXRlJztcbmltcG9ydCB7IENhbGwgfSBmcm9tICcuLi9DYWxsJztcbmltcG9ydCB7IFRyYWNrVHlwZSB9IGZyb20gJy4uL2dlbi92aWRlby9zZnUvbW9kZWxzL21vZGVscyc7XG5pbXBvcnQgeyBnZXRTY3JlZW5TaGFyZVN0cmVhbSB9IGZyb20gJy4vZGV2aWNlcyc7XG5pbXBvcnQgeyBTY3JlZW5TaGFyZVNldHRpbmdzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgU2NyZWVuU2hhcmVNYW5hZ2VyIGV4dGVuZHMgSW5wdXRNZWRpYURldmljZU1hbmFnZXI8XG4gIFNjcmVlblNoYXJlU3RhdGUsXG4gIERpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnNcbj4ge1xuICBjb25zdHJ1Y3RvcihjYWxsOiBDYWxsKSB7XG4gICAgc3VwZXIoY2FsbCwgbmV3IFNjcmVlblNoYXJlU3RhdGUoKSwgVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBlbmFibGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9wdGlvbnMgb24gc3VwcG9ydGVkIHBsYXRmb3Jtcy5cbiAgICpcbiAgICogTm90ZTogZm9yIG9uZ29pbmcgc2NyZWVuIHNoYXJlLCBhdWRpbyB3b24ndCBiZSBlbmFibGVkIHVudGlsIHlvdVxuICAgKiByZS1wdWJsaXNoIHRoZSBzY3JlZW4gc2hhcmUgc3RyZWFtLlxuICAgKi9cbiAgZW5hYmxlU2NyZWVuU2hhcmVBdWRpbygpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRlLnNldEF1ZGlvRW5hYmxlZCh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGRpc2FibGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9wdGlvbnMgb24gc3VwcG9ydGVkIHBsYXRmb3Jtcy5cbiAgICovXG4gIGFzeW5jIGRpc2FibGVTY3JlZW5TaGFyZUF1ZGlvKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuc3RhdGUuc2V0QXVkaW9FbmFibGVkKGZhbHNlKTtcbiAgICBpZiAodGhpcy5jYWxsLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pKSB7XG4gICAgICBhd2FpdCB0aGlzLmNhbGwuc3RvcFB1Ymxpc2goVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIHNldHRpbmdzLlxuICAgKi9cbiAgZ2V0U2V0dGluZ3MoKTogU2NyZWVuU2hhcmVTZXR0aW5ncyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc2V0dGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSBzZXR0aW5ncyB0aGUgc2V0dGluZ3MgdG8gc2V0LlxuICAgKi9cbiAgc2V0U2V0dGluZ3Moc2V0dGluZ3M6IFNjcmVlblNoYXJlU2V0dGluZ3MgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRlLnNldFNldHRpbmdzKHNldHRpbmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXREZXZpY2VzKCk6IE9ic2VydmFibGU8TWVkaWFEZXZpY2VJbmZvW10+IHtcbiAgICByZXR1cm4gb2YoW10pOyAvLyB0aGVyZSBhcmUgbm8gZGV2aWNlcyB0byBiZSBsaXN0ZWQgZm9yIFNjcmVlbiBTaGFyZVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldFN0cmVhbShcbiAgICBjb25zdHJhaW50czogRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xuICAgIGlmICghdGhpcy5zdGF0ZS5hdWRpb0VuYWJsZWQpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBnZXRTY3JlZW5TaGFyZVN0cmVhbShjb25zdHJhaW50cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcHVibGlzaFN0cmVhbShzdHJlYW06IE1lZGlhU3RyZWFtKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbC5wdWJsaXNoU2NyZWVuU2hhcmVTdHJlYW0oc3RyZWFtLCB7XG4gICAgICBzY3JlZW5TaGFyZVNldHRpbmdzOiB0aGlzLnN0YXRlLnNldHRpbmdzLFxuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIHN0b3BQdWJsaXNoU3RyZWFtKHN0b3BUcmFja3M6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmNhbGwuc3RvcFB1Ymxpc2goVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSwgc3RvcFRyYWNrcyk7XG4gICAgYXdhaXQgdGhpcy5jYWxsLnN0b3BQdWJsaXNoKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sIHN0b3BUcmFja3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgc2VsZWN0YCBtZXRob2QgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBkZXZpY2VJZCBpZ25vcmVkLlxuICAgKi9cbiAgYXN5bmMgc2VsZWN0KGRldmljZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZm9yIFNjcmVlbiBTaGFyZScpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBSeFV0aWxzIH0gZnJvbSAnLi4vc3RvcmUnO1xuaW1wb3J0IHsgY2hlY2tJZkF1ZGlvT3V0cHV0Q2hhbmdlU3VwcG9ydGVkIH0gZnJvbSAnLi9kZXZpY2VzJztcblxuZXhwb3J0IGNsYXNzIFNwZWFrZXJTdGF0ZSB7XG4gIHByb3RlY3RlZCBzZWxlY3RlZERldmljZVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4oJycpO1xuICBwcm90ZWN0ZWQgdm9sdW1lU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPigxKTtcbiAgLyoqXG4gICAqIFtUZWxscyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBvdXRwdXQgY2hhbmdlIG9uICdhdWRpbycgZWxlbWVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCkuXG4gICAqL1xuICByZWFkb25seSBpc0RldmljZVNlbGVjdGlvblN1cHBvcnRlZCA9IGNoZWNrSWZBdWRpb091dHB1dENoYW5nZVN1cHBvcnRlZCgpO1xuXG4gIC8qKlxuICAgKiBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkZXZpY2VcbiAgICpcbiAgICogTm90ZTogdGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAqL1xuICBzZWxlY3RlZERldmljZSQ6IE9ic2VydmFibGU8c3RyaW5nPjtcblxuICAvKipcbiAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdm9sdW1lXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgKi9cbiAgdm9sdW1lJDogT2JzZXJ2YWJsZTxudW1iZXI+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VsZWN0ZWREZXZpY2UkID0gdGhpcy5zZWxlY3RlZERldmljZVN1YmplY3RcbiAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgdGhpcy52b2x1bWUkID0gdGhpcy52b2x1bWVTdWJqZWN0XG4gICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGV2aWNlXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkRGV2aWNlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnNlbGVjdGVkRGV2aWNlJCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCB2b2x1bWVcbiAgICpcbiAgICogTm90ZTogdGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAqL1xuICBnZXQgdm9sdW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnZvbHVtZSQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICAgKiBub3QgZW1pdHRlZCBhIHZhbHVlIHlldC5cbiAgICpcbiAgICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICovXG4gIGdldEN1cnJlbnRWYWx1ZSA9IFJ4VXRpbHMuZ2V0Q3VycmVudFZhbHVlO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIGRldmljZUlkXG4gICAqL1xuICBzZXREZXZpY2UoZGV2aWNlSWQ6IHN0cmluZykge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc2VsZWN0ZWREZXZpY2VTdWJqZWN0LCBkZXZpY2VJZCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB2b2x1bWVcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWU6IG51bWJlcikge1xuICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMudm9sdW1lU3ViamVjdCwgdm9sdW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAgICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gICAqIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gICAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0Q3VycmVudFZhbHVlID0gUnhVdGlscy5zZXRDdXJyZW50VmFsdWU7XG59XG4iLCJpbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENhbGwgfSBmcm9tICcuLi9DYWxsJztcbmltcG9ydCB7IGlzUmVhY3ROYXRpdmUgfSBmcm9tICcuLi9oZWxwZXJzL3BsYXRmb3Jtcyc7XG5pbXBvcnQgeyBTcGVha2VyU3RhdGUgfSBmcm9tICcuL1NwZWFrZXJTdGF0ZSc7XG5pbXBvcnQgeyBkZXZpY2VJZHMkLCBnZXRBdWRpb091dHB1dERldmljZXMgfSBmcm9tICcuL2RldmljZXMnO1xuXG5leHBvcnQgY2xhc3MgU3BlYWtlck1hbmFnZXIge1xuICBwdWJsaWMgcmVhZG9ubHkgc3RhdGUgPSBuZXcgU3BlYWtlclN0YXRlKCk7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWxsOiBDYWxsO1xuXG4gIGNvbnN0cnVjdG9yKGNhbGw6IENhbGwpIHtcbiAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgIGlmIChkZXZpY2VJZHMkICYmICFpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KFtkZXZpY2VJZHMkISwgdGhpcy5zdGF0ZS5zZWxlY3RlZERldmljZSRdKS5zdWJzY3JpYmUoXG4gICAgICAgICAgKFtkZXZpY2VzLCBkZXZpY2VJZF0pID0+IHtcbiAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKFxuICAgICAgICAgICAgICAoZCkgPT4gZC5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiYgZC5raW5kID09PSAnYXVkaW9vdXRwdXQnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghZGV2aWNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0KCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgdGhlIGF2YWlsYWJsZSBhdWRpbyBvdXRwdXQgZGV2aWNlc1xuICAgKlxuICAgKiBOb3RlOiBJdCBwcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpXG4gICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgaWYgYSBkZXZpY2UgaXMgY29ubmVjdGVkIG9yIGRpc2Nvbm5lY3RlZFxuICAgKi9cbiAgbGlzdERldmljZXMoKSB7XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9nZXRzdHJlYW0uaW8vdmlkZW8vZG9jcy9yZWFjdG5hdGl2ZS9jb3JlL2NhbWVyYS1hbmQtbWljcm9waG9uZS8jc3BlYWtlci1tYW5hZ2VtZW50IGZvciBtb3JlIGRldGFpbHMnLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEF1ZGlvT3V0cHV0RGV2aWNlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIGRldmljZS5cbiAgICpcbiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmVcbiAgICpcbiAgICogQHBhcmFtIGRldmljZUlkIGVtcHR5IHN0cmluZyBtZWFucyB0aGUgc3lzdGVtIGRlZmF1bHRcbiAgICovXG4gIHNlbGVjdChkZXZpY2VJZDogc3RyaW5nKSB7XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9nZXRzdHJlYW0uaW8vdmlkZW8vZG9jcy9yZWFjdG5hdGl2ZS9jb3JlL2NhbWVyYS1hbmQtbWljcm9waG9uZS8jc3BlYWtlci1tYW5hZ2VtZW50IGZvciBtb3JlIGRldGFpbHMnLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5zZXREZXZpY2UoZGV2aWNlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoZSBtYW5hZ2VyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHMpID0+IHMudW5zdWJzY3JpYmUoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdm9sdW1lIG9mIHRoZSBhdWRpbyBlbGVtZW50c1xuICAgKiBAcGFyYW0gdm9sdW1lIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cbiAgICpcbiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmVcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWU6IG51bWJlcikge1xuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZS4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZ2V0c3RyZWFtLmlvL3ZpZGVvL2RvY3MvcmVhY3RuYXRpdmUvY29yZS9jYW1lcmEtYW5kLW1pY3JvcGhvbmUvI3NwZWFrZXItbWFuYWdlbWVudCBmb3IgbW9yZSBkZXRhaWxzJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh2b2x1bWUgJiYgKHZvbHVtZSA8IDAgfHwgdm9sdW1lID4gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVm9sdW1lIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxJyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2b2x1bWUgb2YgYSBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHBhcnRpY2lwYW50J3Mgc2Vzc2lvbiBpZC5cbiAgICogQHBhcmFtIHZvbHVtZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuIFNldCBpdCB0byBgdW5kZWZpbmVkYCB0byB1c2UgdGhlIGRlZmF1bHQgdm9sdW1lLlxuICAgKi9cbiAgc2V0UGFydGljaXBhbnRWb2x1bWUoc2Vzc2lvbklkOiBzdHJpbmcsIHZvbHVtZTogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9nZXRzdHJlYW0uaW8vdmlkZW8vZG9jcy9yZWFjdG5hdGl2ZS9jb3JlL2NhbWVyYS1hbmQtbWljcm9waG9uZS8jc3BlYWtlci1tYW5hZ2VtZW50IGZvciBtb3JlIGRldGFpbHMnLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSAmJiAodm9sdW1lIDwgMCB8fCB2b2x1bWUgPiAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWb2x1bWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICB0aGlzLmNhbGwuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCB7IGF1ZGlvVm9sdW1lOiB2b2x1bWUgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFN0cmVhbVNmdUNsaWVudCB9IGZyb20gJy4vU3RyZWFtU2Z1Q2xpZW50JztcbmltcG9ydCB7XG4gIERpc3BhdGNoZXIsXG4gIGdldEdlbmVyaWNTZHAsXG4gIGlzU2Z1RXZlbnQsXG4gIFB1Ymxpc2hlcixcbiAgU3Vic2NyaWJlcixcbn0gZnJvbSAnLi9ydGMnO1xuaW1wb3J0IHsgbXV0ZVR5cGVUb1RyYWNrVHlwZSB9IGZyb20gJy4vcnRjL2hlbHBlcnMvdHJhY2tzJztcbmltcG9ydCB7IEdvQXdheVJlYXNvbiwgVHJhY2tUeXBlIH0gZnJvbSAnLi9nZW4vdmlkZW8vc2Z1L21vZGVscy9tb2RlbHMnO1xuaW1wb3J0IHtcbiAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzLFxuICByZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyxcbn0gZnJvbSAnLi9ldmVudHMvY2FsbEV2ZW50SGFuZGxlcnMnO1xuaW1wb3J0IHtcbiAgQ2FsbGluZ1N0YXRlLFxuICBDYWxsU3RhdGUsXG4gIFN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZSxcbn0gZnJvbSAnLi9zdG9yZSc7XG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpcHRpb24sIGdldEN1cnJlbnRWYWx1ZSB9IGZyb20gJy4vc3RvcmUvcnhVdGlscyc7XG5pbXBvcnQge1xuICBBY2NlcHRDYWxsUmVzcG9uc2UsXG4gIEJsb2NrVXNlclJlcXVlc3QsXG4gIEJsb2NrVXNlclJlc3BvbnNlLFxuICBDb2xsZWN0VXNlckZlZWRiYWNrUmVxdWVzdCxcbiAgQ29sbGVjdFVzZXJGZWVkYmFja1Jlc3BvbnNlLFxuICBFbmRDYWxsUmVzcG9uc2UsXG4gIEdldENhbGxSZXNwb25zZSxcbiAgR2V0Q2FsbFN0YXRzUmVzcG9uc2UsXG4gIEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3QsXG4gIEdldE9yQ3JlYXRlQ2FsbFJlc3BvbnNlLFxuICBHb0xpdmVSZXF1ZXN0LFxuICBHb0xpdmVSZXNwb25zZSxcbiAgTGlzdFJlY29yZGluZ3NSZXNwb25zZSxcbiAgTGlzdFRyYW5zY3JpcHRpb25zUmVzcG9uc2UsXG4gIE11dGVVc2Vyc1JlcXVlc3QsXG4gIE11dGVVc2Vyc1Jlc3BvbnNlLFxuICBPd25DYXBhYmlsaXR5LFxuICBQaW5SZXF1ZXN0LFxuICBQaW5SZXNwb25zZSxcbiAgUXVlcnlNZW1iZXJzUmVxdWVzdCxcbiAgUXVlcnlNZW1iZXJzUmVzcG9uc2UsXG4gIFJlamVjdENhbGxSZXNwb25zZSxcbiAgUmVxdWVzdFBlcm1pc3Npb25SZXF1ZXN0LFxuICBSZXF1ZXN0UGVybWlzc2lvblJlc3BvbnNlLFxuICBTZW5kRXZlbnRSZXF1ZXN0LFxuICBTZW5kRXZlbnRSZXNwb25zZSxcbiAgU2VuZFJlYWN0aW9uUmVxdWVzdCxcbiAgU2VuZFJlYWN0aW9uUmVzcG9uc2UsXG4gIFNGVVJlc3BvbnNlLFxuICBTdGFydEhMU0Jyb2FkY2FzdGluZ1Jlc3BvbnNlLFxuICBTdGFydFJlY29yZGluZ1JlcXVlc3QsXG4gIFN0YXJ0UmVjb3JkaW5nUmVzcG9uc2UsXG4gIFN0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3QsXG4gIFN0YXJ0VHJhbnNjcmlwdGlvblJlc3BvbnNlLFxuICBTdGF0c09wdGlvbnMsXG4gIFN0b3BITFNCcm9hZGNhc3RpbmdSZXNwb25zZSxcbiAgU3RvcExpdmVSZXNwb25zZSxcbiAgU3RvcFJlY29yZGluZ1Jlc3BvbnNlLFxuICBTdG9wVHJhbnNjcmlwdGlvblJlc3BvbnNlLFxuICBVbmJsb2NrVXNlclJlcXVlc3QsXG4gIFVuYmxvY2tVc2VyUmVzcG9uc2UsXG4gIFVucGluUmVxdWVzdCxcbiAgVW5waW5SZXNwb25zZSxcbiAgVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0LFxuICBVcGRhdGVDYWxsTWVtYmVyc1Jlc3BvbnNlLFxuICBVcGRhdGVDYWxsUmVxdWVzdCxcbiAgVXBkYXRlQ2FsbFJlc3BvbnNlLFxuICBVcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0LFxuICBVcGRhdGVVc2VyUGVybWlzc2lvbnNSZXNwb25zZSxcbn0gZnJvbSAnLi9nZW4vY29vcmRpbmF0b3InO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJy4vcnRjL2Zsb3dzL2pvaW4nO1xuaW1wb3J0IHtcbiAgQXVkaW9UcmFja1R5cGUsXG4gIENhbGxDb25zdHJ1Y3RvcixcbiAgQ2FsbExlYXZlT3B0aW9ucyxcbiAgRGVib3VuY2VUeXBlLFxuICBKb2luQ2FsbERhdGEsXG4gIFB1Ymxpc2hPcHRpb25zLFxuICBTdHJlYW1WaWRlb1BhcnRpY2lwYW50LFxuICBTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2hlcyxcbiAgU3Vic2NyaXB0aW9uQ2hhbmdlcyxcbiAgVHJhY2tNdXRlVHlwZSxcbiAgVmlkZW9UcmFja1R5cGUsXG4gIFZpc2liaWxpdHlTdGF0ZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBCZWhhdmlvclN1YmplY3QsXG4gIGRlYm91bmNlLFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgU3ViamVjdCxcbiAgdGFrZVdoaWxlLFxuICB0aW1lcixcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgfSBmcm9tICcuL2dlbi92aWRlby9zZnUvc2lnbmFsX3JwYy9zaWduYWwnO1xuaW1wb3J0IHtcbiAgSm9pblJlc3BvbnNlLFxuICBNaWdyYXRpb24sXG4gIFZpZGVvTGF5ZXJTZXR0aW5nLFxufSBmcm9tICcuL2dlbi92aWRlby9zZnUvZXZlbnQvZXZlbnRzJztcbmltcG9ydCB7IFRpbWVzdGFtcCB9IGZyb20gJy4vZ2VuL2dvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAnO1xuaW1wb3J0IHsgY3JlYXRlU3RhdHNSZXBvcnRlciwgU2Z1U3RhdHNSZXBvcnRlciwgU3RhdHNSZXBvcnRlciB9IGZyb20gJy4vc3RhdHMnO1xuaW1wb3J0IHsgRHluYXNjYWxlTWFuYWdlciB9IGZyb20gJy4vaGVscGVycy9EeW5hc2NhbGVNYW5hZ2VyJztcbmltcG9ydCB7IFBlcm1pc3Npb25zQ29udGV4dCB9IGZyb20gJy4vcGVybWlzc2lvbnMnO1xuaW1wb3J0IHsgQ2FsbFR5cGVzIH0gZnJvbSAnLi9DYWxsVHlwZSc7XG5pbXBvcnQgeyBTdHJlYW1DbGllbnQgfSBmcm9tICcuL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vY2xpZW50JztcbmltcG9ydCB7XG4gIEtub3duQ29kZXMsXG4gIHJldHJ5SW50ZXJ2YWwsXG4gIHNsZWVwLFxufSBmcm9tICcuL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vdXRpbHMnO1xuaW1wb3J0IHtcbiAgQWxsQ2FsbEV2ZW50cyxcbiAgQ2FsbEV2ZW50TGlzdGVuZXIsXG4gIExvZ2dlcixcbiAgU3RyZWFtQ2FsbEV2ZW50LFxufSBmcm9tICcuL2Nvb3JkaW5hdG9yL2Nvbm5lY3Rpb24vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0Q2xpZW50RGV0YWlscyB9IGZyb20gJy4vY2xpZW50LWRldGFpbHMnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHtcbiAgQ2FtZXJhRGlyZWN0aW9uLFxuICBDYW1lcmFNYW5hZ2VyLFxuICBNaWNyb3Bob25lTWFuYWdlcixcbiAgU2NyZWVuU2hhcmVNYW5hZ2VyLFxuICBTcGVha2VyTWFuYWdlcixcbn0gZnJvbSAnLi9kZXZpY2VzJztcbmltcG9ydCB7IGdldFNka1NpZ25hdHVyZSB9IGZyb20gJy4vc3RhdHMvdXRpbHMnO1xuXG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGBDYWxsYC5cbiAqL1xuZXhwb3J0IGNsYXNzIENhbGwge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNhbGwuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgY2FsbC5cbiAgICovXG4gIHJlYWRvbmx5IGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsIENJRC5cbiAgICovXG4gIHJlYWRvbmx5IGNpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdGUgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgcmVhZG9ubHkgc3RhdGUgPSBuZXcgQ2FsbFN0YXRlKCk7XG5cbiAgLyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgY2FsbCBpcyBcIndhdGNoZWRcIiBhbmQgcmVjZWl2ZXNcbiAgICogdXBkYXRlcyBmcm9tIHRoZSBiYWNrZW5kLlxuICAgKi9cbiAgd2F0Y2hpbmc6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERldmljZSBtYW5hZ2VyIGZvciB0aGUgY2FtZXJhXG4gICAqL1xuICByZWFkb25seSBjYW1lcmE6IENhbWVyYU1hbmFnZXI7XG5cbiAgLyoqXG4gICAqIERldmljZSBtYW5hZ2VyIGZvciB0aGUgbWljcm9waG9uZS5cbiAgICovXG4gIHJlYWRvbmx5IG1pY3JvcGhvbmU6IE1pY3JvcGhvbmVNYW5hZ2VyO1xuXG4gIC8qKlxuICAgKiBEZXZpY2UgbWFuYWdlciBmb3IgdGhlIHNwZWFrZXIuXG4gICAqL1xuICByZWFkb25seSBzcGVha2VyOiBTcGVha2VyTWFuYWdlcjtcblxuICAvKipcbiAgICogRGV2aWNlIG1hbmFnZXIgZm9yIHRoZSBzY3JlZW4uXG4gICAqL1xuICByZWFkb25seSBzY3JlZW5TaGFyZTogU2NyZWVuU2hhcmVNYW5hZ2VyO1xuXG4gIC8qKlxuICAgKiBUaGUgRHluYXNjYWxlTWFuYWdlciBpbnN0YW5jZS5cbiAgICovXG4gIHJlYWRvbmx5IGR5bmFzY2FsZU1hbmFnZXIgPSBuZXcgRHluYXNjYWxlTWFuYWdlcih0aGlzKTtcblxuICBzdWJzY3JpYmVyPzogU3Vic2NyaWJlcjtcbiAgcHVibGlzaGVyPzogUHVibGlzaGVyO1xuXG4gIC8qKlxuICAgKiBGbGFnIHRlbGxpbmcgd2hldGhlciB0aGlzIGNhbGwgaXMgYSBcInJpbmdpbmdcIiBjYWxsLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByaW5naW5nU3ViamVjdDogU3ViamVjdDxib29sZWFuPjtcblxuICAvKipcbiAgICogVGhlIHBlcm1pc3Npb25zIGNvbnRleHQgb2YgdGhpcyBjYWxsLlxuICAgKi9cbiAgcmVhZG9ubHkgcGVybWlzc2lvbnNDb250ZXh0ID0gbmV3IFBlcm1pc3Npb25zQ29udGV4dCgpO1xuICByZWFkb25seSBsb2dnZXI6IExvZ2dlcjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IGRpc3BhdGNoZXIgaW5zdGFuY2UgZGVkaWNhdGVkIHRvIHRoaXMgQ2FsbCBpbnN0YW5jZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG5cbiAgcHJpdmF0ZSB0cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDx7XG4gICAgdHlwZTogRGVib3VuY2VUeXBlO1xuICAgIGRhdGE6IFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1tdO1xuICB9Pih7IHR5cGU6IERlYm91bmNlVHlwZS5NRURJVU0sIGRhdGE6IFtdIH0pO1xuXG4gIHByaXZhdGUgc3RhdHNSZXBvcnRlcj86IFN0YXRzUmVwb3J0ZXI7XG4gIHByaXZhdGUgc2Z1U3RhdHNSZXBvcnRlcj86IFNmdVN0YXRzUmVwb3J0ZXI7XG4gIHByaXZhdGUgZHJvcFRpbWVvdXQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgY2xpZW50U3RvcmU6IFN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZTtcbiAgcHVibGljIHJlYWRvbmx5IHN0cmVhbUNsaWVudDogU3RyZWFtQ2xpZW50O1xuICBwcml2YXRlIHNmdUNsaWVudD86IFN0cmVhbVNmdUNsaWVudDtcbiAgcHJpdmF0ZSByZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gIHByaXZhdGUgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAxMDtcblxuICAvKipcbiAgICogQSBsaXN0IGhvb2tzL2Z1bmN0aW9ucyB0byBpbnZva2Ugd2hlbiB0aGUgY2FsbCBpcyBsZWZ0LlxuICAgKiBBIHR5cGljYWwgdXNlIGNhc2UgaXMgdG8gY2xlYW4gdXAgc29tZSBnbG9iYWwgZXZlbnQgaGFuZGxlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGxlYXZlQ2FsbEhvb2tzOiBTZXQ8RnVuY3Rpb24+ID0gbmV3IFNldCgpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RyZWFtQ2xpZW50QmFzZVBhdGg6IHN0cmluZztcbiAgcHJpdmF0ZSBzdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzID0gbmV3IE1hcDxGdW5jdGlvbiwgKCkgPT4gdm9pZD4oKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgQ2FsbGAgaW5zdGFuY2UuXG4gICAqXG4gICAqIE5PVEU6IERvbid0IGNhbGwgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LCBpbnN0ZWFkXG4gICAqIFVzZSB0aGUgW2BTdHJlYW1WaWRlb0NsaWVudC5jYWxsYF0oLi9TdHJlYW1WaWRlb0NsaWVudC5tZC8jY2FsbClcbiAgICogbWV0aG9kIHRvIGNvbnN0cnVjdCBhIGBDYWxsYCBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0eXBlLFxuICAgIGlkLFxuICAgIHN0cmVhbUNsaWVudCxcbiAgICBtZW1iZXJzLFxuICAgIG93bkNhcGFiaWxpdGllcyxcbiAgICBzb3J0UGFydGljaXBhbnRzQnksXG4gICAgY2xpZW50U3RvcmUsXG4gICAgcmluZ2luZyA9IGZhbHNlLFxuICAgIHdhdGNoaW5nID0gZmFsc2UsXG4gIH06IENhbGxDb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2lkID0gYCR7dHlwZX06JHtpZH1gO1xuICAgIHRoaXMucmluZ2luZ1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHJpbmdpbmcpO1xuICAgIHRoaXMud2F0Y2hpbmcgPSB3YXRjaGluZztcbiAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICB0aGlzLmNsaWVudFN0b3JlID0gY2xpZW50U3RvcmU7XG4gICAgdGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aCA9IGAvY2FsbC8ke3RoaXMudHlwZX0vJHt0aGlzLmlkfWA7XG4gICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydDYWxsJ10pO1xuXG4gICAgY29uc3QgY2FsbFR5cGVDb25maWcgPSBDYWxsVHlwZXMuZ2V0KHR5cGUpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50U29ydGVyID1cbiAgICAgIHNvcnRQYXJ0aWNpcGFudHNCeSB8fCBjYWxsVHlwZUNvbmZpZy5vcHRpb25zLnNvcnRQYXJ0aWNpcGFudHNCeTtcbiAgICBpZiAocGFydGljaXBhbnRTb3J0ZXIpIHtcbiAgICAgIHRoaXMuc3RhdGUuc2V0U29ydFBhcnRpY2lwYW50c0J5KHBhcnRpY2lwYW50U29ydGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMobWVtYmVycyB8fCBbXSk7XG4gICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMob3duQ2FwYWJpbGl0aWVzIHx8IFtdKTtcbiAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShcbiAgICAgIHJpbmdpbmcgPyBDYWxsaW5nU3RhdGUuUklOR0lORyA6IENhbGxpbmdTdGF0ZS5JRExFLFxuICAgICk7XG5cbiAgICB0aGlzLm9uKCdhbGwnLCAoZXZlbnQpID0+IHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0ZSB3aXRoIHRoZSBsYXRlc3QgZXZlbnQgZGF0YVxuICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tRXZlbnQoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcywgdGhpcy5zdGF0ZSwgdGhpcy5kaXNwYXRjaGVyKSxcbiAgICApO1xuICAgIHRoaXMucmVnaXN0ZXJFZmZlY3RzKCk7XG5cbiAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgIGNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgICAgdGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0LnBpcGUoXG4gICAgICAgICAgZGVib3VuY2UoKHYpID0+IHRpbWVyKHYudHlwZSkpLFxuICAgICAgICAgIG1hcCgodikgPT4gdi5kYXRhKSxcbiAgICAgICAgKSxcbiAgICAgICAgKHN1YnNjcmlwdGlvbnMpID0+IHRoaXMuc2Z1Q2xpZW50Py51cGRhdGVTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMpLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLm1pY3JvcGhvbmUgPSBuZXcgTWljcm9waG9uZU1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5zcGVha2VyID0gbmV3IFNwZWFrZXJNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMuc2NyZWVuU2hhcmUgPSBuZXcgU2NyZWVuU2hhcmVNYW5hZ2VyKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckVmZmVjdHMoKSB7XG4gICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAvLyBoYW5kbGVzIHVwZGF0aW5nIHRoZSBwZXJtaXNzaW9ucyBjb250ZXh0IHdoZW4gdGhlIHNldHRpbmdzIGNoYW5nZS5cbiAgICAgIGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnN0YXRlLnNldHRpbmdzJCwgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgIGlmICghc2V0dGluZ3MpIHJldHVybjtcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuc2V0Q2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHRoZSB1c2VyIHBlcm1pc3Npb25zIGFyZSBtb2RpZmllZC5cbiAgICAgIGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnN0YXRlLm93bkNhcGFiaWxpdGllcyQsIChvd25DYXBhYmlsaXRpZXMpID0+IHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwZXJtaXNzaW9uIGNvbnRleHQuXG4gICAgICAgIHRoaXMucGVybWlzc2lvbnNDb250ZXh0LnNldFBlcm1pc3Npb25zKG93bkNhcGFiaWxpdGllcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB1c2VyIHN0aWxsIGhhcyBwdWJsaXNoaW5nIHBlcm1pc3Npb25zIGFuZCBzdG9wIHB1Ymxpc2hpbmcgaWYgbm90LlxuICAgICAgICBjb25zdCBwZXJtaXNzaW9uVG9UcmFja1R5cGUgPSB7XG4gICAgICAgICAgW093bkNhcGFiaWxpdHkuU0VORF9BVURJT106IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgICBbT3duQ2FwYWJpbGl0eS5TRU5EX1ZJREVPXTogVHJhY2tUeXBlLlZJREVPLFxuICAgICAgICAgIFtPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFXTogVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbcGVybWlzc2lvbiwgdHJhY2tUeXBlXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICBwZXJtaXNzaW9uVG9UcmFja1R5cGUsXG4gICAgICAgICkpIHtcbiAgICAgICAgICBjb25zdCBoYXNQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuaGFzUGVybWlzc2lvbihcbiAgICAgICAgICAgIHBlcm1pc3Npb24gYXMgT3duQ2FwYWJpbGl0eSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFoYXNQZXJtaXNzaW9uICYmXG4gICAgICAgICAgICAodGhpcy5wdWJsaXNoZXIuaXNQdWJsaXNoaW5nKHRyYWNrVHlwZSkgfHxcbiAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIuaXNMaXZlKHRyYWNrVHlwZSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBTdG9wIHRyYWNrcywgdGhlbiBub3RpZnkgZGV2aWNlIG1hbmFnZXJcbiAgICAgICAgICAgIHRoaXMuc3RvcFB1Ymxpc2godHJhY2tUeXBlKVxuICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgIGBFcnJvciBzdG9wcGluZyBwdWJsaXNoICR7dHJhY2tUeXBlfWAsXG4gICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFcbiAgICAgICAgICAgICAgICAgICAgLmRpc2FibGUoKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT5cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBgRXJyb3IgZGlzYWJsaW5nIGNhbWVyYSBhZnRlciBwZXJtaXNzaW9uIHJldm9rZWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLkFVRElPICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmUuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWljcm9waG9uZVxuICAgICAgICAgICAgICAgICAgICAuZGlzYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBkaXNhYmxpbmcgbWljcm9waG9uZSBhZnRlciBwZXJtaXNzaW9uIHJldm9rZWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgIC8vIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgdXNlciBpcyBibG9ja2VkIGJ5IHRoZSBjYWxsIG93bmVyLlxuICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMuc3RhdGUuYmxvY2tlZFVzZXJJZHMkLCBhc3luYyAoYmxvY2tlZFVzZXJJZHMpID0+IHtcbiAgICAgICAgaWYgKCFibG9ja2VkVXNlcklkcyB8fCBibG9ja2VkVXNlcklkcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudFVzZXJJZCA9IHRoaXMuY3VycmVudFVzZXJJZDtcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VySWQgJiYgYmxvY2tlZFVzZXJJZHMuaW5jbHVkZXMoY3VycmVudFVzZXJJZCkpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsICdMZWF2aW5nIGNhbGwgYmVjYXVzZSBvZiBiZWluZyBibG9ja2VkJyk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5sZWF2ZSh7IHJlYXNvbjogJ3VzZXIgYmxvY2tlZCcgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgIC8vIHdhdGNoIGZvciBhdXRvIGRyb3AgY2FuY2VsbGF0aW9uXG4gICAgICBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUkLCAoY2FsbGluZ1N0YXRlKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yaW5naW5nKSByZXR1cm47XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lORUQgfHxcbiAgICAgICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lOSU5HIHx8XG4gICAgICAgICAgY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuTEVGVFxuICAgICAgICApIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kcm9wVGltZW91dCk7XG4gICAgICAgICAgdGhpcy5kcm9wVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgKTtcblxuICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKFxuICAgICAgLy8gXCJyaW5naW5nXCIgbW9kZSBlZmZlY3RzIGFuZCBldmVudCBoYW5kbGVyc1xuICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMucmluZ2luZ1N1YmplY3QsIChpc1JpbmdpbmcpID0+IHtcbiAgICAgICAgaWYgKCFpc1JpbmdpbmcpIHJldHVybjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUF1dG9Ecm9wKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLklETEUpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuUklOR0lORyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQocmVnaXN0ZXJSaW5naW5nQ2FsbEV2ZW50SGFuZGxlcnModGhpcykpO1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBZb3UgY2FuIHN1YnNjcmliZSB0byBXZWJTb2NrZXQgZXZlbnRzIHByb3ZpZGVkIGJ5IHRoZSBBUEkuIFRvIHJlbW92ZSBhIHN1YnNjcmlwdGlvbiwgY2FsbCB0aGUgYG9mZmAgbWV0aG9kLlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHN1YnNjcmliaW5nIHRvIFdlYlNvY2tldCBldmVudHMgaXMgYW4gYWR2YW5jZWQgdXNlLWNhc2UuXG4gICAqIEZvciBtb3N0IHVzZS1jYXNlcywgaXQgc2hvdWxkIGJlIGVub3VnaCB0byB3YXRjaCBmb3Igc3RhdGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGZuIHRoZSBldmVudCBoYW5kbGVyLlxuICAgKi9cbiAgb24gPSA8RSBleHRlbmRzIGtleW9mIEFsbENhbGxFdmVudHM+KFxuICAgIGV2ZW50TmFtZTogRSxcbiAgICBmbjogQ2FsbEV2ZW50TGlzdGVuZXI8RT4sXG4gICkgPT4ge1xuICAgIGlmIChpc1NmdUV2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoZXIub24oZXZlbnROYW1lLCBmbik7XG4gICAgfVxuXG4gICAgY29uc3Qgb2ZmSGFuZGxlciA9IHRoaXMuc3RyZWFtQ2xpZW50Lm9uKGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gZSBhcyBTdHJlYW1DYWxsRXZlbnQ7XG4gICAgICBpZiAoZXZlbnQuY2FsbF9jaWQgJiYgZXZlbnQuY2FsbF9jaWQgPT09IHRoaXMuY2lkKSB7XG4gICAgICAgIGZuKGV2ZW50IGFzIEFsbENhbGxFdmVudHNbRV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8ga2VlcCB0aGUgJ29mZicgcmVmZXJlbmNlIHJldHVybmVkIGJ5IHRoZSBzdHJlYW0gY2xpZW50XG4gICAgdGhpcy5zdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzLnNldChmbiwgb2ZmSGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgZm4pO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzdWJzY3JpcHRpb24gZm9yIFdlYlNvY2tldCBldmVudHMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnkgdGhlIGBvbmAgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIHRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0gZm4gdGhlIGV2ZW50IGhhbmRsZXIuXG4gICAqL1xuICBvZmYgPSA8RSBleHRlbmRzIGtleW9mIEFsbENhbGxFdmVudHM+KFxuICAgIGV2ZW50TmFtZTogRSxcbiAgICBmbjogQ2FsbEV2ZW50TGlzdGVuZXI8RT4sXG4gICkgPT4ge1xuICAgIGlmIChpc1NmdUV2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoZXIub2ZmKGV2ZW50TmFtZSwgZm4pO1xuICAgIH1cblxuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIHN0cmVhbSBjbGllbnQgZXZlbnQgYnkgdXNpbmcgdGhlICdvZmYnIHJlZmVyZW5jZVxuICAgIGNvbnN0IHJlZ2lzdGVyZWRPZmZIYW5kbGVyID0gdGhpcy5zdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzLmdldChmbik7XG4gICAgaWYgKHJlZ2lzdGVyZWRPZmZIYW5kbGVyKSB7XG4gICAgICByZWdpc3RlcmVkT2ZmSGFuZGxlcigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGVhdmUgdGhlIGNhbGwgYW5kIHN0b3AgdGhlIG1lZGlhIHN0cmVhbXMgdGhhdCB3ZXJlIHB1Ymxpc2hlZCBieSB0aGUgY2FsbC5cbiAgICovXG4gIGxlYXZlID0gYXN5bmMgKHtcbiAgICByZWplY3QgPSBmYWxzZSxcbiAgICByZWFzb24gPSAndXNlciBpcyBsZWF2aW5nIHRoZSBjYWxsJyxcbiAgfTogQ2FsbExlYXZlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgY2FsbGluZ1N0YXRlID0gdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGU7XG4gICAgaWYgKGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkxFRlQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxlYXZlIGNhbGwgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGxlZnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5JTkcpIHtcbiAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJpbmdpbmcpIHtcbiAgICAgIC8vIEknbSB0aGUgb25lIHdobyBzdGFydGVkIHRoZSBjYWxsLCBzbyBJIHNob3VsZCBjYW5jZWwgaXQuXG4gICAgICBjb25zdCBoYXNPdGhlclBhcnRpY2lwYW50cyA9IHRoaXMuc3RhdGUucmVtb3RlUGFydGljaXBhbnRzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAodGhpcy5pc0NyZWF0ZWRCeU1lICYmICFoYXNPdGhlclBhcnRpY2lwYW50cykge1xuICAgICAgICAvLyBTaWduYWxzIG90aGVyIHVzZXJzIHRoYXQgSSBoYXZlIGNhbmNlbGxlZCBteSBjYWxsIHRvIHRoZW1cbiAgICAgICAgLy8gYmVmb3JlIHRoZXkgYWNjZXB0ZWQgaXQuXG4gICAgICAgIGF3YWl0IHRoaXMucmVqZWN0KCk7XG4gICAgICB9IGVsc2UgaWYgKHJlamVjdCAmJiBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HKSB7XG4gICAgICAgIC8vIFNpZ25hbHMgb3RoZXIgdXNlcnMgdGhhdCBJIGhhdmUgcmVqZWN0ZWQgdGhlIGluY29taW5nIGNhbGwuXG4gICAgICAgIGF3YWl0IHRoaXMucmVqZWN0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgdGhpcy5zdGF0c1JlcG9ydGVyID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zdWJzY3JpYmVyPy5jbG9zZSgpO1xuICAgIHRoaXMuc3Vic2NyaWJlciA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMucHVibGlzaGVyPy5jbG9zZSgpO1xuICAgIHRoaXMucHVibGlzaGVyID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zZnVDbGllbnQ/LmNsb3NlKFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSwgcmVhc29uKTtcbiAgICB0aGlzLnNmdUNsaWVudCA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZGlzcGF0Y2hlci5vZmZBbGwoKTtcblxuICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5MRUZUKTtcblxuICAgIC8vIENhbGwgYWxsIGxlYXZlIGNhbGwgaG9va3MsIGUuZy4gdG8gY2xlYW4gdXAgZ2xvYmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5mb3JFYWNoKChob29rKSA9PiBob29rKCkpO1xuXG4gICAgdGhpcy5jbGllbnRTdG9yZS51bnJlZ2lzdGVyQ2FsbCh0aGlzKTtcblxuICAgIHRoaXMuY2FtZXJhLmRpc3Bvc2UoKTtcbiAgICB0aGlzLm1pY3JvcGhvbmUuZGlzcG9zZSgpO1xuICAgIHRoaXMuc2NyZWVuU2hhcmUuZGlzcG9zZSgpO1xuICAgIHRoaXMuc3BlYWtlci5kaXNwb3NlKCk7XG5cbiAgICBjb25zdCBzdG9wT25MZWF2ZVByb21pc2VzOiBQcm9taXNlPHZvaWQ+W10gPSBbXTtcbiAgICBpZiAodGhpcy5jYW1lcmEuc3RvcE9uTGVhdmUpIHtcbiAgICAgIHN0b3BPbkxlYXZlUHJvbWlzZXMucHVzaCh0aGlzLmNhbWVyYS5kaXNhYmxlKHRydWUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWljcm9waG9uZS5zdG9wT25MZWF2ZSkge1xuICAgICAgc3RvcE9uTGVhdmVQcm9taXNlcy5wdXNoKHRoaXMubWljcm9waG9uZS5kaXNhYmxlKHRydWUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2NyZWVuU2hhcmUuc3RvcE9uTGVhdmUpIHtcbiAgICAgIHN0b3BPbkxlYXZlUHJvbWlzZXMucHVzaCh0aGlzLnNjcmVlblNoYXJlLmRpc2FibGUodHJ1ZSkpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChzdG9wT25MZWF2ZVByb21pc2VzKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2FsbCBpcyBcInJpbmdpbmdcIiB0eXBlIG9mIGNhbGwuXG4gICAqL1xuICBnZXQgcmluZ2luZygpIHtcbiAgICByZXR1cm4gZ2V0Q3VycmVudFZhbHVlKHRoaXMucmluZ2luZ1N1YmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCB1c2VyIElELlxuICAgKi9cbiAgZ2V0IGN1cnJlbnRVc2VySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50U3RvcmUuY29ubmVjdGVkVXNlcj8uaWQ7XG4gIH1cblxuICAvKipcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2FsbCB3YXMgY3JlYXRlZCBieSB0aGUgY3VycmVudCB1c2VyLlxuICAgKi9cbiAgZ2V0IGlzQ3JlYXRlZEJ5TWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY3JlYXRlZEJ5Py5pZCA9PT0gdGhpcy5jdXJyZW50VXNlcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5yaW5nIGlmIHNldCB0byB0cnVlLCBhIGBjYWxsLnJpbmdgIGV2ZW50IHdpbGwgYmUgc2VudCB0byB0aGUgY2FsbCBtZW1iZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm5vdGlmeSBpZiBzZXQgdG8gdHJ1ZSwgYSBgY2FsbC5ub3RpZmljYXRpb25gIGV2ZW50IHdpbGwgYmUgc2VudCB0byB0aGUgY2FsbCBtZW1iZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1lbWJlcnNfbGltaXQgdGhlIHRvdGFsIG51bWJlciBvZiBtZW1iZXJzIHRvIHJldHVybiBhcyBwYXJ0IG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIGdldCA9IGFzeW5jIChwYXJhbXM/OiB7XG4gICAgcmluZz86IGJvb2xlYW47XG4gICAgbm90aWZ5PzogYm9vbGVhbjtcbiAgICBtZW1iZXJzX2xpbWl0PzogbnVtYmVyO1xuICB9KSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5nZXQ8R2V0Q2FsbFJlc3BvbnNlPihcbiAgICAgIHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGgsXG4gICAgICBwYXJhbXMsXG4gICAgKTtcblxuICAgIGlmIChwYXJhbXM/LnJpbmcgJiYgIXRoaXMucmluZ2luZykge1xuICAgICAgdGhpcy5yaW5naW5nU3ViamVjdC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShyZXNwb25zZS5jYWxsKTtcbiAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMocmVzcG9uc2UubWVtYmVycyk7XG4gICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMocmVzcG9uc2Uub3duX2NhcGFiaWxpdGllcyk7XG5cbiAgICBpZiAodGhpcy5zdHJlYW1DbGllbnQuX2hhc0Nvbm5lY3Rpb25JRCgpKSB7XG4gICAgICB0aGlzLndhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2xpZW50U3RvcmUucmVnaXN0ZXJDYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwbHlEZXZpY2VDb25maWcoKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsIGFuZCBjcmVhdGVzIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIHRvIGNyZWF0ZSB0aGUgY2FsbCB3aXRoLlxuICAgKi9cbiAgZ2V0T3JDcmVhdGUgPSBhc3luYyAoZGF0YT86IEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8XG4gICAgICBHZXRPckNyZWF0ZUNhbGxSZXNwb25zZSxcbiAgICAgIEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3RcbiAgICA+KHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGgsIGRhdGEpO1xuXG4gICAgaWYgKGRhdGE/LnJpbmcgJiYgIXRoaXMucmluZ2luZykge1xuICAgICAgdGhpcy5yaW5naW5nU3ViamVjdC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShyZXNwb25zZS5jYWxsKTtcbiAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMocmVzcG9uc2UubWVtYmVycyk7XG4gICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMocmVzcG9uc2Uub3duX2NhcGFiaWxpdGllcyk7XG5cbiAgICBpZiAodGhpcy5zdHJlYW1DbGllbnQuX2hhc0Nvbm5lY3Rpb25JRCgpKSB7XG4gICAgICB0aGlzLndhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2xpZW50U3RvcmUucmVnaXN0ZXJDYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwbHlEZXZpY2VDb25maWcoKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhbGxcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgdG8gY3JlYXRlIHRoZSBjYWxsIHdpdGguXG4gICAqL1xuICBjcmVhdGUgPSBhc3luYyAoZGF0YT86IEdldE9yQ3JlYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRPckNyZWF0ZShkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBzaG9ydGN1dCBmb3Ige0BsaW5rIENhbGwuZ2V0fSB3aXRoIGByaW5nYCBwYXJhbWV0ZXIgc2V0IHRvIGB0cnVlYC5cbiAgICogV2lsbCBzZW5kIGEgYGNhbGwucmluZ2AgZXZlbnQgdG8gdGhlIGNhbGwgbWVtYmVycy5cbiAgICovXG4gIHJpbmcgPSBhc3luYyAoKTogUHJvbWlzZTxHZXRDYWxsUmVzcG9uc2U+ID0+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoeyByaW5nOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNob3J0Y3V0IGZvciB7QGxpbmsgQ2FsbC5nZXR9IHdpdGggYG5vdGlmeWAgcGFyYW1ldGVyIHNldCB0byBgdHJ1ZWAuXG4gICAqIFdpbGwgc2VuZCBhIGBjYWxsLm5vdGlmaWNhdGlvbmAgZXZlbnQgdG8gdGhlIGNhbGwgbWVtYmVycy5cbiAgICovXG4gIG5vdGlmeSA9IGFzeW5jICgpOiBQcm9taXNlPEdldENhbGxSZXNwb25zZT4gPT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldCh7IG5vdGlmeTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogTWFya3MgdGhlIGluY29taW5nIGNhbGwgYXMgYWNjZXB0ZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIFwicmluZ2luZ1wiIGNhbGwgZmxvd3MuXG4gICAqIHtAbGluayBDYWxsLmpvaW59IGludm9rZXMgdGhpcyBtZXRob2QgYXV0b21hdGljYWxseSBmb3IgeW91IHdoZW4gam9pbmluZyBhIGNhbGwuXG4gICAqIFVubGVzcyB5b3UgYXJlIGltcGxlbWVudGluZyBhIGN1c3RvbSBcInJpbmdpbmdcIiBmbG93LCB5b3Ugc2hvdWxkIG5vdCB1c2UgdGhpcyBtZXRob2QuXG4gICAqL1xuICBhY2NlcHQgPSBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8QWNjZXB0Q2FsbFJlc3BvbnNlPihcbiAgICAgIGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L2FjY2VwdGAsXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFya3MgdGhlIGluY29taW5nIGNhbGwgYXMgcmVqZWN0ZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIFwicmluZ2luZ1wiIGNhbGwgZmxvd3MuXG4gICAqIHtAbGluayBDYWxsLmxlYXZlfSBpbnZva2VzIHRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgZm9yIHlvdSB3aGVuIHlvdSBsZWF2ZSBvciByZWplY3QgdGhpcyBjYWxsLlxuICAgKiBVbmxlc3MgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjdXN0b20gXCJyaW5naW5nXCIgZmxvdywgeW91IHNob3VsZCBub3QgdXNlIHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgcmVqZWN0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PFJlamVjdENhbGxSZXNwb25zZT4oXG4gICAgICBgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9yZWplY3RgLFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdpbGwgc3RhcnQgdG8gd2F0Y2ggZm9yIGNhbGwgcmVsYXRlZCBXZWJTb2NrZXQgZXZlbnRzIGFuZCBpbml0aWF0ZSBhIGNhbGwgc2Vzc2lvbiB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyBvbmNlIHRoZSBjYWxsIGpvaW4tZmxvdyBoYXMgZmluaXNoZWQuXG4gICAqL1xuICBqb2luID0gYXN5bmMgKGRhdGE/OiBKb2luQ2FsbERhdGEpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zdCBjYWxsaW5nU3RhdGUgPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZTtcbiAgICBpZiAoW0NhbGxpbmdTdGF0ZS5KT0lORUQsIENhbGxpbmdTdGF0ZS5KT0lOSU5HXS5pbmNsdWRlcyhjYWxsaW5nU3RhdGUpKSB7XG4gICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgJ3dhcm4nLFxuICAgICAgICAnSm9pbiBtZXRob2QgY2FsbGVkIHR3aWNlLCB5b3Ugc2hvdWxkIG9ubHkgY2FsbCB0aGlzIG9uY2UnLFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBTdGF0ZTogQWxyZWFkeSBqb2luZWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkxFRlQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lsbGVnYWwgU3RhdGU6IENhbm5vdCBqb2luIGFscmVhZHkgbGVmdCBjYWxsLiBDcmVhdGUgYSBuZXcgQ2FsbCBpbnN0YW5jZSB0byBqb2luIGEgY2FsbC4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01pZ3JhdGluZyA9IGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLk1JR1JBVElORztcbiAgICBjb25zdCBpc1JlY29ubmVjdGluZyA9IGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElORztcbiAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuSk9JTklORyk7XG4gICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgJ1N0YXJ0aW5nIGpvaW4gZmxvdycpO1xuXG4gICAgaWYgKGRhdGE/LnJpbmcgJiYgIXRoaXMucmluZ2luZykge1xuICAgICAgdGhpcy5yaW5naW5nU3ViamVjdC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJpbmdpbmcgJiYgIXRoaXMuaXNDcmVhdGVkQnlNZSkge1xuICAgICAgLy8gc2lnbmFscyBvdGhlciB1c2VycyB0aGF0IEkgaGF2ZSBhY2NlcHRlZCB0aGUgaW5jb21pbmcgY2FsbC5cbiAgICAgIGF3YWl0IHRoaXMuYWNjZXB0KCk7XG4gICAgfVxuXG4gICAgbGV0IHNmdVNlcnZlcjogU0ZVUmVzcG9uc2U7XG4gICAgbGV0IHNmdVRva2VuOiBzdHJpbmc7XG4gICAgbGV0IGNvbm5lY3Rpb25Db25maWc6IFJUQ0NvbmZpZ3VyYXRpb24gfCB1bmRlZmluZWQ7XG4gICAgbGV0IHN0YXRzT3B0aW9uczogU3RhdHNPcHRpb25zIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zZnVDbGllbnQ/LmlzRmFzdFJlY29ubmVjdGluZykge1xuICAgICAgICAvLyB1c2UgcHJldmlvdXMgU0ZVIGNvbmZpZ3VyYXRpb24gYW5kIHZhbHVlc1xuICAgICAgICBjb25uZWN0aW9uQ29uZmlnID0gdGhpcy5wdWJsaXNoZXI/LmNvbm5lY3Rpb25Db25maWd1cmF0aW9uO1xuICAgICAgICBzZnVTZXJ2ZXIgPSB0aGlzLnNmdUNsaWVudC5zZnVTZXJ2ZXI7XG4gICAgICAgIHNmdVRva2VuID0gdGhpcy5zZnVDbGllbnQudG9rZW47XG4gICAgICAgIHN0YXRzT3B0aW9ucyA9IHRoaXMuc2Z1U3RhdHNSZXBvcnRlcj8ub3B0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZ1bGwgam9pbiBmbG93IC0gbGV0IHRoZSBDb29yZGluYXRvciBwaWNrIGEgbmV3IFNGVSBmb3IgdXNcbiAgICAgICAgY29uc3QgY2FsbCA9IGF3YWl0IGpvaW4odGhpcy5zdHJlYW1DbGllbnQsIHRoaXMudHlwZSwgdGhpcy5pZCwgZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjYWxsLm1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRNZW1iZXJzKGNhbGwubWVtYmVycyk7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKGNhbGwub3duQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZyA9IGNhbGwuY29ubmVjdGlvbkNvbmZpZztcbiAgICAgICAgc2Z1U2VydmVyID0gY2FsbC5zZnVTZXJ2ZXI7XG4gICAgICAgIHNmdVRva2VuID0gY2FsbC50b2tlbjtcbiAgICAgICAgc3RhdHNPcHRpb25zID0gY2FsbC5zdGF0c09wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0cmVhbUNsaWVudC5faGFzQ29ubmVjdGlvbklEKCkpIHtcbiAgICAgICAgdGhpcy53YXRjaGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xpZW50U3RvcmUucmVnaXN0ZXJDYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBjYWxsIHN0YXRlIGlmIHRoZSBqb2luLWZsb3cgZmFpbHNcbiAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKGNhbGxpbmdTdGF0ZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2aW91c1NmdUNsaWVudCA9IHRoaXMuc2Z1Q2xpZW50O1xuICAgIGNvbnN0IHNmdUNsaWVudCA9ICh0aGlzLnNmdUNsaWVudCA9IG5ldyBTdHJlYW1TZnVDbGllbnQoe1xuICAgICAgZGlzcGF0Y2hlcjogdGhpcy5kaXNwYXRjaGVyLFxuICAgICAgc2Z1U2VydmVyLFxuICAgICAgdG9rZW46IHNmdVRva2VuLFxuICAgICAgc2Vzc2lvbklkOiBwcmV2aW91c1NmdUNsaWVudD8uc2Vzc2lvbklkLFxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIEEgY2xvc3VyZSB3aGljaCBoaWRlcyBhd2F5IHRoZSByZS1jb25uZWN0aW9uIGxvZ2ljLlxuICAgICAqL1xuICAgIGNvbnN0IHJlY29ubmVjdCA9IGFzeW5jIChcbiAgICAgIHN0cmF0ZWd5OiAnZnVsbCcgfCAnZmFzdCcgfCAnbWlncmF0ZScsXG4gICAgICByZWFzb246IHN0cmluZyxcbiAgICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50U3RhdGUgPT09IENhbGxpbmdTdGF0ZS5NSUdSQVRJTkcgfHxcbiAgICAgICAgY3VycmVudFN0YXRlID09PSBDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HXG4gICAgICApIHtcbiAgICAgICAgLy8gcHJldmVudCBwYXJhbGxlbCByZWNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoXG4gICAgICAgIHN0cmF0ZWd5ID09PSAnbWlncmF0ZSdcbiAgICAgICAgICA/IENhbGxpbmdTdGF0ZS5NSUdSQVRJTkdcbiAgICAgICAgICA6IENhbGxpbmdTdGF0ZS5SRUNPTk5FQ1RJTkcsXG4gICAgICApO1xuXG4gICAgICBpZiAoc3RyYXRlZ3kgPT09ICdtaWdyYXRlJykge1xuICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAnZGVidWcnLFxuICAgICAgICAgIGBbTWlncmF0aW9uXTogbWlncmF0aW5nIGNhbGwgJHt0aGlzLmNpZH0gYXdheSBmcm9tICR7c2Z1U2VydmVyLmVkZ2VfbmFtZX1gLFxuICAgICAgICApO1xuICAgICAgICBzZnVDbGllbnQuaXNNaWdyYXRpbmdBd2F5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICdkZWJ1ZycsXG4gICAgICAgICAgYFtSZWpvaW5dOiAke3N0cmF0ZWd5fSByZWpvaW4gY2FsbCAke3RoaXMuY2lkfSAoJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSkuLi5gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyB0YWtlIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgXCJsb2NhbCBwYXJ0aWNpcGFudFwiIHN0YXRlXG4gICAgICAvLyB3ZSdsbCBuZWVkIGl0IGZvciByZXN0b3JpbmcgdGhlIHByZXZpb3VzIHB1Ymxpc2hpbmcgc3RhdGUgbGF0ZXJcbiAgICAgIGNvbnN0IGxvY2FsUGFydGljaXBhbnQgPSB0aGlzLnN0YXRlLmxvY2FsUGFydGljaXBhbnQ7XG5cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gJ2Zhc3QnKSB7XG4gICAgICAgIHNmdUNsaWVudC5jbG9zZShcbiAgICAgICAgICBTdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9CUk9LRU4sXG4gICAgICAgICAgYGF0dGVtcHRpbmcgZmFzdCByZWNvbm5lY3Q6ICR7cmVhc29ufWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmF0ZWd5ID09PSAnZnVsbCcpIHtcbiAgICAgICAgLy8gaW4gbWlncmF0aW9uIG9yIHJlY292ZXJ5IHNjZW5hcmlvcywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyB3YWl0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJlY29ubmVjdCB0byBhbiBTRlUgc2VydmVyXG4gICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5yZWNvbm5lY3RBdHRlbXB0cykpO1xuXG4gICAgICAgIC8vIGluIGZ1bGwtcmVjb25uZWN0LCB3ZSBuZWVkIHRvIGRpc3Bvc2UgYWxsIFBlZXIgQ29ubmVjdGlvbnNcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyPy5jbG9zZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHVibGlzaGVyPy5jbG9zZSh7IHN0b3BUcmFja3M6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgICAgIHRoaXMuc2Z1U3RhdHNSZXBvcnRlciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBjbGVhbiB1cCBjdXJyZW50IGNvbm5lY3Rpb25cbiAgICAgICAgc2Z1Q2xpZW50LmNsb3NlKFxuICAgICAgICAgIFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSxcbiAgICAgICAgICBgYXR0ZW1wdGluZyBmdWxsIHJlY29ubmVjdDogJHtyZWFzb259YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuam9pbih7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIC4uLihzdHJhdGVneSA9PT0gJ21pZ3JhdGUnICYmIHsgbWlncmF0aW5nX2Zyb206IHNmdVNlcnZlci5lZGdlX25hbWUgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gY2xlYW4gdXAgcHJldmlvdXMgY29ubmVjdGlvblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbWlncmF0ZScpIHtcbiAgICAgICAgc2Z1Q2xpZW50LmNsb3NlKFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSwgJ2F0dGVtcHRpbmcgbWlncmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAnaW5mbycsXG4gICAgICAgIGBbUmVqb2luXTogQXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9IHN1Y2Nlc3NmdWwhYCxcbiAgICAgICk7XG4gICAgICAvLyB3ZSBzaG91bGRuJ3QgYmUgcmVwdWJsaXNoaW5nIHRoZSBzdHJlYW1zIGlmIHdlJ3JlIG1pZ3JhdGluZ1xuICAgICAgLy8gYXMgdGhlIHVuZGVybHlpbmcgcGVlciBjb25uZWN0aW9uIHdpbGwgdGFrZSBjYXJlIG9mIGl0IGFzIHBhcnRcbiAgICAgIC8vIG9mIHRoZSBpY2UtcmVzdGFydCBwcm9jZXNzXG4gICAgICBpZiAobG9jYWxQYXJ0aWNpcGFudCAmJiBzdHJhdGVneSA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhdWRpb1N0cmVhbSxcbiAgICAgICAgICB2aWRlb1N0cmVhbSxcbiAgICAgICAgICBzY3JlZW5TaGFyZVN0cmVhbSxcbiAgICAgICAgICBzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtLFxuICAgICAgICB9ID0gbG9jYWxQYXJ0aWNpcGFudDtcblxuICAgICAgICBsZXQgc2NyZWVuU2hhcmU6IE1lZGlhU3RyZWFtIHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc2NyZWVuU2hhcmVTdHJlYW0gfHwgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbSkge1xuICAgICAgICAgIHNjcmVlblNoYXJlID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgICAgc2NyZWVuU2hhcmVTdHJlYW0/LmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgIHNjcmVlblNoYXJlPy5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbT8uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgc2NyZWVuU2hhcmU/LmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgcHVibGlzaGluZyBzdGF0ZVxuICAgICAgICBpZiAoYXVkaW9TdHJlYW0pIGF3YWl0IHRoaXMucHVibGlzaEF1ZGlvU3RyZWFtKGF1ZGlvU3RyZWFtKTtcbiAgICAgICAgaWYgKHZpZGVvU3RyZWFtKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVmlkZW9TdHJlYW0odmlkZW9TdHJlYW0sIHtcbiAgICAgICAgICAgIHByZWZlcnJlZENvZGVjOiB0aGlzLmNhbWVyYS5wcmVmZXJyZWRDb2RlYyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NyZWVuU2hhcmUpIGF3YWl0IHRoaXMucHVibGlzaFNjcmVlblNoYXJlU3RyZWFtKHNjcmVlblNoYXJlKTtcblxuICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgYFtSZWpvaW5dOiBTdGF0ZSByZXN0b3JlZC4gQXR0ZW1wdDogJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlY29ubmVjdCBpZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIHVuZXhwZWN0ZWRseS4gZXhhbXBsZTpcbiAgICAvLyAtIFNGVSBjcmFzaCBvciByZXN0YXJ0XG4gICAgLy8gLSBuZXR3b3JrIGNoYW5nZVxuICAgIHNmdUNsaWVudC5zaWduYWxSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgIC8vIHJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgdGhlIFwiZ29Bd2F5XCIgZXZlbnRcbiAgICAgIGNvbnN0IHVucmVnaXN0ZXJHb0F3YXkgPSB0aGlzLmRpc3BhdGNoZXIub24oJ2dvQXdheScsIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlYXNvbiB9ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICBgW01pZ3JhdGlvbl06IEdvaW5nIGF3YXkgZnJvbSBTRlUuLi4gUmVhc29uOiAke0dvQXdheVJlYXNvbltyZWFzb25dfWAsXG4gICAgICAgICk7XG4gICAgICAgIHJlY29ubmVjdCgnbWlncmF0ZScsIEdvQXdheVJlYXNvbltyZWFzb25dKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICAnd2FybicsXG4gICAgICAgICAgICBgW01pZ3JhdGlvbl06IEZhaWxlZCB0byBtaWdyYXRlIHRvIGFub3RoZXIgU0ZVLmAsXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgc2Z1Q2xpZW50LnNpZ25hbFdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKGUpID0+IHtcbiAgICAgICAgLy8gdW5yZWdpc3RlciB0aGUgXCJnb0F3YXlcIiBoYW5kbGVyLCBhcyB3ZSB3b24ndCBuZWVkIGl0IGFueW1vcmUgZm9yIHRoaXMgY29ubmVjdGlvbi5cbiAgICAgICAgLy8gdGhlIHVwY29taW5nIHJlLWpvaW4gd2lsbCByZWdpc3RlciBhIG5ldyBoYW5kbGVyIGFueXdheVxuICAgICAgICB1bnJlZ2lzdGVyR29Bd2F5KCk7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBvbiBwdXJwb3NlXG4gICAgICAgIGlmIChlLmNvZGUgPT09IFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSkgcmV0dXJuO1xuICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVjYXVzZSBvZiBhIHBvbGljeSB2aW9sYXRpb25cbiAgICAgICAgLy8gZS5nLiwgdGhlIHVzZXIgaGFzIGJlZW4gYmxvY2tlZCBieSBhbiBhZG1pbiBvciBtb2RlcmF0b3JcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gS25vd25Db2Rlcy5XU19QT0xJQ1lfVklPTEFUSU9OKSByZXR1cm47XG4gICAgICAgIC8vIFdoZW4gdGhlIFNGVSBpcyBiZWluZyBzaHV0IGRvd24sIGl0IHNlbmRzIGEgZ29Bd2F5IG1lc3NhZ2UuXG4gICAgICAgIC8vIFdoaWxlIHdlIG1pZ3JhdGUgdG8gYW5vdGhlciBTRlUsIHdlIG1pZ2h0IGhhdmUgdGhlIFdTIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gdG8gdGhlIG9sZCBTRlUgY2xvc2VkIGFicnVwdGx5LiBJbiB0aGlzIGNhc2UsIHdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gcmVjb25uZWN0IHRvIHRoZSBvbGQgU0ZVLCBidXQgcmF0aGVyIHRvIHRoZSBuZXcgb25lLlxuICAgICAgICBjb25zdCBpc01pZ3JhdGluZ0F3YXkgPVxuICAgICAgICAgIGUuY29kZSA9PT0gS25vd25Db2Rlcy5XU19DTE9TRURfQUJSVVBUTFkgJiYgc2Z1Q2xpZW50LmlzTWlncmF0aW5nQXdheTtcbiAgICAgICAgY29uc3QgaXNGYXN0UmVjb25uZWN0aW5nID1cbiAgICAgICAgICBlLmNvZGUgPT09IEtub3duQ29kZXMuV1NfQ0xPU0VEX0FCUlVQVExZICYmXG4gICAgICAgICAgc2Z1Q2xpZW50LmlzRmFzdFJlY29ubmVjdGluZztcbiAgICAgICAgaWYgKGlzTWlncmF0aW5nQXdheSB8fCBpc0Zhc3RSZWNvbm5lY3RpbmcpIHJldHVybjtcblxuICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVjYXVzZSBvZiBhIGZhc3QgcmVjb25uZWN0XG4gICAgICAgIGlmIChlLmNvZGUgPT09IFN0cmVhbVNmdUNsaWVudC5FUlJPUl9DT05ORUNUSU9OX0JST0tFTikgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgIHNmdUNsaWVudC5pc0Zhc3RSZWNvbm5lY3RpbmcgPSB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID09PSAwO1xuICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gc2Z1Q2xpZW50LmlzRmFzdFJlY29ubmVjdGluZyA/ICdmYXN0JyA6ICdmdWxsJztcbiAgICAgICAgICByZWNvbm5lY3Qoc3RyYXRlZ3ksIGBTRlUgY2xvc2VkIHRoZSBXUyB3aXRoIGNvZGU6ICR7ZS5jb2RlfWApLmNhdGNoKFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGBbUmVqb2luXTogJHtzdHJhdGVneX0gcmVqb2luIGZhaWxlZCBmb3IgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSB0aW1lcy4gR2l2aW5nIHVwLmAsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ1tSZWpvaW5dOiBSZWNvbm5lY3QgYXR0ZW1wdHMgZXhjZWVkZWQuIEdpdmluZyB1cC4uLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gaGFuZGxlcnMgZm9yIGNvbm5lY3Rpb24gb25saW5lL29mZmxpbmUgZXZlbnRzXG4gICAgY29uc3QgdW5zdWJzY3JpYmVPbmxpbmVFdmVudCA9IHRoaXMuc3RyZWFtQ2xpZW50Lm9uKFxuICAgICAgJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsXG4gICAgICBhc3luYyAoZSkgPT4ge1xuICAgICAgICBpZiAoZS50eXBlICE9PSAnY29ubmVjdGlvbi5jaGFuZ2VkJykgcmV0dXJuO1xuICAgICAgICBpZiAoIWUub25saW5lKSByZXR1cm47XG4gICAgICAgIHVuc3Vic2NyaWJlT25saW5lRXZlbnQoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxpbmdTdGF0ZSA9IHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlO1xuICAgICAgICBjb25zdCBzaG91bGRSZWNvbm5lY3QgPVxuICAgICAgICAgIGN1cnJlbnRDYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5PRkZMSU5FIHx8XG4gICAgICAgICAgY3VycmVudENhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQ7XG4gICAgICAgIGlmICghc2hvdWxkUmVjb25uZWN0KSByZXR1cm47XG4gICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgJ1tSZWpvaW5dOiBHb2luZyBvbmxpbmUuLi4nKTtcbiAgICAgICAgbGV0IGlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZnVDbGllbnQuaXNGYXN0UmVjb25uZWN0aW5nID0gaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQ7XG4gICAgICAgICAgICBhd2FpdCByZWNvbm5lY3QoXG4gICAgICAgICAgICAgIGlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0ID8gJ2Zhc3QnIDogJ2Z1bGwnLFxuICAgICAgICAgICAgICAnTmV0d29yazogb25saW5lJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47IC8vIGJyZWFrIHRoZSBsb29wIGlmIHJlam9pbiBpcyBzdWNjZXNzZnVsXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgYFtSZWpvaW5dW05ldHdvcmtdOiBSZWpvaW4gZmFpbGVkIGZvciBhdHRlbXB0ICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c31gLFxuICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3YWl0IGZvciBhIGJpdCBiZWZvcmUgdHJ5aW5nIHRvIHJlY29ubmVjdCBhZ2FpblxuICAgICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5yZWNvbm5lY3RBdHRlbXB0cykpO1xuICAgICAgICAgIGlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0ID0gZmFsc2U7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKTtcblxuICAgICAgICAvLyBpZiB3ZSdyZSBoZXJlLCBpdCBtZWFucyB0aGF0IHdlJ3ZlIGV4aGF1c3RlZCBhbGwgdGhlIHJlY29ubmVjdCBhdHRlbXB0c1xuICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl1bTmV0d29ya106IFJlam9pbiBmYWlsZWQuIEdpdmluZyB1cC5gKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQpO1xuICAgICAgfSxcbiAgICApO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlT2ZmbGluZUV2ZW50ID0gdGhpcy5zdHJlYW1DbGllbnQub24oXG4gICAgICAnY29ubmVjdGlvbi5jaGFuZ2VkJyxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnR5cGUgIT09ICdjb25uZWN0aW9uLmNoYW5nZWQnKSByZXR1cm47XG4gICAgICAgIGlmIChlLm9ubGluZSkgcmV0dXJuO1xuICAgICAgICB1bnN1YnNjcmliZU9mZmxpbmVFdmVudCgpO1xuICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuT0ZGTElORSk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZCgoKSA9PiB7XG4gICAgICB1bnN1YnNjcmliZU9ubGluZUV2ZW50KCk7XG4gICAgICB1bnN1YnNjcmliZU9mZmxpbmVFdmVudCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKHtcbiAgICAgICAgc2Z1Q2xpZW50LFxuICAgICAgICBkaXNwYXRjaGVyOiB0aGlzLmRpc3BhdGNoZXIsXG4gICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgY29uc3QgYXVkaW9TZXR0aW5ncyA9IHRoaXMuc3RhdGUuc2V0dGluZ3M/LmF1ZGlvO1xuICAgICAgY29uc3QgaXNEdHhFbmFibGVkID0gISFhdWRpb1NldHRpbmdzPy5vcHVzX2R0eF9lbmFibGVkO1xuICAgICAgY29uc3QgaXNSZWRFbmFibGVkID0gISFhdWRpb1NldHRpbmdzPy5yZWR1bmRhbnRfY29kaW5nX2VuYWJsZWQ7XG4gICAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBQdWJsaXNoZXIoe1xuICAgICAgICBzZnVDbGllbnQsXG4gICAgICAgIGRpc3BhdGNoZXI6IHRoaXMuZGlzcGF0Y2hlcixcbiAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcsXG4gICAgICAgIGlzRHR4RW5hYmxlZCxcbiAgICAgICAgaXNSZWRFbmFibGVkLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXRzUmVwb3J0ZXIpIHtcbiAgICAgIHRoaXMuc3RhdHNSZXBvcnRlciA9IGNyZWF0ZVN0YXRzUmVwb3J0ZXIoe1xuICAgICAgICBzdWJzY3JpYmVyOiB0aGlzLnN1YnNjcmliZXIsXG4gICAgICAgIHB1Ymxpc2hlcjogdGhpcy5wdWJsaXNoZXIsXG4gICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY2xpZW50RGV0YWlscyA9IGdldENsaWVudERldGFpbHMoKTtcbiAgICBpZiAoIXRoaXMuc2Z1U3RhdHNSZXBvcnRlciAmJiBzdGF0c09wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2Z1U3RhdHNSZXBvcnRlciA9IG5ldyBTZnVTdGF0c1JlcG9ydGVyKHNmdUNsaWVudCwge1xuICAgICAgICBjbGllbnREZXRhaWxzLFxuICAgICAgICBvcHRpb25zOiBzdGF0c09wdGlvbnMsXG4gICAgICAgIHN1YnNjcmliZXI6IHRoaXMuc3Vic2NyaWJlcixcbiAgICAgICAgcHVibGlzaGVyOiB0aGlzLnB1Ymxpc2hlcixcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDEuIHdhaXQgZm9yIHRoZSBzaWduYWwgc2VydmVyIHRvIGJlIHJlYWR5IGJlZm9yZSBzZW5kaW5nIFwiam9pblJlcXVlc3RcIlxuICAgICAgc2Z1Q2xpZW50LnNpZ25hbFJlYWR5XG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB0aGlzLmxvZ2dlcignZXJyb3InLCAnU2lnbmFsIHJlYWR5IGZhaWxlZCcsIGVycikpXG4gICAgICAgIC8vIHByZXBhcmUgYSBnZW5lcmljIFNEUCBhbmQgc2VuZCBpdCB0byB0aGUgU0ZVLlxuICAgICAgICAvLyB0aGlzIGlzIGEgdGhyb3ctYXdheSBTRFAgdGhhdCB0aGUgU0ZVIHdpbGwgdXNlIHRvIGRldGVybWluZVxuICAgICAgICAvLyB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBjbGllbnQgKGNvZGVjIHN1cHBvcnQsIGV0Yy4pXG4gICAgICAgIC50aGVuKCgpID0+IGdldEdlbmVyaWNTZHAoJ3JlY3Zvbmx5JykpXG4gICAgICAgIC50aGVuKChzZHApID0+IHtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gZ2V0Q3VycmVudFZhbHVlKHRoaXMudHJhY2tTdWJzY3JpcHRpb25zU3ViamVjdCk7XG4gICAgICAgICAgY29uc3QgbWlncmF0aW9uOiBNaWdyYXRpb24gfCB1bmRlZmluZWQgPSBpc01pZ3JhdGluZ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZnJvbVNmdUlkOiBkYXRhPy5taWdyYXRpbmdfZnJvbSB8fCAnJyxcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zOiBzdWJzY3JpcHRpb25zLmRhdGEgfHwgW10sXG4gICAgICAgICAgICAgICAgYW5ub3VuY2VkVHJhY2tzOiB0aGlzLnB1Ymxpc2hlcj8uZ2V0Q3VycmVudFRyYWNrSW5mb3MoKSB8fCBbXSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICByZXR1cm4gc2Z1Q2xpZW50LmpvaW4oe1xuICAgICAgICAgICAgc3Vic2NyaWJlclNkcDogc2RwIHx8ICcnLFxuICAgICAgICAgICAgY2xpZW50RGV0YWlscyxcbiAgICAgICAgICAgIG1pZ3JhdGlvbixcbiAgICAgICAgICAgIGZhc3RSZWNvbm5lY3Q6IHByZXZpb3VzU2Z1Q2xpZW50Py5pc0Zhc3RSZWNvbm5lY3RpbmcgPz8gZmFsc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyAyLiBpbiBwYXJhbGxlbCwgd2FpdCBmb3IgdGhlIFNGVSB0byBzZW5kIHVzIHRoZSBcImpvaW5SZXNwb25zZVwiXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIFNGVSByZWplY3RzIHRoZSBqb2luIHJlcXVlc3Qgb3JcbiAgICAgIC8vIGZhaWxzIHRvIHJlc3BvbmQgaW4gdGltZVxuICAgICAgY29uc3QgeyBjYWxsU3RhdGUsIHJlY29ubmVjdGVkIH0gPSBhd2FpdCB0aGlzLndhaXRGb3JKb2luUmVzcG9uc2UoKTtcbiAgICAgIGlmIChpc1JlY29ubmVjdGluZykge1xuICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCAnW1Jlam9pbl0gZmFzdCByZWNvbm5lY3RlZDonLCByZWNvbm5lY3RlZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNNaWdyYXRpbmcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdWJzY3JpYmVyLm1pZ3JhdGVUbyhzZnVDbGllbnQsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5taWdyYXRlVG8oc2Z1Q2xpZW50LCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgaWYgKHJlY29ubmVjdGVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBTRlUgY2xpZW50IGluc3RhbmNlIG9uIHRoZSBzdWJzY3JpYmVyIGFuZCBwdWJsaXNoZXJcbiAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuc2V0U2Z1Q2xpZW50KHNmdUNsaWVudCk7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIuc2V0U2Z1Q2xpZW50KHNmdUNsaWVudCk7XG4gICAgICAgICAgLy8gYW5kIHBlcmZvcm0gYSBmdWxsIElDRSByZXN0YXJ0IG9uIHRoZSBwdWJsaXNoZXJcbiAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5yZXN0YXJ0SWNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNTZnVDbGllbnQ/LmlzRmFzdFJlY29ubmVjdGluZykge1xuICAgICAgICAgIC8vIHJlY29ubmVjdGlvbiB3YXNuJ3QgcG9zc2libGUsIHNvIHdlIG5lZWQgdG8gZG8gYSBmdWxsIHJlam9pblxuICAgICAgICAgIHJldHVybiBhd2FpdCByZWNvbm5lY3QoJ2Z1bGwnLCAncmUtYXR0ZW1wdGluZycpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICBgW1Jlam9pbl06IFJlam9pbiBmYWlsZWQgZm9yY2VkIGZ1bGwgcmVqb2luLmAsXG4gICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0aWNpcGFudHMgPSBjYWxsU3RhdGU/LnBhcnRpY2lwYW50cyB8fCBbXTtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50Q291bnQgPSBjYWxsU3RhdGU/LnBhcnRpY2lwYW50Q291bnQ7XG4gICAgICBjb25zdCBzdGFydGVkQXQgPSBjYWxsU3RhdGU/LnN0YXJ0ZWRBdFxuICAgICAgICA/IFRpbWVzdGFtcC50b0RhdGUoY2FsbFN0YXRlLnN0YXJ0ZWRBdClcbiAgICAgICAgOiBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgcGlucyA9IGNhbGxTdGF0ZT8ucGlucyA/PyBbXTtcbiAgICAgIHRoaXMuc3RhdGUuc2V0UGFydGljaXBhbnRzKCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnRMb29rdXAgPSB0aGlzLnN0YXRlLmdldFBhcnRpY2lwYW50TG9va3VwQnlTZXNzaW9uSWQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJ0aWNpcGFudHMubWFwPFN0cmVhbVZpZGVvUGFydGljaXBhbnQ+KChwKSA9PiB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgbG9jYWwgc3RhdGUgb2YgdGhlIHBhcnRpY2lwYW50XG4gICAgICAgICAgLy8gKGUuZy4gdmlkZW9EaW1lbnNpb24sIHZpc2liaWxpdHlTdGF0ZSwgcGlubmVkQXQsIGV0Yy4pXG4gICAgICAgICAgLy8gYXMgaXQgZG9lc24ndCBleGlzdCBvbiB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUGFydGljaXBhbnQgPSBwYXJ0aWNpcGFudExvb2t1cFtwLnNlc3Npb25JZF07XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocCwgZXhpc3RpbmdQYXJ0aWNpcGFudCwge1xuICAgICAgICAgICAgaXNMb2NhbFBhcnRpY2lwYW50OiBwLnNlc3Npb25JZCA9PT0gc2Z1Q2xpZW50LnNlc3Npb25JZCxcbiAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlOlxuICAgICAgICAgICAgICBleGlzdGluZ1BhcnRpY2lwYW50Py52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA/PyB7XG4gICAgICAgICAgICAgICAgdmlkZW9UcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICAgICAgc2NyZWVuU2hhcmVUcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSBzYXRpc2ZpZXMgUGFydGlhbDxTdHJlYW1WaWRlb1BhcnRpY2lwYW50Pik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXRlLnNldFBhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudD8udG90YWwgfHwgMCk7XG4gICAgICB0aGlzLnN0YXRlLnNldEFub255bW91c1BhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudD8uYW5vbnltb3VzIHx8IDApO1xuICAgICAgdGhpcy5zdGF0ZS5zZXRTdGFydGVkQXQoc3RhcnRlZEF0KTtcbiAgICAgIHRoaXMuc3RhdGUuc2V0U2VydmVyU2lkZVBpbnMocGlucyk7XG5cbiAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwOyAvLyByZXNldCB0aGUgcmVjb25uZWN0IGF0dGVtcHRzIGNvdW50ZXJcbiAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5KT0lORUQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRDYW1lcmEoeyBzZXRTdGF0dXM6IHRydWUgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdE1pYyh7IHNldFN0YXR1czogdHJ1ZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICd3YXJuJyxcbiAgICAgICAgICAnQ2FtZXJhIGFuZC9vciBtaWMgaW5pdCBmYWlsZWQgZHVyaW5nIGpvaW4gY2FsbCcsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIDMuIG9uY2Ugd2UgaGF2ZSB0aGUgXCJqb2luUmVzcG9uc2VcIiwgYW5kIHBvc3NpYmx5IHJlY29uY2lsZWQgdGhlIGxvY2FsIHN0YXRlXG4gICAgICAvLyB3ZSBzY2hlZHVsZSBhIGZhc3Qgc3Vic2NyaXB0aW9uIHVwZGF0ZSBmb3IgYWxsIHJlbW90ZSBwYXJ0aWNpcGFudHNcbiAgICAgIC8vIHRoYXQgd2VyZSB2aXNpYmxlIGJlZm9yZSB3ZSByZWNvbm5lY3RlZCBvciBtaWdyYXRlZCB0byBhIG5ldyBTRlUuXG4gICAgICBjb25zdCB7IHJlbW90ZVBhcnRpY2lwYW50cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmIChyZW1vdGVQYXJ0aWNpcGFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMocmVtb3RlUGFydGljaXBhbnRzLCBEZWJvdW5jZVR5cGUuRkFTVCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYEpvaW5lZCBjYWxsICR7dGhpcy5jaWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBqb2luIGZhaWxlZCwgdHJ5IHRvIHJlam9pblxuICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgYFtSZWpvaW5dOiBSZWpvaW4gJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBmYWlsZWQuYCxcbiAgICAgICAgICBlcnIsXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHJlY29ubmVjdCgnZnVsbCcsICdwcmV2aW91cyBhdHRlbXB0IGZhaWxlZCcpO1xuICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgYFtSZWpvaW5dOiBSZWpvaW4gJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBzdWNjZXNzZnVsIWAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgIGBbUmVqb2luXTogUmVqb2luIGZhaWxlZCBmb3IgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSB0aW1lcy4gR2l2aW5nIHVwLmAsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5SRUNPTk5FQ1RJTkdfRkFJTEVEKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKb2luIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHdhaXRGb3JKb2luUmVzcG9uc2UgPSAodGltZW91dDogbnVtYmVyID0gNTAwMCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxKb2luUmVzcG9uc2U+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbignam9pblJlc3BvbnNlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignV2FpdGluZyBmb3IgXCJqb2luUmVzcG9uc2VcIiBoYXMgdGltZWQgb3V0JykpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBwdWJsaXNoaW5nIHRoZSBnaXZlbiB2aWRlbyBzdHJlYW0gdG8gdGhlIGNhbGwuXG4gICAqIFRoZSBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkIGlmIHRoZSB1c2VyIGNoYW5nZXMgYW4gaW5wdXQgZGV2aWNlLCBvciBpZiB0aGUgdXNlciBsZWF2ZXMgdGhlIGNhbGwuXG4gICAqXG4gICAqIENvbnNlY3V0aXZlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgcHJldmlvdXNseSBwdWJsaXNoZWQgc3RyZWFtLlxuICAgKiBUaGUgcHJldmlvdXMgdmlkZW8gc3RyZWFtIHdpbGwgYmUgc3RvcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHZpZGVvU3RyZWFtIHRoZSB2aWRlbyBzdHJlYW0gdG8gcHVibGlzaC5cbiAgICogQHBhcmFtIG9wdHMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gcHVibGlzaGluZyB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHVibGlzaFZpZGVvU3RyZWFtID0gYXN5bmMgKFxuICAgIHZpZGVvU3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgICBvcHRzOiBQdWJsaXNoT3B0aW9ucyA9IHt9LFxuICApID0+IHtcbiAgICAvLyB3ZSBzaG91bGQgd2FpdCB1bnRpbCB3ZSBnZXQgYSBKb2luUmVzcG9uc2UgZnJvbSB0aGUgU0ZVLFxuICAgIC8vIG90aGVyd2lzZSB3ZSByaXNrIGJyZWFraW5nIHRoZSBJQ0VUcmlja2xlIGZsb3cuXG4gICAgYXdhaXQgdGhpcy5hc3NlcnRDYWxsSm9pbmVkKCk7XG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ1RyeWluZyB0byBwdWJsaXNoIHZpZGVvIGJlZm9yZSBqb2luIGlzIGNvbXBsZXRlZCcpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsIG5vdCBqb2luZWQgeWV0LmApO1xuICAgIH1cblxuICAgIGNvbnN0IFt2aWRlb1RyYWNrXSA9IHZpZGVvU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKCF2aWRlb1RyYWNrKSB7XG4gICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgVGhlcmUgaXMgbm8gdmlkZW8gdHJhY2sgdG8gcHVibGlzaCBpbiB0aGUgc3RyZWFtLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0oXG4gICAgICB2aWRlb1N0cmVhbSxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBUcmFja1R5cGUuVklERU8sXG4gICAgICBvcHRzLFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBwdWJsaXNoaW5nIHRoZSBnaXZlbiBhdWRpbyBzdHJlYW0gdG8gdGhlIGNhbGwuXG4gICAqIFRoZSBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkIGlmIHRoZSB1c2VyIGNoYW5nZXMgYW4gaW5wdXQgZGV2aWNlLCBvciBpZiB0aGUgdXNlciBsZWF2ZXMgdGhlIGNhbGwuXG4gICAqXG4gICAqIENvbnNlY3V0aXZlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgYXVkaW8gc3RyZWFtIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHB1Ymxpc2hlZC5cbiAgICogVGhlIHByZXZpb3VzIGF1ZGlvIHN0cmVhbSB3aWxsIGJlIHN0b3BwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhdWRpb1N0cmVhbSB0aGUgYXVkaW8gc3RyZWFtIHRvIHB1Ymxpc2guXG4gICAqL1xuICBwdWJsaXNoQXVkaW9TdHJlYW0gPSBhc3luYyAoYXVkaW9TdHJlYW06IE1lZGlhU3RyZWFtKSA9PiB7XG4gICAgLy8gd2Ugc2hvdWxkIHdhaXQgdW50aWwgd2UgZ2V0IGEgSm9pblJlc3BvbnNlIGZyb20gdGhlIFNGVSxcbiAgICAvLyBvdGhlcndpc2Ugd2UgcmlzayBicmVha2luZyB0aGUgSUNFVHJpY2tsZSBmbG93LlxuICAgIGF3YWl0IHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCgpO1xuICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdUcnlpbmcgdG8gcHVibGlzaCBhdWRpbyBiZWZvcmUgam9pbiBpcyBjb21wbGV0ZWQnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbCBub3Qgam9pbmVkIHlldC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBbYXVkaW9UcmFja10gPSBhdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgIGlmICghYXVkaW9UcmFjaykge1xuICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFRoZXJlIGlzIG5vIGF1ZGlvIHRyYWNrIGluIHRoZSBzdHJlYW0gdG8gcHVibGlzaGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0oXG4gICAgICBhdWRpb1N0cmVhbSxcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICBUcmFja1R5cGUuQVVESU8sXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIHNjcmVlbi1zaGFyZSBzdHJlYW0gdG8gdGhlIGNhbGwuXG4gICAqXG4gICAqIENvbnNlY3V0aXZlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgcHJldmlvdXMgc2NyZWVuLXNoYXJlIHN0cmVhbS5cbiAgICogVGhlIHByZXZpb3VzIHNjcmVlbi1zaGFyZSBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2NyZWVuU2hhcmVTdHJlYW0gdGhlIHNjcmVlbi1zaGFyZSBzdHJlYW0gdG8gcHVibGlzaC5cbiAgICogQHBhcmFtIG9wdHMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gcHVibGlzaGluZyB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHVibGlzaFNjcmVlblNoYXJlU3RyZWFtID0gYXN5bmMgKFxuICAgIHNjcmVlblNoYXJlU3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgICBvcHRzOiBQdWJsaXNoT3B0aW9ucyA9IHt9LFxuICApID0+IHtcbiAgICAvLyB3ZSBzaG91bGQgd2FpdCB1bnRpbCB3ZSBnZXQgYSBKb2luUmVzcG9uc2UgZnJvbSB0aGUgU0ZVLFxuICAgIC8vIG90aGVyd2lzZSB3ZSByaXNrIGJyZWFraW5nIHRoZSBJQ0VUcmlja2xlIGZsb3cuXG4gICAgYXdhaXQgdGhpcy5hc3NlcnRDYWxsSm9pbmVkKCk7XG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgICdUcnlpbmcgdG8gcHVibGlzaCBzY3JlZW4gc2hhcmUgYmVmb3JlIGpvaW4gaXMgY29tcGxldGVkJyxcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgbm90IGpvaW5lZCB5ZXQuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgW3NjcmVlblNoYXJlVHJhY2tdID0gc2NyZWVuU2hhcmVTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICBpZiAoIXNjcmVlblNoYXJlVHJhY2spIHtcbiAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAnZXJyb3InLFxuICAgICAgICBgVGhlcmUgaXMgbm8gdmlkZW8gdHJhY2sgaW4gdGhlIHNjcmVlbiBzaGFyZSBzdHJlYW0gdG8gcHVibGlzaGAsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0oXG4gICAgICBzY3JlZW5TaGFyZVN0cmVhbSxcbiAgICAgIHNjcmVlblNoYXJlVHJhY2ssXG4gICAgICBUcmFja1R5cGUuU0NSRUVOX1NIQVJFLFxuICAgICAgb3B0cyxcbiAgICApO1xuXG4gICAgY29uc3QgW3NjcmVlblNoYXJlQXVkaW9UcmFja10gPSBzY3JlZW5TaGFyZVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgIGlmIChzY3JlZW5TaGFyZUF1ZGlvVHJhY2spIHtcbiAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0oXG4gICAgICAgIHNjcmVlblNoYXJlU3RyZWFtLFxuICAgICAgICBzY3JlZW5TaGFyZUF1ZGlvVHJhY2ssXG4gICAgICAgIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sXG4gICAgICAgIG9wdHMsXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RvcHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gdHJhY2sgdHlwZSB0byB0aGUgY2FsbCwgaWYgaXQgaXMgY3VycmVudGx5IGJlaW5nIHB1Ymxpc2hlZC5cbiAgICogVW5kZXJseWluZyB0cmFjayB3aWxsIGJlIHN0b3BwZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgcHVibGlzaGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB0cmFjayB0eXBlIHRvIHN0b3AgcHVibGlzaGluZy5cbiAgICogQHBhcmFtIHN0b3BUcmFjayBpZiBgdHJ1ZWAgdGhlIHRyYWNrIHdpbGwgYmUgc3RvcHBlZCwgZWxzZSBpdCB3aWxsIGJlIGp1c3QgZGlzYWJsZWRcbiAgICovXG4gIHN0b3BQdWJsaXNoID0gYXN5bmMgKHRyYWNrVHlwZTogVHJhY2tUeXBlLCBzdG9wVHJhY2s6IGJvb2xlYW4gPSB0cnVlKSA9PiB7XG4gICAgdGhpcy5sb2dnZXIoXG4gICAgICAnaW5mbycsXG4gICAgICBgc3RvcFB1Ymxpc2ggJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0sIHN0b3AgdHJhY2tzOiAke3N0b3BUcmFja31gLFxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5wdWJsaXNoZXI/LnVucHVibGlzaFN0cmVhbSh0cmFja1R5cGUsIHN0b3BUcmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0cmFjayBzdWJzY3JpcHRpb24gY29uZmlndXJhdGlvbiBmb3Igb25lIG9yIG1vcmUgcGFydGljaXBhbnRzLlxuICAgKiBZb3UgaGF2ZSB0byBjcmVhdGUgYSBzdWJzY3JpcHRpb24gZm9yIGVhY2ggcGFydGljaXBhbnQgZm9yIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzIG9mIHRyYWNrcyB5b3Ugd2FudCB0byByZWNlaXZlLlxuICAgKiBZb3UgY2FuIG9ubHkgc3Vic2NyaWJlIGZvciB0cmFja3MgYWZ0ZXIgdGhlIHBhcnRpY2lwYW50IHN0YXJ0ZWQgcHVibGlzaGluZyB0aGUgZ2l2ZW4ga2luZCBvZiB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiBzdWJzY3JpcHRpb24gdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gY2hhbmdlcyB0aGUgbGlzdCBvZiBzdWJzY3JpcHRpb24gY2hhbmdlcyB0byBkby5cbiAgICogQHBhcmFtIHR5cGUgdGhlIGRlYm91bmNlIHR5cGUgdG8gdXNlIGZvciB0aGUgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlU3Vic2NyaXB0aW9uc1BhcnRpYWwgPSAoXG4gICAgdHJhY2tUeXBlOiBWaWRlb1RyYWNrVHlwZSB8ICd2aWRlbycgfCAnc2NyZWVuJyxcbiAgICBjaGFuZ2VzOiBTdWJzY3JpcHRpb25DaGFuZ2VzLFxuICAgIHR5cGU6IERlYm91bmNlVHlwZSA9IERlYm91bmNlVHlwZS5TTE9XLFxuICApID0+IHtcbiAgICBpZiAodHJhY2tUeXBlID09PSAndmlkZW8nKSB7XG4gICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgJ3dhcm4nLFxuICAgICAgICBgdXBkYXRlU3Vic2NyaXB0aW9uc1BhcnRpYWw6ICR7dHJhY2tUeXBlfSBpcyBkZXByZWNhdGVkLiBQbGVhc2Ugc3dpdGNoIHRvICd2aWRlb1RyYWNrJ2AsXG4gICAgICApO1xuICAgICAgdHJhY2tUeXBlID0gJ3ZpZGVvVHJhY2snO1xuICAgIH0gZWxzZSBpZiAodHJhY2tUeXBlID09PSAnc2NyZWVuJykge1xuICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICd3YXJuJyxcbiAgICAgICAgYHVwZGF0ZVN1YnNjcmlwdGlvbnNQYXJ0aWFsOiAke3RyYWNrVHlwZX0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHN3aXRjaCB0byAnc2NyZWVuU2hhcmVUcmFjaydgLFxuICAgICAgKTtcbiAgICAgIHRyYWNrVHlwZSA9ICdzY3JlZW5TaGFyZVRyYWNrJztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50cyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNoYW5nZXMpLnJlZHVjZTxTdHJlYW1WaWRlb1BhcnRpY2lwYW50UGF0Y2hlcz4oXG4gICAgICAgIChhY2MsIFtzZXNzaW9uSWQsIGNoYW5nZV0pID0+IHtcbiAgICAgICAgICBpZiAoY2hhbmdlLmRpbWVuc2lvbj8uaGVpZ2h0KSB7XG4gICAgICAgICAgICBjaGFuZ2UuZGltZW5zaW9uLmhlaWdodCA9IE1hdGguY2VpbChjaGFuZ2UuZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFuZ2UuZGltZW5zaW9uPy53aWR0aCkge1xuICAgICAgICAgICAgY2hhbmdlLmRpbWVuc2lvbi53aWR0aCA9IE1hdGguY2VpbChjaGFuZ2UuZGltZW5zaW9uLndpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJvcDoga2V5b2YgU3RyZWFtVmlkZW9QYXJ0aWNpcGFudCB8IHVuZGVmaW5lZCA9XG4gICAgICAgICAgICB0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJ1xuICAgICAgICAgICAgICA/ICd2aWRlb0RpbWVuc2lvbidcbiAgICAgICAgICAgICAgOiB0cmFja1R5cGUgPT09ICdzY3JlZW5TaGFyZVRyYWNrJ1xuICAgICAgICAgICAgICA/ICdzY3JlZW5TaGFyZURpbWVuc2lvbidcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgIGFjY1tzZXNzaW9uSWRdID0ge1xuICAgICAgICAgICAgICBbcHJvcF06IGNoYW5nZS5kaW1lbnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgICksXG4gICAgKTtcblxuICAgIGlmIChwYXJ0aWNpcGFudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucyhwYXJ0aWNpcGFudHMsIHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHVwZGF0ZVN1YnNjcmlwdGlvbnMgPSAoXG4gICAgcGFydGljaXBhbnRzOiBTdHJlYW1WaWRlb1BhcnRpY2lwYW50W10sXG4gICAgdHlwZTogRGVib3VuY2VUeXBlID0gRGVib3VuY2VUeXBlLlNMT1csXG4gICkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnM6IFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1tdID0gW107XG4gICAgZm9yIChjb25zdCBwIG9mIHBhcnRpY2lwYW50cykge1xuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBzdWJzY3JpYmUgdG8gb3VyIG93biB0cmFja3NcbiAgICAgIGlmIChwLmlzTG9jYWxQYXJ0aWNpcGFudCkgY29udGludWU7XG5cbiAgICAgIC8vIE5PVEU6IGF1ZGlvIHRyYWNrcyBkb24ndCBoYXZlIHRvIGJlIHJlcXVlc3RlZCBleHBsaWNpdGx5XG4gICAgICAvLyBhcyB0aGUgU0ZVIHdpbGwgaW1wbGljaXRseSBzdWJzY3JpYmUgdXMgdG8gYWxsIG9mIHRoZW0sXG4gICAgICAvLyBvbmNlIHRoZXkgYmVjb21lIGF2YWlsYWJsZS5cblxuICAgICAgaWYgKHAudmlkZW9EaW1lbnNpb24gJiYgcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlZJREVPKSkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goe1xuICAgICAgICAgIHVzZXJJZDogcC51c2VySWQsXG4gICAgICAgICAgc2Vzc2lvbklkOiBwLnNlc3Npb25JZCxcbiAgICAgICAgICB0cmFja1R5cGU6IFRyYWNrVHlwZS5WSURFTyxcbiAgICAgICAgICBkaW1lbnNpb246IHAudmlkZW9EaW1lbnNpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBwLnNjcmVlblNoYXJlRGltZW5zaW9uICYmXG4gICAgICAgIHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpXG4gICAgICApIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHtcbiAgICAgICAgICB1c2VySWQ6IHAudXNlcklkLFxuICAgICAgICAgIHNlc3Npb25JZDogcC5zZXNzaW9uSWQsXG4gICAgICAgICAgdHJhY2tUeXBlOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFLFxuICAgICAgICAgIGRpbWVuc2lvbjogcC5zY3JlZW5TaGFyZURpbWVuc2lvbixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTykpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHtcbiAgICAgICAgICB1c2VySWQ6IHAudXNlcklkLFxuICAgICAgICAgIHNlc3Npb25JZDogcC5zZXNzaW9uSWQsXG4gICAgICAgICAgdHJhY2tUeXBlOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2NoZWR1bGUgdXBkYXRlXG4gICAgdGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0Lm5leHQoeyB0eXBlLCBkYXRhOiBzdWJzY3JpcHRpb25zIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaWxsIGVuaGFuY2UgdGhlIHJlcG9ydGVkIHN0YXRzIHdpdGggYWRkaXRpb25hbCBwYXJ0aWNpcGFudC1zcGVjaWZpYyBpbmZvcm1hdGlvbiAoYGNhbGxTdGF0c1JlcG9ydCRgIHN0YXRlIFtzdG9yZSB2YXJpYWJsZV0oLi9TdHJlYW1WaWRlb0NsaWVudC5tZC8jcmVhZG9ubHlzdGF0ZXN0b3JlKSkuXG4gICAqIFRoaXMgaXMgdXN1YWxseSBoZWxwZnVsIHdoZW4gZGV0YWlsZWQgc3RhdHMgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnQgYXJlIG5lZWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIHRvIHN0YXJ0IHJlcG9ydGluZyBmb3IuXG4gICAqL1xuICBzdGFydFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNSZXBvcnRlcj8uc3RhcnRSZXBvcnRpbmdTdGF0c0ZvcihzZXNzaW9uSWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcHBvc2l0ZSBvZiBgc3RhcnRSZXBvcnRpbmdTdGF0c0ZvcmAuXG4gICAqIFdpbGwgdHVybiBvZmYgc3RhdHMgcmVwb3J0aW5nIGZvciBhIHNwZWNpZmljIHBhcnRpY2lwYW50LlxuICAgKlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uSWQgdG8gc3RvcCByZXBvcnRpbmcgZm9yLlxuICAgKi9cbiAgc3RvcFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNSZXBvcnRlcj8uc3RvcFJlcG9ydGluZ1N0YXRzRm9yKHNlc3Npb25JZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgbGFzdCBzZW50IHJlYWN0aW9uIGZvciB0aGUgdXNlciBob2xkaW5nIHRoZSBnaXZlbiBgc2Vzc2lvbklkYC4gVGhpcyBpcyBhIGxvY2FsIGFjdGlvbiwgaXQgd29uJ3QgcmVzZXQgdGhlIHJlYWN0aW9uIG9uIHRoZSBiYWNrZW5kLlxuICAgKlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgKi9cbiAgcmVzZXRSZWFjdGlvbiA9IChzZXNzaW9uSWQ6IHN0cmluZykgPT4ge1xuICAgIHRoaXMuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCB7XG4gICAgICByZWFjdGlvbjogdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaXN0IG9mIGNyaXRlcmlhIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cyBieS5cbiAgICpcbiAgICogQHBhcmFtIGNyaXRlcmlhIHRoZSBsaXN0IG9mIGNyaXRlcmlhIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cyBieS5cbiAgICovXG4gIHNldFNvcnRQYXJ0aWNpcGFudHNCeTogQ2FsbFN0YXRlWydzZXRTb3J0UGFydGljaXBhbnRzQnknXSA9IChjcml0ZXJpYSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNldFNvcnRQYXJ0aWNpcGFudHNCeShjcml0ZXJpYSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxpc3Qgb2YgdmlkZW8gbGF5ZXJzIHRvIHB1Ymxpc2guXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0gZW5hYmxlZExheWVycyB0aGUgbGlzdCBvZiBsYXllcnMgdG8gZW5hYmxlLlxuICAgKi9cbiAgdXBkYXRlUHVibGlzaFF1YWxpdHkgPSBhc3luYyAoZW5hYmxlZExheWVyczogVmlkZW9MYXllclNldHRpbmdbXSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlcj8udXBkYXRlVmlkZW9QdWJsaXNoUXVhbGl0eShlbmFibGVkTGF5ZXJzKTtcbiAgfTtcblxuICBwcml2YXRlIGFzc2VydENhbGxKb2luZWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSRcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFrZVdoaWxlKChzdGF0ZSkgPT4gc3RhdGUgIT09IENhbGxpbmdTdGF0ZS5KT0lORUQsIHRydWUpLFxuICAgICAgICAgIGZpbHRlcigocykgPT4gcyA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCksXG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiByZXNvbHZlKCkpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHJlYWN0aW9uIHRvIHRoZSBvdGhlciBjYWxsIHBhcnRpY2lwYW50cy5cbiAgICpcbiAgICogQHBhcmFtIHJlYWN0aW9uIHRoZSByZWFjdGlvbiB0byBzZW5kLlxuICAgKi9cbiAgc2VuZFJlYWN0aW9uID0gYXN5bmMgKFxuICAgIHJlYWN0aW9uOiBTZW5kUmVhY3Rpb25SZXF1ZXN0LFxuICApOiBQcm9taXNlPFNlbmRSZWFjdGlvblJlc3BvbnNlPiA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8U2VuZFJlYWN0aW9uUmVzcG9uc2UsIFNlbmRSZWFjdGlvblJlcXVlc3Q+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vcmVhY3Rpb25gLFxuICAgICAgcmVhY3Rpb24sXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQmxvY2tzIHRoZSB1c2VyIHdpdGggdGhlIGdpdmVuIGB1c2VySWRgLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byBibG9jay5cbiAgICovXG4gIGJsb2NrVXNlciA9IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PEJsb2NrVXNlclJlc3BvbnNlLCBCbG9ja1VzZXJSZXF1ZXN0PihcbiAgICAgIGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L2Jsb2NrYCxcbiAgICAgIHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgfSxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmJsb2NrcyB0aGUgdXNlciB3aXRoIHRoZSBnaXZlbiBgdXNlcklkYC5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gdW5ibG9jay5cbiAgICovXG4gIHVuYmxvY2tVc2VyID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8VW5ibG9ja1VzZXJSZXNwb25zZSwgVW5ibG9ja1VzZXJSZXF1ZXN0PihcbiAgICAgIGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3VuYmxvY2tgLFxuICAgICAge1xuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICB9LFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE11dGVzIHRoZSBjdXJyZW50IHVzZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBtdXRlIG9wZXJhdGlvbi5cbiAgICovXG4gIG11dGVTZWxmID0gKHR5cGU6IFRyYWNrTXV0ZVR5cGUpID0+IHtcbiAgICBjb25zdCBteVVzZXJJZCA9IHRoaXMuY3VycmVudFVzZXJJZDtcbiAgICBpZiAobXlVc2VySWQpIHtcbiAgICAgIHJldHVybiB0aGlzLm11dGVVc2VyKG15VXNlcklkLCB0eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE11dGVzIGFsbCB0aGUgb3RoZXIgcGFydGljaXBhbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgbXV0ZSBvcGVyYXRpb24uXG4gICAqL1xuICBtdXRlT3RoZXJzID0gKHR5cGU6IFRyYWNrTXV0ZVR5cGUpID0+IHtcbiAgICBjb25zdCB0cmFja1R5cGUgPSBtdXRlVHlwZVRvVHJhY2tUeXBlKHR5cGUpO1xuICAgIGlmICghdHJhY2tUeXBlKSByZXR1cm47XG4gICAgY29uc3QgdXNlcklkc1RvTXV0ZTogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhcnRpY2lwYW50IG9mIHRoaXMuc3RhdGUucmVtb3RlUGFydGljaXBhbnRzKSB7XG4gICAgICBpZiAocGFydGljaXBhbnQucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKHRyYWNrVHlwZSkpIHtcbiAgICAgICAgdXNlcklkc1RvTXV0ZS5wdXNoKHBhcnRpY2lwYW50LnVzZXJJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubXV0ZVVzZXIodXNlcklkc1RvTXV0ZSwgdHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE11dGVzIHRoZSB1c2VyIHdpdGggdGhlIGdpdmVuIGB1c2VySWRgLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byBtdXRlLlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgbXV0ZSBvcGVyYXRpb24uXG4gICAqL1xuICBtdXRlVXNlciA9ICh1c2VySWQ6IHN0cmluZyB8IHN0cmluZ1tdLCB0eXBlOiBUcmFja011dGVUeXBlKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8TXV0ZVVzZXJzUmVzcG9uc2UsIE11dGVVc2Vyc1JlcXVlc3Q+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbXV0ZV91c2Vyc2AsXG4gICAgICB7XG4gICAgICAgIHVzZXJfaWRzOiBBcnJheS5pc0FycmF5KHVzZXJJZCkgPyB1c2VySWQgOiBbdXNlcklkXSxcbiAgICAgICAgW3R5cGVdOiB0cnVlLFxuICAgICAgfSxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaWxsIG11dGUgYWxsIHVzZXJzIGluIHRoZSBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgbXV0ZSBvcGVyYXRpb24uXG4gICAqL1xuICBtdXRlQWxsVXNlcnMgPSAodHlwZTogVHJhY2tNdXRlVHlwZSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PE11dGVVc2Vyc1Jlc3BvbnNlLCBNdXRlVXNlcnNSZXF1ZXN0PihcbiAgICAgIGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L211dGVfdXNlcnNgLFxuICAgICAge1xuICAgICAgICBtdXRlX2FsbF91c2VyczogdHJ1ZSxcbiAgICAgICAgW3R5cGVdOiB0cnVlLFxuICAgICAgfSxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgcmVjb3JkaW5nIHRoZSBjYWxsXG4gICAqL1xuICBzdGFydFJlY29yZGluZyA9IGFzeW5jIChyZXF1ZXN0PzogU3RhcnRSZWNvcmRpbmdSZXF1ZXN0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8XG4gICAgICBTdGFydFJlY29yZGluZ1Jlc3BvbnNlLFxuICAgICAgU3RhcnRSZWNvcmRpbmdSZXF1ZXN0XG4gICAgPihgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdGFydF9yZWNvcmRpbmdgLCByZXF1ZXN0ID8gcmVxdWVzdCA6IHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcHMgcmVjb3JkaW5nIHRoZSBjYWxsXG4gICAqL1xuICBzdG9wUmVjb3JkaW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PFN0b3BSZWNvcmRpbmdSZXNwb25zZT4oXG4gICAgICBgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdG9wX3JlY29yZGluZ2AsXG4gICAgICB7fSxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHRyYW5zY3JpcHRpb24gb2YgdGhlIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IHRoZSByZXF1ZXN0IGRhdGEuXG4gICAqL1xuICBzdGFydFRyYW5zY3JpcHRpb24gPSBhc3luYyAoXG4gICAgcmVxdWVzdD86IFN0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3QsXG4gICk6IFByb21pc2U8U3RhcnRUcmFuc2NyaXB0aW9uUmVzcG9uc2U+ID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdDxcbiAgICAgIFN0YXJ0VHJhbnNjcmlwdGlvblJlc3BvbnNlLFxuICAgICAgU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdFxuICAgID4oYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RhcnRfdHJhbnNjcmlwdGlvbmAsIHJlcXVlc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdHJhbnNjcmlwdGlvbiBvZiB0aGUgY2FsbC5cbiAgICovXG4gIHN0b3BUcmFuc2NyaXB0aW9uID0gYXN5bmMgKCk6IFByb21pc2U8U3RvcFRyYW5zY3JpcHRpb25SZXNwb25zZT4gPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PFN0b3BUcmFuc2NyaXB0aW9uUmVzcG9uc2U+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RvcF90cmFuc2NyaXB0aW9uYCxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGBjYWxsLnBlcm1pc3Npb25fcmVxdWVzdGAgZXZlbnQgdG8gYWxsIHVzZXJzIGNvbm5lY3RlZCB0byB0aGUgY2FsbC4gVGhlIGNhbGwgc2V0dGluZ3Mgb2JqZWN0IGNvbnRhaW5zIGluZm9tcmF0aW9uIGFib3V0IHdoaWNoIHBlcm1pc3Npb25zIGNhbiBiZSByZXF1ZXN0ZWQgZHVyaW5nIGEgY2FsbCAoZm9yIGV4YW1wbGUgYSB1c2VyIG1pZ2h0IGJlIGFsbG93ZWQgdG8gcmVxdWVzdCBwZXJtaXNzaW9uIHRvIHB1Ymxpc2ggYXVkaW8sIGJ1dCBub3QgdmlkZW8pLlxuICAgKi9cbiAgcmVxdWVzdFBlcm1pc3Npb25zID0gYXN5bmMgKFxuICAgIGRhdGE6IFJlcXVlc3RQZXJtaXNzaW9uUmVxdWVzdCxcbiAgKTogUHJvbWlzZTxSZXF1ZXN0UGVybWlzc2lvblJlc3BvbnNlPiA9PiB7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gZGF0YTtcbiAgICBjb25zdCBjYW5SZXF1ZXN0UGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucy5ldmVyeSgocGVybWlzc2lvbikgPT5cbiAgICAgIHRoaXMucGVybWlzc2lvbnNDb250ZXh0LmNhblJlcXVlc3QocGVybWlzc2lvbiBhcyBPd25DYXBhYmlsaXR5KSxcbiAgICApO1xuICAgIGlmICghY2FuUmVxdWVzdFBlcm1pc3Npb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgYXJlIG5vdCBhbGxvd2VkIHRvIHJlcXVlc3QgcGVybWlzc2lvbnM6ICR7cGVybWlzc2lvbnMuam9pbignLCAnKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8XG4gICAgICBSZXF1ZXN0UGVybWlzc2lvblJlc3BvbnNlLFxuICAgICAgUmVxdWVzdFBlcm1pc3Npb25SZXF1ZXN0XG4gICAgPihgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9yZXF1ZXN0X3Blcm1pc3Npb25gLCBkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byBncmFudCBjZXJ0YWluIHBlcm1pc3Npb25zIHRvIGEgdXNlciBpbiBhIGNhbGwuXG4gICAqIFRoZSBwZXJtaXNzaW9ucyBhcmUgc3BlY2lmaWMgdG8gdGhlIGNhbGwgZXhwZXJpZW5jZSBhbmQgZG8gbm90IHN1cnZpdmUgdGhlIGNhbGwgaXRzZWxmLlxuICAgKlxuICAgKiBTdXBwb3J0ZWQgcGVybWlzc2lvbnMgdGhhdCBjYW4gYmUgZ3JhbnRlZCBhcmU6XG4gICAqIC0gYHNlbmQtYXVkaW9gXG4gICAqIC0gYHNlbmQtdmlkZW9gXG4gICAqIC0gYHNjcmVlbnNoYXJlYFxuICAgKlxuICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byBncmFudCBwZXJtaXNzaW9ucyB0by5cbiAgICogQHBhcmFtIHBlcm1pc3Npb25zIHRoZSBwZXJtaXNzaW9ucyB0byBncmFudC5cbiAgICovXG4gIGdyYW50UGVybWlzc2lvbnMgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIHBlcm1pc3Npb25zOiBzdHJpbmdbXSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyh7XG4gICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICBncmFudF9wZXJtaXNzaW9uczogcGVybWlzc2lvbnMsXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93cyB5b3UgdG8gcmV2b2tlIGNlcnRhaW4gcGVybWlzc2lvbnMgZnJvbSBhIHVzZXIgaW4gYSBjYWxsLlxuICAgKiBUaGUgcGVybWlzc2lvbnMgYXJlIHNwZWNpZmljIHRvIHRoZSBjYWxsIGV4cGVyaWVuY2UgYW5kIGRvIG5vdCBzdXJ2aXZlIHRoZSBjYWxsIGl0c2VsZi5cbiAgICpcbiAgICogU3VwcG9ydGVkIHBlcm1pc3Npb25zIHRoYXQgY2FuIGJlIHJldm9rZWQgYXJlOlxuICAgKiAtIGBzZW5kLWF1ZGlvYFxuICAgKiAtIGBzZW5kLXZpZGVvYFxuICAgKiAtIGBzY3JlZW5zaGFyZWBcbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gcmV2b2tlIHBlcm1pc3Npb25zIGZyb20uXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9ucyB0aGUgcGVybWlzc2lvbnMgdG8gcmV2b2tlLlxuICAgKi9cbiAgcmV2b2tlUGVybWlzc2lvbnMgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIHBlcm1pc3Npb25zOiBzdHJpbmdbXSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyh7XG4gICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICByZXZva2VfcGVybWlzc2lvbnM6IHBlcm1pc3Npb25zLFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIGdyYW50IG9yIHJldm9rZSBhIHNwZWNpZmljIHBlcm1pc3Npb24gdG8gYSB1c2VyIGluIGEgY2FsbC4gVGhlIHBlcm1pc3Npb25zIGFyZSBzcGVjaWZpYyB0byB0aGUgY2FsbCBleHBlcmllbmNlIGFuZCBkbyBub3Qgc3Vydml2ZSB0aGUgY2FsbCBpdHNlbGYuXG4gICAqXG4gICAqIFdoZW4gcmV2b2tpbmcgYSBwZXJtaXNzaW9uLCB0aGlzIGVuZHBvaW50IHdpbGwgYWxzbyBtdXRlIHRoZSByZWxldmFudCB0cmFjayBmcm9tIHRoZSB1c2VyLiBUaGlzIGlzIHNpbWlsYXIgdG8gbXV0aW5nIGEgdXNlciB3aXRoIHRoZSBkaWZmZXJlbmNlIHRoYXQgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byB1bm11dGUgYWZ0ZXJ3YXJkcy5cbiAgICpcbiAgICogU3VwcG9ydGVkIHBlcm1pc3Npb25zIHRoYXQgY2FuIGJlIGdyYW50ZWQgb3IgcmV2b2tlZDogYHNlbmQtYXVkaW9gLCBgc2VuZC12aWRlb2AgYW5kIGBzY3JlZW5zaGFyZWAuXG4gICAqXG4gICAqIGBjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWRgIGV2ZW50IGlzIHNlbnQgdG8gYWxsIG1lbWJlcnMgb2YgdGhlIGNhbGwuXG4gICAqXG4gICAqL1xuICB1cGRhdGVVc2VyUGVybWlzc2lvbnMgPSBhc3luYyAoZGF0YTogVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PFxuICAgICAgVXBkYXRlVXNlclBlcm1pc3Npb25zUmVzcG9uc2UsXG4gICAgICBVcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0XG4gICAgPihgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS91c2VyX3Blcm1pc3Npb25zYCwgZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgbGl2ZXN0cmVhbWluZyBvZiB0aGUgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIHJlcXVlc3QgZGF0YS5cbiAgICogQHBhcmFtIHBhcmFtcyB0aGUgcmVxdWVzdCBwYXJhbXMuXG4gICAqL1xuICBnb0xpdmUgPSBhc3luYyAoZGF0YTogR29MaXZlUmVxdWVzdCA9IHt9LCBwYXJhbXM/OiB7IG5vdGlmeT86IGJvb2xlYW4gfSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PEdvTGl2ZVJlc3BvbnNlLCBHb0xpdmVSZXF1ZXN0PihcbiAgICAgIGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L2dvX2xpdmVgLFxuICAgICAgZGF0YSxcbiAgICAgIHBhcmFtcyxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgbGl2ZXN0cmVhbWluZyBvZiB0aGUgY2FsbC5cbiAgICovXG4gIHN0b3BMaXZlID0gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0PFN0b3BMaXZlUmVzcG9uc2U+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RvcF9saXZlYCxcbiAgICAgIHt9LFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgYnJvYWRjYXN0aW5nIG9mIHRoZSBjYWxsLlxuICAgKi9cbiAgc3RhcnRITFMgPSBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8U3RhcnRITFNCcm9hZGNhc3RpbmdSZXNwb25zZT4oXG4gICAgICBgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdGFydF9icm9hZGNhc3RpbmdgLFxuICAgICAge30sXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcHMgdGhlIGJyb2FkY2FzdGluZyBvZiB0aGUgY2FsbC5cbiAgICovXG4gIHN0b3BITFMgPSBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8U3RvcEhMU0Jyb2FkY2FzdGluZ1Jlc3BvbnNlPihcbiAgICAgIGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0b3BfYnJvYWRjYXN0aW5nYCxcbiAgICAgIHt9LFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNhbGwgc2V0dGluZ3Mgb3IgY3VzdG9tIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB1cGRhdGVzIHRoZSB1cGRhdGVzIHRvIGFwcGx5IHRvIHRoZSBjYWxsLlxuICAgKi9cbiAgdXBkYXRlID0gYXN5bmMgKHVwZGF0ZXM6IFVwZGF0ZUNhbGxSZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5wYXRjaDxcbiAgICAgIFVwZGF0ZUNhbGxSZXNwb25zZSxcbiAgICAgIFVwZGF0ZUNhbGxSZXF1ZXN0XG4gICAgPihgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofWAsIHVwZGF0ZXMpO1xuXG4gICAgY29uc3QgeyBjYWxsLCBtZW1iZXJzLCBvd25fY2FwYWJpbGl0aWVzIH0gPSByZXNwb25zZTtcbiAgICB0aGlzLnN0YXRlLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoY2FsbCk7XG4gICAgdGhpcy5zdGF0ZS5zZXRNZW1iZXJzKG1lbWJlcnMpO1xuICAgIHRoaXMuc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKG93bl9jYXBhYmlsaXRpZXMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmRzIHRoZSBjYWxsLiBPbmNlIHRoZSBjYWxsIGlzIGVuZGVkLCBpdCBjYW5ub3QgYmUgcmUtam9pbmVkLlxuICAgKi9cbiAgZW5kQ2FsbCA9IGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdDxFbmRDYWxsUmVzcG9uc2U+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbWFya19lbmRlZGAsXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogUGlucyB0aGUgZ2l2ZW4gc2Vzc2lvbiB0byB0aGUgdG9wIG9mIHRoZSBwYXJ0aWNpcGFudHMgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIHRvIHBpbi5cbiAgICovXG4gIHBpbiA9IChzZXNzaW9uSWQ6IHN0cmluZykgPT4ge1xuICAgIHRoaXMuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCB7XG4gICAgICBwaW46IHtcbiAgICAgICAgaXNMb2NhbFBpbjogdHJ1ZSxcbiAgICAgICAgcGlubmVkQXQ6IERhdGUubm93KCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnBpbnMgdGhlIGdpdmVuIHNlc3Npb24gZnJvbSB0aGUgdG9wIG9mIHRoZSBwYXJ0aWNpcGFudHMgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIHRvIHVucGluLlxuICAgKi9cbiAgdW5waW4gPSAoc2Vzc2lvbklkOiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwge1xuICAgICAgcGluOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBpbnMgdGhlIGdpdmVuIHNlc3Npb24gdG8gdGhlIHRvcCBvZiB0aGUgcGFydGljaXBhbnRzIGxpc3QgZm9yIGV2ZXJ5b25lXG4gICAqIGluIHRoZSBjYWxsLlxuICAgKiBZb3UgY2FuIGV4ZWN1dGUgdGhpcyBtZXRob2Qgb25seSBpZiB5b3UgaGF2ZSB0aGUgYHBpbi1mb3ItZXZlcnlvbmVgIGNhcGFiaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHBpbkZvckV2ZXJ5b25lID0gYXN5bmMgKHJlcXVlc3Q6IFBpblJlcXVlc3QpID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdDxQaW5SZXNwb25zZSwgUGluUmVxdWVzdD4oXG4gICAgICBgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9waW5gLFxuICAgICAgcmVxdWVzdCxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnBpbnMgdGhlIGdpdmVuIHNlc3Npb24gZnJvbSB0aGUgdG9wIG9mIHRoZSBwYXJ0aWNpcGFudHMgbGlzdCBmb3IgZXZlcnlvbmVcbiAgICogaW4gdGhlIGNhbGwuXG4gICAqIFlvdSBjYW4gZXhlY3V0ZSB0aGlzIG1ldGhvZCBvbmx5IGlmIHlvdSBoYXZlIHRoZSBgcGluLWZvci1ldmVyeW9uZWAgY2FwYWJpbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgdW5waW5Gb3JFdmVyeW9uZSA9IGFzeW5jIChyZXF1ZXN0OiBVbnBpblJlcXVlc3QpID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdDxVbnBpblJlc3BvbnNlLCBVbnBpblJlcXVlc3Q+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vdW5waW5gLFxuICAgICAgcmVxdWVzdCxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBRdWVyeSBjYWxsIG1lbWJlcnMgd2l0aCBmaWx0ZXIgcXVlcnkuIFRoZSByZXN1bHQgd29uJ3QgYmUgc3RvcmVkIGluIGNhbGwgc3RhdGUuXG4gICAqIEBwYXJhbSByZXF1ZXN0XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBxdWVyeU1lbWJlcnMgPSAocmVxdWVzdD86IE9taXQ8UXVlcnlNZW1iZXJzUmVxdWVzdCwgJ3R5cGUnIHwgJ2lkJz4pID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdDxRdWVyeU1lbWJlcnNSZXNwb25zZSwgUXVlcnlNZW1iZXJzUmVxdWVzdD4oXG4gICAgICAnL2NhbGwvbWVtYmVycycsXG4gICAgICB7XG4gICAgICAgIC4uLihyZXF1ZXN0IHx8IHt9KSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0sXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogV2lsbCB1cGRhdGUgdGhlIGNhbGwgbWVtYmVycy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIHJlcXVlc3QgZGF0YS5cbiAgICovXG4gIHVwZGF0ZUNhbGxNZW1iZXJzID0gYXN5bmMgKFxuICAgIGRhdGE6IFVwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCxcbiAgKTogUHJvbWlzZTxVcGRhdGVDYWxsTWVtYmVyc1Jlc3BvbnNlPiA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8XG4gICAgICBVcGRhdGVDYWxsTWVtYmVyc1Jlc3BvbnNlLFxuICAgICAgVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0XG4gICAgPihgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9tZW1iZXJzYCwgZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhbiBhdXRvLWRyb3AgdGltZW91dCBiYXNlZCBvbiB0aGUgY2FsbCBzZXR0aW5ncy5cbiAgICogQXBwbGljYWJsZSBvbmx5IGZvciByaW5naW5nIGNhbGxzLlxuICAgKi9cbiAgcHJpdmF0ZSBzY2hlZHVsZUF1dG9Ecm9wID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmRyb3BUaW1lb3V0KTtcbiAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgIGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnN0YXRlLnNldHRpbmdzJCwgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgIGlmICghc2V0dGluZ3MpIHJldHVybjtcbiAgICAgICAgLy8gaWdub3JlIGlmIHRoZSBjYWxsIGlzIG5vdCByaW5naW5nXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLlJJTkdJTkcpIHJldHVybjtcblxuICAgICAgICBjb25zdCB0aW1lb3V0SW5NcyA9IHNldHRpbmdzLnJpbmcuYXV0b19jYW5jZWxfdGltZW91dF9tcztcbiAgICAgICAgLy8gMCBtZWFucyBubyBhdXRvLWRyb3BcbiAgICAgICAgaWYgKHRpbWVvdXRJbk1zIDw9IDApIHJldHVybjtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kcm9wVGltZW91dCk7XG4gICAgICAgIHRoaXMuZHJvcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmxlYXZlKHsgcmVhc29uOiAncmluZzogdGltZW91dCcgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ0ZhaWxlZCB0byBkcm9wIGNhbGwnLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aW1lb3V0SW5Ncyk7XG4gICAgICB9KSxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgcmVjb3JkaW5ncyBmb3IgdGhlIGN1cnJlbnQgY2FsbCBvciBjYWxsIHNlc3Npb24uXG4gICAqXG4gICAqIElmIGBjYWxsU2Vzc2lvbklkYCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHJlY29yZGluZ3MgZm9yIHRoYXQgY2FsbCBzZXNzaW9uLlxuICAgKiBPdGhlcndpc2UsIGFsbCByZWNvcmRpbmdzIGZvciB0aGUgY3VycmVudCBjYWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsU2Vzc2lvbklkIHRoZSBjYWxsIHNlc3Npb24gaWQgdG8gcmV0cmlldmUgcmVjb3JkaW5ncyBmb3IuXG4gICAqL1xuICBxdWVyeVJlY29yZGluZ3MgPSBhc3luYyAoXG4gICAgY2FsbFNlc3Npb25JZD86IHN0cmluZyxcbiAgKTogUHJvbWlzZTxMaXN0UmVjb3JkaW5nc1Jlc3BvbnNlPiA9PiB7XG4gICAgbGV0IGVuZHBvaW50ID0gdGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aDtcbiAgICBpZiAoY2FsbFNlc3Npb25JZCkge1xuICAgICAgZW5kcG9pbnQgPSBgJHtlbmRwb2ludH0vJHtjYWxsU2Vzc2lvbklkfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQ8TGlzdFJlY29yZGluZ3NSZXNwb25zZT4oXG4gICAgICBgJHtlbmRwb2ludH0vcmVjb3JkaW5nc2AsXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIHRyYW5zY3JpcHRpb25zIGZvciB0aGUgY3VycmVudCBjYWxsLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2NyaXB0aW9ucy5cbiAgICovXG4gIHF1ZXJ5VHJhbnNjcmlwdGlvbnMgPSBhc3luYyAoKTogUHJvbWlzZTxMaXN0VHJhbnNjcmlwdGlvbnNSZXNwb25zZT4gPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQ8TGlzdFRyYW5zY3JpcHRpb25zUmVzcG9uc2U+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vdHJhbnNjcmlwdGlvbnNgLFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGNhbGwgc3RhdGlzdGljcyBmb3IgYSBwYXJ0aWN1bGFyIGNhbGwgc2Vzc2lvbiAoaGlzdG9yaWNhbCkuXG4gICAqIEhlcmUgYGNhbGxTZXNzaW9uSURgIGlzIG1hbmRhdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxTZXNzaW9uSUQgdGhlIGNhbGwgc2Vzc2lvbiBJRCB0byByZXRyaWV2ZSBzdGF0aXN0aWNzIGZvci5cbiAgICogQHJldHVybnMgVGhlIGNhbGwgc3RhdHMuXG4gICAqL1xuICBnZXRDYWxsU3RhdHMgPSBhc3luYyAoY2FsbFNlc3Npb25JRDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdGF0cy8ke2NhbGxTZXNzaW9uSUR9YDtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZ2V0PEdldENhbGxTdGF0c1Jlc3BvbnNlPihlbmRwb2ludCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN1Ym1pdCB1c2VyIGZlZWRiYWNrIGZvciB0aGUgY2FsbFxuICAgKlxuICAgKiBAcGFyYW0gcmF0aW5nIFJhdGluZyBiZXR3ZWVuIDEgYW5kIDUgZGVub3RpbmcgdGhlIGV4cGVyaWVuY2Ugb2YgdGhlIHVzZXIgaW4gdGhlIGNhbGxcbiAgICogQHBhcmFtIHJlYXNvbiBUaGUgcmVhc29uL2Rlc2NyaXB0aW9uIGZvciB0aGUgcmF0aW5nXG4gICAqIEBwYXJhbSBjdXN0b20gQ3VzdG9tIGRhdGFcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN1Ym1pdEZlZWRiYWNrID0gYXN5bmMgKFxuICAgIHJhdGluZzogbnVtYmVyLFxuICAgIHtcbiAgICAgIHJlYXNvbixcbiAgICAgIGN1c3RvbSxcbiAgICB9OiB7XG4gICAgICByZWFzb24/OiBzdHJpbmc7XG4gICAgICBjdXN0b20/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIH0gPSB7fSxcbiAgKSA9PiB7XG4gICAgaWYgKHJhdGluZyA8IDEgfHwgcmF0aW5nID4gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYXRpbmcgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUnKTtcbiAgICB9XG4gICAgY29uc3QgdXNlclNlc3Npb25JZCA9IHRoaXMuc2Z1Q2xpZW50Py5zZXNzaW9uSWQ7XG4gICAgY29uc3QgY2FsbFNlc3Npb25JZCA9IHRoaXMuc3RhdGUuc2Vzc2lvbj8uaWQ7XG4gICAgaWYgKCFjYWxsU2Vzc2lvbklkIHx8ICF1c2VyU2Vzc2lvbklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdGZWVkYmFjayBjYW4gYmUgc3VibWl0dGVkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSBjYWxsIHNlc3Npb24nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHNka05hbWUsIHNka1ZlcnNpb24sIC4uLnBsYXRmb3JtIH0gPSBnZXRTZGtTaWduYXR1cmUoXG4gICAgICBnZXRDbGllbnREZXRhaWxzKCksXG4gICAgKTtcblxuICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vZmVlZGJhY2svJHtjYWxsU2Vzc2lvbklkfWA7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8XG4gICAgICBDb2xsZWN0VXNlckZlZWRiYWNrUmVzcG9uc2UsXG4gICAgICBDb2xsZWN0VXNlckZlZWRiYWNrUmVxdWVzdFxuICAgID4oZW5kcG9pbnQsIHtcbiAgICAgIHJhdGluZyxcbiAgICAgIHJlYXNvbixcbiAgICAgIHVzZXJfc2Vzc2lvbl9pZDogdXNlclNlc3Npb25JZCxcbiAgICAgIHNkazogc2RrTmFtZSxcbiAgICAgIHNka192ZXJzaW9uOiBzZGtWZXJzaW9uLFxuICAgICAgY3VzdG9tOiB7XG4gICAgICAgIC4uLmN1c3RvbSxcbiAgICAgICAgJ3gtc3RyZWFtLXBsYXRmb3JtLWRhdGEnOiBwbGF0Zm9ybSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY3VzdG9tIGV2ZW50IHRvIGFsbCBjYWxsIHBhcnRpY2lwYW50cy5cbiAgICpcbiAgICogQHBhcmFtIHBheWxvYWQgdGhlIHBheWxvYWQgdG8gc2VuZC5cbiAgICovXG4gIHNlbmRDdXN0b21FdmVudCA9IGFzeW5jIChwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8U2VuZEV2ZW50UmVzcG9uc2UsIFNlbmRFdmVudFJlcXVlc3Q+KFxuICAgICAgYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vZXZlbnRgLFxuICAgICAgeyBjdXN0b206IHBheWxvYWQgfSxcbiAgICApO1xuICB9O1xuXG4gIGFwcGx5RGV2aWNlQ29uZmlnID0gKCkgPT4ge1xuICAgIHRoaXMuaW5pdENhbWVyYSh7IHNldFN0YXR1czogZmFsc2UgfSk7XG4gICAgdGhpcy5pbml0TWljKHsgc2V0U3RhdHVzOiBmYWxzZSB9KTtcbiAgfTtcblxuICBwcml2YXRlIGFzeW5jIGluaXRDYW1lcmEob3B0aW9uczogeyBzZXRTdGF0dXM6IGJvb2xlYW4gfSkge1xuICAgIC8vIFdhaXQgZm9yIGFueSBpbiBwcm9ncmVzcyBjYW1lcmEgb3BlcmF0aW9uXG4gICAgaWYgKHRoaXMuY2FtZXJhLmVuYWJsZVByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuY2FtZXJhLmVuYWJsZVByb21pc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhbWVyYS5kaXNhYmxlUHJvbWlzZSkge1xuICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuZGlzYWJsZVByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5zdGF0ZS5sb2NhbFBhcnRpY2lwYW50Py52aWRlb1N0cmVhbSB8fFxuICAgICAgIXRoaXMucGVybWlzc2lvbnNDb250ZXh0Lmhhc1Blcm1pc3Npb24oJ3NlbmQtdmlkZW8nKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNldCBjYW1lcmEgZGlyZWN0aW9uIGlmIGl0J3Mgbm90IHlldCBzZXRcbiAgICBpZiAoIXRoaXMuY2FtZXJhLnN0YXRlLmRpcmVjdGlvbiAmJiAhdGhpcy5jYW1lcmEuc3RhdGUuc2VsZWN0ZWREZXZpY2UpIHtcbiAgICAgIGxldCBkZWZhdWx0RGlyZWN0aW9uOiBDYW1lcmFEaXJlY3Rpb24gPSAnZnJvbnQnO1xuICAgICAgY29uc3QgYmFja2VuZFNldHRpbmcgPSB0aGlzLnN0YXRlLnNldHRpbmdzPy52aWRlby5jYW1lcmFfZmFjaW5nO1xuICAgICAgaWYgKGJhY2tlbmRTZXR0aW5nKSB7XG4gICAgICAgIGRlZmF1bHREaXJlY3Rpb24gPSBiYWNrZW5kU2V0dGluZyA9PT0gJ2Zyb250JyA/ICdmcm9udCcgOiAnYmFjayc7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbWVyYS5zdGF0ZS5zZXREaXJlY3Rpb24oZGVmYXVsdERpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRhcmdldCByZXNvbHV0aW9uXG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMuc3RhdGUuc2V0dGluZ3M/LnZpZGVvLnRhcmdldF9yZXNvbHV0aW9uO1xuICAgIGlmICh0YXJnZXRSZXNvbHV0aW9uKSB7XG4gICAgICBhd2FpdCB0aGlzLmNhbWVyYS5zZWxlY3RUYXJnZXRSZXNvbHV0aW9uKHRhcmdldFJlc29sdXRpb24pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNldFN0YXR1cykge1xuICAgICAgLy8gUHVibGlzaCBhbHJlYWR5IHRoYXQgd2FzIHNldCBiZWZvcmUgd2Ugam9pbmVkXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuY2FtZXJhLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnICYmXG4gICAgICAgIHRoaXMuY2FtZXJhLnN0YXRlLm1lZGlhU3RyZWFtICYmXG4gICAgICAgICF0aGlzLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5WSURFTylcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hWaWRlb1N0cmVhbSh0aGlzLmNhbWVyYS5zdGF0ZS5tZWRpYVN0cmVhbSwge1xuICAgICAgICAgIHByZWZlcnJlZENvZGVjOiB0aGlzLmNhbWVyYS5wcmVmZXJyZWRDb2RlYyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IGNhbWVyYSBpZiBiYWNrZW5kIGNvbmZpZyBzcGVjaWZpZXMsIGFuZCB0aGVyZSBpcyBubyBsb2NhbCBzZXR0aW5nXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuY2FtZXJhLnN0YXRlLnN0YXR1cyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHRoaXMuc3RhdGUuc2V0dGluZ3M/LnZpZGVvLmNhbWVyYV9kZWZhdWx0X29uXG4gICAgICApIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0TWljKG9wdGlvbnM6IHsgc2V0U3RhdHVzOiBib29sZWFuIH0pIHtcbiAgICAvLyBXYWl0IGZvciBhbnkgaW4gcHJvZ3Jlc3MgbWljIG9wZXJhdGlvblxuICAgIGlmICh0aGlzLm1pY3JvcGhvbmUuZW5hYmxlUHJvbWlzZSkge1xuICAgICAgYXdhaXQgdGhpcy5taWNyb3Bob25lLmVuYWJsZVByb21pc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1pY3JvcGhvbmUuZGlzYWJsZVByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMubWljcm9waG9uZS5kaXNhYmxlUHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnN0YXRlLmxvY2FsUGFydGljaXBhbnQ/LmF1ZGlvU3RyZWFtIHx8XG4gICAgICAhdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuaGFzUGVybWlzc2lvbignc2VuZC1hdWRpbycpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2V0U3RhdHVzKSB7XG4gICAgICAvLyBQdWJsaXNoIG1lZGlhIHN0cmVhbSB0aGF0IHdhcyBzZXQgYmVmb3JlIHdlIGpvaW5lZFxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm1pY3JvcGhvbmUuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcgJiZcbiAgICAgICAgdGhpcy5taWNyb3Bob25lLnN0YXRlLm1lZGlhU3RyZWFtICYmXG4gICAgICAgICF0aGlzLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5BVURJTylcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBdWRpb1N0cmVhbSh0aGlzLm1pY3JvcGhvbmUuc3RhdGUubWVkaWFTdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBtaWMgaWYgYmFja2VuZCBjb25maWcgc3BlY2lmaWVzLCBhbmQgdGhlcmUgaXMgbm8gbG9jYWwgc2V0dGluZ1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm1pY3JvcGhvbmUuc3RhdGUuc3RhdHVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXR0aW5ncz8uYXVkaW8ubWljX2RlZmF1bHRfb25cbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLm1pY3JvcGhvbmUuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgYmVnaW4gdHJhY2tpbmcgdGhlIGdpdmVuIGVsZW1lbnQgZm9yIHZpc2liaWxpdHkgY2hhbmdlcyB3aXRoaW4gdGhlXG4gICAqIGNvbmZpZ3VyZWQgdmlld3BvcnQgZWxlbWVudCAoYGNhbGwuc2V0Vmlld3BvcnRgKS5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gdHJhY2suXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHZpZGVvIG1vZGUuXG4gICAqL1xuICB0cmFja0VsZW1lbnRWaXNpYmlsaXR5ID0gPFQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oXG4gICAgZWxlbWVudDogVCxcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICB0cmFja1R5cGU6IFZpZGVvVHJhY2tUeXBlLFxuICApID0+IHtcbiAgICByZXR1cm4gdGhpcy5keW5hc2NhbGVNYW5hZ2VyLnRyYWNrRWxlbWVudFZpc2liaWxpdHkoXG4gICAgICBlbGVtZW50LFxuICAgICAgc2Vzc2lvbklkLFxuICAgICAgdHJhY2tUeXBlLFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gdHJhY2sgYm91bmQgdmlkZW8gZWxlbWVudHMgZm9yIHZpc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICAgKi9cbiAgc2V0Vmlld3BvcnQgPSA8VCBleHRlbmRzIEhUTUxFbGVtZW50PihlbGVtZW50OiBUKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuZHluYXNjYWxlTWFuYWdlci5zZXRWaWV3cG9ydChlbGVtZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQmluZHMgYSBET00gPHZpZGVvPiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgcGxheVxuICAgKiB0aGUgY29ycmVjdCB2aWRlbyBzdHJlYW0gZm9yIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgKlxuICAgKiBVbmRlciB0aGUgaG9vZCwgaXQgd291bGQgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSB2aWRlbyBlbGVtZW50IGRpbWVuc2lvbnNcbiAgICogYW5kIHVwZGF0ZSB0aGUgc3Vic2NyaXB0aW9uIGFjY29yZGluZ2x5IGluIG9yZGVyIHRvIG9wdGltaXplIHRoZSBiYW5kd2lkdGguXG4gICAqXG4gICAqIElmIGEgXCJ2aWV3cG9ydFwiIGlzIGNvbmZpZ3VyZWQsIHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgYmUgYXV0b21hdGljYWxseVxuICAgKiB0cmFja2VkIGZvciB2aXNpYmlsaXR5IGFuZCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHZpZGVvRWxlbWVudCB0aGUgdmlkZW8gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIHZpZGVvLlxuICAgKi9cbiAgYmluZFZpZGVvRWxlbWVudCA9IChcbiAgICB2aWRlb0VsZW1lbnQ6IEhUTUxWaWRlb0VsZW1lbnQsXG4gICAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gICAgdHJhY2tUeXBlOiBWaWRlb1RyYWNrVHlwZSxcbiAgKSA9PiB7XG4gICAgY29uc3QgdW5iaW5kID0gdGhpcy5keW5hc2NhbGVNYW5hZ2VyLmJpbmRWaWRlb0VsZW1lbnQoXG4gICAgICB2aWRlb0VsZW1lbnQsXG4gICAgICBzZXNzaW9uSWQsXG4gICAgICB0cmFja1R5cGUsXG4gICAgKTtcblxuICAgIGlmICghdW5iaW5kKSByZXR1cm47XG4gICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQodW5iaW5kKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5kZWxldGUodW5iaW5kKTtcbiAgICAgIHVuYmluZCgpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpbmRzIGEgRE9NIDxhdWRpbz4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBtYWtlIHN1cmUgdGhhdCB0aGUgYXVkaW8gZWxlbWVudCB3aWxsXG4gICAqIHBsYXkgdGhlIGNvcnJlY3QgYXVkaW8gc3RyZWFtIGZvciB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICpcbiAgICogQHBhcmFtIGF1ZGlvRWxlbWVudCB0aGUgYXVkaW8gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIGF1ZGlvLlxuICAgKi9cbiAgYmluZEF1ZGlvRWxlbWVudCA9IChcbiAgICBhdWRpb0VsZW1lbnQ6IEhUTUxBdWRpb0VsZW1lbnQsXG4gICAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gICAgdHJhY2tUeXBlOiBBdWRpb1RyYWNrVHlwZSA9ICdhdWRpb1RyYWNrJyxcbiAgKSA9PiB7XG4gICAgY29uc3QgdW5iaW5kID0gdGhpcy5keW5hc2NhbGVNYW5hZ2VyLmJpbmRBdWRpb0VsZW1lbnQoXG4gICAgICBhdWRpb0VsZW1lbnQsXG4gICAgICBzZXNzaW9uSWQsXG4gICAgICB0cmFja1R5cGUsXG4gICAgKTtcblxuICAgIGlmICghdW5iaW5kKSByZXR1cm47XG4gICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQodW5iaW5kKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5kZWxldGUodW5iaW5kKTtcbiAgICAgIHVuYmluZCgpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpbmRzIGEgRE9NIDxpbWc+IGVsZW1lbnQgdG8gdGhpcyBjYWxsJ3MgdGh1bWJuYWlsIChpZiBlbmFibGVkIGluIHNldHRpbmdzKS5cbiAgICpcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCB0aGUgaW1hZ2UgZWxlbWVudCB0byBiaW5kIHRvLlxuICAgKiBAcGFyYW0gb3B0cyBvcHRpb25zIGZvciB0aGUgYmluZGluZy5cbiAgICovXG4gIGJpbmRDYWxsVGh1bWJuYWlsRWxlbWVudCA9IChcbiAgICBpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsXG4gICAgb3B0czoge1xuICAgICAgZmFsbGJhY2tJbWFnZVNvdXJjZT86IHN0cmluZztcbiAgICB9ID0ge30sXG4gICkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKCkgPT4ge1xuICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9XG4gICAgICAgIG9wdHMuZmFsbGJhY2tJbWFnZVNvdXJjZSB8fFxuICAgICAgICAnaHR0cHM6Ly9nZXRzdHJlYW0uaW8vcmFuZG9tX3N2Zy8/bmFtZT14JmlkPXgnO1xuICAgIH07XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgIHRoaXMuc3RhdGUudGh1bWJuYWlscyQsXG4gICAgICAodGh1bWJuYWlscykgPT4ge1xuICAgICAgICBpZiAoIXRodW1ibmFpbHMpIHJldHVybjtcbiAgICAgICAgaW1hZ2VFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuXG4gICAgICAgIGNvbnN0IHRodW1ibmFpbFVybCA9IG5ldyBVUkwodGh1bWJuYWlscy5pbWFnZV91cmwpO1xuICAgICAgICB0aHVtYm5haWxVcmwuc2VhcmNoUGFyYW1zLnNldCgndycsIFN0cmluZyhpbWFnZUVsZW1lbnQuY2xpZW50V2lkdGgpKTtcbiAgICAgICAgdGh1bWJuYWlsVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2gnLCBTdHJpbmcoaW1hZ2VFbGVtZW50LmNsaWVudEhlaWdodCkpO1xuXG4gICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSB0aHVtYm5haWxVcmwudG9TdHJpbmcoKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgaW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgIH07XG4gIH07XG59XG4iLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgU3RhYmxlV1NDb25uZWN0aW9uIH0gZnJvbSAnLi9jb25uZWN0aW9uJztcbmltcG9ydCB7IHJhbmRvbUlkLCBzbGVlcCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBJbnNpZ2h0VHlwZXMgPVxuICB8ICd3c19mYXRhbCdcbiAgfCAnd3Nfc3VjY2Vzc19hZnRlcl9mYWlsdXJlJ1xuICB8ICdodHRwX2hpX2ZhaWxlZCc7XG5leHBvcnQgY2xhc3MgSW5zaWdodE1ldHJpY3Mge1xuICBjb25uZWN0aW9uU3RhcnRUaW1lc3RhbXA6IG51bWJlciB8IG51bGw7XG4gIHdzQ29uc2VjdXRpdmVGYWlsdXJlczogbnVtYmVyO1xuICB3c1RvdGFsRmFpbHVyZXM6IG51bWJlcjtcbiAgaW5zdGFuY2VDbGllbnRJZDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXJ0VGltZXN0YW1wID0gbnVsbDtcbiAgICB0aGlzLndzVG90YWxGYWlsdXJlcyA9IDA7XG4gICAgdGhpcy53c0NvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIHRoaXMuaW5zdGFuY2VDbGllbnRJZCA9IHJhbmRvbUlkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBwb3N0SW5zaWdodHMgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgYnkgZW5kIHVzZXJzIGRpcmVjdGx5IHdpdGhpbiBjaGF0IGFwcGxpY2F0aW9uLCBhbmQgdGh1cyBpcyBrZXB0IGlzb2xhdGVkXG4gKiBmcm9tIGFsbCB0aGUgY2xpZW50L2Nvbm5lY3Rpb24gY29kZS9sb2dpYy5cbiAqXG4gKiBAcGFyYW0gaW5zaWdodFR5cGVcbiAqIEBwYXJhbSBpbnNpZ2h0c1xuICovXG5leHBvcnQgY29uc3QgcG9zdEluc2lnaHRzID0gYXN5bmMgKFxuICBpbnNpZ2h0VHlwZTogSW5zaWdodFR5cGVzLFxuICBpbnNpZ2h0czogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pID0+IHtcbiAgY29uc3QgbWF4QXR0ZW1wdHMgPSAzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEF0dGVtcHRzOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXhpb3MucG9zdChcbiAgICAgICAgYGh0dHBzOi8vY2hhdC1pbnNpZ2h0cy5nZXRzdHJlYW0uaW8vaW5zaWdodHMvJHtpbnNpZ2h0VHlwZX1gLFxuICAgICAgICBpbnNpZ2h0cyxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgc2xlZXAoKGkgKyAxKSAqIDMwMDApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRXc0ZhdGFsSW5zaWdodChcbiAgY29ubmVjdGlvbjogU3RhYmxlV1NDb25uZWN0aW9uLFxuICBldmVudDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5ldmVudCxcbiAgICAuLi5idWlsZFdzQmFzZUluc2lnaHQoY29ubmVjdGlvbiksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkV3NCYXNlSW5zaWdodChjb25uZWN0aW9uOiBTdGFibGVXU0Nvbm5lY3Rpb24pIHtcbiAgY29uc3QgeyBjbGllbnQgfSA9IGNvbm5lY3Rpb247XG4gIHJldHVybiB7XG4gICAgcmVhZHlfc3RhdGU6IGNvbm5lY3Rpb24ud3M/LnJlYWR5U3RhdGUsXG4gICAgdXJsOiBjb25uZWN0aW9uLl9idWlsZFVybCgpLFxuICAgIGFwaV9rZXk6IGNsaWVudC5rZXksXG4gICAgc3RhcnRfdHM6IGNsaWVudC5pbnNpZ2h0TWV0cmljcy5jb25uZWN0aW9uU3RhcnRUaW1lc3RhbXAsXG4gICAgZW5kX3RzOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICBhdXRoX3R5cGU6IGNsaWVudC5nZXRBdXRoVHlwZSgpLFxuICAgIHRva2VuOiBjbGllbnQudG9rZW5NYW5hZ2VyLnRva2VuLFxuICAgIHVzZXJfaWQ6IGNsaWVudC51c2VySUQsXG4gICAgdXNlcl9kZXRhaWxzOiBjbGllbnQuX3VzZXIsXG4gICAgLy8gZGV2aWNlOiBjbGllbnQub3B0aW9ucy5kZXZpY2UsXG4gICAgZGV2aWNlOiAnYnJvd3NlcicsXG4gICAgY2xpZW50X2lkOiBjb25uZWN0aW9uLmNvbm5lY3Rpb25JRCxcbiAgICB3c19kZXRhaWxzOiBjb25uZWN0aW9uLndzLFxuICAgIHdzX2NvbnNlY3V0aXZlX2ZhaWx1cmVzOiBjbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzLFxuICAgIHdzX3RvdGFsX2ZhaWx1cmVzOiBjbGllbnQuaW5zaWdodE1ldHJpY3Mud3NUb3RhbEZhaWx1cmVzLFxuICAgIHJlcXVlc3RfaWQ6IGNvbm5lY3Rpb24ucmVxdWVzdElELFxuICAgIG9ubGluZTogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3I/Lm9uTGluZSA6IG51bGwsXG4gICAgdXNlcl9hZ2VudDogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3I/LnVzZXJBZ2VudCA6IG51bGwsXG4gICAgaW5zdGFuY2VfY2xpZW50X2lkOiBjbGllbnQuaW5zaWdodE1ldHJpY3MuaW5zdGFuY2VDbGllbnRJZCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkV3NTdWNjZXNzQWZ0ZXJGYWlsdXJlSW5zaWdodChcbiAgY29ubmVjdGlvbjogU3RhYmxlV1NDb25uZWN0aW9uLFxuKSB7XG4gIHJldHVybiBidWlsZFdzQmFzZUluc2lnaHQoY29ubmVjdGlvbik7XG59XG4iLCJpbXBvcnQgV2ViU29ja2V0IGZyb20gJ2lzb21vcnBoaWMtd3MnO1xuaW1wb3J0IHsgU3RyZWFtQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQnO1xuaW1wb3J0IHtcbiAgYnVpbGRXc0ZhdGFsSW5zaWdodCxcbiAgYnVpbGRXc1N1Y2Nlc3NBZnRlckZhaWx1cmVJbnNpZ2h0LFxuICBwb3N0SW5zaWdodHMsXG59IGZyb20gJy4vaW5zaWdodHMnO1xuaW1wb3J0IHtcbiAgYWRkQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzLFxuICBjb252ZXJ0RXJyb3JUb0pzb24sXG4gIEtub3duQ29kZXMsXG4gIHJhbmRvbUlkLFxuICByZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMsXG4gIHJldHJ5SW50ZXJ2YWwsXG4gIHNsZWVwLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB0eXBlIHtcbiAgQ29ubmVjdEFQSVJlc3BvbnNlLFxuICBMb2dMZXZlbCxcbiAgU3RyZWFtVmlkZW9FdmVudCxcbiAgVVIsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBDb25uZWN0ZWRFdmVudCxcbiAgV1NBdXRoTWVzc2FnZVJlcXVlc3QsXG59IGZyb20gJy4uLy4uL2dlbi9jb29yZGluYXRvcic7XG5cbi8vIFR5cGUgZ3VhcmRzIHRvIGNoZWNrIFdlYlNvY2tldCBlcnJvciB0eXBlXG5jb25zdCBpc0Nsb3NlRXZlbnQgPSAoXG4gIHJlczogV2ViU29ja2V0LkNsb3NlRXZlbnQgfCBXZWJTb2NrZXQuRGF0YSB8IFdlYlNvY2tldC5FcnJvckV2ZW50LFxuKTogcmVzIGlzIFdlYlNvY2tldC5DbG9zZUV2ZW50ID0+XG4gIChyZXMgYXMgV2ViU29ja2V0LkNsb3NlRXZlbnQpLmNvZGUgIT09IHVuZGVmaW5lZDtcblxuY29uc3QgaXNFcnJvckV2ZW50ID0gKFxuICByZXM6IFdlYlNvY2tldC5DbG9zZUV2ZW50IHwgV2ViU29ja2V0LkRhdGEgfCBXZWJTb2NrZXQuRXJyb3JFdmVudCxcbik6IHJlcyBpcyBXZWJTb2NrZXQuRXJyb3JFdmVudCA9PlxuICAocmVzIGFzIFdlYlNvY2tldC5FcnJvckV2ZW50KS5lcnJvciAhPT0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFN0YWJsZVdTQ29ubmVjdGlvbiAtIEEgV1MgY29ubmVjdGlvbiB0aGF0IHJlY29ubmVjdHMgdXBvbiBmYWlsdXJlLlxuICogLSB0aGUgYnJvd3NlciB3aWxsIHNvbWV0aW1lcyByZXBvcnQgdGhhdCB5b3UncmUgb25saW5lIG9yIG9mZmxpbmVcbiAqIC0gdGhlIFdTIGNvbm5lY3Rpb24gY2FuIGJyZWFrIGFuZCBmYWlsICh0aGVyZSBpcyBhIDMwcyBoZWFsdGggY2hlY2spXG4gKiAtIHNvbWV0aW1lcyB5b3VyIFdTIGNvbm5lY3Rpb24gd2lsbCBzZWVtIHRvIHdvcmsgd2hpbGUgdGhlIHVzZXIgaXMgaW4gZmFjdCBvZmZsaW5lXG4gKiAtIHRvIHNwZWVkIHVwIG9ubGluZS9vZmZsaW5lIGRldGVjdGlvbiB5b3UgY2FuIHVzZSB0aGUgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnKTtcbiAqXG4gKiBUaGVyZSBhcmUgNCB3YXlzIGluIHdoaWNoIGEgY29ubmVjdGlvbiBjYW4gYmVjb21lIHVuaGVhbHRoeTpcbiAqIC0gd2Vic29ja2V0Lm9uZXJyb3IgaXMgY2FsbGVkXG4gKiAtIHdlYnNvY2tldC5vbmNsb3NlIGlzIGNhbGxlZFxuICogLSB0aGUgaGVhbHRoIGNoZWNrIGZhaWxzIGFuZCBubyBldmVudCBpcyByZWNlaXZlZCBmb3IgfjQwIHNlY29uZHNcbiAqIC0gdGhlIGJyb3dzZXIgaW5kaWNhdGVzIHRoZSBjb25uZWN0aW9uIGlzIG5vdyBvZmZsaW5lXG4gKlxuICogVGhlcmUgYXJlIDIgYXNzdW1wdGlvbnMgd2UgbWFrZSBhYm91dCB0aGUgc2VydmVyOlxuICogLSBzdGF0ZSBjYW4gYmUgcmVjb3ZlcmVkIGJ5IHF1ZXJ5aW5nIHRoZSBjaGFubmVsIGFnYWluXG4gKiAtIGlmIHRoZSBzZXJ2ZXJzIGZhaWxzIHRvIHB1Ymxpc2ggYSBtZXNzYWdlIHRvIHRoZSBjbGllbnQsIHRoZSBXUyBjb25uZWN0aW9uIGlzIGRlc3Ryb3llZFxuICovXG5leHBvcnQgY2xhc3MgU3RhYmxlV1NDb25uZWN0aW9uIHtcbiAgLy8gbG9jYWwgdmFyc1xuICBjb25uZWN0aW9uSUQ/OiBzdHJpbmc7XG4gIGNvbm5lY3Rpb25PcGVuPzogQ29ubmVjdEFQSVJlc3BvbnNlO1xuICBhdXRoZW50aWNhdGlvblNlbnQ6IGJvb2xlYW47XG4gIGNvbnNlY3V0aXZlRmFpbHVyZXM6IG51bWJlcjtcbiAgcGluZ0ludGVydmFsOiBudW1iZXI7XG4gIGhlYWx0aENoZWNrVGltZW91dFJlZj86IE5vZGVKUy5UaW1lb3V0O1xuICBpc0Nvbm5lY3Rpbmc6IGJvb2xlYW47XG4gIGlzRGlzY29ubmVjdGVkOiBib29sZWFuO1xuICBpc0hlYWx0aHk6IGJvb2xlYW47XG4gIGlzUmVzb2x2ZWQ/OiBib29sZWFuO1xuICBsYXN0RXZlbnQ6IERhdGUgfCBudWxsO1xuICBjb25uZWN0aW9uQ2hlY2tUaW1lb3V0OiBudW1iZXI7XG4gIGNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWY/OiBOb2RlSlMuVGltZW91dDtcbiAgcmVqZWN0UHJvbWlzZT86IChcbiAgICByZWFzb24/OiBFcnJvciAmIHtcbiAgICAgIGNvZGU/OiBzdHJpbmcgfCBudW1iZXI7XG4gICAgICBpc1dTRmFpbHVyZT86IGJvb2xlYW47XG4gICAgICBTdGF0dXNDb2RlPzogc3RyaW5nIHwgbnVtYmVyO1xuICAgIH0sXG4gICkgPT4gdm9pZDtcbiAgcmVxdWVzdElEOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHJlc29sdmVQcm9taXNlPzogKHZhbHVlOiBDb25uZWN0ZWRFdmVudCkgPT4gdm9pZDtcbiAgdG90YWxGYWlsdXJlczogbnVtYmVyO1xuICB3cz86IFdlYlNvY2tldDtcbiAgd3NJRDogbnVtYmVyO1xuXG4gIGNsaWVudDogU3RyZWFtQ2xpZW50O1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogU3RyZWFtQ2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgLyoqIGNvbnNlY3V0aXZlIGZhaWx1cmVzIGluZmx1ZW5jZSB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWVvdXQgKi9cbiAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIC8qKiBrZWVwIHRyYWNrIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgZmFpbHVyZXMgKi9cbiAgICB0aGlzLnRvdGFsRmFpbHVyZXMgPSAwO1xuICAgIC8qKiBXZSBvbmx5IG1ha2UgMSBhdHRlbXB0IHRvIHJlY29ubmVjdCBhdCB0aGUgc2FtZSB0aW1lLi4gKi9cbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgIC8qKiBUcnVlIGFmdGVyIHRoZSBhdXRoIHBheWxvYWQgaXMgc2VudCB0byB0aGUgc2VydmVyICovXG4gICAgdGhpcy5hdXRoZW50aWNhdGlvblNlbnQgPSBmYWxzZTtcbiAgICAvKiogVG8gYXZvaWQgcmVjb25uZWN0IGlmIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKi9cbiAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqIEJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNvbm5lY3Rpb24gcHJvbWlzZSBpcyByZXNvbHZlZCAqL1xuICAgIHRoaXMuaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIC8qKiBCb29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHdlIGhhdmUgYSB3b3JraW5nIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciAqL1xuICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgLyoqIEluY3JlbWVudGVkIHdoZW4gYSBuZXcgV1MgY29ubmVjdGlvbiBpcyBtYWRlICovXG4gICAgdGhpcy53c0lEID0gMTtcbiAgICAvKiogU3RvcmUgdGhlIGxhc3QgZXZlbnQgdGltZSBmb3IgaGVhbHRoIGNoZWNrcyAqL1xuICAgIHRoaXMubGFzdEV2ZW50ID0gbnVsbDtcbiAgICAvKiogU2VuZCBhIGhlYWx0aCBjaGVjayBtZXNzYWdlIGV2ZXJ5IDI1IHNlY29uZHMgKi9cbiAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IDI1ICogMTAwMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXQgPSB0aGlzLnBpbmdJbnRlcnZhbCArIDEwICogMTAwMDtcblxuICAgIGFkZENvbm5lY3Rpb25FdmVudExpc3RlbmVycyh0aGlzLm9ubGluZVN0YXR1c0NoYW5nZWQpO1xuICB9XG5cbiAgX2xvZyA9IChtc2c6IHN0cmluZywgZXh0cmE6IFVSID0ge30sIGxldmVsOiBMb2dMZXZlbCA9ICdpbmZvJykgPT4ge1xuICAgIHRoaXMuY2xpZW50LmxvZ2dlcihsZXZlbCwgJ2Nvbm5lY3Rpb246JyArIG1zZywge1xuICAgICAgLi4uZXh0cmEsXG4gICAgfSk7XG4gIH07XG5cbiAgc2V0Q2xpZW50ID0gKGNsaWVudDogU3RyZWFtQ2xpZW50KSA9PiB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNvbm5lY3QgLSBDb25uZWN0IHRvIHRoZSBXUyBVUkxcbiAgICogdGhlIGRlZmF1bHQgMTVzIHRpbWVvdXQgYWxsb3dzIGJldHdlZW4gMn4zIHRyaWVzXG4gICAqIEByZXR1cm4ge0Nvbm5lY3RBUElSZXNwb25zZTxDb25uZWN0ZWRFdmVudD59IFByb21pc2UgdGhhdCBjb21wbGV0ZXMgb25jZSB0aGUgZmlyc3QgaGVhbHRoIGNoZWNrIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dCA9IDE1MDAwKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFlvdSd2ZSBjYWxsZWQgY29ubmVjdCB0d2ljZSwgY2FuIG9ubHkgYXR0ZW1wdCAxIGNvbm5lY3Rpb24gYXQgdGhlIHRpbWVgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhbHRoQ2hlY2sgPSBhd2FpdCB0aGlzLl9jb25uZWN0KCk7XG4gICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuXG4gICAgICB0aGlzLl9sb2coXG4gICAgICAgIGBjb25uZWN0KCkgLSBFc3RhYmxpc2hlZCB3cyBjb25uZWN0aW9uIHdpdGggaGVhbHRoY2hlY2s6ICR7aGVhbHRoQ2hlY2t9YCxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcblxuICAgICAgaWYgKFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVycm9yLmNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAhdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmlzU3RhdGljKClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9sb2coXG4gICAgICAgICAgJ2Nvbm5lY3QoKSAtIFdTIGZhaWx1cmUgZHVlIHRvIGV4cGlyZWQgdG9rZW4sIHNvIGdvaW5nIHRvIHRyeSB0byByZWxvYWQgdG9rZW4gYW5kIHJlY29ubmVjdCcsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdCh7IHJlZnJlc2hUb2tlbjogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFlcnJvci5pc1dTRmFpbHVyZSkge1xuICAgICAgICAgIC8vIEFQSSByZWplY3RlZCB0aGUgY29ubmVjdGlvbiBhbmQgd2Ugc2hvdWxkIG5vdCByZXRyeVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIFN0YXR1c0NvZGU6IGVycm9yLlN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBpc1dTRmFpbHVyZTogZXJyb3IuaXNXU0ZhaWx1cmUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhaXRGb3JIZWFsdGh5KHRpbWVvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIF93YWl0Rm9ySGVhbHRoeSBwb2xscyB0aGUgcHJvbWlzZSBjb25uZWN0aW9uIHRvIHNlZSBpZiBpdHMgcmVzb2x2ZWQgdW50aWwgaXQgdGltZXMgb3V0XG4gICAqIHRoZSBkZWZhdWx0IDE1cyB0aW1lb3V0IGFsbG93cyBiZXR3ZWVuIDJ+MyB0cmllc1xuICAgKiBAcGFyYW0gdGltZW91dCBkdXJhdGlvbihtcylcbiAgICovXG4gIGFzeW5jIF93YWl0Rm9ySGVhbHRoeSh0aW1lb3V0ID0gMTUwMDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gNTA7IC8vIG1zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRpbWVvdXQ7IGkgKz0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdGlvbk9wZW47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICBTdGF0dXNDb2RlOiBlcnJvci5TdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIGlzV1NGYWlsdXJlOiBlcnJvci5pc1dTRmFpbHVyZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKGludGVydmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKCksXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBzbGVlcCh0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGNvZGU6ICcnLFxuICAgICAgICAgICAgU3RhdHVzQ29kZTogJycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnaW5pdGlhbCBXUyBjb25uZWN0aW9uIGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCcsXG4gICAgICAgICAgICBpc1dTRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0pKCksXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuZCByZXR1cm5zIHRoZSB1cmwgZm9yIHdlYnNvY2tldC5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMgdXJsIHN0cmluZ1xuICAgKi9cbiAgX2J1aWxkVXJsID0gKCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAvLyBjb25zdCBxcyA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmNsaWVudC5fYnVpbGRXU1BheWxvYWQodGhpcy5yZXF1ZXN0SUQpKTtcbiAgICAvLyBwYXJhbXMuc2V0KCdqc29uJywgcXMpO1xuICAgIHBhcmFtcy5zZXQoJ2FwaV9rZXknLCB0aGlzLmNsaWVudC5rZXkpO1xuICAgIHBhcmFtcy5zZXQoJ3N0cmVhbS1hdXRoLXR5cGUnLCB0aGlzLmNsaWVudC5nZXRBdXRoVHlwZSgpKTtcbiAgICBwYXJhbXMuc2V0KCdYLVN0cmVhbS1DbGllbnQnLCB0aGlzLmNsaWVudC5nZXRVc2VyQWdlbnQoKSk7XG4gICAgLy8gcGFyYW1zLmFwcGVuZCgnYXV0aG9yaXphdGlvbicsIHRoaXMuY2xpZW50Ll9nZXRUb2tlbigpISk7XG5cbiAgICByZXR1cm4gYCR7dGhpcy5jbGllbnQud3NCYXNlVVJMfS9jb25uZWN0PyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgfTtcblxuICAvKipcbiAgICogZGlzY29ubmVjdCAtIERpc2Nvbm5lY3QgdGhlIGNvbm5lY3Rpb24gYW5kIGRvZXNuJ3QgcmVjb3Zlci4uLlxuICAgKlxuICAgKi9cbiAgZGlzY29ubmVjdCh0aW1lb3V0PzogbnVtYmVyKSB7XG4gICAgdGhpcy5fbG9nKFxuICAgICAgYGRpc2Nvbm5lY3QoKSAtIENsb3NpbmcgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGZvciB3c0lEICR7dGhpcy53c0lEfWAsXG4gICAgKTtcblxuICAgIHRoaXMud3NJRCArPSAxO1xuICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAvLyBzdGFydCBieSByZW1vdmluZyBhbGwgdGhlIGxpc3RlbmVyc1xuICAgIGlmICh0aGlzLmhlYWx0aENoZWNrVGltZW91dFJlZikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYWx0aENoZWNrVGltZW91dFJlZik7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWYpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICB9XG5cbiAgICByZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnModGhpcy5vbmxpbmVTdGF0dXNDaGFuZ2VkKTtcblxuICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG5cbiAgICAvLyByZW1vdmUgd3MgaGFuZGxlcnMuLi5cbiAgICBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlbW92ZUFsbExpc3RlbmVycykge1xuICAgICAgdGhpcy53cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNDbG9zZWRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICAgIC8vIGFuZCBmaW5hbGx5IGNsb3NlLi4uXG4gICAgLy8gQXNzaWduaW5nIHRvIGxvY2FsIGhlcmUgYmVjYXVzZSB3ZSB3aWxsIHJlbW92ZSBpdCBmcm9tIHRoaXMgYmVmb3JlIHRoZVxuICAgIC8vIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgY29uc3QgeyB3cyB9ID0gdGhpcztcbiAgICBpZiAod3MgJiYgd3MuY2xvc2UgJiYgd3MucmVhZHlTdGF0ZSA9PT0gd3MuT1BFTikge1xuICAgICAgaXNDbG9zZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgb25jbG9zZSA9IChldmVudDogV2ViU29ja2V0LkNsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLl9sb2coXG4gICAgICAgICAgICBgZGlzY29ubmVjdCgpIC0gcmVzb2x2aW5nIGlzQ2xvc2VkUHJvbWlzZSAke1xuICAgICAgICAgICAgICBldmVudCA/ICd3aXRoJyA6ICd3aXRob3V0J1xuICAgICAgICAgICAgfSBjbG9zZSBmcmFtZWAsXG4gICAgICAgICAgICB7IGV2ZW50IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd3Mub25jbG9zZSA9IG9uY2xvc2U7XG4gICAgICAgIC8vIEluIGNhc2Ugd2UgZG9uJ3QgcmVjZWl2ZSBjbG9zZSBmcmFtZSB3ZWJzb2NrZXQgc2VydmVyIGluIHRpbWUsXG4gICAgICAgIC8vIGxldHMgbm90IHdhaXQgZm9yIG1vcmUgdGhhbiAxIHNlY29uZC5cbiAgICAgICAgc2V0VGltZW91dChvbmNsb3NlLCB0aW1lb3V0ICE9IG51bGwgPyB0aW1lb3V0IDogMTAwMCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fbG9nKFxuICAgICAgICBgZGlzY29ubmVjdCgpIC0gTWFudWFsbHkgY2xvc2VkIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBjbGllbnQuZGlzY29ubmVjdCgpYCxcbiAgICAgICk7XG5cbiAgICAgIHdzLmNsb3NlKFxuICAgICAgICBLbm93bkNvZGVzLldTX0NMT1NFRF9TVUNDRVNTLFxuICAgICAgICAnTWFudWFsbHkgY2xvc2VkIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBjbGllbnQuZGlzY29ubmVjdCgpJyxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZyhcbiAgICAgICAgYGRpc2Nvbm5lY3QoKSAtIHdzIGNvbm5lY3Rpb24gZG9lc24ndCBleGlzdCBvciBpdCBpcyBhbHJlYWR5IGNsb3NlZC5gLFxuICAgICAgKTtcbiAgICAgIGlzQ2xvc2VkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLndzO1xuXG4gICAgcmV0dXJuIGlzQ2xvc2VkUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBfY29ubmVjdCAtIENvbm5lY3QgdG8gdGhlIFdTIGVuZHBvaW50XG4gICAqXG4gICAqIEByZXR1cm4ge0Nvbm5lY3RBUElSZXNwb25zZTxDb25uZWN0ZWRFdmVudD59IFByb21pc2UgdGhhdCBjb21wbGV0ZXMgb25jZSB0aGUgZmlyc3QgaGVhbHRoIGNoZWNrIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICovXG4gIGFzeW5jIF9jb25uZWN0KCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nIHx8XG4gICAgICAodGhpcy5pc0Rpc2Nvbm5lY3RlZCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2spXG4gICAgKVxuICAgICAgcmV0dXJuOyAvLyBzaW1wbHkgaWdub3JlIF9jb25uZWN0IGlmIGl0J3MgY3VycmVudGx5IHRyeWluZyB0byBjb25uZWN0XG4gICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHRoaXMucmVxdWVzdElEID0gcmFuZG9tSWQoKTtcbiAgICB0aGlzLmNsaWVudC5pbnNpZ2h0TWV0cmljcy5jb25uZWN0aW9uU3RhcnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBsZXQgaXNUb2tlblJlYWR5ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIHdhaXRpbmcgZm9yIHRva2VuYCk7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIudG9rZW5SZWFkeSgpO1xuICAgICAgaXNUb2tlblJlYWR5ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyB0b2tlbiBwcm92aWRlciBoYXMgZmFpbGVkIGJlZm9yZSwgc28gdHJ5IGFnYWluXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghaXNUb2tlblJlYWR5KSB7XG4gICAgICAgIHRoaXMuX2xvZyhcbiAgICAgICAgICBgX2Nvbm5lY3QoKSAtIHRva2VuUHJvdmlkZXIgZmFpbGVkIGJlZm9yZSwgc28gZ29pbmcgdG8gcmV0cnlgLFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIubG9hZFRva2VuKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvblByb21pc2UoKTtcbiAgICAgIGNvbnN0IHdzVVJMID0gdGhpcy5fYnVpbGRVcmwoKTtcbiAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIENvbm5lY3RpbmcgdG8gJHt3c1VSTH1gLCB7XG4gICAgICAgIHdzVVJMLFxuICAgICAgICByZXF1ZXN0SUQ6IHRoaXMucmVxdWVzdElELFxuICAgICAgfSk7XG4gICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh3c1VSTCk7XG4gICAgICB0aGlzLndzLm9ub3BlbiA9IHRoaXMub25vcGVuLmJpbmQodGhpcywgdGhpcy53c0lEKTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMub25jbG9zZS5iaW5kKHRoaXMsIHRoaXMud3NJRCk7XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IuYmluZCh0aGlzLCB0aGlzLndzSUQpO1xuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLm9ubWVzc2FnZS5iaW5kKHRoaXMsIHRoaXMud3NJRCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbk9wZW47XG4gICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uSUQgPSByZXNwb25zZS5jb25uZWN0aW9uX2lkO1xuICAgICAgICB0aGlzLmNsaWVudC5yZXNvbHZlQ29ubmVjdGlvbklkPy4odGhpcy5jb25uZWN0aW9uSUQpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzID4gMCAmJlxuICAgICAgICAgIHRoaXMuY2xpZW50Lm9wdGlvbnMuZW5hYmxlSW5zaWdodHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgcG9zdEluc2lnaHRzKFxuICAgICAgICAgICAgJ3dzX3N1Y2Nlc3NfYWZ0ZXJfZmFpbHVyZScsXG4gICAgICAgICAgICBidWlsZFdzU3VjY2Vzc0FmdGVyRmFpbHVyZUluc2lnaHQoXG4gICAgICAgICAgICAgIHRoaXMgYXMgdW5rbm93biBhcyBTdGFibGVXU0Nvbm5lY3Rpb24sXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5fbG9nKGBfY29ubmVjdCgpIC0gRXJyb3IgLSBgLCBlcnIpO1xuICAgICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuZW5hYmxlSW5zaWdodHMpIHtcbiAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzKys7XG4gICAgICAgIHRoaXMuY2xpZW50Lmluc2lnaHRNZXRyaWNzLndzVG90YWxGYWlsdXJlcysrO1xuXG4gICAgICAgIGNvbnN0IGluc2lnaHRzID0gYnVpbGRXc0ZhdGFsSW5zaWdodChcbiAgICAgICAgICB0aGlzIGFzIHVua25vd24gYXMgU3RhYmxlV1NDb25uZWN0aW9uLFxuICAgICAgICAgIGNvbnZlcnRFcnJvclRvSnNvbihlcnIgYXMgRXJyb3IpLFxuICAgICAgICApO1xuICAgICAgICBwb3N0SW5zaWdodHM/Lignd3NfZmF0YWwnLCBpbnNpZ2h0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsaWVudC5yZWplY3RDb25uZWN0aW9uSWQ/LigpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBfcmVjb25uZWN0IC0gUmV0cnkgdGhlIGNvbm5lY3Rpb24gdG8gV1MgZW5kcG9pbnRcbiAgICpcbiAgICogQHBhcmFtIHt7IGludGVydmFsPzogbnVtYmVyOyByZWZyZXNoVG9rZW4/OiBib29sZWFuIH19IG9wdGlvbnMgRm9sbG93aW5nIG9wdGlvbnMgYXJlIGF2YWlsYWJsZVxuICAgKlxuICAgKiAtIGBpbnRlcnZhbGBcdHtpbnR9XHRcdFx0bnVtYmVyIG9mIG1zIHRoYXQgZnVuY3Rpb24gc2hvdWxkIHdhaXQgYmVmb3JlIHJlY29ubmVjdGluZ1xuICAgKiAtIGByZWZyZXNoVG9rZW5gIHtib29sZWFufVx0cmVsb2FkL3JlZnJlc2ggdXNlciB0b2tlbiBiZSByZWZyZXNoZWQgYmVmb3JlIGF0dGVtcHRpbmcgcmVjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgX3JlY29ubmVjdChcbiAgICBvcHRpb25zOiB7IGludGVydmFsPzogbnVtYmVyOyByZWZyZXNoVG9rZW4/OiBib29sZWFuIH0gPSB7fSxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBJbml0aWF0aW5nIHRoZSByZWNvbm5lY3QnKTtcblxuICAgIC8vIG9ubHkgYWxsb3cgMSBjb25uZWN0aW9uIGF0IHRoZSB0aW1lXG4gICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nIHx8IHRoaXMuaXNIZWFsdGh5KSB7XG4gICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIEFib3J0ICgxKSBzaW5jZSBhbHJlYWR5IGNvbm5lY3Rpbmcgb3IgaGVhbHRoeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJlY29ubmVjdCBpbiBjYXNlIG9mIG9uIGVycm9yIG9yIG9uIGNsb3NlXG4gICAgLy8gYWxzbyByZWNvbm5lY3QgaWYgdGhlIGhlYWx0aCBjaGVjayBjeWNsZSBmYWlsc1xuICAgIGxldCBpbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgaW50ZXJ2YWwgPSByZXRyeUludGVydmFsKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyk7XG4gICAgfVxuICAgIC8vIHJlY29ubmVjdCwgb3IgdHJ5IGFnYWluIGFmdGVyIGEgbGl0dGxlIHdoaWxlLi4uXG4gICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuXG4gICAgLy8gQ2hlY2sgb25jZSBhZ2FpbiBpZiBieSBzb21lIG90aGVyIGNhbGwgdG8gX3JlY29ubmVjdCBpcyBhY3RpdmUgb3IgY29ubmVjdGlvbiBpc1xuICAgIC8vIGFscmVhZHkgcmVzdG9yZWQsIHRoZW4gbm8gbmVlZCB0byBwcm9jZWVkLlxuICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZyB8fCB0aGlzLmlzSGVhbHRoeSkge1xuICAgICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBBYm9ydCAoMikgc2luY2UgYWxyZWFkeSBjb25uZWN0aW5nIG9yIGhlYWx0aHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0Rpc2Nvbm5lY3RlZCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2spIHtcbiAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gQWJvcnQgKDMpIHNpbmNlIGRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIERlc3Ryb3lpbmcgY3VycmVudCBXUyBjb25uZWN0aW9uJyk7XG5cbiAgICAvLyBjbGVhbnVwIHRoZSBvbGQgY29ubmVjdGlvblxuICAgIHRoaXMuX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uKCk7XG5cbiAgICBpZiAob3B0aW9ucy5yZWZyZXNoVG9rZW4pIHtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnRva2VuTWFuYWdlci5sb2FkVG9rZW4oKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fY29ubmVjdCgpO1xuICAgICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBXYWl0aW5nIGZvciByZWNvdmVyQ2FsbEJhY2snKTtcbiAgICAgIC8vIGF3YWl0IHRoaXMuY2xpZW50LnJlY292ZXJTdGF0ZSgpO1xuICAgICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBGaW5pc2hlZCByZWNvdmVyQ2FsbEJhY2snKTtcblxuICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aGlzLmlzSGVhbHRoeSA9IGZhbHNlO1xuICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgICBpZiAoXG4gICAgICAgIGVycm9yLmNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAhdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmlzU3RhdGljKClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9sb2coXG4gICAgICAgICAgJ19yZWNvbm5lY3QoKSAtIFdTIGZhaWx1cmUgZHVlIHRvIGV4cGlyZWQgdG9rZW4sIHNvIGdvaW5nIHRvIHRyeSB0byByZWxvYWQgdG9rZW4gYW5kIHJlY29ubmVjdCcsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdCh7IHJlZnJlc2hUb2tlbjogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVjb25uZWN0IG9uIFdTIGZhaWx1cmVzLCBkb24ndCByZWNvbm5lY3QgaWYgdGhlcmUgaXMgYSBjb2RlIGJ1Z1xuICAgICAgaWYgKGVycm9yLmlzV1NGYWlsdXJlKSB7XG4gICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gV1MgZmFpbHVyZSwgc28gZ29pbmcgdG8gdHJ5IHRvIHJlY29ubmVjdCcpO1xuXG4gICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtID09IEVORCA9PScpO1xuICB9XG5cbiAgLyoqXG4gICAqIG9ubGluZVN0YXR1c0NoYW5nZWQgLSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyIGNvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzIGZyb20gdGhlIGludGVybmV0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCB3aXRoIHR5cGUgb25saW5lIG9yIG9mZmxpbmVcbiAgICpcbiAgICovXG4gIG9ubGluZVN0YXR1c0NoYW5nZWQgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdvZmZsaW5lJykge1xuICAgICAgLy8gbWFyayB0aGUgY29ubmVjdGlvbiBhcyBkb3duXG4gICAgICB0aGlzLl9sb2coJ29ubGluZVN0YXR1c0NoYW5nZWQoKSAtIFN0YXR1cyBjaGFuZ2luZyB0byBvZmZsaW5lJyk7XG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGFwcCBpcyBvZmZsaW5lIHNvIGRpc3BhdGNoIHRoZSB1bmhlYWx0aHkgY29ubmVjdGlvbiBldmVudCBpbW1lZGlhdGVseVxuICAgICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdvbmxpbmUnKSB7XG4gICAgICAvLyByZXRyeSByaWdodCBub3cuLi5cbiAgICAgIC8vIFdlIGNoZWNrIHRoaXMuaXNIZWFsdGh5LCBub3Qgc3VyZSBpZiBpdCdzIGFsd2F5c1xuICAgICAgLy8gc21hcnQgdG8gY3JlYXRlIGEgbmV3IFdTIGNvbm5lY3Rpb24gaWYgdGhlIG9sZCBvbmUgaXMgc3RpbGwgdXAgYW5kIHJ1bm5pbmcuXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHdlIGRpZG4ndCBtaXNzIGFueSBtZXNzYWdlcywgc28gdGhpcyBwcm9jZXNzIGlzIGp1c3QgZXhwZW5zaXZlIGFuZCBub3QgbmVlZGVkLlxuICAgICAgdGhpcy5fbG9nKFxuICAgICAgICBgb25saW5lU3RhdHVzQ2hhbmdlZCgpIC0gU3RhdHVzIGNoYW5naW5nIHRvIG9ubGluZS4gaXNIZWFsdGh5OiAke3RoaXMuaXNIZWFsdGh5fWAsXG4gICAgICApO1xuICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeSkge1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3QoeyBpbnRlcnZhbDogMTAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG9ub3BlbiA9ICh3c0lEOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy53c0lEICE9PSB3c0lEKSByZXR1cm47XG5cbiAgICBjb25zdCB1c2VyID0gdGhpcy5jbGllbnQudXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRoaXMuY2xpZW50LmxvZ2dlcignZXJyb3InLCBgVXNlciBub3Qgc2V0LCBjYW4ndCBjb25uZWN0IHRvIFdTYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmNsaWVudC5fZ2V0VG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aGlzLmNsaWVudC5sb2dnZXIoJ2Vycm9yJywgYFRva2VuIG5vdCBzZXQsIGNhbid0IGNvbm5lY3QgYXV0aGVudGljYXRlYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXV0aE1lc3NhZ2U6IFdTQXV0aE1lc3NhZ2VSZXF1ZXN0ID0ge1xuICAgICAgdG9rZW4sXG4gICAgICB1c2VyX2RldGFpbHM6IHtcbiAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgIG5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgaW1hZ2U6IHVzZXIuaW1hZ2UsXG4gICAgICAgIGN1c3RvbTogdXNlci5jdXN0b20sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0aGlzLmF1dGhlbnRpY2F0aW9uU2VudCA9IHRydWU7XG4gICAgdGhpcy53cz8uc2VuZChKU09OLnN0cmluZ2lmeShhdXRoTWVzc2FnZSkpO1xuICAgIHRoaXMuX2xvZygnb25vcGVuKCkgLSBvbm9wZW4gY2FsbGJhY2snLCB7IHdzSUQgfSk7XG4gIH07XG5cbiAgb25tZXNzYWdlID0gKHdzSUQ6IG51bWJlciwgZXZlbnQ6IFdlYlNvY2tldC5NZXNzYWdlRXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy53c0lEICE9PSB3c0lEKSByZXR1cm47XG5cbiAgICB0aGlzLl9sb2coJ29ubWVzc2FnZSgpIC0gb25tZXNzYWdlIGNhbGxiYWNrJywgeyBldmVudCwgd3NJRCB9KTtcbiAgICBjb25zdCBkYXRhID1cbiAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJ1xuICAgICAgICA/IChKU09OLnBhcnNlKGV2ZW50LmRhdGEpIGFzIFN0cmVhbVZpZGVvRXZlbnQpXG4gICAgICAgIDogbnVsbDtcblxuICAgIC8vIHdlIHdhaXQgdGlsbCB0aGUgZmlyc3QgbWVzc2FnZSBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gb3Blbi5cbiAgICAvLyB0aGUgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgYXV0aCBlcnJvcnMgYW5kIHNpbWlsYXIgZXJyb3JzIHRyaWdnZXIgYSB3cy5vbm9wZW4gYW5kIGltbWVkaWF0ZWx5XG4gICAgLy8gYWZ0ZXIgdGhhdCBhIHdzLm9uY2xvc2UuXG4gICAgaWYgKCF0aGlzLmlzUmVzb2x2ZWQgJiYgZGF0YSAmJiBkYXRhLnR5cGUgPT09ICdjb25uZWN0aW9uLmVycm9yJykge1xuICAgICAgdGhpcy5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGUgdHlwZXMgb2YgX2Vycm9yRnJvbVdTRXZlbnQgYXJlIGluY29ycmVjdFxuICAgICAgICB0aGlzLnJlamVjdFByb21pc2U/Lih0aGlzLl9lcnJvckZyb21XU0V2ZW50KGRhdGEsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSBldmVudC4uXG4gICAgdGhpcy5sYXN0RXZlbnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKFxuICAgICAgZGF0YSAmJlxuICAgICAgKGRhdGEudHlwZSA9PT0gJ2hlYWx0aC5jaGVjaycgfHwgZGF0YS50eXBlID09PSAnY29ubmVjdGlvbi5vaycpXG4gICAgKSB7XG4gICAgICAvLyB0aGUgaW5pdGlhbCBoZWFsdGgtY2hlY2sgc2hvdWxkIGNvbWUgZnJvbSB0aGUgY2xpZW50XG4gICAgICB0aGlzLnNjaGVkdWxlTmV4dFBpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09ICdjb25uZWN0aW9uLm9rJykge1xuICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZT8uKGRhdGEpO1xuICAgICAgdGhpcy5fc2V0SGVhbHRoKHRydWUpO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIGRhdGEudHlwZSA9PT0gJ2Nvbm5lY3Rpb24uZXJyb3InICYmIGRhdGEuZXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSB9ID0gZGF0YS5lcnJvcjtcbiAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgICBpZiAoXG4gICAgICAgIGNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAhdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmlzU3RhdGljKClcbiAgICAgICkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICAgICAgdGhpcy5fbG9nKFxuICAgICAgICAgICdjb25uZWN0KCkgLSBXUyBmYWlsdXJlIGR1ZSB0byBleHBpcmVkIHRva2VuLCBzbyBnb2luZyB0byB0cnkgdG8gcmVsb2FkIHRva2VuIGFuZCByZWNvbm5lY3QnLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3QoeyByZWZyZXNoVG9rZW46IHRydWUgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2soKTtcbiAgfTtcblxuICBvbmNsb3NlID0gKHdzSUQ6IG51bWJlciwgZXZlbnQ6IFdlYlNvY2tldC5DbG9zZUV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMud3NJRCAhPT0gd3NJRCkgcmV0dXJuO1xuXG4gICAgdGhpcy5fbG9nKCdvbmNsb3NlKCkgLSBvbmNsb3NlIGNhbGxiYWNrIC0gJyArIGV2ZW50LmNvZGUsIHsgZXZlbnQsIHdzSUQgfSk7XG5cbiAgICBpZiAoZXZlbnQuY29kZSA9PT0gS25vd25Db2Rlcy5XU19DTE9TRURfU1VDQ0VTUykge1xuICAgICAgLy8gdGhpcyBpcyBhIHBlcm1hbmVudCBlcnJvciByYWlzZWQgYnkgc3RyZWFtLi5cbiAgICAgIC8vIHVzdWFsbHkgY2F1c2VkIGJ5IGludmFsaWQgYXV0aCBkZXRhaWxzXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYFdTIGNvbm5lY3Rpb24gcmVqZWN0IHdpdGggZXJyb3IgJHtldmVudC5yZWFzb259YCxcbiAgICAgICkgYXMgRXJyb3IgJiBXZWJTb2NrZXQuQ2xvc2VFdmVudDtcblxuICAgICAgZXJyb3IucmVhc29uID0gZXZlbnQucmVhc29uO1xuICAgICAgZXJyb3IuY29kZSA9IGV2ZW50LmNvZGU7XG4gICAgICBlcnJvci53YXNDbGVhbiA9IGV2ZW50Lndhc0NsZWFuO1xuICAgICAgZXJyb3IudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICB0aGlzLnJlamVjdFByb21pc2U/LihlcnJvcik7XG4gICAgICB0aGlzLl9sb2coYG9uY2xvc2UoKSAtIFdTIGNvbm5lY3Rpb24gcmVqZWN0IHdpdGggZXJyb3IgJHtldmVudC5yZWFzb259YCwge1xuICAgICAgICBldmVudCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgIHRoaXMudG90YWxGYWlsdXJlcyArPSAxO1xuICAgICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlKTtcbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucmVqZWN0UHJvbWlzZT8uKHRoaXMuX2Vycm9yRnJvbVdTRXZlbnQoZXZlbnQpKTtcblxuICAgICAgdGhpcy5fbG9nKGBvbmNsb3NlKCkgLSBXUyBjb25uZWN0aW9uIGNsb3NlZC4gQ2FsbGluZyByZWNvbm5lY3QgLi4uYCwge1xuICAgICAgICBldmVudCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZWNvbm5lY3QgaWYgaXRzIGFuIGFibm9ybWFsIGZhaWx1cmVcbiAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcblxuICBvbmVycm9yID0gKHdzSUQ6IG51bWJlciwgZXZlbnQ6IFdlYlNvY2tldC5FcnJvckV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMud3NJRCAhPT0gd3NJRCkgcmV0dXJuO1xuXG4gICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgdGhpcy50b3RhbEZhaWx1cmVzICs9IDE7XG4gICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlKTtcbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucmVqZWN0UHJvbWlzZT8uKHRoaXMuX2Vycm9yRnJvbVdTRXZlbnQoZXZlbnQpKTtcbiAgICB0aGlzLl9sb2coYG9uZXJyb3IoKSAtIFdTIGNvbm5lY3Rpb24gcmVzdWx0ZWQgaW50byBlcnJvcmAsIHsgZXZlbnQgfSk7XG5cbiAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogX3NldEhlYWx0aCAtIFNldHMgdGhlIGNvbm5lY3Rpb24gdG8gaGVhbHRoeSBvciB1bmhlYWx0aHkuXG4gICAqIEJyb2FkY2FzdHMgYW4gZXZlbnQgaW4gY2FzZSB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBoZWFsdGh5IGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29ubmVjdGlvbiBpcyBoZWFsdGh5IG9yIG5vdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc3BhdGNoSW1tZWRpYXRlbHkgYm9vbGVhbiBpbmRpY2F0aW5nIHRvIGRpc3BhdGNoIGV2ZW50IGltbWVkaWF0ZWx5IGV2ZW4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgdW5oZWFsdGh5XG4gICAqXG4gICAqL1xuICBfc2V0SGVhbHRoID0gKGhlYWx0aHk6IGJvb2xlYW4sIGRpc3BhdGNoSW1tZWRpYXRlbHkgPSBmYWxzZSkgPT4ge1xuICAgIGlmIChoZWFsdGh5ID09PSB0aGlzLmlzSGVhbHRoeSkgcmV0dXJuO1xuXG4gICAgdGhpcy5pc0hlYWx0aHkgPSBoZWFsdGh5O1xuXG4gICAgaWYgKHRoaXMuaXNIZWFsdGh5IHx8IGRpc3BhdGNoSW1tZWRpYXRlbHkpIHtcbiAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi5jaGFuZ2VkJyxcbiAgICAgICAgb25saW5lOiB0aGlzLmlzSGVhbHRoeSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdlJ3JlIG9mZmxpbmUsIHdhaXQgZmV3IHNlY29uZHMgYW5kIGZpcmUgYW5kIGV2ZW50IGlmIHN0aWxsIG9mZmxpbmVcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSGVhbHRoeSkgcmV0dXJuO1xuICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLmNoYW5nZWQnLFxuICAgICAgICBvbmxpbmU6IHRoaXMuaXNIZWFsdGh5LFxuICAgICAgfSk7XG4gICAgfSwgNTAwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9lcnJvckZyb21XU0V2ZW50IC0gQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgZm9yIHRoZSBXUyBldmVudFxuICAgKlxuICAgKi9cbiAgX2Vycm9yRnJvbVdTRXZlbnQgPSAoXG4gICAgZXZlbnQ6IFdlYlNvY2tldC5DbG9zZUV2ZW50IHwgV2ViU29ja2V0LkRhdGEgfCBXZWJTb2NrZXQuRXJyb3JFdmVudCxcbiAgICBpc1dTRmFpbHVyZSA9IHRydWUsXG4gICkgPT4ge1xuICAgIGxldCBjb2RlO1xuICAgIGxldCBzdGF0dXNDb2RlO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGlmIChpc0Nsb3NlRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb2RlID0gZXZlbnQuY29kZTtcbiAgICAgIHN0YXR1c0NvZGUgPSAndW5rbm93bic7XG4gICAgICBtZXNzYWdlID0gZXZlbnQucmVhc29uO1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb2RlID0gZXZlbnQuZXJyb3IuY29kZTtcbiAgICAgIHN0YXR1c0NvZGUgPSBldmVudC5lcnJvci5TdGF0dXNDb2RlO1xuICAgICAgbWVzc2FnZSA9IGV2ZW50LmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLy8gS2VlcGluZyB0aGlzIGB3YXJuYCBsZXZlbCBsb2csIHRvIGF2b2lkIGNsdXR0ZXJpbmcgb2YgZXJyb3IgbG9ncyBmcm9tIHdzIGZhaWx1cmVzLlxuICAgIHRoaXMuX2xvZyhcbiAgICAgIGBfZXJyb3JGcm9tV1NFdmVudCgpIC0gV1MgZmFpbGVkIHdpdGggY29kZSAke2NvZGV9YCxcbiAgICAgIHsgZXZlbnQgfSxcbiAgICAgICd3YXJuJyxcbiAgICApO1xuXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICBgV1MgZmFpbGVkIHdpdGggY29kZSAke2NvZGV9IGFuZCByZWFzb24gLSAke21lc3NhZ2V9YCxcbiAgICApIGFzIEVycm9yICYge1xuICAgICAgY29kZT86IHN0cmluZyB8IG51bWJlcjtcbiAgICAgIGlzV1NGYWlsdXJlPzogYm9vbGVhbjtcbiAgICAgIFN0YXR1c0NvZGU/OiBzdHJpbmcgfCBudW1iZXI7XG4gICAgfTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAvKipcbiAgICAgKiBTdGF0dXNDb2RlIGRvZXMgbm90IGV4aXN0IG9uIGFueSBldmVudCB0eXBlcyBidXQgaGFzIGJlZW4gbGVmdFxuICAgICAqIGFzIGlzIHRvIHByZXNlcnZlIEpTIGZ1bmN0aW9uYWxpdHkgZHVyaW5nIHRoZSBUUyBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGVycm9yLlN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIGVycm9yLmlzV1NGYWlsdXJlID0gaXNXU0ZhaWx1cmU7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfZGVzdHJveUN1cnJlbnRXU0Nvbm5lY3Rpb24gLSBSZW1vdmVzIHRoZSBjdXJyZW50IFdTIGNvbm5lY3Rpb25cbiAgICpcbiAgICovXG4gIF9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbigpIHtcbiAgICAvLyBpbmNyZW1lbnQgdGhlIElELCBtZWFuaW5nIHdlIHdpbGwgaWdub3JlIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSBvbGRcbiAgICAvLyB3cyBjb25uZWN0aW9uIGZyb20gbm93IG9uLlxuICAgIHRoaXMud3NJRCArPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXM/LndzPy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXM/LndzPy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHdlIGRvbid0IGNhcmVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogX3NldHVwUHJvbWlzZSAtIHNldHMgdXAgdGhlIHRoaXMuY29ubmVjdE9wZW4gcHJvbWlzZVxuICAgKi9cbiAgX3NldHVwQ29ubmVjdGlvblByb21pc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5pc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgLyoqIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIG9uY2Ugd3Mub3BlbiBpcyBjYWxsZWQgKi9cbiAgICB0aGlzLmNvbm5lY3Rpb25PcGVuID0gbmV3IFByb21pc2U8Q29ubmVjdGVkRXZlbnQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgdGhpcy5yZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBuZXh0IGhlYWx0aCBjaGVjayBwaW5nIGZvciB3ZWJzb2NrZXQuXG4gICAqL1xuICBzY2hlZHVsZU5leHRQaW5nID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmhlYWx0aENoZWNrVGltZW91dFJlZikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICB9XG5cbiAgICAvLyAzMCBzZWNvbmRzIGlzIHRoZSByZWNvbW1lbmRlZCBpbnRlcnZhbCAobWVzc2VuZ2VyIHVzZXMgdGhpcylcbiAgICB0aGlzLmhlYWx0aENoZWNrVGltZW91dFJlZiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gc2VuZCB0aGUgaGVhbHRoY2hlY2suLi4sIHNlcnZlciByZXBsaWVzIHdpdGggYSBoZWFsdGggY2hlY2sgZXZlbnRcbiAgICAgIGNvbnN0IGRhdGEgPSBbeyB0eXBlOiAnaGVhbHRoLmNoZWNrJywgY2xpZW50X2lkOiB0aGlzLmNsaWVudC5jbGllbnRJRCB9XTtcbiAgICAgIC8vIHRyeSB0byBzZW5kIG9uIHRoZSBjb25uZWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndzPy5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZXJyb3Igd2lsbCBhbHJlYWR5IGJlIGRldGVjdGVkIGVsc2V3aGVyZVxuICAgICAgfVxuICAgIH0sIHRoaXMucGluZ0ludGVydmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2sgLSBzY2hlZHVsZXMgYSBjaGVjayBmb3IgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gbGFzdCByZWNlaXZlZCBldmVudCBhbmQgbm93LlxuICAgKiBJZiB0aGUgZGlmZmVyZW5jZSBpcyBtb3JlIHRoYW4gMzUgc2Vjb25kcywgaXQgbWVhbnMgb3VyIGhlYWx0aCBjaGVjayBsb2dpYyBoYXMgZmFpbGVkIGFuZCB3ZWJzb2NrZXQgbmVlZHNcbiAgICogdG8gYmUgcmVjb25uZWN0ZWQuXG4gICAqL1xuICBzY2hlZHVsZUNvbm5lY3Rpb25DaGVjayA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubGFzdEV2ZW50ICYmXG4gICAgICAgIG5vdy5nZXRUaW1lKCkgLSB0aGlzLmxhc3RFdmVudC5nZXRUaW1lKCkgPiB0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9sb2coJ3NjaGVkdWxlQ29ubmVjdGlvbkNoZWNrIC0gZ29pbmcgdG8gcmVjb25uZWN0Jyk7XG4gICAgICAgIHRoaXMuX3NldEhlYWx0aChmYWxzZSk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCk7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBmcm9tQnl0ZUFycmF5IH0gZnJvbSAnYmFzZTY0LWpzJztcblxuZnVuY3Rpb24gaXNTdHJpbmc8VD4oYXJyYXlPclN0cmluZzogc3RyaW5nIHwgVFtdKTogYXJyYXlPclN0cmluZyBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIChhcnJheU9yU3RyaW5nIGFzIHN0cmluZykgPT09ICdzdHJpbmcnO1xufVxuXG50eXBlIE1hcEdlbmVyaWNDYWxsYmFjazxULCBVPiA9ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgYXJyYXk6IFRbXSkgPT4gVTtcbnR5cGUgTWFwU3RyaW5nQ2FsbGJhY2s8VT4gPSAodmFsdWU6IHN0cmluZywgaW5kZXg6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcpID0+IFU7XG5cbmZ1bmN0aW9uIGlzTWFwU3RyaW5nQ2FsbGJhY2s8VCwgVT4oXG4gIGFycmF5T3JTdHJpbmc6IHN0cmluZyB8IFRbXSxcbiAgY2FsbGJhY2s6IE1hcEdlbmVyaWNDYWxsYmFjazxULCBVPiB8IE1hcFN0cmluZ0NhbGxiYWNrPFU+LFxuKTogY2FsbGJhY2sgaXMgTWFwU3RyaW5nQ2FsbGJhY2s8VT4ge1xuICByZXR1cm4gISFjYWxsYmFjayAmJiBpc1N0cmluZyhhcnJheU9yU3RyaW5nKTtcbn1cblxuLy8gc291cmNlIC0gaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2Jsb2IvbWFzdGVyL3Rlc3QvY29udmVydC5qcyNMNzJcbmZ1bmN0aW9uIG1hcDxULCBVPihhcnJheTogVFtdLCBjYWxsYmFjazogTWFwR2VuZXJpY0NhbGxiYWNrPFQsIFU+KTogVVtdO1xuZnVuY3Rpb24gbWFwPFU+KHN0cmluZzogc3RyaW5nLCBjYWxsYmFjazogTWFwU3RyaW5nQ2FsbGJhY2s8VT4pOiBVW107XG5mdW5jdGlvbiBtYXA8VCwgVT4oXG4gIGFycmF5T3JTdHJpbmc6IHN0cmluZyB8IFRbXSxcbiAgY2FsbGJhY2s6IE1hcEdlbmVyaWNDYWxsYmFjazxULCBVPiB8IE1hcFN0cmluZ0NhbGxiYWNrPFU+LFxuKTogVVtdIHtcbiAgY29uc3QgcmVzID0gW107XG5cbiAgaWYgKGlzU3RyaW5nKGFycmF5T3JTdHJpbmcpICYmIGlzTWFwU3RyaW5nQ2FsbGJhY2soYXJyYXlPclN0cmluZywgY2FsbGJhY2spKSB7XG4gICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGFycmF5T3JTdHJpbmcubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIGlmIChhcnJheU9yU3RyaW5nLmNoYXJBdChrKSkge1xuICAgICAgICBjb25zdCBrVmFsdWUgPSBhcnJheU9yU3RyaW5nLmNoYXJBdChrKTtcbiAgICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSBjYWxsYmFjayhrVmFsdWUsIGssIGFycmF5T3JTdHJpbmcpO1xuICAgICAgICByZXNba10gPSBtYXBwZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgIWlzU3RyaW5nKGFycmF5T3JTdHJpbmcpICYmXG4gICAgIWlzTWFwU3RyaW5nQ2FsbGJhY2soYXJyYXlPclN0cmluZywgY2FsbGJhY2spXG4gICkge1xuICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBhcnJheU9yU3RyaW5nLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICBpZiAoayBpbiBhcnJheU9yU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGtWYWx1ZSA9IGFycmF5T3JTdHJpbmdba107XG4gICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gY2FsbGJhY2soa1ZhbHVlLCBrLCBhcnJheU9yU3RyaW5nKTtcbiAgICAgICAgcmVzW2tdID0gbWFwcGVkVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGNvbnN0IGVuY29kZUJhc2U2NCA9IChkYXRhOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShtYXAoZGF0YSwgKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpKTtcblxuLy8gYmFzZS02NCBkZWNvZGVyIHRocm93cyBleGNlcHRpb24gaWYgZW5jb2RlZCBzdHJpbmcgaXMgbm90IHBhZGRlZCBieSAnPScgdG8gbWFrZSBzdHJpbmcgbGVuZ3RoXG4vLyBpbiBtdWx0aXBsZXMgb2YgNC4gU28gZ29ubmEgdXNlIG91ciBvd24gbWV0aG9kIGZvciB0aGlzIHB1cnBvc2UgdG8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyNlxuZXhwb3J0IGNvbnN0IGRlY29kZUJhc2U2NCA9IChzOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBlID0ge30gYXMgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSxcbiAgICB3ID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcbiAgICBMID0gcy5sZW5ndGg7XG4gIGxldCBpLFxuICAgIGIgPSAwLFxuICAgIGMsXG4gICAgeCxcbiAgICBsID0gMCxcbiAgICBhLFxuICAgIHIgPSAnJztcbiAgY29uc3QgQSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICBlW0EuY2hhckF0KGkpXSA9IGk7XG4gIH1cbiAgZm9yICh4ID0gMDsgeCA8IEw7IHgrKykge1xuICAgIGMgPSBlW3MuY2hhckF0KHgpXTtcbiAgICBiID0gKGIgPDwgNikgKyBjO1xuICAgIGwgKz0gNjtcbiAgICB3aGlsZSAobCA+PSA4KSB7XG4gICAgICAoKGEgPSAoYiA+Pj4gKGwgLT0gOCkpICYgMHhmZikgfHwgeCA8IEwgLSAyKSAmJiAociArPSB3KGEpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuIiwiaW1wb3J0IHsgZGVjb2RlQmFzZTY0LCBlbmNvZGVCYXNlNjQgfSBmcm9tICcuL2Jhc2U2NCc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgdGhlIGlkIG9mIHRoZSB1c2VyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBEZXZUb2tlbih1c2VySWQ6IHN0cmluZykge1xuICByZXR1cm4gW1xuICAgICdleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjknLCAvL3tcImFsZ1wiOiBcIkhTMjU2XCIsIFwidHlwXCI6IFwiSldUXCJ9XG4gICAgZW5jb2RlQmFzZTY0KEpTT04uc3RyaW5naWZ5KHsgdXNlcl9pZDogdXNlcklkIH0pKSxcbiAgICAnZGV2dG9rZW4nLCAvLyBoYXJkY29kZWQgc2lnbmF0dXJlXG4gIF0uam9pbignLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVXNlckZyb21Ub2tlbih0b2tlbjogc3RyaW5nKSB7XG4gIGNvbnN0IGZyYWdtZW50cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gIGlmIChmcmFnbWVudHMubGVuZ3RoICE9PSAzKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGI2NFBheWxvYWQgPSBmcmFnbWVudHNbMV07XG4gIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVCYXNlNjQoYjY0UGF5bG9hZCk7XG4gIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHBheWxvYWQpO1xuICByZXR1cm4gZGF0YS51c2VyX2lkIGFzIHN0cmluZztcbn1cbiIsImltcG9ydCB7IFVzZXJGcm9tVG9rZW4gfSBmcm9tICcuL3NpZ25pbmcnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBUb2tlbk9yUHJvdmlkZXIsIFVzZXJXaXRoSWQgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBUb2tlbk1hbmFnZXJcbiAqXG4gKiBIYW5kbGVzIGFsbCB0aGUgb3BlcmF0aW9ucyBhcm91bmQgdXNlciB0b2tlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuTWFuYWdlciB7XG4gIGxvYWRUb2tlblByb21pc2U6IFByb21pc2U8c3RyaW5nPiB8IG51bGw7XG4gIHR5cGU6ICdzdGF0aWMnIHwgJ3Byb3ZpZGVyJztcbiAgc2VjcmV0Pzogc3RyaW5nO1xuICB0b2tlbj86IHN0cmluZztcbiAgdG9rZW5Qcm92aWRlcj86IFRva2VuT3JQcm92aWRlcjtcbiAgdXNlcj86IFVzZXJXaXRoSWQ7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge1NlY3JldH0gc2VjcmV0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZWNyZXQ/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvYWRUb2tlblByb21pc2UgPSBudWxsO1xuICAgIGlmIChzZWNyZXQpIHtcbiAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdzdGF0aWMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGljIHN0cmluZyB0b2tlbiBvciB0b2tlbiBwcm92aWRlci5cbiAgICogVG9rZW4gcHJvdmlkZXIgc2hvdWxkIHJldHVybiBhIHRva2VuIHN0cmluZyBvciBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gc3RyaW5nIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge1Rva2VuT3JQcm92aWRlcn0gdG9rZW5PclByb3ZpZGVyIC0gdGhlIHRva2VuIG9yIHRva2VuIHByb3ZpZGVyLlxuICAgKiBAcGFyYW0ge1VzZXJSZXNwb25zZX0gdXNlciAtIHRoZSB1c2VyIG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0Fub255bW91cyAtIHdoZXRoZXIgdGhlIHVzZXIgaXMgYW5vbnltb3VzIG9yIG5vdC5cbiAgICovXG4gIHNldFRva2VuT3JQcm92aWRlciA9IGFzeW5jIChcbiAgICB0b2tlbk9yUHJvdmlkZXI6IFRva2VuT3JQcm92aWRlcixcbiAgICB1c2VyOiBVc2VyV2l0aElkLFxuICAgIGlzQW5vbnltb3VzOiBib29sZWFuLFxuICApID0+IHtcbiAgICB0aGlzLnZhbGlkYXRlVG9rZW4odG9rZW5PclByb3ZpZGVyLCB1c2VyLCBpc0Fub255bW91cyk7XG4gICAgdGhpcy51c2VyID0gdXNlcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRva2VuT3JQcm92aWRlcikpIHtcbiAgICAgIHRoaXMudG9rZW5Qcm92aWRlciA9IHRva2VuT3JQcm92aWRlcjtcbiAgICAgIHRoaXMudHlwZSA9ICdwcm92aWRlcic7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbk9yUHJvdmlkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW5PclByb3ZpZGVyO1xuICAgICAgdGhpcy50eXBlID0gJ3N0YXRpYyc7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5sb2FkVG9rZW4oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSB0b2tlbiBtYW5hZ2VyLlxuICAgKiBVc2VmdWwgZm9yIGNsaWVudCBkaXNjb25uZWN0aW9uIG9yIHN3aXRjaGluZyB1c2VyLlxuICAgKi9cbiAgcmVzZXQgPSAoKSA9PiB7XG4gICAgdGhpcy50b2tlbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkVG9rZW5Qcm9taXNlID0gbnVsbDtcbiAgfTtcblxuICAvLyBWYWxpZGF0ZXMgdGhlIHVzZXIgdG9rZW4uXG4gIHZhbGlkYXRlVG9rZW4gPSAoXG4gICAgdG9rZW5PclByb3ZpZGVyOiBUb2tlbk9yUHJvdmlkZXIsXG4gICAgdXNlcjogVXNlcldpdGhJZCxcbiAgICBpc0Fub255bW91czogYm9vbGVhbixcbiAgKSA9PiB7XG4gICAgLy8gYWxsb3cgZW1wdHkgdG9rZW4gZm9yIGFub24gdXNlclxuICAgIGlmICh1c2VyICYmIGlzQW5vbnltb3VzICYmICF0b2tlbk9yUHJvdmlkZXIpIHJldHVybjtcblxuICAgIC8vIERvbid0IGFsbG93IGVtcHR5IHRva2VuIGZvciBub24tc2VydmVyIHNpZGUgY2xpZW50LlxuICAgIGlmICghdGhpcy5zZWNyZXQgJiYgIXRva2VuT3JQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyV2l0aElkIHRva2VuIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0b2tlbk9yUHJvdmlkZXIgJiZcbiAgICAgIHR5cGVvZiB0b2tlbk9yUHJvdmlkZXIgIT09ICdzdHJpbmcnICYmXG4gICAgICAhaXNGdW5jdGlvbih0b2tlbk9yUHJvdmlkZXIpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIgdG9rZW4gc2hvdWxkIGVpdGhlciBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbk9yUHJvdmlkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBBbGxvdyBlbXB0eSB0b2tlbiBmb3IgYW5vbnltb3VzIHVzZXJzXG4gICAgICBpZiAoaXNBbm9ueW1vdXMgJiYgdG9rZW5PclByb3ZpZGVyID09PSAnJykgcmV0dXJuO1xuXG4gICAgICBjb25zdCB0b2tlblVzZXJJZCA9IFVzZXJGcm9tVG9rZW4odG9rZW5PclByb3ZpZGVyKTtcbiAgICAgIGlmIChcbiAgICAgICAgdG9rZW5PclByb3ZpZGVyICE9IG51bGwgJiZcbiAgICAgICAgKHRva2VuVXNlcklkID09IG51bGwgfHxcbiAgICAgICAgICB0b2tlblVzZXJJZCA9PT0gJycgfHxcbiAgICAgICAgICAoIWlzQW5vbnltb3VzICYmIHRva2VuVXNlcklkICE9PSB1c2VyLmlkKSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ3VzZXJUb2tlbiBkb2VzIG5vdCBoYXZlIGEgdXNlcl9pZCBvciBpcyBub3QgbWF0Y2hpbmcgd2l0aCB1c2VyLmlkJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmVzb2x2ZXMgd2hlbiB0b2tlbiBpcyByZWFkeS4gVGhpcyBmdW5jdGlvbiBpcyBzaW1wbHkgdG8gY2hlY2sgaWYgbG9hZFRva2VuIGlzIGluIHByb2dyZXNzLCBpbiB3aGljaFxuICAvLyBjYXNlIGEgZnVuY3Rpb24gc2hvdWxkIHdhaXQuXG4gIHRva2VuUmVhZHkgPSAoKSA9PiB0aGlzLmxvYWRUb2tlblByb21pc2U7XG5cbiAgLy8gRmV0Y2hlcyBhIHRva2VuIGZyb20gdG9rZW5Qcm92aWRlciBmdW5jdGlvbiBhbmQgc2V0cyBpbiB0b2tlbk1hbmFnZXIuXG4gIC8vIEluIGNhc2Ugb2Ygc3RhdGljIHRva2VuLCBpdCB3aWxsIHNpbXBseSByZXNvbHZlIHRvIHN0YXRpYyB0b2tlbi5cbiAgbG9hZFRva2VuID0gKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgdGhpcy5sb2FkVG9rZW5Qcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcy50b2tlbiBhcyBzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50b2tlblByb3ZpZGVyICYmIHR5cGVvZiB0aGlzLnRva2VuUHJvdmlkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy50b2tlbiA9IGF3YWl0IHRoaXMudG9rZW5Qcm92aWRlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihgQ2FsbCB0byB0b2tlblByb3ZpZGVyIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZX1gKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUodGhpcy50b2tlbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5sb2FkVG9rZW5Qcm9taXNlO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBjdXJyZW50IHRva2VuXG4gIGdldFRva2VuID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VyICYmICF0aGlzLnRva2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbjtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQm90aCBzZWNyZXQgYW5kIHVzZXIgdG9rZW5zIGFyZSBub3Qgc2V0LiBFaXRoZXIgY2xpZW50LmNvbm5lY3RVc2VyIHdhc24ndCBjYWxsZWQgb3IgY2xpZW50LmRpc2Nvbm5lY3Qgd2FzIGNhbGxlZGAsXG4gICAgKTtcbiAgfTtcblxuICBpc1N0YXRpYyA9ICgpID0+IHRoaXMudHlwZSA9PT0gJ3N0YXRpYyc7XG59XG4iLCJpbXBvcnQgeyBBeGlvc1Jlc3BvbnNlIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgQVBJRXJyb3JSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgQVBJRXJyb3JDb2RlczogUmVjb3JkPFxuICBzdHJpbmcsXG4gIHsgbmFtZTogc3RyaW5nOyByZXRyeWFibGU6IGJvb2xlYW4gfVxuPiA9IHtcbiAgJy0xJzogeyBuYW1lOiAnSW50ZXJuYWxTeXN0ZW1FcnJvcicsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAnMic6IHsgbmFtZTogJ0FjY2Vzc0tleUVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAnMyc6IHsgbmFtZTogJ0F1dGhlbnRpY2F0aW9uRmFpbGVkRXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgJzQnOiB7IG5hbWU6ICdJbnB1dEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAnNic6IHsgbmFtZTogJ0R1cGxpY2F0ZVVzZXJuYW1lRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICc5JzogeyBuYW1lOiAnUmF0ZUxpbWl0RXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgJzE2JzogeyBuYW1lOiAnRG9lc05vdEV4aXN0RXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICcxNyc6IHsgbmFtZTogJ05vdEFsbG93ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgJzE4JzogeyBuYW1lOiAnRXZlbnROb3RTdXBwb3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgJzE5JzogeyBuYW1lOiAnQ2hhbm5lbEZlYXR1cmVOb3RTdXBwb3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgJzIwJzogeyBuYW1lOiAnTWVzc2FnZVRvb0xvbmdFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgJzIxJzogeyBuYW1lOiAnTXVsdGlwbGVOZXN0aW5nTGV2ZWxFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgJzIyJzogeyBuYW1lOiAnUGF5bG9hZFRvb0JpZ0Vycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAnMjMnOiB7IG5hbWU6ICdSZXF1ZXN0VGltZW91dEVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICcyNCc6IHsgbmFtZTogJ01heEhlYWRlclNpemVFeGNlZWRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAnNDAnOiB7IG5hbWU6ICdBdXRoRXJyb3JUb2tlbkV4cGlyZWQnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICc0MSc6IHsgbmFtZTogJ0F1dGhFcnJvclRva2VuTm90VmFsaWRZZXQnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICc0Mic6IHsgbmFtZTogJ0F1dGhFcnJvclRva2VuVXNlZEJlZm9yZUlzc3VlZEF0JywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAnNDMnOiB7IG5hbWU6ICdBdXRoRXJyb3JUb2tlblNpZ25hdHVyZUludmFsaWQnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICc0NCc6IHsgbmFtZTogJ0N1c3RvbUNvbW1hbmRFbmRwb2ludE1pc3NpbmdFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgJzQ1JzogeyBuYW1lOiAnQ3VzdG9tQ29tbWFuZEVuZHBvaW50Q2FsbEVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICc0Nic6IHsgbmFtZTogJ0Nvbm5lY3Rpb25JRE5vdEZvdW5kRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICc2MCc6IHsgbmFtZTogJ0Nvb2xEb3duRXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgJzY5JzogeyBuYW1lOiAnRXJyV3JvbmdSZWdpb24nLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICc3MCc6IHsgbmFtZTogJ0VyclF1ZXJ5Q2hhbm5lbFBlcm1pc3Npb25zJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAnNzEnOiB7IG5hbWU6ICdFcnJUb29NYW55Q29ubmVjdGlvbnMnLCByZXRyeWFibGU6IHRydWUgfSxcbiAgJzk5JzogeyBuYW1lOiAnQXBwU3VzcGVuZGVkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG59O1xuXG4vLyB0b2RvOiB0aGlzIGlzIG5vdCBhIGNvcnJlY3QgZXJyb3IgZGVjbGFyYXRpb24uIC9yZWNvcmRpbmdzIGVuZHBvaW50IHJldHVybnMgZXJyb3Igb2JqZWN0cyBhcyBmb2xsb3dzOlxuLy8ge1xuLy8gICAgIFwiY29kZVwiOiAxNixcbi8vICAgICBcIm1lc3NhZ2VcIjogXCJMaXN0UmVjb3JkaW5ncyBmYWlsZWQgd2l0aCBlcnJvcjogXFxcIkNhbid0IGZpbmQgY2FsbCB3aXRoIGlkIGRlZmF1bHQ6YmJiYlxcXCJcIixcbi8vICAgICBcIlN0YXR1c0NvZGVcIjogNDA0LFxuLy8gICAgIFwiZHVyYXRpb25cIjogXCIwLjAwbXNcIixcbi8vICAgICBcIm1vcmVfaW5mb1wiOiBcImh0dHBzOi8vZ2V0c3RyZWFtLmlvL2NoYXQvZG9jcy9hcGlfZXJyb3JzX3Jlc3BvbnNlXCIsXG4vLyAgICAgXCJkZXRhaWxzXCI6IFtdXG4vLyB9XG5cbnR5cGUgQVBJRXJyb3IgPSBFcnJvciAmIHsgY29kZTogbnVtYmVyOyBpc1dTRmFpbHVyZT86IGJvb2xlYW4gfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQVBJRXJyb3IoZXJyb3I6IEVycm9yKTogZXJyb3IgaXMgQVBJRXJyb3Ige1xuICByZXR1cm4gKGVycm9yIGFzIEFQSUVycm9yKS5jb2RlICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yUmV0cnlhYmxlKGVycm9yOiBBUElFcnJvcikge1xuICBpZiAoIWVycm9yLmNvZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZXJyID0gQVBJRXJyb3JDb2Rlc1tgJHtlcnJvci5jb2RlfWBdO1xuICBpZiAoIWVycikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZXJyLnJldHJ5YWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29ubmVjdGlvbklERXJyb3IoZXJyb3I6IEFQSUVycm9yKSB7XG4gIHJldHVybiBlcnJvci5jb2RlID09PSA0NjsgLy8gQ29ubmVjdGlvbklETm90Rm91bmRFcnJvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNXU0ZhaWx1cmUoZXJyOiBBUElFcnJvcik6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIGVyci5pc1dTRmFpbHVyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGVyci5pc1dTRmFpbHVyZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZXJyLm1lc3NhZ2UpLmlzV1NGYWlsdXJlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yUmVzcG9uc2UoXG4gIHJlczogQXhpb3NSZXNwb25zZTx1bmtub3duPixcbik6IHJlcyBpcyBBeGlvc1Jlc3BvbnNlPEFQSUVycm9yUmVzcG9uc2U+IHtcbiAgcmV0dXJuICFyZXMuc3RhdHVzIHx8IHJlcy5zdGF0dXMgPCAyMDAgfHwgMzAwIDw9IHJlcy5zdGF0dXM7XG59XG4iLCJpbXBvcnQgYXhpb3MsIHsgQXhpb3NSZXF1ZXN0Q29uZmlnLCBDYW5jZWxUb2tlblNvdXJjZSB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IFN0cmVhbUNsaWVudCB9IGZyb20gJy4vY2xpZW50JztcbmltcG9ydCB7XG4gIGFkZENvbm5lY3Rpb25FdmVudExpc3RlbmVycyxcbiAgcmVtb3ZlQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzLFxuICByZXRyeUludGVydmFsLFxuICBzbGVlcCxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBpc0FQSUVycm9yLCBpc0Nvbm5lY3Rpb25JREVycm9yLCBpc0Vycm9yUmV0cnlhYmxlIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgTG9nTGV2ZWwsIFN0cmVhbVZpZGVvRXZlbnQsIFVSIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBDb25uZWN0ZWRFdmVudCB9IGZyb20gJy4uLy4uL2dlbi9jb29yZGluYXRvcic7XG5cbmV4cG9ydCBlbnVtIENvbm5lY3Rpb25TdGF0ZSB7XG4gIENsb3NlZCA9ICdDTE9TRUQnLFxuICBDb25uZWN0ZWQgPSAnQ09OTkVDVEVEJyxcbiAgQ29ubmVjdGluZyA9ICdDT05ORUNUSU5HJyxcbiAgRGlzY29ubmVjdGVkID0gJ0RJU0NPTk5FQ1RFRCcsXG4gIEluaXQgPSAnSU5JVCcsXG59XG5cbmV4cG9ydCBjbGFzcyBXU0Nvbm5lY3Rpb25GYWxsYmFjayB7XG4gIGNsaWVudDogU3RyZWFtQ2xpZW50O1xuICBzdGF0ZTogQ29ubmVjdGlvblN0YXRlO1xuICBjb25zZWN1dGl2ZUZhaWx1cmVzOiBudW1iZXI7XG4gIGNvbm5lY3Rpb25JRD86IHN0cmluZztcbiAgY2FuY2VsVG9rZW4/OiBDYW5jZWxUb2tlblNvdXJjZTtcblxuICBjb25zdHJ1Y3RvcihjbGllbnQ6IFN0cmVhbUNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuSW5pdDtcbiAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuXG4gICAgYWRkQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKHRoaXMuX29ubGluZVN0YXR1c0NoYW5nZWQpO1xuICB9XG5cbiAgX2xvZyhtc2c6IHN0cmluZywgZXh0cmE6IFVSID0ge30sIGxldmVsOiBMb2dMZXZlbCA9ICdpbmZvJykge1xuICAgIHRoaXMuY2xpZW50LmxvZ2dlcihsZXZlbCwgJ1dTQ29ubmVjdGlvbkZhbGxiYWNrOicgKyBtc2csIHtcbiAgICAgIC4uLmV4dHJhLFxuICAgIH0pO1xuICB9XG5cbiAgX3NldFN0YXRlKHN0YXRlOiBDb25uZWN0aW9uU3RhdGUpIHtcbiAgICB0aGlzLl9sb2coYF9zZXRTdGF0ZSgpIC0gJHtzdGF0ZX1gKTtcblxuICAgIC8vIHRyYW5zaXRpb24gZnJvbSBjb25uZWN0aW5nID0+IGNvbm5lY3RlZFxuICAgIGlmIChcbiAgICAgIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nICYmXG4gICAgICBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZFxuICAgICkge1xuICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICdjb25uZWN0aW9uLmNoYW5nZWQnLCBvbmxpbmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQgfHxcbiAgICAgIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkXG4gICAgKSB7XG4gICAgICB0aGlzLmNsaWVudC5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIG9ubGluZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vbmxpbmVTdGF0dXNDaGFuZ2VkID0gKGV2ZW50OiB7IHR5cGU6IHN0cmluZyB9KSA9PiB7XG4gICAgdGhpcy5fbG9nKGBfb25saW5lU3RhdHVzQ2hhbmdlZCgpIC0gJHtldmVudC50eXBlfWApO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdvZmZsaW5lJykge1xuICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNsb3NlZCk7XG4gICAgICB0aGlzLmNhbmNlbFRva2VuPy5jYW5jZWwoJ2Rpc2Nvbm5lY3QoKSBpcyBjYWxsZWQnKTtcbiAgICAgIHRoaXMuY2FuY2VsVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdvbmxpbmUnICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpIHtcbiAgICAgIHRoaXMuY29ubmVjdCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9yZXEgPSBhc3luYyA8VCA9IFVSPihcbiAgICBwYXJhbXM6IFVSLFxuICAgIGNvbmZpZzogQXhpb3NSZXF1ZXN0Q29uZmlnLFxuICAgIHJldHJ5OiBib29sZWFuLFxuICApOiBQcm9taXNlPFQ+ID0+IHtcbiAgICBpZiAoIXRoaXMuY2FuY2VsVG9rZW4gJiYgIXBhcmFtcy5jbG9zZSkge1xuICAgICAgdGhpcy5jYW5jZWxUb2tlbiA9IGF4aW9zLkNhbmNlbFRva2VuLnNvdXJjZSgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5kb0F4aW9zUmVxdWVzdDxUPihcbiAgICAgICAgJ2dldCcsXG4gICAgICAgICh0aGlzLmNsaWVudC5iYXNlVVJMIGFzIHN0cmluZykucmVwbGFjZSgnOjMwMzAnLCAnOjg5MDAnKSArICcvbG9uZ3BvbGwnLCAvLyByZXBsYWNlIHBvcnQgaWYgcHJlc2VudCBmb3IgdGVzdGluZyB3aXRoIGxvY2FsIEFQSVxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBjb25maWc6IHsgLi4uY29uZmlnLCBjYW5jZWxUb2tlbjogdGhpcy5jYW5jZWxUb2tlbj8udG9rZW4gfSxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgcHVibGljRW5kcG9pbnQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwOyAvLyBhbHdheXMgcmVzZXQgaW4gY2FzZSBvZiBubyBlcnJvclxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAocmV0cnkgJiYgaXNFcnJvclJldHJ5YWJsZShlcnIpKSB7XG4gICAgICAgIHRoaXMuX2xvZyhgX3JlcSgpIC0gUmV0cnlhYmxlIGVycm9yLCByZXRyeWluZyByZXF1ZXN0YCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXE8VD4ocGFyYW1zLCBjb25maWcsIHJldHJ5KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3BvbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9yZXE8e1xuICAgICAgICAgIGV2ZW50czogU3RyZWFtVmlkZW9FdmVudFtdO1xuICAgICAgICB9PihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aW1lb3V0OiAzMDAwMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICk7IC8vIDMwcyA9PiBBUEkgcmVzcG9uZHMgaW4gMjBzIGlmIHRoZXJlIGlzIG5vIGV2ZW50XG5cbiAgICAgICAgaWYgKGRhdGEuZXZlbnRzPy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5kaXNwYXRjaEV2ZW50KGRhdGEuZXZlbnRzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoYXhpb3MuaXNDYW5jZWwoZXJyKSkge1xuICAgICAgICAgIHRoaXMuX2xvZyhgX3BvbGwoKSAtIGF4aW9zIGNhbmNlbGVkIHJlcXVlc3RgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogY2xpZW50LmRvQXhpb3NSZXF1ZXN0IHdpbGwgdGFrZSBjYXJlIG9mIFRPS0VOX0VYUElSRUQgZXJyb3IgKi9cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChpc0Nvbm5lY3Rpb25JREVycm9yKGVycikpIHtcbiAgICAgICAgICB0aGlzLl9sb2coYF9wb2xsKCkgLSBDb25uZWN0aW9uSUQgZXJyb3IsIGNvbm5lY3Rpbmcgd2l0aG91dCBJRC4uLmApO1xuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgIHRoaXMuY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChpc0FQSUVycm9yKGVycikgJiYgIWlzRXJyb3JSZXRyeWFibGUoZXJyKSkge1xuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjb25uZWN0IHRyeSB0byBvcGVuIGEgbG9uZ3BvbGwgcmVxdWVzdFxuICAgKiBAcGFyYW0gcmVjb25uZWN0IHNob3VsZCBiZSBmYWxzZSBmb3IgZmlyc3QgY2FsbCBhbmQgdHJ1ZSBmb3Igc3Vic2VxdWVudCBjYWxscyB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlIGFuZCBjYWxsIHJlY292ZXJTdGF0ZVxuICAgKi9cbiAgY29ubmVjdCA9IGFzeW5jIChyZWNvbm5lY3QgPSBmYWxzZSkgPT4ge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZykge1xuICAgICAgdGhpcy5fbG9nKFxuICAgICAgICAnY29ubmVjdCgpIC0gY29ubmVjdGluZyBhbHJlYWR5IGluIHByb2dyZXNzJyxcbiAgICAgICAgeyByZWNvbm5lY3QgfSxcbiAgICAgICAgJ3dhcm4nLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX2xvZyhcbiAgICAgICAgJ2Nvbm5lY3QoKSAtIGFscmVhZHkgY29ubmVjdGVkIGFuZCBwb2xsaW5nJyxcbiAgICAgICAgeyByZWNvbm5lY3QgfSxcbiAgICAgICAgJ3dhcm4nLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyk7XG4gICAgdGhpcy5jb25uZWN0aW9uSUQgPSB1bmRlZmluZWQ7IC8vIGNvbm5lY3Qgc2hvdWxkIGJlIHNlbnQgd2l0aCBlbXB0eSBjb25uZWN0aW9uX2lkIHNvIEFQSSBjcmVhdGVzIG9uZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGV2ZW50IH0gPSBhd2FpdCB0aGlzLl9yZXE8e1xuICAgICAgICBldmVudDogQ29ubmVjdGVkRXZlbnQ7XG4gICAgICB9PihcbiAgICAgICAgeyBqc29uOiB0aGlzLmNsaWVudC5fYnVpbGRXU1BheWxvYWQoKSB9LFxuICAgICAgICB7XG4gICAgICAgICAgdGltZW91dDogODAwMCwgLy8gOHNcbiAgICAgICAgfSxcbiAgICAgICAgcmVjb25uZWN0LFxuICAgICAgKTtcblxuICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25JRCA9IGV2ZW50LmNvbm5lY3Rpb25faWQ7XG4gICAgICB0aGlzLmNsaWVudC5yZXNvbHZlQ29ubmVjdGlvbklkPy4oKTtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgdGhpcy5fcG9sbCgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNsb3NlZCk7XG4gICAgICB0aGlzLmNsaWVudC5yZWplY3RDb25uZWN0aW9uSWQ/LigpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogaXNIZWFsdGh5IGNoZWNrcyBpZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb25JRCBhbmQgY29ubmVjdGlvbiBpcyBpbiBDb25uZWN0ZWQgc3RhdGVcbiAgICovXG4gIGlzSGVhbHRoeSA9ICgpID0+IHtcbiAgICByZXR1cm4gISF0aGlzLmNvbm5lY3Rpb25JRCAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkO1xuICB9O1xuXG4gIGRpc2Nvbm5lY3QgPSBhc3luYyAodGltZW91dCA9IDIwMDApID0+IHtcbiAgICByZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnModGhpcy5fb25saW5lU3RhdHVzQ2hhbmdlZCk7XG5cbiAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKTtcbiAgICB0aGlzLmNhbmNlbFRva2VuPy5jYW5jZWwoJ2Rpc2Nvbm5lY3QoKSBpcyBjYWxsZWQnKTtcbiAgICB0aGlzLmNhbmNlbFRva2VuID0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgY29ubmVjdGlvbl9pZCA9IHRoaXMuY29ubmVjdGlvbklEO1xuICAgIHRoaXMuY29ubmVjdGlvbklEID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlcShcbiAgICAgICAgeyBjbG9zZTogdHJ1ZSwgY29ubmVjdGlvbl9pZCB9LFxuICAgICAgICB7XG4gICAgICAgICAgdGltZW91dCxcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2UsXG4gICAgICApO1xuICAgICAgdGhpcy5fbG9nKGBkaXNjb25uZWN0KCkgLSBDbG9zZWQgY29ubmVjdGlvbklEYCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9sb2coYGRpc2Nvbm5lY3QoKSAtIEZhaWxlZGAsIHsgZXJyIH0sICdlcnJvcicpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5cbmNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ2xvY2F0aW9uJ10pO1xuY29uc3QgSElOVF9VUkwgPSBgaHR0cHM6Ly9oaW50LnN0cmVhbS1pby12aWRlby5jb20vYDtcblxuZXhwb3J0IGNvbnN0IGdldExvY2F0aW9uSGludCA9IGFzeW5jIChcbiAgaGludFVybDogc3RyaW5nID0gSElOVF9VUkwsXG4gIHRpbWVvdXQ6IG51bWJlciA9IDIwMDAsXG4pID0+IHtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGhpbnRVcmwsIHtcbiAgICAgIG1ldGhvZDogJ0hFQUQnLFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH0pO1xuICAgIGNvbnN0IGF3c1BvcCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWFtei1jZi1wb3AnKSB8fCAnRVJSJztcbiAgICBsb2dnZXIoJ2RlYnVnJywgYExvY2F0aW9uIGhlYWRlcjogJHthd3NQb3B9YCk7XG4gICAgcmV0dXJuIGF3c1BvcC5zdWJzdHJpbmcoMCwgMyk7IC8vIEFNUzEtUDIgLT4gQU1TXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIoJ3dhcm4nLCBgRmFpbGVkIHRvIGdldCBsb2NhdGlvbiBoaW50IGZyb20gJHtoaW50VXJsfWAsIGUpO1xuICAgIHJldHVybiAnRVJSJztcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfVxufTtcbiIsImltcG9ydCBheGlvcywge1xuICBBeGlvc0Vycm9yLFxuICBBeGlvc0hlYWRlcnMsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZyxcbiAgQXhpb3NSZXNwb25zZSxcbn0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCB7IFN0YWJsZVdTQ29ubmVjdGlvbiB9IGZyb20gJy4vY29ubmVjdGlvbic7XG5pbXBvcnQgeyBEZXZUb2tlbiB9IGZyb20gJy4vc2lnbmluZyc7XG5pbXBvcnQgeyBUb2tlbk1hbmFnZXIgfSBmcm9tICcuL3Rva2VuX21hbmFnZXInO1xuaW1wb3J0IHsgV1NDb25uZWN0aW9uRmFsbGJhY2sgfSBmcm9tICcuL2Nvbm5lY3Rpb25fZmFsbGJhY2snO1xuaW1wb3J0IHsgaXNFcnJvclJlc3BvbnNlLCBpc1dTRmFpbHVyZSB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7XG4gIGlzRnVuY3Rpb24sXG4gIGlzT25saW5lLFxuICBLbm93bkNvZGVzLFxuICByYW5kb21JZCxcbiAgcmV0cnlJbnRlcnZhbCxcbiAgc2xlZXAsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQge1xuICBBbGxDbGllbnRFdmVudHMsXG4gIEFsbENsaWVudEV2ZW50VHlwZXMsXG4gIEFQSUVycm9yUmVzcG9uc2UsXG4gIENsaWVudEV2ZW50TGlzdGVuZXIsXG4gIENvbm5lY3RBUElSZXNwb25zZSxcbiAgRXJyb3JGcm9tUmVzcG9uc2UsXG4gIExvZ2dlcixcbiAgU3RyZWFtQ2xpZW50T3B0aW9ucyxcbiAgU3RyZWFtVmlkZW9FdmVudCxcbiAgVG9rZW5PclByb3ZpZGVyLFxuICBVc2VyLFxuICBVc2VyV2l0aElkLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEluc2lnaHRNZXRyaWNzLCBwb3N0SW5zaWdodHMgfSBmcm9tICcuL2luc2lnaHRzJztcbmltcG9ydCB7IGdldExvY2F0aW9uSGludCB9IGZyb20gJy4vbG9jYXRpb24nO1xuaW1wb3J0IHsgQ3JlYXRlR3Vlc3RSZXF1ZXN0LCBDcmVhdGVHdWVzdFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vZ2VuL2Nvb3JkaW5hdG9yJztcblxuZXhwb3J0IGNsYXNzIFN0cmVhbUNsaWVudCB7XG4gIF91c2VyPzogVXNlcldpdGhJZDtcbiAgYW5vbnltb3VzOiBib29sZWFuO1xuICBwZXJzaXN0VXNlck9uQ29ubmVjdGlvbkZhaWx1cmU/OiBib29sZWFuO1xuICBheGlvc0luc3RhbmNlOiBBeGlvc0luc3RhbmNlO1xuICBiYXNlVVJMPzogc3RyaW5nO1xuICBicm93c2VyOiBib29sZWFuO1xuICBjbGVhbmluZ0ludGVydmFsUmVmPzogTm9kZUpTLlRpbWVvdXQ7XG4gIGNsaWVudElEPzogc3RyaW5nO1xuICBrZXk6IHN0cmluZztcbiAgbGlzdGVuZXJzOiBQYXJ0aWFsPFxuICAgIFJlY29yZDxBbGxDbGllbnRFdmVudFR5cGVzLCBDbGllbnRFdmVudExpc3RlbmVyPGFueT5bXSB8IHVuZGVmaW5lZD5cbiAgPiA9IHt9O1xuICBsb2dnZXI6IExvZ2dlcjtcblxuICBwcml2YXRlIGxvY2F0aW9uSGludDogUHJvbWlzZTxzdHJpbmc+IHwgdW5kZWZpbmVkO1xuXG4gIG5vZGU6IGJvb2xlYW47XG4gIG9wdGlvbnM6IFN0cmVhbUNsaWVudE9wdGlvbnM7XG4gIHNlY3JldD86IHN0cmluZztcbiAgc2V0VXNlclByb21pc2U6IENvbm5lY3RBUElSZXNwb25zZSB8IG51bGw7XG4gIHRva2VuTWFuYWdlcjogVG9rZW5NYW5hZ2VyO1xuICB1c2VyPzogVXNlcldpdGhJZDtcbiAgdXNlckFnZW50Pzogc3RyaW5nO1xuICB1c2VySUQ/OiBzdHJpbmc7XG4gIHdzQmFzZVVSTD86IHN0cmluZztcbiAgd3NDb25uZWN0aW9uOiBTdGFibGVXU0Nvbm5lY3Rpb24gfCBudWxsO1xuICB3c0ZhbGxiYWNrPzogV1NDb25uZWN0aW9uRmFsbGJhY2s7XG4gIHdzUHJvbWlzZTogQ29ubmVjdEFQSVJlc3BvbnNlIHwgbnVsbDtcbiAgY29uc2VjdXRpdmVGYWlsdXJlczogbnVtYmVyO1xuICBpbnNpZ2h0TWV0cmljczogSW5zaWdodE1ldHJpY3M7XG4gIGRlZmF1bHRXU1RpbWVvdXRXaXRoRmFsbGJhY2s6IG51bWJlcjtcbiAgZGVmYXVsdFdTVGltZW91dDogbnVtYmVyO1xuICByZXNvbHZlQ29ubmVjdGlvbklkPzogRnVuY3Rpb247XG4gIHJlamVjdENvbm5lY3Rpb25JZD86IEZ1bmN0aW9uO1xuICBjb25uZWN0aW9uSWRQcm9taXNlPzogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuICBndWVzdFVzZXJDcmVhdGVQcm9taXNlPzogUHJvbWlzZTxDcmVhdGVHdWVzdFJlc3BvbnNlPjtcbiAgcHJpdmF0ZSBuZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSB0aGUgYXBpIGtleVxuICAgKiBAcGFyYW0ge1N0cmVhbUNsaWVudE9wdGlvbnN9IFtvcHRpb25zXSAtIGFkZGl0aW9uYWwgb3B0aW9ucywgaGVyZSB5b3UgY2FuIHBhc3MgY3VzdG9tIG9wdGlvbnMgdG8gYXhpb3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlY3JldF0gLSB0aGUgYXBpIHNlY3JldFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJyb3dzZXJdIC0gZW5mb3JjZSB0aGUgY2xpZW50IHRvIGJlIGluIGJyb3dzZXIgbW9kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndhcm1VcF0gLSBkZWZhdWx0IHRvIGZhbHNlLCBpZiB0cnVlLCBjbGllbnQgd2lsbCBvcGVuIGEgY29ubmVjdGlvbiBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHNwZWVkIHVwIGZvbGxvd2luZyByZXF1ZXN0c1xuICAgKiBAcGFyYW0ge0xvZ2dlcn0gW29wdGlvbnMuTG9nZ2VyXSAtIGN1c3RvbSBsb2dnZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbWVvdXRdIC0gZGVmYXVsdCB0byAzMDAwXG4gICAqIEBwYXJhbSB7aHR0cHNBZ2VudH0gW29wdGlvbnMuaHR0cHNBZ2VudF0gLSBjdXN0b20gaHR0cHNBZ2VudCwgaW4gbm9kZSBpdCdzIGRlZmF1bHQgdG8gaHR0cHMuYWdlbnQoKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5OiBzdHJpbmcsIG9wdGlvbnM/OiBTdHJlYW1DbGllbnRPcHRpb25zKSB7XG4gICAgLy8gc2V0IHRoZSBrZXlcbiAgICB0aGlzLmtleSA9IGtleTtcblxuICAgIC8vIHNldCB0aGUgc2VjcmV0XG4gICAgdGhpcy5zZWNyZXQgPSBvcHRpb25zPy5zZWNyZXQ7XG5cbiAgICAvLyBzZXQgdGhlIG9wdGlvbnMuLi4gYW5kIGZpZ3VyZSBvdXQgZGVmYXVsdHMuLi5cbiAgICBjb25zdCBpbnB1dE9wdGlvbnMgPSBvcHRpb25zXG4gICAgICA/IG9wdGlvbnNcbiAgICAgIDogKHtcbiAgICAgICAgICBicm93c2VyOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgfSBhcyBQYXJ0aWFsPFN0cmVhbUNsaWVudE9wdGlvbnM+KTtcblxuICAgIHRoaXMuYnJvd3NlciA9IGlucHV0T3B0aW9ucy5icm93c2VyIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgIHRoaXMubm9kZSA9ICF0aGlzLmJyb3dzZXI7XG5cbiAgICBpZiAodGhpcy5icm93c2VyKSB7XG4gICAgICB0aGlzLmxvY2F0aW9uSGludCA9IGdldExvY2F0aW9uSGludChcbiAgICAgICAgb3B0aW9ucz8ubG9jYXRpb25IaW50VXJsLFxuICAgICAgICBvcHRpb25zPy5sb2NhdGlvbkhpbnRUaW1lb3V0LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSwgLy8gbWFraW5nIHN1cmUgY29va2llcyBhcmUgbm90IHNlbnRcbiAgICAgIHdhcm1VcDogZmFsc2UsXG4gICAgICAuLi5pbnB1dE9wdGlvbnMsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm5vZGUgJiYgIXRoaXMub3B0aW9ucy5odHRwc0FnZW50KSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaHR0cHNBZ2VudCA9IG5ldyBodHRwcy5BZ2VudCh7XG4gICAgICAgIGtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgICAga2VlcEFsaXZlTXNlY3M6IDMwMDAsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEJhc2VVUkwoXG4gICAgICB0aGlzLm9wdGlvbnMuYmFzZVVSTCB8fCAnaHR0cHM6Ly92aWRlby5zdHJlYW0taW8tYXBpLmNvbS92aWRlbycsXG4gICAgKTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuU1RSRUFNX0xPQ0FMX1RFU1RfUlVOKSB7XG4gICAgICB0aGlzLnNldEJhc2VVUkwoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAzMC92aWRlbycpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuU1RSRUFNX0xPQ0FMX1RFU1RfSE9TVCkge1xuICAgICAgdGhpcy5zZXRCYXNlVVJMKGBodHRwOi8vJHtwcm9jZXNzLmVudi5TVFJFQU1fTE9DQUxfVEVTVF9IT1NUfS92aWRlb2ApO1xuICAgIH1cblxuICAgIHRoaXMuYXhpb3NJbnN0YW5jZSA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICBiYXNlVVJMOiB0aGlzLmJhc2VVUkwsXG4gICAgfSk7XG5cbiAgICAvLyBXUyBjb25uZWN0aW9uIGlzIGluaXRpYWxpemVkIHdoZW4gc2V0VXNlciBpcyBjYWxsZWRcbiAgICB0aGlzLndzQ29ubmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy53c1Byb21pc2UgPSBudWxsO1xuICAgIHRoaXMuc2V0VXNlclByb21pc2UgPSBudWxsO1xuXG4gICAgLy8gbWFwcGluZyBiZXR3ZWVuIGNoYW5uZWwgZ3JvdXBzIGFuZCBjb25maWdzXG4gICAgdGhpcy5hbm9ueW1vdXMgPSBmYWxzZTtcbiAgICB0aGlzLnBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZSA9XG4gICAgICB0aGlzLm9wdGlvbnM/LnBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZTtcblxuICAgIC8vIElmIGl0IGlzIGEgc2VydmVyLXNpZGUgY2xpZW50LCB0aGVuIGxldHMgaW5pdGlhbGl6ZSB0aGUgdG9rZW5NYW5hZ2VyLCBzaW5jZSB0b2tlbiB3aWxsIGJlXG4gICAgLy8gZ2VuZXJhdGVkIGZyb20gc2VjcmV0LlxuICAgIHRoaXMudG9rZW5NYW5hZ2VyID0gbmV3IFRva2VuTWFuYWdlcih0aGlzLnNlY3JldCk7XG4gICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICB0aGlzLmluc2lnaHRNZXRyaWNzID0gbmV3IEluc2lnaHRNZXRyaWNzKCk7XG5cbiAgICB0aGlzLmRlZmF1bHRXU1RpbWVvdXRXaXRoRmFsbGJhY2sgPSA2MDAwO1xuICAgIHRoaXMuZGVmYXVsdFdTVGltZW91dCA9IDE1MDAwO1xuXG4gICAgdGhpcy5sb2dnZXIgPSBpc0Z1bmN0aW9uKGlucHV0T3B0aW9ucy5sb2dnZXIpXG4gICAgICA/IGlucHV0T3B0aW9ucy5sb2dnZXJcbiAgICAgIDogKCkgPT4gbnVsbDtcbiAgfVxuXG4gIGRldlRva2VuID0gKHVzZXJJRDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIERldlRva2VuKHVzZXJJRCk7XG4gIH07XG5cbiAgZ2V0QXV0aFR5cGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuYW5vbnltb3VzID8gJ2Fub255bW91cycgOiAnand0JztcbiAgfTtcblxuICBzZXRCYXNlVVJMID0gKGJhc2VVUkw6IHN0cmluZykgPT4ge1xuICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XG4gICAgdGhpcy53c0Jhc2VVUkwgPSB0aGlzLmJhc2VVUkxcbiAgICAgIC5yZXBsYWNlKCdodHRwJywgJ3dzJylcbiAgICAgIC5yZXBsYWNlKCc6MzAzMCcsICc6ODgwMCcpO1xuICB9O1xuXG4gIGdldExvY2F0aW9uSGludCA9IGFzeW5jIChcbiAgICBoaW50VXJsPzogc3RyaW5nLFxuICAgIHRpbWVvdXQ/OiBudW1iZXIsXG4gICk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgaGludCA9IGF3YWl0IHRoaXMubG9jYXRpb25IaW50O1xuICAgIGlmICghaGludCB8fCBoaW50ID09PSAnRVJSJykge1xuICAgICAgdGhpcy5sb2NhdGlvbkhpbnQgPSBnZXRMb2NhdGlvbkhpbnQoXG4gICAgICAgIGhpbnRVcmwgPz8gdGhpcy5vcHRpb25zLmxvY2F0aW9uSGludFVybCxcbiAgICAgICAgdGltZW91dCA/PyB0aGlzLm9wdGlvbnMubG9jYXRpb25IaW50VGltZW91dCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbkhpbnQ7XG4gICAgfVxuICAgIHJldHVybiBoaW50O1xuICB9O1xuXG4gIF9nZXRDb25uZWN0aW9uSUQgPSAoKSA9PlxuICAgIHRoaXMud3NDb25uZWN0aW9uPy5jb25uZWN0aW9uSUQgfHwgdGhpcy53c0ZhbGxiYWNrPy5jb25uZWN0aW9uSUQ7XG5cbiAgX2hhc0Nvbm5lY3Rpb25JRCA9ICgpID0+IEJvb2xlYW4odGhpcy5fZ2V0Q29ubmVjdGlvbklEKCkpO1xuXG4gIC8qKlxuICAgKiBjb25uZWN0VXNlciAtIFNldCB0aGUgY3VycmVudCB1c2VyIGFuZCBvcGVuIGEgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHVzZXIgRGF0YSBhYm91dCB0aGlzIHVzZXIuIElFIHtuYW1lOiBcImpvaG5cIn1cbiAgICogQHBhcmFtIHtUb2tlbk9yUHJvdmlkZXJ9IHVzZXJUb2tlbk9yUHJvdmlkZXIgVG9rZW4gb3IgcHJvdmlkZXJcbiAgICpcbiAgICogQHJldHVybiB7Q29ubmVjdEFQSVJlc3BvbnNlfSBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgc2V0dXBcbiAgICovXG4gIGNvbm5lY3RVc2VyID0gYXN5bmMgKFxuICAgIHVzZXI6IFVzZXJXaXRoSWQsXG4gICAgdXNlclRva2VuT3JQcm92aWRlcjogVG9rZW5PclByb3ZpZGVyLFxuICApID0+IHtcbiAgICBpZiAoIXVzZXIuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwiaWRcIiBmaWVsZCBvbiB0aGUgdXNlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGluZyBjb25uZWN0VXNlciBtdWx0aXBsZSB0aW1lcyBpcyBwb3RlbnRpYWxseSB0aGUgcmVzdWx0IG9mIGEgIGJhZCBpbnRlZ3JhdGlvbiwgaG93ZXZlcixcbiAgICAgKiBJZiB0aGUgdXNlciBpZCByZW1haW5zIHRoZSBzYW1lIHdlIGRvbid0IHRocm93IGVycm9yXG4gICAgICovXG4gICAgaWYgKHRoaXMudXNlcklEID09PSB1c2VyLmlkICYmIHRoaXMuc2V0VXNlclByb21pc2UpIHtcbiAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAnd2FybicsXG4gICAgICAgICdDb25zZWN1dGl2ZSBjYWxscyB0byBjb25uZWN0VXNlciBpcyBkZXRlY3RlZCwgaWRlYWxseSB5b3Ugc2hvdWxkIG9ubHkgY2FsbCB0aGlzIGZ1bmN0aW9uIG9uY2UgaW4geW91ciBhcHAuJyxcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRVc2VyUHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VySUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VzZSBjbGllbnQuZGlzY29ubmVjdCgpIGJlZm9yZSB0cnlpbmcgdG8gY29ubmVjdCBhcyBhIGRpZmZlcmVudCB1c2VyLiBjb25uZWN0VXNlciB3YXMgY2FsbGVkIHR3aWNlLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh0aGlzLl9pc1VzaW5nU2VydmVyQXV0aCgpIHx8IHRoaXMubm9kZSkgJiZcbiAgICAgICF0aGlzLm9wdGlvbnMuYWxsb3dTZXJ2ZXJTaWRlQ29ubmVjdFxuICAgICkge1xuICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICd3YXJuJyxcbiAgICAgICAgJ1BsZWFzZSBkbyBub3QgdXNlIGNvbm5lY3RVc2VyIHNlcnZlciBzaWRlLiBjb25uZWN0VXNlciBpbXBhY3RzIE1BVSBhbmQgY29uY3VycmVudCBjb25uZWN0aW9uIHVzYWdlIGFuZCB0aHVzIHlvdXIgYmlsbC4gSWYgeW91IGhhdmUgYSB2YWxpZCB1c2UtY2FzZSwgYWRkIFwiYWxsb3dTZXJ2ZXJTaWRlQ29ubmVjdDogdHJ1ZVwiIHRvIHRoZSBjbGllbnQgb3B0aW9ucyB0byBkaXNhYmxlIHRoaXMgd2FybmluZy4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBnZW5lcmF0ZSB0aGUgY2xpZW50IGlkIGNsaWVudCBzaWRlXG4gICAgdGhpcy51c2VySUQgPSB1c2VyLmlkO1xuICAgIHRoaXMuYW5vbnltb3VzID0gZmFsc2U7XG5cbiAgICBjb25zdCBzZXRUb2tlblByb21pc2UgPSB0aGlzLl9zZXRUb2tlbihcbiAgICAgIHVzZXIsXG4gICAgICB1c2VyVG9rZW5PclByb3ZpZGVyLFxuICAgICAgdGhpcy5hbm9ueW1vdXMsXG4gICAgKTtcbiAgICB0aGlzLl9zZXRVc2VyKHVzZXIpO1xuXG4gICAgY29uc3Qgd3NQcm9taXNlID0gdGhpcy5vcGVuQ29ubmVjdGlvbigpO1xuXG4gICAgdGhpcy5zZXRVc2VyUHJvbWlzZSA9IFByb21pc2UuYWxsKFtzZXRUb2tlblByb21pc2UsIHdzUHJvbWlzZV0pLnRoZW4oXG4gICAgICAocmVzdWx0KSA9PiByZXN1bHRbMV0sIC8vIFdlIG9ubHkgcmV0dXJuIGNvbm5lY3Rpb24gcHJvbWlzZTtcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldFVzZXJQcm9taXNlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRoaXMucGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlKSB7XG4gICAgICAgIC8vIGNsZWFudXAgY2xpZW50IHRvIGFsbG93IHRoZSB1c2VyIHRvIHJldHJ5IGNvbm5lY3RVc2VyIGFnYWluXG4gICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RVc2VyKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuXG4gIF9zZXRUb2tlbiA9IChcbiAgICB1c2VyOiBVc2VyV2l0aElkLFxuICAgIHVzZXJUb2tlbk9yUHJvdmlkZXI6IFRva2VuT3JQcm92aWRlcixcbiAgICBpc0Fub255bW91czogYm9vbGVhbixcbiAgKSA9PlxuICAgIHRoaXMudG9rZW5NYW5hZ2VyLnNldFRva2VuT3JQcm92aWRlcihcbiAgICAgIHVzZXJUb2tlbk9yUHJvdmlkZXIsXG4gICAgICB1c2VyLFxuICAgICAgaXNBbm9ueW1vdXMsXG4gICAgKTtcblxuICBfc2V0VXNlciA9ICh1c2VyOiBVc2VyV2l0aElkKSA9PiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBvbmUgaXMgdXNlZCBieSB0aGUgZnJvbnRlbmQuIFRoaXMgaXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHVzZXIgb2JqZWN0IHN0b3JlZCBvbiBiYWNrZW5kLlxuICAgICAqIEl0IGNvbnRhaW5zIHJlc2VydmVkIHByb3BlcnRpZXMgYW5kIG93biB1c2VyIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBwcmVzZW50IGluIGB0aGlzLl91c2VyYC5cbiAgICAgKi9cbiAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgIHRoaXMudXNlcklEID0gdXNlci5pZDtcbiAgICAvLyB0aGlzIG9uZSBpcyBhY3R1YWxseSB1c2VkIGZvciByZXF1ZXN0cy4gVGhpcyBpcyBhIGNvcHkgb2YgY3VycmVudCB1c2VyIHByb3ZpZGVkIHRvIGBjb25uZWN0VXNlcmAgZnVuY3Rpb24uXG4gICAgdGhpcy5fdXNlciA9IHsgLi4udXNlciB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24sIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIHVzZXIgc2V0IG9uIGNsaWVudC5cbiAgICogY2xpZW50LmNsb3NlQ29ubmVjdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGRlZmF1bHQgYXV0by1yZXRyeSBtZWNoYW5pc20gZm9yIHJlY29ubmVjdGlvbi4gWW91IG5lZWRcbiAgICogdG8gY2FsbCBjbGllbnQub3BlbkNvbm5lY3Rpb24gdG8gcmVjb25uZWN0IHRvIHdlYnNvY2tldC5cbiAgICpcbiAgICogVGhpcyBpcyBtYWlubHkgdXNlZnVsIG9uIG1vYmlsZSBzaWRlLiBZb3UgY2FuIG9ubHkgcmVjZWl2ZSBwdXNoIG5vdGlmaWNhdGlvbnNcbiAgICogaWYgeW91IGRvbid0IGhhdmUgYWN0aXZlIHdlYnNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBTbyB3aGVuIHlvdXIgYXBwIGdvZXMgdG8gYmFja2dyb3VuZCwgeW91IGNhbiBjYWxsIGBjbGllbnQuY2xvc2VDb25uZWN0aW9uYC5cbiAgICogQW5kIHdoZW4gYXBwIGNvbWVzIGJhY2sgdG8gZm9yZWdyb3VuZCwgY2FsbCBgY2xpZW50Lm9wZW5Db25uZWN0aW9uYC5cbiAgICpcbiAgICogQHBhcmFtIHRpbWVvdXQgTWF4IG51bWJlciBvZiBtcywgdG8gd2FpdCBmb3IgY2xvc2UgZXZlbnQgb2Ygd2Vic29ja2V0LCBiZWZvcmUgZm9yY2VmdWxseSBhc3N1bWluZyBzdWNjZXNmdWwgZGlzY29ubmVjdGlvbi5cbiAgICogICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnRcbiAgICovXG4gIGNsb3NlQ29ubmVjdGlvbiA9IGFzeW5jICh0aW1lb3V0PzogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHRoaXMuY2xlYW5pbmdJbnRlcnZhbFJlZiAhPSBudWxsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW5pbmdJbnRlcnZhbFJlZik7XG4gICAgICB0aGlzLmNsZWFuaW5nSW50ZXJ2YWxSZWYgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy53c0Nvbm5lY3Rpb24/LmRpc2Nvbm5lY3QodGltZW91dCksXG4gICAgICB0aGlzLndzRmFsbGJhY2s/LmRpc2Nvbm5lY3QodGltZW91dCksXG4gICAgXSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFdlYlNvY2tldCBjb25uZWN0aW9uIHdpdGggdGhlIGN1cnJlbnQgdXNlci4gUmV0dXJucyBlbXB0eSBwcm9taXNlLCBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgY29ubmVjdGlvblxuICAgKi9cbiAgb3BlbkNvbm5lY3Rpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnVzZXJJRCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdVc2VyV2l0aElkIGlzIG5vdCBzZXQgb24gY2xpZW50LCB1c2UgY2xpZW50LmNvbm5lY3RVc2VyIG9yIGNsaWVudC5jb25uZWN0QW5vbnltb3VzVXNlciBpbnN0ZWFkJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3NDb25uZWN0aW9uPy5pc0Nvbm5lY3RpbmcgJiYgdGhpcy53c1Byb21pc2UpIHtcbiAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAnaW5mbycsXG4gICAgICAgICdjbGllbnQ6b3BlbkNvbm5lY3Rpb24oKSAtIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcycsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMud3NQcm9taXNlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh0aGlzLndzQ29ubmVjdGlvbj8uaXNIZWFsdGh5IHx8IHRoaXMud3NGYWxsYmFjaz8uaXNIZWFsdGh5KCkpICYmXG4gICAgICB0aGlzLl9oYXNDb25uZWN0aW9uSUQoKVxuICAgICkge1xuICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICdpbmZvJyxcbiAgICAgICAgJ2NsaWVudDpvcGVuQ29ubmVjdGlvbigpIC0gb3BlbkNvbm5lY3Rpb24gY2FsbGVkIHR3aWNlLCBoZWFsdGh5IGNvbm5lY3Rpb24gYWxyZWFkeSBleGlzdHMnLFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGlvbklkUHJvbWlzZSA9IG5ldyBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4oXG4gICAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25JZCA9IHJlc29sdmU7XG4gICAgICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbklkID0gcmVqZWN0O1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5jbGllbnRJRCA9IGAke3RoaXMudXNlcklEfS0tJHtyYW5kb21JZCgpfWA7XG4gICAgdGhpcy53c1Byb21pc2UgPSB0aGlzLmNvbm5lY3QoKTtcbiAgICByZXR1cm4gdGhpcy53c1Byb21pc2U7XG4gIH07XG5cbiAgX25vcm1hbGl6ZURhdGUgPSAoYmVmb3JlOiBEYXRlIHwgc3RyaW5nIHwgbnVsbCk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIGlmIChiZWZvcmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBiZWZvcmUgPSBiZWZvcmUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoYmVmb3JlID09PSAnJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkRvbid0IHBhc3MgYmxhbmsgc3RyaW5nIGZvciBzaW5jZSwgdXNlIG51bGwgaW5zdGVhZCBpZiByZXNldHRpbmcgdGhlIHRva2VuIHJldm9rZVwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVmb3JlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgd2Vic29ja2V0IGFuZCByZW1vdmVzIHRoZSB1c2VyIGZyb20gY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dCBNYXggbnVtYmVyIG9mIG1zLCB0byB3YWl0IGZvciBjbG9zZSBldmVudCBvZiB3ZWJzb2NrZXQsIGJlZm9yZSBmb3JjZWZ1bGx5IGFzc3VtaW5nIHN1Y2Nlc3NmdWwgZGlzY29ubmVjdGlvbi5cbiAgICogICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnRcbiAgICovXG4gIGRpc2Nvbm5lY3RVc2VyID0gYXN5bmMgKHRpbWVvdXQ/OiBudW1iZXIpID0+IHtcbiAgICB0aGlzLmxvZ2dlcignaW5mbycsICdjbGllbnQ6ZGlzY29ubmVjdCgpIC0gRGlzY29ubmVjdGluZyB0aGUgY2xpZW50Jyk7XG5cbiAgICAvLyByZW1vdmUgdGhlIHVzZXIgc3BlY2lmaWMgZmllbGRzXG4gICAgZGVsZXRlIHRoaXMudXNlcjtcbiAgICBkZWxldGUgdGhpcy5fdXNlcjtcbiAgICBkZWxldGUgdGhpcy51c2VySUQ7XG5cbiAgICB0aGlzLmFub255bW91cyA9IGZhbHNlO1xuXG4gICAgYXdhaXQgdGhpcy5jbG9zZUNvbm5lY3Rpb24odGltZW91dCk7XG5cbiAgICB0aGlzLnRva2VuTWFuYWdlci5yZXNldCgpO1xuXG4gICAgdGhpcy5jb25uZWN0aW9uSWRQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICBjb25uZWN0R3Vlc3RVc2VyID0gYXN5bmMgKHVzZXI6IFVzZXIgJiB7IHR5cGU6ICdndWVzdCcgfSkgPT4ge1xuICAgIHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZSA9IHRoaXMuZG9BeGlvc1JlcXVlc3Q8XG4gICAgICBDcmVhdGVHdWVzdFJlc3BvbnNlLFxuICAgICAgQ3JlYXRlR3Vlc3RSZXF1ZXN0XG4gICAgPihcbiAgICAgICdwb3N0JyxcbiAgICAgICcvZ3Vlc3QnLFxuICAgICAge1xuICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgLi4udXNlcixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7IHB1YmxpY0VuZHBvaW50OiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlO1xuICAgIHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZS5maW5hbGx5KFxuICAgICAgKCkgPT4gKHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZSA9IHVuZGVmaW5lZCksXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLmNvbm5lY3RVc2VyKHJlc3BvbnNlLnVzZXIsIHJlc3BvbnNlLmFjY2Vzc190b2tlbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNvbm5lY3RBbm9ueW1vdXNVc2VyIC0gU2V0IGFuIGFub255bW91cyB1c2VyIGFuZCBvcGVuIGEgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICovXG4gIGNvbm5lY3RBbm9ueW1vdXNVc2VyID0gYXN5bmMgKFxuICAgIHVzZXI6IFVzZXJXaXRoSWQsXG4gICAgdG9rZW5PclByb3ZpZGVyOiBUb2tlbk9yUHJvdmlkZXIsXG4gICkgPT4ge1xuICAgIHRoaXMuY29ubmVjdGlvbklkUHJvbWlzZSA9IG5ldyBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4oXG4gICAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25JZCA9IHJlc29sdmU7XG4gICAgICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbklkID0gcmVqZWN0O1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5hbm9ueW1vdXMgPSB0cnVlO1xuICAgIGF3YWl0IHRoaXMuX3NldFRva2VuKHVzZXIsIHRva2VuT3JQcm92aWRlciwgdGhpcy5hbm9ueW1vdXMpO1xuXG4gICAgdGhpcy5fc2V0VXNlcih1c2VyKTtcbiAgICAvLyBzb21lIGVuZHBvaW50cyByZXF1aXJlIGEgY29ubmVjdGlvbl9pZCB0byBiZSByZXNvbHZlZC5cbiAgICAvLyBhcyBhbm9ueW1vdXMgdXNlcnMgYXJlbid0IGFsbG93ZWQgdG8gb3BlbiBXUyBjb25uZWN0aW9ucywgd2UganVzdFxuICAgIC8vIHJlc29sdmUgdGhlIGNvbm5lY3Rpb25faWQgaGVyZS5cbiAgICB0aGlzLnJlc29sdmVDb25uZWN0aW9uSWQ/LigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBvbiAtIExpc3RlbiB0byBldmVudHMgb24gYWxsIGNoYW5uZWxzIGFuZCB1c2VycyB5b3VyIHdhdGNoaW5nXG4gICAqXG4gICAqIGNsaWVudC5vbignbWVzc2FnZS5uZXcnLCBldmVudCA9PiB7Y29uc29sZS5sb2coXCJteSBuZXcgbWVzc2FnZVwiLCBldmVudCwgY2hhbm5lbC5zdGF0ZS5tZXNzYWdlcyl9KVxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IgKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGNhbGxcbiAgICpcbiAgICogQHJldHVybiAgUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoLCB3aGVuIGNhbGxlZCwgdW5zdWJzY3JpYmVzIHRoZSBldmVudCBoYW5kbGVyLlxuICAgKi9cbiAgb24gPSA8RSBleHRlbmRzIGtleW9mIEFsbENsaWVudEV2ZW50cz4oXG4gICAgZXZlbnROYW1lOiBFLFxuICAgIGNhbGxiYWNrOiBDbGllbnRFdmVudExpc3RlbmVyPEU+LFxuICApID0+IHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgQWRkaW5nIGxpc3RlbmVyIGZvciAke2V2ZW50TmFtZX0gZXZlbnRgKTtcbiAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdPy5wdXNoKGNhbGxiYWNrIGFzIENsaWVudEV2ZW50TGlzdGVuZXI8YW55Pik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIG9mZiAtIFJlbW92ZSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb2ZmID0gPEUgZXh0ZW5kcyBrZXlvZiBBbGxDbGllbnRFdmVudHM+KFxuICAgIGV2ZW50TmFtZTogRSxcbiAgICBjYWxsYmFjazogQ2xpZW50RXZlbnRMaXN0ZW5lcjxFPixcbiAgKSA9PiB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYFJlbW92aW5nIGxpc3RlbmVyIGZvciAke2V2ZW50TmFtZX0gZXZlbnRgKTtcbiAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXT8uZmlsdGVyKFxuICAgICAgKHZhbHVlKSA9PiB2YWx1ZSAhPT0gY2FsbGJhY2ssXG4gICAgKTtcbiAgfTtcblxuICBfbG9nQXBpUmVxdWVzdCA9IChcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgZGF0YTogdW5rbm93bixcbiAgICBjb25maWc6IEF4aW9zUmVxdWVzdENvbmZpZyAmIHtcbiAgICAgIGNvbmZpZz86IEF4aW9zUmVxdWVzdENvbmZpZyAmIHsgbWF4Qm9keUxlbmd0aD86IG51bWJlciB9O1xuICAgIH0sXG4gICkgPT4ge1xuICAgIHRoaXMubG9nZ2VyKCd0cmFjZScsIGBjbGllbnQ6ICR7dHlwZX0gLSBSZXF1ZXN0IC0gJHt1cmx9YCwge1xuICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgIGNvbmZpZyxcbiAgICB9KTtcbiAgfTtcblxuICBfbG9nQXBpUmVzcG9uc2UgPSA8VD4oXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIHVybDogc3RyaW5nLFxuICAgIHJlc3BvbnNlOiBBeGlvc1Jlc3BvbnNlPFQ+LFxuICApID0+IHtcbiAgICB0aGlzLmxvZ2dlcihcbiAgICAgICd0cmFjZScsXG4gICAgICBgY2xpZW50OiR7dHlwZX0gLSBSZXNwb25zZSAtIHVybDogJHt1cmx9ID4gc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSxcbiAgICApO1xuICB9O1xuXG4gIF9sb2dBcGlFcnJvciA9ICh0eXBlOiBzdHJpbmcsIHVybDogc3RyaW5nLCBlcnJvcjogdW5rbm93bikgPT4ge1xuICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBjbGllbnQ6JHt0eXBlfSAtIEVycm9yIC0gdXJsOiAke3VybH1gLCB7XG4gICAgICB1cmwsXG4gICAgICBlcnJvcixcbiAgICB9KTtcbiAgfTtcblxuICBkb0F4aW9zUmVxdWVzdCA9IGFzeW5jIDxULCBEID0gdW5rbm93bj4oXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGRhdGE/OiBELFxuICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyAmIHtcbiAgICAgIGNvbmZpZz86IEF4aW9zUmVxdWVzdENvbmZpZyAmIHsgbWF4Qm9keUxlbmd0aD86IG51bWJlciB9O1xuICAgIH0gJiB7IHB1YmxpY0VuZHBvaW50PzogYm9vbGVhbiB9ID0ge30sXG4gICk6IFByb21pc2U8VD4gPT4ge1xuICAgIGlmICghb3B0aW9ucy5wdWJsaWNFbmRwb2ludCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLnRva2VuTWFuYWdlci50b2tlblJlYWR5KCksXG4gICAgICAgIHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZSxcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uSWRQcm9taXNlLFxuICAgICAgXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDb25maWcgPSB0aGlzLl9lbnJpY2hBeGlvc09wdGlvbnMob3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXNwb25zZTogQXhpb3NSZXNwb25zZTxUPjtcbiAgICAgIHRoaXMuX2xvZ0FwaVJlcXVlc3QodHlwZSwgdXJsLCBkYXRhLCByZXF1ZXN0Q29uZmlnKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLmdldCh1cmwsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLmRlbGV0ZSh1cmwsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb3N0JzpcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5wb3N0KHVybCwgZGF0YSwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UucHV0KHVybCwgZGF0YSwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5wYXRjaCh1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvcHRpb25zJzpcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5vcHRpb25zKHVybCwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlcXVlc3QgdHlwZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9nQXBpUmVzcG9uc2U8VD4odHlwZSwgdXJsLCByZXNwb25zZSk7XG4gICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB9IGNhdGNoIChlOiBhbnkgLyoqVE9ETzogZ2VuZXJhbGl6ZSBlcnJvciB0eXBlcyAgKi8pIHtcbiAgICAgIGUuY2xpZW50X3JlcXVlc3RfaWQgPSByZXF1ZXN0Q29uZmlnLmhlYWRlcnM/LlsneC1jbGllbnQtcmVxdWVzdC1pZCddO1xuICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgICBpZiAoZS5yZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9sb2dBcGlFcnJvcih0eXBlLCB1cmwsIGUucmVzcG9uc2UpO1xuICAgICAgICAvKiogY29ubmVjdGlvbl9mYWxsYmFjayBkZXBlbmRzIG9uIHRoaXMgdG9rZW4gZXhwaXJhdGlvbiBsb2dpYyAqL1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZS5yZXNwb25zZS5kYXRhLmNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAgICF0aGlzLnRva2VuTWFuYWdlci5pc1N0YXRpYygpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPiAxKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuTWFuYWdlci5sb2FkVG9rZW4oKTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kb0F4aW9zUmVxdWVzdDxULCBEPih0eXBlLCB1cmwsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKGUucmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbG9nQXBpRXJyb3IodHlwZSwgdXJsLCBlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgdGhyb3cgZSBhcyBBeGlvc0Vycm9yPEFQSUVycm9yUmVzcG9uc2U+O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBnZXQgPSA8VD4odXJsOiBzdHJpbmcsIHBhcmFtcz86IEF4aW9zUmVxdWVzdENvbmZpZ1sncGFyYW1zJ10pID0+IHtcbiAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdDxULCB1bmtub3duPignZ2V0JywgdXJsLCBudWxsLCB7XG4gICAgICBwYXJhbXMsXG4gICAgfSk7XG4gIH07XG5cbiAgcHV0ID0gPFQsIEQgPSB1bmtub3duPihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBkYXRhPzogRCxcbiAgICBwYXJhbXM/OiBBeGlvc1JlcXVlc3RDb25maWdbJ3BhcmFtcyddLFxuICApID0+IHtcbiAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdDxULCBEPigncHV0JywgdXJsLCBkYXRhLCB7IHBhcmFtcyB9KTtcbiAgfTtcblxuICBwb3N0ID0gPFQsIEQgPSB1bmtub3duPihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBkYXRhPzogRCxcbiAgICBwYXJhbXM/OiBBeGlvc1JlcXVlc3RDb25maWdbJ3BhcmFtcyddLFxuICApID0+IHtcbiAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdDxULCBEPigncG9zdCcsIHVybCwgZGF0YSwgeyBwYXJhbXMgfSk7XG4gIH07XG5cbiAgcGF0Y2ggPSA8VCwgRCA9IHVua25vd24+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGRhdGE/OiBELFxuICAgIHBhcmFtcz86IEF4aW9zUmVxdWVzdENvbmZpZ1sncGFyYW1zJ10sXG4gICkgPT4ge1xuICAgIHJldHVybiB0aGlzLmRvQXhpb3NSZXF1ZXN0PFQsIEQ+KCdwYXRjaCcsIHVybCwgZGF0YSwgeyBwYXJhbXMgfSk7XG4gIH07XG5cbiAgZGVsZXRlID0gPFQ+KHVybDogc3RyaW5nLCBwYXJhbXM/OiBBeGlvc1JlcXVlc3RDb25maWdbJ3BhcmFtcyddKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuZG9BeGlvc1JlcXVlc3Q8VCwgdW5rbm93bj4oJ2RlbGV0ZScsIHVybCwgbnVsbCwge1xuICAgICAgcGFyYW1zLFxuICAgIH0pO1xuICB9O1xuXG4gIGVycm9yRnJvbVJlc3BvbnNlID0gKFxuICAgIHJlc3BvbnNlOiBBeGlvc1Jlc3BvbnNlPEFQSUVycm9yUmVzcG9uc2U+LFxuICApOiBFcnJvckZyb21SZXNwb25zZTxBUElFcnJvclJlc3BvbnNlPiA9PiB7XG4gICAgbGV0IGVycjogRXJyb3JGcm9tUmVzcG9uc2U8QVBJRXJyb3JSZXNwb25zZT47XG4gICAgZXJyID0gbmV3IEVycm9yRnJvbVJlc3BvbnNlKGBTdHJlYW0gZXJyb3IgSFRUUCBjb2RlOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmNvZGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgYFN0cmVhbSBlcnJvciBjb2RlICR7cmVzcG9uc2UuZGF0YS5jb2RlfTogJHtyZXNwb25zZS5kYXRhLm1lc3NhZ2V9YCxcbiAgICAgICk7XG4gICAgICBlcnIuY29kZSA9IHJlc3BvbnNlLmRhdGEuY29kZTtcbiAgICB9XG4gICAgZXJyLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgZXJyLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICByZXR1cm4gZXJyO1xuICB9O1xuXG4gIGhhbmRsZVJlc3BvbnNlID0gPFQ+KHJlc3BvbnNlOiBBeGlvc1Jlc3BvbnNlPFQ+KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgaWYgKGlzRXJyb3JSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JGcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBkaXNwYXRjaEV2ZW50ID0gKGV2ZW50OiBTdHJlYW1WaWRlb0V2ZW50KSA9PiB7XG4gICAgaWYgKCFldmVudC5yZWNlaXZlZF9hdCkgZXZlbnQucmVjZWl2ZWRfYXQgPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBEaXNwYXRjaGluZyBldmVudDogJHtldmVudC50eXBlfWAsIGV2ZW50KTtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAvLyBjYWxsIGdlbmVyaWMgbGlzdGVuZXJzXG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycy5hbGwgfHwgW10pIHtcbiAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBjYWxsIHR5cGUgc3BlY2lmaWMgbGlzdGVuZXJzXG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSB8fCBbXSkge1xuICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbm5lY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnVzZXJJRCB8fCAhdGhpcy5fdXNlcikge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdDYWxsIGNvbm5lY3RVc2VyIG9yIGNvbm5lY3RBbm9ueW1vdXNVc2VyIGJlZm9yZSBzdGFydGluZyB0aGUgY29ubmVjdGlvbicsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMud3NCYXNlVVJMKSB7XG4gICAgICB0aHJvdyBFcnJvcignV2Vic29ja2V0IGJhc2UgdXJsIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsaWVudElEKSB7XG4gICAgICB0aHJvdyBFcnJvcignY2xpZW50SUQgaXMgbm90IHNldCcpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICF0aGlzLndzQ29ubmVjdGlvbiAmJlxuICAgICAgKHRoaXMub3B0aW9ucy53YXJtVXAgfHwgdGhpcy5vcHRpb25zLmVuYWJsZUluc2lnaHRzKVxuICAgICkge1xuICAgICAgdGhpcy5fc2F5SGkoKTtcbiAgICB9XG4gICAgLy8gVGhlIFN0YWJsZVdTQ29ubmVjdGlvbiBoYW5kbGVzIGFsbCB0aGUgcmVjb25uZWN0aW9uIGxvZ2ljLlxuICAgIGlmICh0aGlzLm9wdGlvbnMud3NDb25uZWN0aW9uICYmIHRoaXMubm9kZSkge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBhdm9pZGluZyBhZGRpbmcgdHMgZ2VuZXJpY3Mgb24gd3NDb25uZWN0aW9uIGluIG9wdGlvbnMgc2luY2UgaXRzIG9ubHkgdXNlZnVsIGZvciB1bml0IHRlc3QgcHVycG9zZS5cbiAgICAgICh0aGlzLm9wdGlvbnMud3NDb25uZWN0aW9uIGFzIHVua25vd24gYXMgU3RhYmxlV1NDb25uZWN0aW9uKS5zZXRDbGllbnQoXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuICAgICAgdGhpcy53c0Nvbm5lY3Rpb24gPSB0aGlzLm9wdGlvbnNcbiAgICAgICAgLndzQ29ubmVjdGlvbiBhcyB1bmtub3duIGFzIFN0YWJsZVdTQ29ubmVjdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53c0Nvbm5lY3Rpb24gPSBuZXcgU3RhYmxlV1NDb25uZWN0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZiBmYWxsYmFjayBpcyB1c2VkIGJlZm9yZSwgY29udGludWUgdXNpbmcgaXQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBXUyB0byBmYWlsXG4gICAgICBpZiAodGhpcy53c0ZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndzRmFsbGJhY2suY29ubmVjdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnU3RyZWFtQ2xpZW50LmNvbm5lY3Q6IHRoaXMud3NDb25uZWN0aW9uLmNvbm5lY3QoKScpO1xuICAgICAgLy8gaWYgV1NGYWxsYmFjayBpcyBlbmFibGVkLCB3cyBjb25uZWN0IHNob3VsZCB0aW1lb3V0IGZhc3RlciBzbyBmYWxsYmFjayBjYW4gdHJ5XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy53c0Nvbm5lY3Rpb24uY29ubmVjdChcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2tcbiAgICAgICAgICA/IHRoaXMuZGVmYXVsdFdTVGltZW91dFdpdGhGYWxsYmFja1xuICAgICAgICAgIDogdGhpcy5kZWZhdWx0V1NUaW1lb3V0LFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHJ1biBmYWxsYmFjayBvbmx5IGlmIGl0J3MgV1MvTmV0d29yayBlcnJvciBhbmQgbm90IGEgbm9ybWFsIEFQSSBlcnJvclxuICAgICAgLy8gbWFrZSBzdXJlIGJyb3dzZXIgaXMgb25saW5lIGJlZm9yZSBldmVuIHRyeWluZyB0aGUgbG9uZ3BvbGxcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2sgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpc1dTRmFpbHVyZShlcnIpICYmXG4gICAgICAgIGlzT25saW5lKHRoaXMubG9nZ2VyKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICd3YXJuJyxcbiAgICAgICAgICAnY2xpZW50OmNvbm5lY3QoKSAtIFdTIGZhaWxlZCwgZmFsbGJhY2sgdG8gbG9uZ3BvbGwnLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAndHJhbnNwb3J0LmNoYW5nZWQnLCBtb2RlOiAnbG9uZ3BvbGwnIH0pO1xuXG4gICAgICAgIHRoaXMud3NDb25uZWN0aW9uLl9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbigpO1xuICAgICAgICB0aGlzLndzQ29ubmVjdGlvbi5kaXNjb25uZWN0KCkudGhlbigpOyAvLyBjbG9zZSBXUyBzbyBubyByZXRyeVxuICAgICAgICB0aGlzLndzRmFsbGJhY2sgPSBuZXcgV1NDb25uZWN0aW9uRmFsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndzRmFsbGJhY2suY29ubmVjdCgpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgY29ubmVjdGl2aXR5IHdpdGggc2VydmVyIGZvciB3YXJtdXAgcHVycG9zZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXlIaSA9ICgpID0+IHtcbiAgICBjb25zdCBjbGllbnRfcmVxdWVzdF9pZCA9IHJhbmRvbUlkKCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGhlYWRlcnM6IEF4aW9zSGVhZGVycy5mcm9tKHtcbiAgICAgICAgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiBjbGllbnRfcmVxdWVzdF9pZCxcbiAgICAgIH0pLFxuICAgIH07XG4gICAgdGhpcy5kb0F4aW9zUmVxdWVzdCgnZ2V0JywgdGhpcy5iYXNlVVJMICsgJy9oaScsIG51bGwsIG9wdHMpLmNhdGNoKChlKSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUluc2lnaHRzKSB7XG4gICAgICAgIHBvc3RJbnNpZ2h0cygnaHR0cF9oaV9mYWlsZWQnLCB7XG4gICAgICAgICAgYXBpX2tleTogdGhpcy5rZXksXG4gICAgICAgICAgZXJyOiBlLFxuICAgICAgICAgIGNsaWVudF9yZXF1ZXN0X2lkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBnZXRVc2VyQWdlbnQgPSAoKSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MuZW52LlBLR19WRVJTSU9OIHx8ICcwLjAuMC1kZXZlbG9wbWVudCc7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMudXNlckFnZW50IHx8XG4gICAgICBgc3RyZWFtLXZpZGVvLWphdmFzY3JpcHQtY2xpZW50LSR7XG4gICAgICAgIHRoaXMubm9kZSA/ICdub2RlJyA6ICdicm93c2VyJ1xuICAgICAgfS0ke3ZlcnNpb259YFxuICAgICk7XG4gIH07XG5cbiAgc2V0VXNlckFnZW50ID0gKHVzZXJBZ2VudDogc3RyaW5nKSA9PiB7XG4gICAgdGhpcy51c2VyQWdlbnQgPSB1c2VyQWdlbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc1VzaW5nU2VydmVyQXV0aCAtIFJldHVybnMgdHJ1ZSBpZiB3ZSdyZSB1c2luZyBzZXJ2ZXIgc2lkZSBhdXRoXG4gICAqL1xuICBfaXNVc2luZ1NlcnZlckF1dGggPSAoKSA9PiAhIXRoaXMuc2VjcmV0O1xuXG4gIF9lbnJpY2hBeGlvc09wdGlvbnMgPSAoXG4gICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnICYgeyBjb25maWc/OiBBeGlvc1JlcXVlc3RDb25maWcgfSAmIHtcbiAgICAgIHB1YmxpY0VuZHBvaW50PzogYm9vbGVhbjtcbiAgICB9ID0ge1xuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgY29uZmlnOiB7fSxcbiAgICB9LFxuICApOiBBeGlvc1JlcXVlc3RDb25maWcgPT4ge1xuICAgIGNvbnN0IHRva2VuID1cbiAgICAgIG9wdGlvbnMucHVibGljRW5kcG9pbnQgJiYgIXRoaXMudXNlciA/IHVuZGVmaW5lZCA6IHRoaXMuX2dldFRva2VuKCk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IHRva2VuID8geyBBdXRob3JpemF0aW9uOiB0b2tlbiB9IDogdW5kZWZpbmVkO1xuICAgIGxldCBzaWduYWw6IEFib3J0U2lnbmFsIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKHRoaXMubmV4dFJlcXVlc3RBYm9ydENvbnRyb2xsZXIgIT09IG51bGwpIHtcbiAgICAgIHNpZ25hbCA9IHRoaXMubmV4dFJlcXVlc3RBYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgdGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnM/LlsneC1jbGllbnQtcmVxdWVzdC1pZCddKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiByYW5kb21JZCgpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHVzZXJfaWQ6IHRoaXMudXNlcklELFxuICAgICAgICBjb25uZWN0aW9uX2lkOiB0aGlzLl9nZXRDb25uZWN0aW9uSUQoKSxcbiAgICAgICAgYXBpX2tleTogdGhpcy5rZXksXG4gICAgICAgIC4uLm9wdGlvbnMucGFyYW1zLFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uYXV0aG9yaXphdGlvbixcbiAgICAgICAgJ3N0cmVhbS1hdXRoLXR5cGUnOlxuICAgICAgICAgIG9wdGlvbnMucHVibGljRW5kcG9pbnQgJiYgIXRoaXMudXNlclxuICAgICAgICAgICAgPyAnYW5vbnltb3VzJ1xuICAgICAgICAgICAgOiB0aGlzLmdldEF1dGhUeXBlKCksXG4gICAgICAgICdYLVN0cmVhbS1DbGllbnQnOiB0aGlzLmdldFVzZXJBZ2VudCgpLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICB9LFxuICAgICAgLi4uKHNpZ25hbCA/IHsgc2lnbmFsIH0gOiB7fSksXG4gICAgICAuLi5vcHRpb25zLmNvbmZpZyxcbiAgICAgIC4uLnRoaXMub3B0aW9ucy5heGlvc1JlcXVlc3RDb25maWcsXG4gICAgfTtcbiAgfTtcblxuICBfZ2V0VG9rZW4gPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnRva2VuTWFuYWdlcikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdGhpcy50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oKTtcbiAgfTtcblxuICAvKipcbiAgICogZW5jb2RlIHdzIHVybCBwYXlsb2FkXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIGpzb24gc3RyaW5nXG4gICAqL1xuICBfYnVpbGRXU1BheWxvYWQgPSAoY2xpZW50X3JlcXVlc3RfaWQ/OiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdXNlcl9pZDogdGhpcy51c2VySUQsXG4gICAgICB1c2VyX2RldGFpbHM6IHRoaXMuX3VzZXIsXG4gICAgICBjbGllbnRfcmVxdWVzdF9pZCxcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogY3JlYXRlcyBhbiBhYm9ydCBjb250cm9sbGVyIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBuZXh0IEhUVFAgUmVxdWVzdC5cbiAgICovXG4gIGNyZWF0ZUFib3J0Q29udHJvbGxlckZvck5leHRSZXF1ZXN0ID0gKCkgPT4ge1xuICAgIHJldHVybiAodGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSk7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBDYWxsIH0gZnJvbSAnLi9DYWxsJztcbmltcG9ydCB7IFN0cmVhbUNsaWVudCB9IGZyb20gJy4vY29vcmRpbmF0b3IvY29ubmVjdGlvbi9jbGllbnQnO1xuaW1wb3J0IHtcbiAgU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUsXG4gIFN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZSxcbn0gZnJvbSAnLi9zdG9yZSc7XG5pbXBvcnQgdHlwZSB7XG4gIENvbm5lY3RlZEV2ZW50LFxuICBDcmVhdGVEZXZpY2VSZXF1ZXN0LFxuICBDcmVhdGVHdWVzdFJlcXVlc3QsXG4gIENyZWF0ZUd1ZXN0UmVzcG9uc2UsXG4gIEdldEVkZ2VzUmVzcG9uc2UsXG4gIExpc3REZXZpY2VzUmVzcG9uc2UsXG4gIFF1ZXJ5Q2FsbHNSZXF1ZXN0LFxuICBRdWVyeUNhbGxzUmVzcG9uc2UsXG4gIFF1ZXJ5Q2FsbFN0YXRzUmVxdWVzdCxcbiAgUXVlcnlDYWxsU3RhdHNSZXNwb25zZSxcbn0gZnJvbSAnLi9nZW4vY29vcmRpbmF0b3InO1xuaW1wb3J0IHtcbiAgQWxsQ2xpZW50RXZlbnRzLFxuICBDbGllbnRFdmVudExpc3RlbmVyLFxuICBMb2dnZXIsXG4gIExvZ0xldmVsLFxuICBTdHJlYW1DbGllbnRPcHRpb25zLFxuICBUb2tlbk9yUHJvdmlkZXIsXG4gIFRva2VuUHJvdmlkZXIsXG4gIFVzZXIsXG4gIFVzZXJXaXRoSWQsXG59IGZyb20gJy4vY29vcmRpbmF0b3IvY29ubmVjdGlvbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIsIGxvZ1RvQ29uc29sZSwgc2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgZ2V0U2RrSW5mbyB9IGZyb20gJy4vY2xpZW50LWRldGFpbHMnO1xuaW1wb3J0IHsgU2RrVHlwZSB9IGZyb20gJy4vZ2VuL3ZpZGVvL3NmdS9tb2RlbHMvbW9kZWxzJztcblxuLyoqXG4gKiBBIGBTdHJlYW1WaWRlb0NsaWVudGAgaW5zdGFuY2UgbGV0cyB5b3UgY29tbXVuaWNhdGUgd2l0aCBvdXIgQVBJLCBhbmQgYXV0aGVudGljYXRlIHVzZXJzLlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtVmlkZW9DbGllbnQge1xuICAvKipcbiAgICogQSByZWFjdGl2ZSBzdG9yZSB0aGF0IGV4cG9zZXMgYWxsIHRoZSBzdGF0ZSB2YXJpYWJsZXMgaW4gYSByZWFjdGl2ZSBtYW5uZXIgLSB5b3UgY2FuIHN1YnNjcmliZSB0byBjaGFuZ2VzIG9mIHRoZSBkaWZmZXJlbnQgc3RhdGUgdmFyaWFibGVzLiBPdXIgbGlicmFyeSBpcyBidWlsdCBpbiBhIHdheSB0aGF0IGFsbCBzdGF0ZSBjaGFuZ2VzIGFyZSBleHBvc2VkIGluIHRoaXMgc3RvcmUsIHNvIGFsbCBVSSBjaGFuZ2VzIGluIHlvdXIgYXBwbGljYXRpb24gc2hvdWxkIGJlIGhhbmRsZWQgYnkgc3Vic2NyaWJpbmcgdG8gdGhlc2UgdmFyaWFibGVzLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVhZE9ubHlTdGF0ZVN0b3JlOiBTdHJlYW1WaWRlb1JlYWRPbmx5U3RhdGVTdG9yZTtcbiAgcmVhZG9ubHkgbG9nTGV2ZWw6IExvZ0xldmVsID0gJ3dhcm4nO1xuICByZWFkb25seSBsb2dnZXI6IExvZ2dlcjtcblxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgd3JpdGVhYmxlU3RhdGVTdG9yZTogU3RyZWFtVmlkZW9Xcml0ZWFibGVTdGF0ZVN0b3JlO1xuICBzdHJlYW1DbGllbnQ6IFN0cmVhbUNsaWVudDtcblxuICBwcm90ZWN0ZWQgZXZlbnRIYW5kbGVyc1RvVW5yZWdpc3RlcjogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcbiAgcHJvdGVjdGVkIGNvbm5lY3Rpb25Qcm9taXNlOiBQcm9taXNlPHZvaWQgfCBDb25uZWN0ZWRFdmVudD4gfCB1bmRlZmluZWQ7XG4gIHByb3RlY3RlZCBkaXNjb25uZWN0aW9uUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogWW91IHNob3VsZCBjcmVhdGUgb25seSBvbmUgaW5zdGFuY2Ugb2YgYFN0cmVhbVZpZGVvQ2xpZW50YC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFwaUtleTogc3RyaW5nLCBvcHRzPzogU3RyZWFtQ2xpZW50T3B0aW9ucyk7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IHtcbiAgICBhcGlLZXk6IHN0cmluZztcbiAgICBvcHRpb25zPzogU3RyZWFtQ2xpZW50T3B0aW9ucztcbiAgICB1c2VyPzogVXNlcjtcbiAgICB0b2tlbj86IHN0cmluZztcbiAgICB0b2tlblByb3ZpZGVyPzogVG9rZW5Qcm92aWRlcjtcbiAgfSk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwaUtleU9yQXJnczpcbiAgICAgIHwgc3RyaW5nXG4gICAgICB8IHtcbiAgICAgICAgICBhcGlLZXk6IHN0cmluZztcbiAgICAgICAgICBvcHRpb25zPzogU3RyZWFtQ2xpZW50T3B0aW9ucztcbiAgICAgICAgICB1c2VyPzogVXNlcjtcbiAgICAgICAgICB0b2tlbj86IHN0cmluZztcbiAgICAgICAgICB0b2tlblByb3ZpZGVyPzogVG9rZW5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICBvcHRzPzogU3RyZWFtQ2xpZW50T3B0aW9ucyxcbiAgKSB7XG4gICAgbGV0IGxvZ2dlcjogTG9nZ2VyID0gbG9nVG9Db25zb2xlO1xuICAgIGxldCBsb2dMZXZlbDogTG9nTGV2ZWwgPSAnd2Fybic7XG4gICAgaWYgKHR5cGVvZiBhcGlLZXlPckFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsb2dMZXZlbCA9IG9wdHM/LmxvZ0xldmVsIHx8IGxvZ0xldmVsO1xuICAgICAgbG9nZ2VyID0gb3B0cz8ubG9nZ2VyIHx8IGxvZ2dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nTGV2ZWwgPSBhcGlLZXlPckFyZ3Mub3B0aW9ucz8ubG9nTGV2ZWwgfHwgbG9nTGV2ZWw7XG4gICAgICBsb2dnZXIgPSBhcGlLZXlPckFyZ3Mub3B0aW9ucz8ubG9nZ2VyIHx8IGxvZ2dlcjtcbiAgICB9XG5cbiAgICBzZXRMb2dnZXIobG9nZ2VyLCBsb2dMZXZlbCk7XG4gICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydjbGllbnQnXSk7XG5cbiAgICBpZiAodHlwZW9mIGFwaUtleU9yQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gbmV3IFN0cmVhbUNsaWVudChhcGlLZXlPckFyZ3MsIHtcbiAgICAgICAgcGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlOiB0cnVlLFxuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IG5ldyBTdHJlYW1DbGllbnQoYXBpS2V5T3JBcmdzLmFwaUtleSwge1xuICAgICAgICBwZXJzaXN0VXNlck9uQ29ubmVjdGlvbkZhaWx1cmU6IHRydWUsXG4gICAgICAgIC4uLmFwaUtleU9yQXJncy5vcHRpb25zLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzZGtJbmZvID0gZ2V0U2RrSW5mbygpO1xuICAgICAgaWYgKHNka0luZm8pIHtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQuc2V0VXNlckFnZW50KFxuICAgICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50LmdldFVzZXJBZ2VudCgpICtcbiAgICAgICAgICAgIGAtdmlkZW8tJHtTZGtUeXBlW3Nka0luZm8udHlwZV0udG9Mb3dlckNhc2UoKX0tc2RrLSR7XG4gICAgICAgICAgICAgIHNka0luZm8ubWFqb3JcbiAgICAgICAgICAgIH0uJHtzZGtJbmZvLm1pbm9yfS4ke3Nka0luZm8ucGF0Y2h9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUgPSBuZXcgU3RyZWFtVmlkZW9Xcml0ZWFibGVTdGF0ZVN0b3JlKCk7XG4gICAgdGhpcy5yZWFkT25seVN0YXRlU3RvcmUgPSBuZXcgU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUoXG4gICAgICB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgKTtcblxuICAgIGlmICh0eXBlb2YgYXBpS2V5T3JBcmdzICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdXNlciA9IGFwaUtleU9yQXJncy51c2VyO1xuICAgICAgY29uc3QgdG9rZW4gPSBhcGlLZXlPckFyZ3MudG9rZW4gfHwgYXBpS2V5T3JBcmdzLnRva2VuUHJvdmlkZXI7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICB0aGlzLmNvbm5lY3RVc2VyKHVzZXIsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSByZWFjdGl2ZSBzdGF0ZSBzdG9yZSwgdXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gYmUgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0byB0aGUgY2xpZW50IHN0YXRlXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZE9ubHlTdGF0ZVN0b3JlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBnaXZlbiB1c2VyIHRvIHRoZSBjbGllbnQuXG4gICAqIE9ubHkgb25lIHVzZXIgY2FuIGNvbm5lY3QgYXQgYSB0aW1lLCBpZiB5b3Ugd2FudCB0byBjaGFuZ2UgdXNlcnMsIGNhbGwgYGRpc2Nvbm5lY3RVc2VyYCBiZWZvcmUgY29ubmVjdGluZyBhIG5ldyB1c2VyLlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgY29ubmVjdGVkIHVzZXIgW3N0YXRlIHZhcmlhYmxlXSgjcmVhZG9ubHlzdGF0ZXN0b3JlKSB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyIHRoZSB1c2VyIHRvIGNvbm5lY3QuXG4gICAqIEBwYXJhbSB0b2tlbiBhIHRva2VuIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdG9rZW4uXG4gICAqL1xuICBhc3luYyBjb25uZWN0VXNlcihcbiAgICB1c2VyOiBVc2VyLFxuICAgIHRva2VuPzogVG9rZW5PclByb3ZpZGVyLFxuICApOiBQcm9taXNlPHZvaWQgfCBDb25uZWN0ZWRFdmVudD4ge1xuICAgIGlmICh1c2VyLnR5cGUgPT09ICdhbm9ueW1vdXMnKSB7XG4gICAgICB1c2VyLmlkID0gJyFhbm9uJztcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RBbm9ueW1vdXNVc2VyKHVzZXIgYXMgVXNlcldpdGhJZCwgdG9rZW4pO1xuICAgIH1cbiAgICBsZXQgY29ubmVjdFVzZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuY29ubmVjdFVzZXIodXNlciwgdG9rZW4pO1xuICAgIH07XG4gICAgaWYgKHVzZXIudHlwZSA9PT0gJ2d1ZXN0Jykge1xuICAgICAgY29ubmVjdFVzZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5jb25uZWN0R3Vlc3RVc2VyKHVzZXIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuZGlzY29ubmVjdGlvblByb21pc2VcbiAgICAgID8gdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IGNvbm5lY3RVc2VyKCkpXG4gICAgICA6IGNvbm5lY3RVc2VyKCk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlPy5maW5hbGx5KCgpID0+ICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkKSk7XG4gICAgY29uc3QgY29ubmVjdFVzZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgLy8gY29ubmVjdFVzZXJSZXNwb25zZSB3aWxsIGJlIHZvaWQgaWYgY29ubmVjdFVzZXIgY2FsbGVkIHR3aWNlIGZvciB0aGUgc2FtZSB1c2VyXG4gICAgaWYgKGNvbm5lY3RVc2VyUmVzcG9uc2U/Lm1lKSB7XG4gICAgICB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUuc2V0Q29ubmVjdGVkVXNlcihjb25uZWN0VXNlclJlc3BvbnNlLm1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIucHVzaChcbiAgICAgIHRoaXMub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQub25saW5lKSB7XG4gICAgICAgICAgY29uc3QgY2FsbHNUb1JlV2F0Y2ggPSB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUuY2FsbHNcbiAgICAgICAgICAgIC5maWx0ZXIoKGNhbGwpID0+IGNhbGwud2F0Y2hpbmcpXG4gICAgICAgICAgICAubWFwKChjYWxsKSA9PiBjYWxsLmNpZCk7XG5cbiAgICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgIGBSZXdhdGNoaW5nIGNhbGxzIGFmdGVyIGNvbm5lY3Rpb24gY2hhbmdlZCAke2NhbGxzVG9SZVdhdGNoLmpvaW4oXG4gICAgICAgICAgICAgICcsICcsXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoY2FsbHNUb1JlV2F0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeUNhbGxzKHtcbiAgICAgICAgICAgICAgd2F0Y2g6IHRydWUsXG4gICAgICAgICAgICAgIGZpbHRlcl9jb25kaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgY2lkOiB7ICRpbjogY2FsbHNUb1JlV2F0Y2ggfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc29ydDogW3sgZmllbGQ6ICdjaWQnLCBkaXJlY3Rpb246IDEgfV0sXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gcmUtd2F0Y2ggY2FsbHMnLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyLnB1c2goXG4gICAgICB0aGlzLm9uKCdjYWxsLmNyZWF0ZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBjYWxsLCBtZW1iZXJzIH0gPSBldmVudDtcbiAgICAgICAgaWYgKHVzZXIuaWQgPT09IGNhbGwuY3JlYXRlZF9ieS5pZCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICAgICAgJ3dhcm4nLFxuICAgICAgICAgICAgJ1JlY2VpdmVkIGBjYWxsLmNyZWF0ZWRgIHNlbnQgYnkgdGhlIGN1cnJlbnQgdXNlcicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBOZXcgY2FsbCBjcmVhdGVkIGFuZCByZWdpc3RlcmVkOiAke2NhbGwuY2lkfWApO1xuICAgICAgICBjb25zdCBuZXdDYWxsID0gbmV3IENhbGwoe1xuICAgICAgICAgIHN0cmVhbUNsaWVudDogdGhpcy5zdHJlYW1DbGllbnQsXG4gICAgICAgICAgdHlwZTogY2FsbC50eXBlLFxuICAgICAgICAgIGlkOiBjYWxsLmlkLFxuICAgICAgICAgIG1lbWJlcnMsXG4gICAgICAgICAgY2xpZW50U3RvcmU6IHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NhbGwuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjYWxsKTtcbiAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnJlZ2lzdGVyQ2FsbChuZXdDYWxsKTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIucHVzaChcbiAgICAgIHRoaXMub24oJ2NhbGwucmluZycsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGNhbGwsIG1lbWJlcnMgfSA9IGV2ZW50O1xuICAgICAgICBpZiAodXNlci5pZCA9PT0gY2FsbC5jcmVhdGVkX2J5LmlkKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICAnZGVidWcnLFxuICAgICAgICAgICAgJ1JlY2VpdmVkIGBjYWxsLnJpbmdgIHNlbnQgYnkgdGhlIGN1cnJlbnQgdXNlciBzbyBpZ25vcmluZyB0aGUgZXZlbnQnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGNhbGwgbWlnaHQgYWxyZWFkeSBiZSB0cmFja2VkIGJ5IHRoZSBjbGllbnQsXG4gICAgICAgIC8vIGlmIGBjYWxsLmNyZWF0ZWRgIHdhcyByZWNlaXZlZCBiZWZvcmUgYGNhbGwucmluZ2AuXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgY2xlYW51cCB0aGUgYWxyZWFkeSB0cmFja2VkIGNhbGwuXG4gICAgICAgIGNvbnN0IHByZXZDYWxsID0gdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLmZpbmRDYWxsKGNhbGwudHlwZSwgY2FsbC5pZCk7XG4gICAgICAgIGF3YWl0IHByZXZDYWxsPy5sZWF2ZSh7IHJlYXNvbjogJ2NsZWFuaW5nLXVwIGluIGNhbGwucmluZycgfSk7XG4gICAgICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBjYWxsXG4gICAgICAgIGNvbnN0IHRoZUNhbGwgPSBuZXcgQ2FsbCh7XG4gICAgICAgICAgc3RyZWFtQ2xpZW50OiB0aGlzLnN0cmVhbUNsaWVudCxcbiAgICAgICAgICB0eXBlOiBjYWxsLnR5cGUsXG4gICAgICAgICAgaWQ6IGNhbGwuaWQsXG4gICAgICAgICAgbWVtYmVycyxcbiAgICAgICAgICBjbGllbnRTdG9yZTogdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLFxuICAgICAgICAgIHJpbmdpbmc6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGVDYWxsLnN0YXRlLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoY2FsbCk7XG4gICAgICAgIC8vIHdlIGZldGNoIHRoZSBsYXRlc3QgbWV0YWRhdGEgZm9yIHRoZSBjYWxsIGZyb20gdGhlIHNlcnZlclxuICAgICAgICBhd2FpdCB0aGVDYWxsLmdldCgpO1xuICAgICAgICB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUucmVnaXN0ZXJDYWxsKHRoZUNhbGwpO1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIHJldHVybiBjb25uZWN0VXNlclJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIHVzZXIgZnJvbSB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgZGlzY29ubmVjdGVkLCB0aGUgY29ubmVjdGVkIHVzZXIgW3N0YXRlIHZhcmlhYmxlXSgjcmVhZG9ubHlzdGF0ZXN0b3JlKSB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHlcbiAgICpcbiAgICogQHBhcmFtIHRpbWVvdXQgTWF4IG51bWJlciBvZiBtcywgdG8gd2FpdCBmb3IgY2xvc2UgZXZlbnQgb2Ygd2Vic29ja2V0LCBiZWZvcmUgZm9yY2VmdWxseSBhc3N1bWluZyBzdWNjZXNzZnVsIGRpc2Nvbm5lY3Rpb24uXG4gICAqICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50XG4gICAqL1xuICBkaXNjb25uZWN0VXNlciA9IGFzeW5jICh0aW1lb3V0PzogbnVtYmVyKSA9PiB7XG4gICAgaWYgKCF0aGlzLnN0cmVhbUNsaWVudC51c2VyICYmICF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc2Nvbm5lY3RVc2VyID0gKCkgPT4gdGhpcy5zdHJlYW1DbGllbnQuZGlzY29ubmVjdFVzZXIodGltZW91dCk7XG4gICAgdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuY29ubmVjdGlvblByb21pc2VcbiAgICAgID8gdGhpcy5jb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IGRpc2Nvbm5lY3RVc2VyKCkpXG4gICAgICA6IGRpc2Nvbm5lY3RVc2VyKCk7XG4gICAgdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZS5maW5hbGx5KFxuICAgICAgKCkgPT4gKHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQpLFxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZTtcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIuZm9yRWFjaCgodW5yZWdpc3RlcikgPT4gdW5yZWdpc3RlcigpKTtcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIgPSBbXTtcbiAgICB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUuc2V0Q29ubmVjdGVkVXNlcih1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBZb3UgY2FuIHN1YnNjcmliZSB0byBXZWJTb2NrZXQgZXZlbnRzIHByb3ZpZGVkIGJ5IHRoZSBBUEkuXG4gICAqIFRvIHJlbW92ZSBhIHN1YnNjcmlwdGlvbiwgY2FsbCB0aGUgYG9mZmAgbWV0aG9kIG9yLCBleGVjdXRlIHRoZSByZXR1cm5lZCB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbiAgICogUGxlYXNlIG5vdGUgdGhhdCBzdWJzY3JpYmluZyB0byBXZWJTb2NrZXQgZXZlbnRzIGlzIGFuIGFkdmFuY2VkIHVzZS1jYXNlLCBmb3IgbW9zdCB1c2UtY2FzZXMgaXQgc2hvdWxkIGJlIGVub3VnaCB0byB3YXRjaCBmb3IgY2hhbmdlcyBpbiB0aGUgcmVhY3RpdmUgW3N0YXRlIHN0b3JlXSgjcmVhZG9ubHlzdGF0ZXN0b3JlKS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZSBvciAnYWxsJy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLlxuICAgKiBAcmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbiAgICovXG4gIG9uID0gPEUgZXh0ZW5kcyBrZXlvZiBBbGxDbGllbnRFdmVudHM+KFxuICAgIGV2ZW50TmFtZTogRSxcbiAgICBjYWxsYmFjazogQ2xpZW50RXZlbnRMaXN0ZW5lcjxFPixcbiAgKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50Lm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgc3Vic2NyaXB0aW9uIGZvciBXZWJTb2NrZXQgZXZlbnRzIHRoYXQgd2VyZSBjcmVhdGVkIGJ5IHRoZSBgb25gIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayB3aGljaCB3YXMgcGFzc2VkIHRvIHRoZSBgb25gIG1ldGhvZC5cbiAgICovXG4gIG9mZiA9IDxFIGV4dGVuZHMga2V5b2YgQWxsQ2xpZW50RXZlbnRzPihcbiAgICBldmVudE5hbWU6IEUsXG4gICAgY2FsbGJhY2s6IENsaWVudEV2ZW50TGlzdGVuZXI8RT4sXG4gICkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIGNhbGwuXG4gICAqIEBwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIGNhbGwuXG4gICAqL1xuICBjYWxsID0gKHR5cGU6IHN0cmluZywgaWQ6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBuZXcgQ2FsbCh7XG4gICAgICBzdHJlYW1DbGllbnQ6IHRoaXMuc3RyZWFtQ2xpZW50LFxuICAgICAgaWQ6IGlkLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZ3Vlc3QgdXNlciB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGd1ZXN0IHVzZXIuXG4gICAqL1xuICBjcmVhdGVHdWVzdFVzZXIgPSBhc3luYyAoZGF0YTogQ3JlYXRlR3Vlc3RSZXF1ZXN0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmRvQXhpb3NSZXF1ZXN0PFxuICAgICAgQ3JlYXRlR3Vlc3RSZXNwb25zZSxcbiAgICAgIENyZWF0ZUd1ZXN0UmVxdWVzdFxuICAgID4oJ3Bvc3QnLCAnL2d1ZXN0JywgZGF0YSwgeyBwdWJsaWNFbmRwb2ludDogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogV2lsbCBxdWVyeSB0aGUgQVBJIGZvciBjYWxscyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIHF1ZXJ5IGRhdGEuXG4gICAqL1xuICBxdWVyeUNhbGxzID0gYXN5bmMgKGRhdGE6IFF1ZXJ5Q2FsbHNSZXF1ZXN0ID0ge30pID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LnBvc3Q8XG4gICAgICBRdWVyeUNhbGxzUmVzcG9uc2UsXG4gICAgICBRdWVyeUNhbGxzUmVxdWVzdFxuICAgID4oJy9jYWxscycsIGRhdGEpO1xuICAgIGNvbnN0IGNhbGxzID0gcmVzcG9uc2UuY2FsbHMubWFwKChjKSA9PiB7XG4gICAgICBjb25zdCBjYWxsID0gbmV3IENhbGwoe1xuICAgICAgICBzdHJlYW1DbGllbnQ6IHRoaXMuc3RyZWFtQ2xpZW50LFxuICAgICAgICBpZDogYy5jYWxsLmlkLFxuICAgICAgICB0eXBlOiBjLmNhbGwudHlwZSxcbiAgICAgICAgbWVtYmVyczogYy5tZW1iZXJzLFxuICAgICAgICBvd25DYXBhYmlsaXRpZXM6IGMub3duX2NhcGFiaWxpdGllcyxcbiAgICAgICAgd2F0Y2hpbmc6IGRhdGEud2F0Y2gsXG4gICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICB9KTtcbiAgICAgIGNhbGwuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjLmNhbGwpO1xuICAgICAgY2FsbC5hcHBseURldmljZUNvbmZpZygpO1xuICAgICAgaWYgKGRhdGEud2F0Y2gpIHtcbiAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnJlZ2lzdGVyQ2FsbChjYWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGNhbGxzOiBjYWxscyxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgY2FsbCBzdGF0aXN0aWNzIHJlcG9ydHMgbWF0Y2hpbmcgYSBwYXJ0aWN1bGFyIGNvbmRpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgRmlsdGVyIGFuZCBzb3J0IGNvbmRpdGlvbnMgZm9yIHJldHJpZXZpbmcgYXZhaWxhYmxlIGNhbGwgcmVwb3J0IHN1bW1hcmllcy5cbiAgICogQHJldHVybnMgTGlzdCB3aXRoIHN1bW1hcnkgb2YgYXZhaWxhYmxlIGNhbGwgcmVwb3J0cyBtYXRjaGluZyB0aGUgY29uZGl0aW9uLlxuICAgKi9cbiAgcXVlcnlDYWxsU3RhdHMgPSBhc3luYyAoZGF0YTogUXVlcnlDYWxsU3RhdHNSZXF1ZXN0ID0ge30pID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdDxcbiAgICAgIFF1ZXJ5Q2FsbFN0YXRzUmVzcG9uc2UsXG4gICAgICBRdWVyeUNhbGxTdGF0c1JlcXVlc3RcbiAgICA+KGAvY2FsbC9zdGF0c2AsIGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgZGF0YSBjZW50ZXJzIGF2YWlsYWJsZSBmb3IgaG9zdGluZyBjYWxscy5cbiAgICovXG4gIGVkZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQ8R2V0RWRnZXNSZXNwb25zZT4oYC9lZGdlc2ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBhZGREZXZpY2UgLSBBZGRzIGEgcHVzaCBkZXZpY2UgZm9yIGEgdXNlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBkZXZpY2UgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1c2hfcHJvdmlkZXIgdGhlIHB1c2ggcHJvdmlkZXIgbmFtZSAoZWcuIGFwbiwgZmlyZWJhc2UpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdXNoX3Byb3ZpZGVyX25hbWUgdXNlciBwcm92aWRlZCBwdXNoIHByb3ZpZGVyIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VySURdIHRoZSB1c2VyIGlkIChkZWZhdWx0cyB0byBjdXJyZW50IHVzZXIpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZvaXBfdG9rZW5dIGVuYWJsZXMgdXNlIG9mIFZvSVAgdG9rZW4gZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBvbiBpT1MgcGxhdGZvcm1cbiAgICovXG4gIGFkZERldmljZSA9IGFzeW5jIChcbiAgICBpZDogc3RyaW5nLFxuICAgIHB1c2hfcHJvdmlkZXI6IHN0cmluZyxcbiAgICBwdXNoX3Byb3ZpZGVyX25hbWU/OiBzdHJpbmcsXG4gICAgdXNlcklEPzogc3RyaW5nLFxuICAgIHZvaXBfdG9rZW4/OiBib29sZWFuLFxuICApID0+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zdHJlYW1DbGllbnQucG9zdDxDcmVhdGVEZXZpY2VSZXF1ZXN0PignL2RldmljZXMnLCB7XG4gICAgICBpZCxcbiAgICAgIHB1c2hfcHJvdmlkZXIsXG4gICAgICB2b2lwX3Rva2VuLFxuICAgICAgLi4uKHVzZXJJRCAhPSBudWxsID8geyB1c2VyX2lkOiB1c2VySUQgfSA6IHt9KSxcbiAgICAgIC4uLihwdXNoX3Byb3ZpZGVyX25hbWUgIT0gbnVsbCA/IHsgcHVzaF9wcm92aWRlcl9uYW1lIH0gOiB7fSksXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZERldmljZSAtIEFkZHMgYSBwdXNoIGRldmljZSBmb3IgYSB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGRldmljZSBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHVzaF9wcm92aWRlciB0aGUgcHVzaCBwcm92aWRlciBuYW1lIChlZy4gYXBuLCBmaXJlYmFzZSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1c2hfcHJvdmlkZXJfbmFtZSB1c2VyIHByb3ZpZGVkIHB1c2ggcHJvdmlkZXIgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJJRF0gdGhlIHVzZXIgaWQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgdXNlcilcbiAgICovXG4gIGFzeW5jIGFkZFZvaXBEZXZpY2UoXG4gICAgaWQ6IHN0cmluZyxcbiAgICBwdXNoX3Byb3ZpZGVyOiBzdHJpbmcsXG4gICAgcHVzaF9wcm92aWRlcl9uYW1lOiBzdHJpbmcsXG4gICAgdXNlcklEPzogc3RyaW5nLFxuICApIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGREZXZpY2UoXG4gICAgICBpZCxcbiAgICAgIHB1c2hfcHJvdmlkZXIsXG4gICAgICBwdXNoX3Byb3ZpZGVyX25hbWUsXG4gICAgICB1c2VySUQsXG4gICAgICB0cnVlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0RGV2aWNlcyAtIFJldHVybnMgdGhlIGRldmljZXMgYXNzb2NpYXRlZCB3aXRoIGEgY3VycmVudCB1c2VyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcklEXSBVc2VyIElELiBPbmx5IHdvcmtzIG9uIHNlcnZlcnNpZGVcbiAgICovXG4gIGdldERldmljZXMgPSBhc3luYyAodXNlcklEPzogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LmdldDxMaXN0RGV2aWNlc1Jlc3BvbnNlPihcbiAgICAgICcvZGV2aWNlcycsXG4gICAgICB1c2VySUQgPyB7IHVzZXJfaWQ6IHVzZXJJRCB9IDoge30sXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogcmVtb3ZlRGV2aWNlIC0gUmVtb3ZlcyB0aGUgZGV2aWNlIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGRldmljZSBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJJRF0gVGhlIHVzZXIgaWQuIE9ubHkgc3BlY2lmeSB0aGlzIGZvciBzZXJ2ZXJzaWRlIHJlcXVlc3RzXG4gICAqL1xuICByZW1vdmVEZXZpY2UgPSBhc3luYyAoaWQ6IHN0cmluZywgdXNlcklEPzogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LmRlbGV0ZSgnL2RldmljZXMnLCB7XG4gICAgICBpZCxcbiAgICAgIC4uLih1c2VySUQgPyB7IHVzZXJfaWQ6IHVzZXJJRCB9IDoge30pLFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHJpbmdpbmcgY2FsbHMgZnJvbSBwdXNoIG5vdGlmaWNhdGlvbnMuIElmIHRoZSBjYWxsIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGRvIG5vdGhpbmcuXG4gICAqIEBwYXJhbSBjYWxsX2NpZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgb25SaW5naW5nQ2FsbCA9IGFzeW5jIChjYWxsX2NpZDogc3RyaW5nKSA9PiB7XG4gICAgLy8gaWYgd2UgZmluZCB0aGUgY2FsbCBhbmQgaXMgYWxyZWFkeSByaW5naW5nLCB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBjYWxsXG4gICAgLy8gYXMgY2xpZW50IHdvdWxkIGhhdmUgcmVjZWl2ZWQgdGhlIGNhbGwucmluZyBzdGF0ZSBiZWNhdXNlIHRoZSBhcHAgaGFkIFdTIGFsaXZlIHdoZW4gcmVjZWl2aW5nIHB1c2ggbm90aWZpY2F0aW9uc1xuICAgIGxldCBjYWxsID0gdGhpcy5yZWFkT25seVN0YXRlU3RvcmUuY2FsbHMuZmluZChcbiAgICAgIChjKSA9PiBjLmNpZCA9PT0gY2FsbF9jaWQgJiYgYy5yaW5naW5nLFxuICAgICk7XG4gICAgaWYgKCFjYWxsKSB7XG4gICAgICAvLyBpZiBub3QgaXQgbWVhbnMgdGhhdCBXUyBpcyBub3QgYWxpdmUgd2hlbiByZWNlaXZpbmcgdGhlIHB1c2ggbm90aWZpY2F0aW9ucyBhbmQgd2UgbmVlZCB0byBmZXRjaCB0aGUgY2FsbFxuICAgICAgY29uc3QgW2NhbGxUeXBlLCBjYWxsSWRdID0gY2FsbF9jaWQuc3BsaXQoJzonKTtcbiAgICAgIGNhbGwgPSBuZXcgQ2FsbCh7XG4gICAgICAgIHN0cmVhbUNsaWVudDogdGhpcy5zdHJlYW1DbGllbnQsXG4gICAgICAgIHR5cGU6IGNhbGxUeXBlLFxuICAgICAgICBpZDogY2FsbElkLFxuICAgICAgICBjbGllbnRTdG9yZTogdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLFxuICAgICAgICByaW5naW5nOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBjYWxsLmdldCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgZ2l2ZW4gYW5vbnltb3VzIHVzZXIgdG8gdGhlIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHVzZXIgdGhlIHVzZXIgdG8gY29ubmVjdC5cbiAgICogQHBhcmFtIHRva2VuT3JQcm92aWRlciBhIHRva2VuIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdG9rZW4uXG4gICAqL1xuICBwcm90ZWN0ZWQgY29ubmVjdEFub255bW91c1VzZXIgPSBhc3luYyAoXG4gICAgdXNlcjogVXNlcldpdGhJZCxcbiAgICB0b2tlbk9yUHJvdmlkZXI6IFRva2VuT3JQcm92aWRlcixcbiAgKSA9PiB7XG4gICAgY29uc3QgY29ubmVjdEFub255bW91c1VzZXIgPSAoKSA9PlxuICAgICAgdGhpcy5zdHJlYW1DbGllbnQuY29ubmVjdEFub255bW91c1VzZXIodXNlciwgdG9rZW5PclByb3ZpZGVyKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZVxuICAgICAgPyB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4gY29ubmVjdEFub255bW91c1VzZXIoKSlcbiAgICAgIDogY29ubmVjdEFub255bW91c1VzZXIoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLmZpbmFsbHkoKCkgPT4gKHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQpKTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0iLCJTUEVBS0VSIiwiRUFSUElFQ0UiLCJBdWRpb1NldHRpbmdzUmVxdWVzdERlZmF1bHREZXZpY2VFbnVtIiwiQ3JlYXRlRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0iLCJGSVJFQkFTRSIsIkFQTiIsIkhVQVdFSSIsIlhJQU9NSSIsIk93bkNhcGFiaWxpdHkiLCJCTE9DS19VU0VSUyIsIkNSRUFURV9DQUxMIiwiQ1JFQVRFX1JFQUNUSU9OIiwiRU5EX0NBTEwiLCJKT0lOX0JBQ0tTVEFHRSIsIkpPSU5fQ0FMTCIsIkpPSU5fRU5ERURfQ0FMTCIsIk1VVEVfVVNFUlMiLCJQSU5fRk9SX0VWRVJZT05FIiwiUkVBRF9DQUxMIiwiUkVNT1ZFX0NBTExfTUVNQkVSIiwiU0NSRUVOU0hBUkUiLCJTRU5EX0FVRElPIiwiU0VORF9WSURFTyIsIlNUQVJUX0JST0FEQ0FTVF9DQUxMIiwiU1RBUlRfUkVDT1JEX0NBTEwiLCJTVEFSVF9UUkFOU0NSSVBUSU9OX0NBTEwiLCJTVE9QX0JST0FEQ0FTVF9DQUxMIiwiU1RPUF9SRUNPUkRfQ0FMTCIsIlNUT1BfVFJBTlNDUklQVElPTl9DQUxMIiwiVVBEQVRFX0NBTEwiLCJVUERBVEVfQ0FMTF9NRU1CRVIiLCJVUERBVEVfQ0FMTF9QRVJNSVNTSU9OUyIsIlVQREFURV9DQUxMX1NFVFRJTkdTIiwiUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0iLCJBVkFJTEFCTEUiLCJESVNBQkxFRCIsIkFVVE9fT04iLCJSZWNvcmRTZXR0aW5nc1JlcXVlc3RRdWFsaXR5RW51bSIsIl8zNjBQIiwiXzQ4MFAiLCJfNzIwUCIsIl8xMDgwUCIsIl8xNDQwUCIsIlRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtIiwiVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtIiwiVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0iLCJGUk9OVCIsIkJBQ0siLCJFWFRFUk5BTCIsIlZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSIsIkVycm9yRnJvbVJlc3BvbnNlIiwiRXJyb3IiLCJOdWxsVmFsdWUiLCJTdHJ1Y3QkVHlwZSIsIk1lc3NhZ2VUeXBlIiwiY29uc3RydWN0b3IiLCJubyIsIm5hbWUiLCJraW5kIiwiSyIsIlYiLCJUIiwiVmFsdWUiLCJpbnRlcm5hbEpzb25Xcml0ZSIsIm1lc3NhZ2UiLCJvcHRpb25zIiwianNvbiIsImsiLCJ2IiwiT2JqZWN0IiwiZW50cmllcyIsImZpZWxkcyIsInRvSnNvbiIsImludGVybmFsSnNvblJlYWQiLCJ0YXJnZXQiLCJpc0pzb25PYmplY3QiLCJnbG9iYWxUaGlzIiwidHlwZU5hbWUiLCJ0eXBlb2ZKc29uVmFsdWUiLCJjcmVhdGUiLCJmcm9tSnNvbiIsInZhbHVlIiwibWVzc2FnZVByb3RvdHlwZSIsInVuZGVmaW5lZCIsInJlZmxlY3Rpb25NZXJnZVBhcnRpYWwiLCJpbnRlcm5hbEJpbmFyeVJlYWQiLCJyZWFkZXIiLCJsZW5ndGgiLCJlbmQiLCJwb3MiLCJmaWVsZE5vIiwid2lyZVR5cGUiLCJ0YWciLCJiaW5hcnlSZWFkTWFwMSIsInUiLCJyZWFkVW5rbm93bkZpZWxkIiwiZCIsInNraXAiLCJVbmtub3duRmllbGRIYW5kbGVyIiwib25SZWFkIiwibWFwIiwibGVuIiwidWludDMyIiwia2V5IiwidmFsIiwic3RyaW5nIiwiaW50ZXJuYWxCaW5hcnlXcml0ZSIsIndyaXRlciIsImtleXMiLCJXaXJlVHlwZSIsIkxlbmd0aERlbGltaXRlZCIsImZvcmsiLCJqb2luIiwid3JpdGVVbmtub3duRmllbGRzIiwib25Xcml0ZSIsIlN0cnVjdCIsIlZhbHVlJFR5cGUiLCJvbmVvZiIsIkxpc3RWYWx1ZSIsIm9uZW9mS2luZCIsImJvb2xWYWx1ZSIsIm51bWJlclZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzdHJpbmdWYWx1ZSIsImxpc3RWYWx1ZUZpZWxkIiwiZmluZCIsImYiLCJsaXN0VmFsdWUiLCJzdHJ1Y3RWYWx1ZUZpZWxkIiwic3RydWN0VmFsdWUiLCJudWxsVmFsdWUiLCJOVUxMX1ZBTFVFIiwiQXJyYXkiLCJpc0FycmF5IiwiaW50MzIiLCJkb3VibGUiLCJib29sIiwiVmFyaW50IiwiQml0NjQiLCJMaXN0VmFsdWUkVHlwZSIsInJlcGVhdCIsInZhbHVlcyIsInB1c2giLCJpIiwiVGltZXN0YW1wJFR5cGUiLCJub3ciLCJtc2ciLCJtcyIsIkRhdGUiLCJzZWNvbmRzIiwiUGJMb25nIiwiZnJvbSIsIk1hdGgiLCJmbG9vciIsInRvU3RyaW5nIiwibmFub3MiLCJ0b0RhdGUiLCJ0b051bWJlciIsImNlaWwiLCJmcm9tRGF0ZSIsImRhdGUiLCJnZXRUaW1lIiwicGFyc2UiLCJ6IiwibmFub3NTdHIiLCJzdWJzdHJpbmciLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJtYXRjaGVzIiwibWF0Y2giLCJpc05hTiIsInBhcnNlSW50IiwiaW50NjQiLCJUaW1lc3RhbXAiLCJQZWVyVHlwZSIsIkNvbm5lY3Rpb25RdWFsaXR5IiwiVmlkZW9RdWFsaXR5IiwiVHJhY2tUeXBlIiwiRXJyb3JDb2RlIiwiU2RrVHlwZSIsIlRyYWNrVW5wdWJsaXNoUmVhc29uIiwiR29Bd2F5UmVhc29uIiwiQ2FsbFN0YXRlJFR5cGUiLCJQYXJ0aWNpcGFudCIsIlBhcnRpY2lwYW50Q291bnQiLCJQaW4iLCJwYXJ0aWNpcGFudHMiLCJwaW5zIiwic3RhcnRlZEF0IiwicGFydGljaXBhbnRDb3VudCIsIkNhbGxTdGF0ZSIsIlBhcnRpY2lwYW50Q291bnQkVHlwZSIsInRvdGFsIiwiYW5vbnltb3VzIiwiUGluJFR5cGUiLCJ1c2VySWQiLCJzZXNzaW9uSWQiLCJQYXJ0aWNpcGFudCRUeXBlIiwicHVibGlzaGVkVHJhY2tzIiwidHJhY2tMb29rdXBQcmVmaXgiLCJjb25uZWN0aW9uUXVhbGl0eSIsImlzU3BlYWtpbmciLCJpc0RvbWluYW50U3BlYWtlciIsImF1ZGlvTGV2ZWwiLCJpbWFnZSIsInJvbGVzIiwiZSIsImpvaW5lZEF0IiwiZmxvYXQiLCJjdXN0b20iLCJCaXQzMiIsIlN0cmVhbVF1YWxpdHkkVHlwZSIsInZpZGVvUXVhbGl0eSIsIlN0cmVhbVF1YWxpdHkiLCJWaWRlb0RpbWVuc2lvbiRUeXBlIiwid2lkdGgiLCJoZWlnaHQiLCJWaWRlb0RpbWVuc2lvbiIsIlZpZGVvTGF5ZXIkVHlwZSIsInJpZCIsImJpdHJhdGUiLCJmcHMiLCJxdWFsaXR5IiwidmlkZW9EaW1lbnNpb24iLCJWaWRlb0xheWVyIiwiQ29kZWMkVHlwZSIsInBheWxvYWRUeXBlIiwiZm10cExpbmUiLCJjbG9ja1JhdGUiLCJlbmNvZGluZ1BhcmFtZXRlcnMiLCJmZWVkYmFja3MiLCJDb2RlYyIsIklDRVRyaWNrbGUkVHlwZSIsInBlZXJUeXBlIiwiaWNlQ2FuZGlkYXRlIiwiSUNFVHJpY2tsZSIsIlRyYWNrSW5mbyRUeXBlIiwidHJhY2tJZCIsInRyYWNrVHlwZSIsImxheWVycyIsIm1pZCIsImR0eCIsInN0ZXJlbyIsInJlZCIsIlRyYWNrSW5mbyIsIkNhbGwkVHlwZSIsInR5cGUiLCJpZCIsImNyZWF0ZWRCeVVzZXJJZCIsImhvc3RVc2VySWQiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJDYWxsIiwiRXJyb3IkVHlwZSIsImNvZGUiLCJzaG91bGRSZXRyeSIsIkNsaWVudERldGFpbHMkVHlwZSIsIlNkayIsIk9TIiwiQnJvd3NlciIsIkRldmljZSIsInNkayIsIm9zIiwiYnJvd3NlciIsImRldmljZSIsIkNsaWVudERldGFpbHMiLCJTZGskVHlwZSIsIm1ham9yIiwibWlub3IiLCJwYXRjaCIsIk9TJFR5cGUiLCJ2ZXJzaW9uIiwiYXJjaGl0ZWN0dXJlIiwiQnJvd3NlciRUeXBlIiwiRGV2aWNlJFR5cGUiLCJDYWxsR3JhbnRzJFR5cGUiLCJjYW5QdWJsaXNoQXVkaW8iLCJjYW5QdWJsaXNoVmlkZW8iLCJjYW5TY3JlZW5zaGFyZSIsIkNhbGxHcmFudHMiLCJTZW5kU3RhdHNSZXF1ZXN0JFR5cGUiLCJzdWJzY3JpYmVyU3RhdHMiLCJwdWJsaXNoZXJTdGF0cyIsIndlYnJ0Y1ZlcnNpb24iLCJzZGtWZXJzaW9uIiwiU2VuZFN0YXRzUmVxdWVzdCIsIlNlbmRTdGF0c1Jlc3BvbnNlJFR5cGUiLCJlcnJvciIsIlNlbmRTdGF0c1Jlc3BvbnNlIiwiSUNFUmVzdGFydFJlcXVlc3QkVHlwZSIsIklDRVJlc3RhcnRSZXF1ZXN0IiwiSUNFUmVzdGFydFJlc3BvbnNlJFR5cGUiLCJJQ0VSZXN0YXJ0UmVzcG9uc2UiLCJVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCRUeXBlIiwiVHJhY2tNdXRlU3RhdGUiLCJtdXRlU3RhdGVzIiwiVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QiLCJVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UkVHlwZSIsIlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSIsIlRyYWNrTXV0ZVN0YXRlJFR5cGUiLCJtdXRlZCIsIkF1ZGlvTXV0ZUNoYW5nZWQkVHlwZSIsIlZpZGVvTXV0ZUNoYW5nZWQkVHlwZSIsIlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0JFR5cGUiLCJUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMiLCJ0cmFja3MiLCJVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCIsIlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSRUeXBlIiwiVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlIiwiVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzJFR5cGUiLCJkaW1lbnNpb24iLCJTZW5kQW5zd2VyUmVxdWVzdCRUeXBlIiwic2RwIiwiU2VuZEFuc3dlclJlcXVlc3QiLCJTZW5kQW5zd2VyUmVzcG9uc2UkVHlwZSIsIlNlbmRBbnN3ZXJSZXNwb25zZSIsIklDRVRyaWNrbGVSZXNwb25zZSRUeXBlIiwiSUNFVHJpY2tsZVJlc3BvbnNlIiwiU2V0UHVibGlzaGVyUmVxdWVzdCRUeXBlIiwiU2V0UHVibGlzaGVyUmVxdWVzdCIsIlNldFB1Ymxpc2hlclJlc3BvbnNlJFR5cGUiLCJpY2VSZXN0YXJ0IiwiU2V0UHVibGlzaGVyUmVzcG9uc2UiLCJTaWduYWxTZXJ2ZXIiLCJTZXJ2aWNlVHlwZSIsIkkiLCJPIiwiVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHkiLCJTZnVFdmVudCRUeXBlIiwiU3Vic2NyaWJlck9mZmVyIiwiUHVibGlzaGVyQW5zd2VyIiwiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwiQXVkaW9MZXZlbENoYW5nZWQiLCJJQ0VUcmlja2xlJCIsIkNoYW5nZVB1Ymxpc2hRdWFsaXR5IiwiUGFydGljaXBhbnRKb2luZWQiLCJQYXJ0aWNpcGFudExlZnQiLCJEb21pbmFudFNwZWFrZXJDaGFuZ2VkIiwiSm9pblJlc3BvbnNlIiwiSGVhbHRoQ2hlY2tSZXNwb25zZSIsIlRyYWNrUHVibGlzaGVkIiwiVHJhY2tVbnB1Ymxpc2hlZCIsIkNhbGxHcmFudHNVcGRhdGVkIiwiR29Bd2F5IiwiSUNFUmVzdGFydCIsIlBpbnNDaGFuZ2VkIiwiZXZlbnRQYXlsb2FkIiwic3Vic2NyaWJlck9mZmVyIiwicHVibGlzaGVyQW5zd2VyIiwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwiYXVkaW9MZXZlbENoYW5nZWQiLCJpY2VUcmlja2xlIiwiY2hhbmdlUHVibGlzaFF1YWxpdHkiLCJwYXJ0aWNpcGFudEpvaW5lZCIsInBhcnRpY2lwYW50TGVmdCIsImRvbWluYW50U3BlYWtlckNoYW5nZWQiLCJqb2luUmVzcG9uc2UiLCJoZWFsdGhDaGVja1Jlc3BvbnNlIiwidHJhY2tQdWJsaXNoZWQiLCJ0cmFja1VucHVibGlzaGVkIiwiY2FsbEdyYW50c1VwZGF0ZWQiLCJnb0F3YXkiLCJwaW5zVXBkYXRlZCIsIlNmdUV2ZW50IiwiUGluc0NoYW5nZWQkVHlwZSIsIkVycm9yJCIsIklDRVJlc3RhcnQkVHlwZSIsIlNmdVJlcXVlc3QkVHlwZSIsIkpvaW5SZXF1ZXN0IiwiSGVhbHRoQ2hlY2tSZXF1ZXN0IiwicmVxdWVzdFBheWxvYWQiLCJqb2luUmVxdWVzdCIsImhlYWx0aENoZWNrUmVxdWVzdCIsIlNmdVJlcXVlc3QiLCJIZWFsdGhDaGVja1JlcXVlc3QkVHlwZSIsIkhlYWx0aENoZWNrUmVzcG9uc2UkVHlwZSIsIlRyYWNrUHVibGlzaGVkJFR5cGUiLCJwYXJ0aWNpcGFudCIsIlRyYWNrVW5wdWJsaXNoZWQkVHlwZSIsImNhdXNlIiwiSm9pblJlcXVlc3QkVHlwZSIsIk1pZ3JhdGlvbiIsInRva2VuIiwic3Vic2NyaWJlclNkcCIsImZhc3RSZWNvbm5lY3QiLCJjbGllbnREZXRhaWxzIiwibWlncmF0aW9uIiwiTWlncmF0aW9uJFR5cGUiLCJmcm9tU2Z1SWQiLCJhbm5vdW5jZWRUcmFja3MiLCJzdWJzY3JpcHRpb25zIiwiSm9pblJlc3BvbnNlJFR5cGUiLCJyZWNvbm5lY3RlZCIsImNhbGxTdGF0ZSIsIlBhcnRpY2lwYW50Sm9pbmVkJFR5cGUiLCJjYWxsQ2lkIiwiUGFydGljaXBhbnRMZWZ0JFR5cGUiLCJTdWJzY3JpYmVyT2ZmZXIkVHlwZSIsIlB1Ymxpc2hlckFuc3dlciRUeXBlIiwiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJFR5cGUiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8iLCJjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8kVHlwZSIsIkRvbWluYW50U3BlYWtlckNoYW5nZWQkVHlwZSIsIkF1ZGlvTGV2ZWwkVHlwZSIsImxldmVsIiwiQXVkaW9MZXZlbCIsIkF1ZGlvTGV2ZWxDaGFuZ2VkJFR5cGUiLCJhdWRpb0xldmVscyIsIkF1ZGlvTWVkaWFSZXF1ZXN0JFR5cGUiLCJjaGFubmVsQ291bnQiLCJBdWRpb01lZGlhUmVxdWVzdCIsIkF1ZGlvU2VuZGVyJFR5cGUiLCJtZWRpYVJlcXVlc3QiLCJjb2RlYyIsIkF1ZGlvU2VuZGVyIiwiVmlkZW9NZWRpYVJlcXVlc3QkVHlwZSIsImlkZWFsSGVpZ2h0IiwiaWRlYWxXaWR0aCIsImlkZWFsRnJhbWVSYXRlIiwiVmlkZW9NZWRpYVJlcXVlc3QiLCJWaWRlb0xheWVyU2V0dGluZyRUeXBlIiwiYWN0aXZlIiwibWF4Qml0cmF0ZSIsInNjYWxlUmVzb2x1dGlvbkRvd25CeSIsInByaW9yaXR5IiwibWF4RnJhbWVyYXRlIiwiVmlkZW9MYXllclNldHRpbmciLCJWaWRlb1NlbmRlciRUeXBlIiwiVmlkZW9TZW5kZXIiLCJDaGFuZ2VQdWJsaXNoUXVhbGl0eSRUeXBlIiwiYXVkaW9TZW5kZXJzIiwidmlkZW9TZW5kZXJzIiwiQ2FsbEdyYW50c1VwZGF0ZWQkVHlwZSIsImN1cnJlbnRHcmFudHMiLCJHb0F3YXkkVHlwZSIsInJlYXNvbiIsIlZpc2liaWxpdHlTdGF0ZSIsIkRlYm91bmNlVHlwZSIsIlNpZ25hbFNlcnZlckNsaWVudCIsIl90cmFuc3BvcnQiLCJtZXRob2RzIiwic2V0UHVibGlzaGVyIiwiaW5wdXQiLCJtZXRob2QiLCJvcHQiLCJtZXJnZU9wdGlvbnMiLCJzdGFja0ludGVyY2VwdCIsInNlbmRBbnN3ZXIiLCJ1cGRhdGVTdWJzY3JpcHRpb25zIiwidXBkYXRlTXV0ZVN0YXRlcyIsInNlbmRTdGF0cyIsImRlZmF1bHRPcHRpb25zIiwiYmFzZVVybCIsInNlbmRKc29uIiwidGltZW91dCIsImpzb25PcHRpb25zIiwiaWdub3JlVW5rbm93bkZpZWxkcyIsIndpdGhIZWFkZXJzIiwiaGVhZGVycyIsImludGVyY2VwdFVuYXJ5IiwibmV4dCIsIm1ldGEiLCJjcmVhdGVTaWduYWxDbGllbnQiLCJ0cmFuc3BvcnQiLCJUd2lycEZldGNoVHJhbnNwb3J0IiwiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ0b0xvd2VyQ2FzZSIsImxvZ0xldmVscyIsImZyZWV6ZSIsInRyYWNlIiwiZGVidWciLCJpbmZvIiwid2FybiIsImxvZ2dlciIsImxvZ1RvQ29uc29sZSIsImxvZ0xldmVsIiwiYXJncyIsImxvZ01ldGhvZCIsImNvbnNvbGUiLCJsb2ciLCJzZXRMb2dnZXIiLCJsIiwibHZsIiwic2V0TG9nTGV2ZWwiLCJnZXRMb2dnZXIiLCJ3aXRoVGFncyIsImxvZ2dlck1ldGhvZCIsInRhZ3MiLCJyZXN1bHQiLCJnZXRQcmVmZXJyZWRDb2RlY3MiLCJwcmVmZXJyZWRDb2RlYyIsImNvZGVjVG9SZW1vdmUiLCJSVENSdHBSZWNlaXZlciIsImNhcCIsImdldENhcGFiaWxpdGllcyIsIm1hdGNoZWQiLCJwYXJ0aWFsTWF0Y2hlZCIsInVubWF0Y2hlZCIsImNvZGVjcyIsImZvckVhY2giLCJjIiwibWltZVR5cGUiLCJzaG91bGRSZW1vdmVDb2RlYyIsIm1hdGNoZXNDb2RlYyIsInNkcEZtdHBMaW5lIiwiaW5jbHVkZXMiLCJnZXRHZW5lcmljU2RwIiwiZGlyZWN0aW9uIiwidGVtcFBjIiwiUlRDUGVlckNvbm5lY3Rpb24iLCJhZGRUcmFuc2NlaXZlciIsIm9mZmVyIiwiY3JlYXRlT2ZmZXIiLCJnZXRUcmFuc2NlaXZlcnMiLCJ0Iiwic3RvcCIsImNsb3NlIiwic2Z1RXZlbnRLaW5kcyIsImlzU2Z1RXZlbnQiLCJldmVudE5hbWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJEaXNwYXRjaGVyIiwic3Vic2NyaWJlcnMiLCJkaXNwYXRjaCIsImV2ZW50S2luZCIsInBheWxvYWQiLCJsaXN0ZW5lcnMiLCJmbiIsIm9uIiwiX2EiLCJvZmYiLCJmaWx0ZXIiLCJvZmZBbGwiLCJJY2VUcmlja2xlQnVmZmVyIiwic3Vic2NyaWJlckNhbmRpZGF0ZXMiLCJSZXBsYXlTdWJqZWN0IiwicHVibGlzaGVyQ2FuZGlkYXRlcyIsIlNVQlNDUklCRVIiLCJQVUJMSVNIRVJfVU5TUEVDSUZJRUQiLCJnZXRJY2VDYW5kaWRhdGUiLCJjYW5kaWRhdGUiLCJ1c2VybmFtZUZyYWdtZW50Iiwic3BsaXR0ZWRDYW5kaWRhdGUiLCJzcGxpdCIsInVmcmFnSW5kZXgiLCJmaW5kSW5kZXgiLCJzIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvSlNPTiIsInNka0luZm8iLCJvc0luZm8iLCJkZXZpY2VJbmZvIiwid2ViUnRjSW5mbyIsInNldFNka0luZm8iLCJnZXRTZGtJbmZvIiwic2V0T1NJbmZvIiwiZ2V0T1NJbmZvIiwic2V0RGV2aWNlSW5mbyIsImdldERldmljZUluZm8iLCJnZXRXZWJSVENJbmZvIiwic2V0V2ViUlRDSW5mbyIsImdldENsaWVudERldGFpbHMiLCJ1c2VyQWdlbnQiLCJVQVBhcnNlciIsImNwdSIsImdldFJlc3VsdCIsInZlbmRvciIsIm1vZGVsIiwiQm9vbGVhbiIsIkRFRkFVTFRfQklUUkFURSIsImRlZmF1bHRUYXJnZXRSZXNvbHV0aW9uIiwiZmluZE9wdGltYWxWaWRlb0xheWVycyIsInZpZGVvVHJhY2siLCJ0YXJnZXRSZXNvbHV0aW9uIiwib3B0aW1hbFZpZGVvTGF5ZXJzIiwic2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsInciLCJoIiwiaXNSTklvcyIsImdldENvbXB1dGVkTWF4Qml0cmF0ZSIsImRvd25zY2FsZUZhY3RvciIsInVuc2hpZnQiLCJyb3VuZCIsInEiLCJ3aXRoU2ltdWxjYXN0Q29uc3RyYWludHMiLCJjdXJyZW50V2lkdGgiLCJjdXJyZW50SGVpZ2h0IiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJjdXJyZW50UGl4ZWxzIiwidGFyZ2V0UGl4ZWxzIiwicmVkdWN0aW9uRmFjdG9yIiwic2l6ZSIsIm1heCIsImxheWVyIiwicmlkTWFwcGluZyIsImluZGV4IiwiZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzIiwicHJlZmVyZW5jZXMiLCJ0cmFja1R5cGVUb1BhcnRpY2lwYW50U3RyZWFtS2V5IiwiU0NSRUVOX1NIQVJFIiwiU0NSRUVOX1NIQVJFX0FVRElPIiwiVklERU8iLCJBVURJTyIsIlVOU1BFQ0lGSUVEIiwiZXhoYXVzdGl2ZVRyYWNrVHlwZUNoZWNrIiwibXV0ZVR5cGVUb1RyYWNrVHlwZSIsIm11dGVUeXBlIiwiZXhoYXVzdGl2ZU11dGVUeXBlQ2hlY2siLCJpc0Z1bmN0aW9uUGF0Y2giLCJ1cGRhdGUiLCJnZXRDdXJyZW50VmFsdWUiLCJvYnNlcnZhYmxlJCIsImVyciIsImNvbWJpbmVMYXRlc3QiLCJzdWJzY3JpYmUiLCJ1bnN1YnNjcmliZSIsInNldEN1cnJlbnRWYWx1ZSIsInN1YmplY3QiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJvYnNlcnZhYmxlIiwiaGFuZGxlciIsInN1YnNjcmlwdGlvbiIsImNvbWJpbmVDb21wYXJhdG9ycyIsImNvbXBhcmF0b3JzIiwiYSIsImIiLCJjb21wYXJhdG9yIiwiZGVzY2VuZGluZyIsImNvbmRpdGlvbmFsIiwicHJlZGljYXRlIiwibm9vcENvbXBhcmF0b3IiLCJkb21pbmFudFNwZWFrZXIiLCJzcGVha2luZyIsInNjcmVlblNoYXJpbmciLCJoYXNTY3JlZW5TaGFyZSIsInB1Ymxpc2hpbmdWaWRlbyIsImhhc1ZpZGVvIiwicHVibGlzaGluZ0F1ZGlvIiwiaGFzQXVkaW8iLCJwaW5uZWQiLCJwaW4iLCJpc0xvY2FsUGluIiwicGlubmVkQXQiLCJyZWFjdGlvblR5cGUiLCJyZWFjdGlvbiIsInJvbGUiLCJoYXNBbnlSb2xlIiwicCIsInNvbWUiLCJyIiwiaWZJbnZpc2libGVCeSIsInZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlIiwiSU5WSVNJQkxFIiwiaWZJbnZpc2libGVPclVua25vd25CeSIsIlVOS05PV04iLCJkZWZhdWx0U29ydFByZXNldCIsInNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0IiwicGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCIsImxpdmVzdHJlYW1PckF1ZGlvUm9vbVNvcnRQcmVzZXQiLCJDYWxsaW5nU3RhdGUiLCJkZWZhdWx0RWdyZXNzIiwiYnJvYWRjYXN0aW5nIiwiaGxzIiwicGxheWxpc3RfdXJsIiwicnRtcHMiLCJiYWNrc3RhZ2VTdWJqZWN0IiwiQmVoYXZpb3JTdWJqZWN0IiwiYmxvY2tlZFVzZXJJZHNTdWJqZWN0IiwiY3JlYXRlZEF0U3ViamVjdCIsImVuZGVkQXRTdWJqZWN0Iiwic3RhcnRzQXRTdWJqZWN0IiwidXBkYXRlZEF0U3ViamVjdCIsImNyZWF0ZWRCeVN1YmplY3QiLCJjdXN0b21TdWJqZWN0IiwiZWdyZXNzU3ViamVjdCIsImluZ3Jlc3NTdWJqZWN0IiwicmVjb3JkaW5nU3ViamVjdCIsInNlc3Npb25TdWJqZWN0Iiwic2V0dGluZ3NTdWJqZWN0IiwidHJhbnNjcmliaW5nU3ViamVjdCIsImVuZGVkQnlTdWJqZWN0IiwidGh1bWJuYWlsc1N1YmplY3QiLCJtZW1iZXJzU3ViamVjdCIsIm93bkNhcGFiaWxpdGllc1N1YmplY3QiLCJjYWxsaW5nU3RhdGVTdWJqZWN0Iiwic3RhcnRlZEF0U3ViamVjdCIsInBhcnRpY2lwYW50Q291bnRTdWJqZWN0IiwiYW5vbnltb3VzUGFydGljaXBhbnRDb3VudFN1YmplY3QiLCJwYXJ0aWNpcGFudHNTdWJqZWN0IiwiY2FsbFN0YXRzUmVwb3J0U3ViamVjdCIsInNvcnRQYXJ0aWNpcGFudHNCeSIsIlNvcnRpbmdQcmVzZXQuZGVmYXVsdFNvcnRQcmVzZXQiLCJzZXRTb3J0UGFydGljaXBhbnRzQnkiLCJwcyIsIlJ4VXRpbHMuZ2V0Q3VycmVudFZhbHVlIiwiUnhVdGlscy5zZXRDdXJyZW50VmFsdWUiLCJzZXRQYXJ0aWNpcGFudENvdW50IiwiY291bnQiLCJzZXRTdGFydGVkQXQiLCJzZXRBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50Iiwic2V0UGFydGljaXBhbnRzIiwic2V0Q2FsbGluZ1N0YXRlIiwic3RhdGUiLCJzZXRDYWxsU3RhdHNSZXBvcnQiLCJyZXBvcnQiLCJzZXRNZW1iZXJzIiwibWVtYmVycyIsInNldE93bkNhcGFiaWxpdGllcyIsImNhcGFiaWxpdGllcyIsImZpbmRQYXJ0aWNpcGFudEJ5U2Vzc2lvbklkIiwiZ2V0UGFydGljaXBhbnRMb29rdXBCeVNlc3Npb25JZCIsInJlZHVjZSIsImxvb2t1cFRhYmxlIiwidXBkYXRlUGFydGljaXBhbnQiLCJ0aGVQYXRjaCIsInVwZGF0ZWRQYXJ0aWNpcGFudCIsInVwZGF0ZU9yQWRkUGFydGljaXBhbnQiLCJ1cGRhdGVQYXJ0aWNpcGFudHMiLCJ1cGRhdGVGcm9tRXZlbnQiLCJldmVudCIsImV2ZW50SGFuZGxlcnMiLCJzZXRTZXJ2ZXJTaWRlUGlucyIsInBpbnNMb29rdXAiLCJsb29rdXAiLCJzZXJ2ZXJTaWRlUGlubmVkQXQiLCJ1cGRhdGVGcm9tQ2FsbFJlc3BvbnNlIiwiYmFja3N0YWdlIiwiYmxvY2tlZF91c2VyX2lkcyIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0Iiwic3RhcnRzX2F0IiwiZW5kZWRfYXQiLCJjcmVhdGVkX2J5IiwiZWdyZXNzIiwiaW5ncmVzcyIsInJlY29yZGluZyIsInNlc3Npb24iLCJ0cmFuc2NyaWJpbmciLCJ0aHVtYm5haWxzIiwidXBkYXRlRnJvbU1lbWJlclJlbW92ZWQiLCJtIiwiaW5kZXhPZiIsInVzZXJfaWQiLCJ1cGRhdGVGcm9tTWVtYmVyQWRkZWQiLCJ1cGRhdGVGcm9tSExTQnJvYWRjYXN0U3RvcHBlZCIsInVwZGF0ZUZyb21ITFNCcm9hZGNhc3RpbmdGYWlsZWQiLCJ1cGRhdGVGcm9tSExTQnJvYWRjYXN0U3RhcnRlZCIsImhsc19wbGF5bGlzdF91cmwiLCJ1cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50TGVmdCIsInBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlIiwidXNlciIsInVzZXJfc2Vzc2lvbl9pZCIsInVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRKb2luZWQiLCJzaG91bGRJbnNlcnRQYXJ0aWNpcGFudCIsInVwZGF0ZWRQYXJ0aWNpcGFudHMiLCJpbmNyZW1lbnQiLCJ1cGRhdGVNZW1iZXJzIiwibWVtYmVyIiwibWVtYmVyVXBkYXRlIiwidXBkYXRlUGFydGljaXBhbnRSZWFjdGlvbiIsImVtb2ppX2NvZGUiLCJ1bmJsb2NrVXNlciIsImN1cnJlbnQiLCJibG9ja1VzZXIiLCJ1cGRhdGVPd25DYXBhYmlsaXRpZXMiLCJsb2NhbFBhcnRpY2lwYW50Iiwib3duX2NhcGFiaWxpdGllcyIsInBhcnRpY2lwYW50cyQiLCJhc09ic2VydmFibGUiLCJwaXBlIiwic29ydCIsInNoYXJlUmVwbGF5IiwiYnVmZmVyU2l6ZSIsInJlZkNvdW50IiwibG9jYWxQYXJ0aWNpcGFudCQiLCJpc0xvY2FsUGFydGljaXBhbnQiLCJyZW1vdGVQYXJ0aWNpcGFudHMkIiwicGlubmVkUGFydGljaXBhbnRzJCIsImRvbWluYW50U3BlYWtlciQiLCJoYXNPbmdvaW5nU2NyZWVuU2hhcmUkIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJzdGFydGVkQXQkIiwicGFydGljaXBhbnRDb3VudCQiLCJhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50JCIsImNhbGxTdGF0c1JlcG9ydCQiLCJtZW1iZXJzJCIsIm93bkNhcGFiaWxpdGllcyQiLCJjYWxsaW5nU3RhdGUkIiwiYmFja3N0YWdlJCIsImJsb2NrZWRVc2VySWRzJCIsImNyZWF0ZWRBdCQiLCJlbmRlZEF0JCIsInN0YXJ0c0F0JCIsInVwZGF0ZWRBdCQiLCJjcmVhdGVkQnkkIiwiY3VzdG9tJCIsImVncmVzcyQiLCJpbmdyZXNzJCIsInJlY29yZGluZyQiLCJzZXNzaW9uJCIsInNldHRpbmdzJCIsInRyYW5zY3JpYmluZyQiLCJlbmRlZEJ5JCIsInRodW1ibmFpbHMkIiwiYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCIsInJlbW90ZVBhcnRpY2lwYW50cyIsInBpbm5lZFBhcnRpY2lwYW50cyIsImhhc09uZ29pbmdTY3JlZW5TaGFyZSIsImNhbGxpbmdTdGF0ZSIsImNhbGxTdGF0c1JlcG9ydCIsIm93bkNhcGFiaWxpdGllcyIsImJsb2NrZWRVc2VySWRzIiwiZW5kZWRBdCIsInN0YXJ0c0F0IiwiY3JlYXRlZEJ5IiwiZW5kZWRCeSIsIlN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZSIsImNvbm5lY3RlZFVzZXJTdWJqZWN0IiwiY2FsbHNTdWJqZWN0Iiwic2V0Q29ubmVjdGVkVXNlciIsInNldENhbGxzIiwiY2FsbHMiLCJyZWdpc3RlckNhbGwiLCJjaWQiLCJ1bnJlZ2lzdGVyQ2FsbCIsImZpbmRDYWxsIiwiTEVGVCIsImxlYXZlIiwiY2F0Y2giLCJjb25uZWN0ZWRVc2VyIiwiU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUiLCJzdG9yZSIsImNvbm5lY3RlZFVzZXIkIiwiY2FsbHMkIiwiZ2V0UnRwTWFwIiwibGluZSIsInJ0cFJlZ2V4IiwicnRwTWF0Y2giLCJleGVjIiwib3JpZ2luYWwiLCJnZXRGbXRwIiwiZm10cFJlZ2V4IiwiZm10cE1hdGNoIiwiY29uZmlnIiwiZ2V0TWVkaWEiLCJtZWRpYVR5cGUiLCJyZWdleCIsIlJlZ0V4cCIsIm1lZGlhV2l0aFBvcnRzIiwiY29kZWNPcmRlciIsImdldE1lZGlhU2VjdGlvbiIsIm1lZGlhIiwicnRwTWFwIiwiZm10cCIsImlzVGhlUmVxdWlyZWRNZWRpYVNlY3Rpb24iLCJpc1ZhbGlkTGluZSIsInRlc3QiLCJfbWVkaWEiLCJydHBNYXBMaW5lIiwiZ2V0T3B1c0ZtdHAiLCJzZWN0aW9uIiwiY29kZWNJZCIsInRvZ2dsZUR0eCIsImVuYWJsZSIsIm9wdXNGbXRwIiwibWF0Y2hEdHgiLCJyZXF1aXJlZER0eENvbmZpZyIsIm5ld0ZtdHAiLCJlbmFibGVIaWdoUXVhbGl0eUF1ZGlvIiwidHJhY2tNaWQiLCJtaW4iLCJwYXJzZWRTZHAiLCJTRFAiLCJhdWRpb01lZGlhIiwiU3RyaW5nIiwib3B1c1J0cCIsInJ0cCIsIndyaXRlIiwiUHVibGlzaGVyIiwiY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24iLCJwYyIsImdldENvbmZpZ3VyYXRpb24iLCJfY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24iLCJjb25uZWN0aW9uQ29uZmlnIiwic2Z1Q2xpZW50IiwiZGlzcGF0Y2hlciIsImlzRHR4RW5hYmxlZCIsImlzUmVkRW5hYmxlZCIsImljZVJlc3RhcnREZWxheSIsInRyYW5zY2VpdmVyUmVnaXN0cnkiLCJwdWJsaXNoT3B0aW9uc1BlclRyYWNrVHlwZSIsIk1hcCIsInRyYW5zY2VpdmVySW5pdE9yZGVyIiwidHJhY2tLaW5kTWFwcGluZyIsInRyYWNrTGF5ZXJzQ2FjaGUiLCJpc0ljZVJlc3RhcnRpbmciLCJjcmVhdGVQZWVyQ29ubmVjdGlvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkljZUNhbmRpZGF0ZSIsIm9uTmVnb3RpYXRpb25OZWVkZWQiLCJvbkljZUNhbmRpZGF0ZUVycm9yIiwib25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlIiwib25TaWduYWxpbmdTdGF0ZUNoYW5nZSIsInN0b3BUcmFja3MiLCJzdG9wUHVibGlzaGluZyIsImNsZWFyVGltZW91dCIsImljZVJlc3RhcnRUaW1lb3V0IiwidW5zdWJzY3JpYmVPbkljZVJlc3RhcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHVibGlzaFN0cmVhbSIsIm1lZGlhU3RyZWFtIiwidHJhY2siLCJvcHRzIiwicmVhZHlTdGF0ZSIsInRyYW5zY2VpdmVyIiwic2VuZGVyIiwiaGFuZGxlVHJhY2tFbmRlZCIsIm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZCIsInZpZGVvIiwidGFyZ2V0X3Jlc29sdXRpb24iLCJ2aWRlb0VuY29kaW5ncyIsInNjcmVlblNoYXJlU2V0dGluZ3MiLCJvc05hbWUiLCJjb2RlY1ByZWZlcmVuY2VzIiwiZ2V0Q29kZWNQcmVmZXJlbmNlcyIsImVuYWJsZWQiLCJzdHJlYW1zIiwic2VuZEVuY29kaW5ncyIsInNldCIsInNldENvZGVjUHJlZmVyZW5jZXMiLCJwcmV2aW91c1RyYWNrIiwicmVwbGFjZVRyYWNrIiwidW5wdWJsaXNoU3RyZWFtIiwic3RvcFRyYWNrIiwiaXNQdWJsaXNoaW5nIiwidHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUiLCJpc0xpdmUiLCJpc011dGVkIiwidXBkYXRlTXV0ZVN0YXRlIiwiYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbSIsImdldFNlbmRlcnMiLCJzaWduYWxpbmdTdGF0ZSIsInJlbW92ZVRyYWNrIiwidXBkYXRlVmlkZW9QdWJsaXNoUXVhbGl0eSIsImVuYWJsZWRMYXllcnMiLCJ2aWRlb1NlbmRlciIsInBhcmFtcyIsImdldFBhcmFtZXRlcnMiLCJlbmNvZGluZ3MiLCJjaGFuZ2VkIiwiZW5hYmxlZFJpZHMiLCJseSIsImVuYyIsInNob3VsZEVuYWJsZSIsInZscyIsImFjdGl2ZUxheWVycyIsInNldFBhcmFtZXRlcnMiLCJnZXRTdGF0cyIsInNlbGVjdG9yIiwiZGVmYXVsdEF1ZGlvQ29kZWMiLCJzZXRTZnVDbGllbnQiLCJtaWdyYXRlVG8iLCJzZXRDb25maWd1cmF0aW9uIiwic2hvdWxkUmVzdGFydEljZSIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIm5lZ290aWF0ZSIsInJlc3RhcnRJY2UiLCJtdW5nZUNvZGVjcyIsImV4dHJhY3RNaWQiLCJ0cmFja0luZm9zIiwiZ2V0Q3VycmVudFRyYWNrSW5mb3MiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwicmVzcG9uc2UiLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsImljZVRyaWNrbGVCdWZmZXIiLCJhZGRJY2VDYW5kaWRhdGUiLCJtc2lkIiwiaGV1cmlzdGljTWlkIiwibG9jYWxEZXNjcmlwdGlvbiIsIm9wdGltYWxMYXllcnMiLCJwdWJsaXNoT3B0cyIsImdldCIsIm9wdGltYWxMYXllciIsInJpZFRvVmlkZW9RdWFsaXR5IiwiaXNBdWRpb1RyYWNrIiwidHJhY2tTZXR0aW5ncyIsImlzU3RlcmVvIiwiZXJyb3JNZXNzYWdlIiwiUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50IiwiZXJyb3JDb2RlIiwiZXJyb3JUZXh0IiwiaWNlU3RhdGUiLCJoYXNOZXR3b3JrQ29ubmVjdGlvbiIsIk9GRkxJTkUiLCJzZXRUaW1lb3V0IiwiaWNlR2F0aGVyaW5nU3RhdGUiLCJMT1dfVU5TUEVDSUZJRUQiLCJNSUQiLCJISUdIIiwiU3Vic2NyaWJlciIsImhhbmRsZU9uVHJhY2siLCJ1bnJlZ2lzdGVyT25TdWJzY3JpYmVyT2ZmZXIiLCJ1bnJlZ2lzdGVyT25JY2VSZXN0YXJ0IiwicHJldmlvdXNQQyIsInRyYWNrSWRzVG9NaWdyYXRlIiwiU2V0IiwiZ2V0UmVjZWl2ZXJzIiwiYWRkIiwibWlncmF0aW9uVGltZW91dElkIiwiY2xlYW51cE1pZ3JhdGlvbiIsImhhbmRsZVRyYWNrTWlncmF0aW9uIiwiZGVsZXRlIiwiaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwiY29ubmVjdGlvblN0YXRlIiwicHJldmlvdXNJc0ljZVJlc3RhcnRpbmciLCJwcmltYXJ5U3RyZWFtIiwicGFydGljaXBhbnRUb1VwZGF0ZSIsInN0cmVhbUtpbmRQcm9wIiwiVFJBQ0tfVFlQRV9BVURJTyIsIlRSQUNLX1RZUEVfVklERU8iLCJUUkFDS19UWVBFX1NDUkVFTl9TSEFSRSIsIlRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFX0FVRElPIiwicHJldmlvdXNTdHJlYW0iLCJnZXRUcmFja3MiLCJhbnN3ZXIiLCJjcmVhdGVBbnN3ZXIiLCJjcmVhdGVXZWJTb2NrZXRTaWduYWxDaGFubmVsIiwiZW5kcG9pbnQiLCJvbk1lc3NhZ2UiLCJ3cyIsIldlYlNvY2tldCIsImJpbmFyeVR5cGUiLCJkYXRhIiwiQXJyYXlCdWZmZXIiLCJmcm9tQmluYXJ5IiwiVWludDhBcnJheSIsImZyb21Kc29uU3RyaW5nIiwic2xlZXAiLCJQcm9taXNlIiwiaXNGdW5jdGlvbiIsIkZ1bmN0aW9uIiwiS25vd25Db2RlcyIsIlRPS0VOX0VYUElSRUQiLCJXU19DTE9TRURfU1VDQ0VTUyIsIldTX0NMT1NFRF9BQlJVUFRMWSIsIldTX1BPTElDWV9WSU9MQVRJT04iLCJyZXRyeUludGVydmFsIiwibnVtYmVyT2ZGYWlsdXJlcyIsInJhbmRvbSIsInJhbmRvbUlkIiwiZ2VuZXJhdGVVVUlEdjQiLCJoZXgiLCJieXRlcyIsInBhZFN0YXJ0IiwiZ2V0UmFuZG9tQnl0ZXMiLCJzdWJhcnJheSIsImdldFJhbmRvbVZhbHVlc1dpdGhNYXRoUmFuZG9tIiwicG93IiwiYnl0ZUxlbmd0aCIsImdldFJhbmRvbVZhbHVlcyIsImNyeXB0byIsImJpbmQiLCJtc0NyeXB0byIsImNvbnZlcnRFcnJvclRvSnNvbiIsImpzb25PYmoiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiXyIsImlzT25saW5lIiwibmF2Iiwid2luZG93Iiwib25MaW5lIiwiYWRkQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzIiwiY2IiLCJyZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMiLCJTdHJlYW1TZnVDbGllbnQiLCJzZnVTZXJ2ZXIiLCJpc01pZ3JhdGluZ0F3YXkiLCJpc0Zhc3RSZWNvbm5lY3RpbmciLCJwaW5nSW50ZXJ2YWxJbk1zIiwidW5oZWFsdGh5VGltZW91dEluTXMiLCJzaWduYWxXcyIsIkNMT1NFRCIsInVuc3Vic2NyaWJlSWNlVHJpY2tsZSIsImNsZWFySW50ZXJ2YWwiLCJrZWVwQWxpdmVJbnRlcnZhbCIsImNvbm5lY3Rpb25DaGVja1RpbWVvdXQiLCJyZXRyeWFibGUiLCJycGMiLCJzdGF0cyIsInNlbmQiLCJzaWduYWxSZWFkeSIsInRoZW4iLCJzaWduYWwiLCJPUEVOIiwiZWRnZU5hbWUiLCJ0b0JpbmFyeSIsImtlZXBBbGl2ZSIsInNldEludGVydmFsIiwic2NoZWR1bGVDb25uZWN0aW9uQ2hlY2siLCJsYXN0TWVzc2FnZVRpbWVzdGFtcCIsInRpbWVTaW5jZUxhc3RNZXNzYWdlIiwiRVJST1JfQ09OTkVDVElPTl9VTkhFQUxUSFkiLCJlZGdlX25hbWUiLCJsb2dJbnRlcmNlcHRvciIsInVybCIsImludGVyY2VwdG9ycyIsIkF1dGhvcml6YXRpb24iLCJ3c19lbmRwb2ludCIsInJlc29sdmUiLCJvbk9wZW4iLCJOT1JNQUxfQ0xPU1VSRSIsIkVSUk9SX0NPTk5FQ1RJT05fQlJPS0VOIiwiTUFYX1JFVFJJRVMiLCJyZXRyeUF0dGVtcHQiLCJycGNDYWxsUmVzdWx0Iiwid2F0Y2hDYWxsQWNjZXB0ZWQiLCJvbkNhbGxBY2NlcHRlZCIsImN1cnJlbnRVc2VySWQiLCJSSU5HSU5HIiwid2F0Y2hDYWxsUmVqZWN0ZWQiLCJvbkNhbGxSZWplY3RlZCIsImV2ZW50Q2FsbCIsImNhbGxTZXNzaW9uIiwicmVqZWN0ZWRCeSIsInJlamVjdGVkX2J5IiwiaXNDcmVhdGVkQnlNZSIsImV2ZXJ5b25lRWxzZVJlamVjdGVkIiwiZXZlcnkiLCJ3YXRjaENhbGxFbmRlZCIsIm9uQ2FsbEVuZGVkIiwiSk9JTkVEIiwiSk9JTklORyIsIndhdGNoQ2FsbEdyYW50c1VwZGF0ZWQiLCJvbkNhbGxHcmFudHNVcGRhdGVkIiwibmV4dENhcGFiaWxpdGllcyIsImNhcGFiaWxpdHkiLCJ3YXRjaENoYW5nZVB1Ymxpc2hRdWFsaXR5IiwidXBkYXRlUHVibGlzaFF1YWxpdHkiLCJ3YXRjaENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsInBhdGNoZXMiLCJ3YXRjaFBhcnRpY2lwYW50Q291bnRDaGFuZ2VkIiwid2F0Y2hMaXZlRW5kZWQiLCJMSVZFX0VOREVEIiwicGVybWlzc2lvbnNDb250ZXh0IiwiaGFzUGVybWlzc2lvbiIsIndhdGNoU2Z1RXJyb3JSZXBvcnRzIiwid2F0Y2hQaW5zVXBkYXRlZCIsIm9uUGluc1VwZGF0ZWQiLCJoYW5kbGVSZW1vdGVTb2Z0TXV0ZSIsIk1PREVSQVRJT04iLCJjYW1lcmEiLCJkaXNhYmxlIiwibWljcm9waG9uZSIsInB1Ymxpc2hlciIsInN0b3BQdWJsaXNoIiwid2F0Y2hQYXJ0aWNpcGFudEpvaW5lZCIsIm9uUGFydGljaXBhbnRKb2luZWQiLCJhc3NpZ24iLCJzY3JlZW5TaGFyZVRyYWNrIiwid2F0Y2hQYXJ0aWNpcGFudExlZnQiLCJvblBhcnRpY2lwYW50TGVmdCIsIndhdGNoVHJhY2tQdWJsaXNoZWQiLCJvblRyYWNrUHVibGlzaGVkIiwidW5pcXVlIiwid2F0Y2hUcmFja1VucHVibGlzaGVkIiwib25UcmFja1VucHVibGlzaGVkIiwiYXJyIiwid2F0Y2hEb21pbmFudFNwZWFrZXJDaGFuZ2VkIiwid2F0Y2hBdWRpb0xldmVsQ2hhbmdlZCIsInJlZ2lzdGVyRXZlbnRIYW5kbGVycyIsInJpbmdpbmciLCJyZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyIsImNvb3JkaW5hdG9yUmluZ0V2ZW50cyIsImh0dHBDbGllbnQiLCJjcmVkZW50aWFscyIsInN0YXRzX29wdGlvbnMiLCJkb0pvaW4iLCJ0b1J0Y0NvbmZpZ3VyYXRpb24iLCJpY2Vfc2VydmVycyIsInNlcnZlciIsIm1ldGFkYXRhIiwic3RhdHNPcHRpb25zIiwibG9jYXRpb24iLCJnZXRMb2NhdGlvbkhpbnQiLCJyZXF1ZXN0IiwicG9zdCIsInJ0Y0NvbmZpZyIsImljZVNlcnZlcnMiLCJpY2UiLCJ1cmxzIiwidXNlcm5hbWUiLCJjcmVkZW50aWFsIiwicGFzc3dvcmQiLCJmbGF0dGVuIiwiZ2V0U2RrU2lnbmF0dXJlIiwicGxhdGZvcm0iLCJzZGtOYW1lIiwiUkVBQ1QiLCJSRUFDVF9OQVRJVkUiLCJjcmVhdGVTdGF0c1JlcG9ydGVyIiwic3Vic2NyaWJlciIsInBvbGxpbmdJbnRlcnZhbEluTXMiLCJnZXRSYXdTdGF0c0ZvclRyYWNrIiwiZ2V0U3RhdHNGb3JTdHJlYW0iLCJzdGF0c0ZvclN0cmVhbSIsInRyYW5zZm9ybSIsInRyYWNrS2luZCIsInN0YXJ0UmVwb3J0aW5nU3RhdHNGb3IiLCJzZXNzaW9uSWRzVG9UcmFjayIsInJ1biIsInN0b3BSZXBvcnRpbmdTdGF0c0ZvciIsInBhcnRpY2lwYW50U3RhdHMiLCJzZXNzaW9uSWRzIiwiaGFzIiwibWVyZ2VkU3RyZWFtIiwiTWVkaWFTdHJlYW0iLCJ2aWRlb1N0cmVhbSIsImdldFZpZGVvVHJhY2tzIiwiYXVkaW9TdHJlYW0iLCJnZXRBdWRpb1RyYWNrcyIsImFsbCIsImFnZ3JlZ2F0ZSIsInN1YnNjcmliZXJSYXdTdGF0cyIsInB1Ymxpc2hlclJhd1N0YXRzIiwiZGF0YWNlbnRlciIsInRpbWVzdGFtcCIsInRpbWVvdXRJZCIsImxvb3AiLCJzdGF0IiwicnRjU3RyZWFtU3RhdHMiLCJ0cmFuc3BvcnRJZCIsInJvdW5kVHJpcFRpbWUiLCJkdGxzU3RhdGUiLCJjYW5kaWRhdGVQYWlyIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQiLCJjdXJyZW50Um91bmRUcmlwVGltZSIsImJ5dGVzU2VudCIsImJ5dGVzUmVjZWl2ZWQiLCJmcmFtZUhlaWdodCIsImZyYW1lV2lkdGgiLCJmcmFtZXNQZXJTZWNvbmQiLCJqaXR0ZXIiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbiIsInNzcmMiLCJyYXdTdGF0cyIsImFnZ3JlZ2F0ZWRTdGF0cyIsInJhd1JlcG9ydCIsInRvdGFsQnl0ZXNTZW50IiwidG90YWxCeXRlc1JlY2VpdmVkIiwiYXZlcmFnZUppdHRlckluTXMiLCJhdmVyYWdlUm91bmRUcmlwVGltZUluTXMiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMiLCJoaWdoZXN0RnJhbWVXaWR0aCIsImhpZ2hlc3RGcmFtZUhlaWdodCIsImhpZ2hlc3RGcmFtZXNQZXJTZWNvbmQiLCJtYXhBcmVhIiwiYXJlYSIsImFjYyIsInN0cmVhbSIsInN0cmVhbUFyZWEiLCJTZnVTdGF0c1JlcG9ydGVyIiwid2ViUlRDVmVyc2lvbiIsInN0YXJ0IiwicmVwb3J0aW5nX2ludGVydmFsX21zIiwiaW50ZXJ2YWxJZCIsIndlYlJUQ0luZm8iLCJERUZBVUxUX1RIUkVTSE9MRCIsIlZpZXdwb3J0VHJhY2tlciIsImVsZW1lbnRIYW5kbGVyTWFwIiwib2JzZXJ2ZXIiLCJxdWV1ZVNldCIsInNldFZpZXdwb3J0Iiwidmlld3BvcnRFbGVtZW50IiwiY2xlYW51cCIsImRpc2Nvbm5lY3QiLCJjbGVhciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cnkiLCJyb290IiwidGhyZXNob2xkIiwicXVldWVFbGVtZW50IiwicXVldWVIYW5kbGVyIiwiY29udGFpbnMiLCJvYnNlcnZlIiwiZWxlbWVudCIsInF1ZXVlSXRlbSIsInVub2JzZXJ2ZSIsImlzU2FmYXJpIiwiaXNGaXJlZm94IiwiaXNDaHJvbWUiLCJERUZBVUxUX1ZJRVdQT1JUX1ZJU0lCSUxJVFlfU1RBVEUiLCJEeW5hc2NhbGVNYW5hZ2VyIiwidmlld3BvcnRUcmFja2VyIiwidHJhY2tFbGVtZW50VmlzaWJpbGl0eSIsInByZXZpb3VzVmlzaWJpbGl0eVN0YXRlIiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJkb2N1bWVudCIsImZ1bGxzY3JlZW5FbGVtZW50IiwiVklTSUJMRSIsImJpbmRWaWRlb0VsZW1lbnQiLCJ2aWRlb0VsZW1lbnQiLCJib3VuZFBhcnRpY2lwYW50IiwicmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMiLCJkZWJvdW5jZVR5cGUiLCJ1cGRhdGVTdWJzY3JpcHRpb25zUGFydGlhbCIsInBhcnRpY2lwYW50JCIsInRha2VXaGlsZSIsInZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlU3Vic2NyaXB0aW9uIiwibmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlIiwiTUVESVVNIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJsYXN0RGltZW5zaW9ucyIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJjdXJyZW50RGltZW5zaW9ucyIsIlNMT1ciLCJwdWJsaXNoZWRUcmFja3NTdWJzY3JpcHRpb24iLCJkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCIsIkZBU1QiLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwic3RyZWFtU3Vic2NyaXB0aW9uIiwic291cmNlIiwic2NyZWVuU2hhcmVTdHJlYW0iLCJzcmNPYmplY3QiLCJwbGF5IiwiYmluZEF1ZGlvRWxlbWVudCIsImF1ZGlvRWxlbWVudCIsInVwZGF0ZU1lZGlhU3RyZWFtU3Vic2NyaXB0aW9uIiwic2NyZWVuU2hhcmVBdWRpb1N0cmVhbSIsInNlbGVjdGVkRGV2aWNlIiwic3BlYWtlciIsInNldFNpbmtJZCIsInNpbmtJZFN1YnNjcmlwdGlvbiIsInNlbGVjdGVkRGV2aWNlJCIsImRldmljZUlkIiwidm9sdW1lU3Vic2NyaXB0aW9uIiwidm9sdW1lJCIsInZvbHVtZSIsImF1ZGlvVm9sdW1lIiwiUGVybWlzc2lvbnNDb250ZXh0IiwicGVybWlzc2lvbnMiLCJzZXRQZXJtaXNzaW9ucyIsInNldENhbGxTZXR0aW5ncyIsInBlcm1pc3Npb24iLCJjYW5SZXF1ZXN0IiwiYXVkaW8iLCJzY3JlZW5zaGFyaW5nIiwiYWNjZXNzX3JlcXVlc3RfZW5hYmxlZCIsIkNhbGxUeXBlIiwiQ2FsbFR5cGVzUmVnaXN0cnkiLCJjYWxsVHlwZXMiLCJyZWdpc3RlciIsImNhbGxUeXBlIiwidW5yZWdpc3RlciIsIkNhbGxUeXBlcyIsImdldERldmljZXMiLCJjb25zdHJhaW50cyIsIk9ic2VydmFibGUiLCJlbnVtZXJhdGUiLCJkZXZpY2VzIiwibWVkaWFEZXZpY2VzIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5lZWRzR2V0VXNlck1lZGlhIiwibGFiZWwiLCJnZXRVc2VyTWVkaWEiLCJkaXNwb3NlT2ZNZWRpYVN0cmVhbSIsImNvbXBsZXRlIiwiY2hlY2tJZkF1ZGlvT3V0cHV0Q2hhbmdlU3VwcG9ydGVkIiwiY3JlYXRlRWxlbWVudCIsImF1ZGlvRGV2aWNlQ29uc3RyYWludHMiLCJhdXRvR2FpbkNvbnRyb2wiLCJub2lzZVN1cHByZXNzaW9uIiwiZWNob0NhbmNlbGxhdGlvbiIsInZpZGVvRGV2aWNlQ29uc3RyYWludHMiLCJtZW1vaXplZE9ic2VydmFibGUiLCJtZW1vaXplZCIsImdldERldmljZUNoYW5nZU9ic2VydmVyIiwibm90aWZ5IiwiZGVib3VuY2VUaW1lIiwiY29uY2F0TWFwIiwiZ2V0QXVkaW9EZXZpY2VzT2JzZXJ2ZXIiLCJtZXJnZSIsImdldEF1ZGlvT3V0cHV0RGV2aWNlc09ic2VydmVyIiwiZ2V0VmlkZW9EZXZpY2VzT2JzZXJ2ZXIiLCJnZXRBdWRpb0RldmljZXMiLCJnZXRWaWRlb0RldmljZXMiLCJnZXRBdWRpb091dHB1dERldmljZXMiLCJnZXRTdHJlYW0iLCJnZXRBdWRpb1N0cmVhbSIsInRyYWNrQ29uc3RyYWludHMiLCJnZXRWaWRlb1N0cmVhbSIsImdldFNjcmVlblNoYXJlU3RyZWFtIiwiZ2V0RGlzcGxheU1lZGlhIiwiaWRlYWwiLCJzeXN0ZW1BdWRpbyIsImRldmljZUlkcyQiLCJyZWxlYXNlIiwiSW5wdXRNZWRpYURldmljZU1hbmFnZXIiLCJzdG9wT25MZWF2ZSIsImlzVHJhY2tTdG9wcGVkRHVlVG9UcmFja0VuZCIsImZpbHRlcnMiLCJkaXNwb3NlIiwiaGFuZGxlRGlzY29ubmVjdGVkT3JSZXBsYWNlZERldmljZXMiLCJsaXN0RGV2aWNlcyIsInN0YXR1cyIsImVuYWJsZVByb21pc2UiLCJ1bm11dGVTdHJlYW0iLCJzZXRTdGF0dXMiLCJmb3JjZVN0b3AiLCJwcmV2U3RhdHVzIiwiZGlzYWJsZU1vZGUiLCJkaXNhYmxlUHJvbWlzZSIsIm11dGVTdHJlYW0iLCJyZXN1bWUiLCJ0b2dnbGUiLCJyZWdpc3RlckZpbHRlciIsImFwcGx5U2V0dGluZ3NUb1N0cmVhbSIsInNldERlZmF1bHRDb25zdHJhaW50cyIsInNlbGVjdCIsInNldERldmljZSIsInN0b3BQdWJsaXNoU3RyZWFtIiwibXV0ZUxvY2FsU3RyZWFtIiwiYWxsRW5kZWQiLCJzZXRNZWRpYVN0cmVhbSIsIm11dGVUcmFja3MiLCJ1bm11dGVUcmFja3MiLCJkZWZhdWx0Q29uc3RyYWludHMiLCJjaGFpbldpdGgiLCJwYXJlbnRTdHJlYW0iLCJmaWx0ZXJTdHJlYW0iLCJwYXJlbnQiLCJvcmlnaW5hbFN0b3AiLCJwYXJlbnRUcmFjayIsImhhbmRsZVBhcmVudFRyYWNrRW5kZWQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJtZWRpYURldmljZUtpbmQiLCJwYWlyd2lzZSIsInByZXZEZXZpY2VzIiwiY3VycmVudERldmljZXMiLCJpc0RldmljZURpc2Nvbm5lY3RlZCIsImlzRGV2aWNlUmVwbGFjZWQiLCJjdXJyZW50RGV2aWNlIiwiZmluZERldmljZUluTGlzdCIsInByZXZEZXZpY2UiLCJncm91cElkIiwiSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSIsInBlcm1pc3Npb25OYW1lIiwic3RhdHVzU3ViamVjdCIsIm1lZGlhU3RyZWFtU3ViamVjdCIsInNlbGVjdGVkRGV2aWNlU3ViamVjdCIsImRlZmF1bHRDb25zdHJhaW50c1N1YmplY3QiLCJtZWRpYVN0cmVhbSQiLCJzdGF0dXMkIiwiZGVmYXVsdENvbnN0cmFpbnRzJCIsImhhc0Jyb3dzZXJQZXJtaXNzaW9uJCIsIm5vdGlmeUdyYW50ZWQiLCJwZXJtaXNzaW9uc0FQSUF2YWlsYWJsZSIsInF1ZXJ5IiwicGVybWlzc2lvblN0YXRlIiwicGVybWlzc2lvblN0YXR1cyIsImdldERldmljZUlkRnJvbVN0cmVhbSIsIkNhbWVyYU1hbmFnZXJTdGF0ZSIsImRpcmVjdGlvblN1YmplY3QiLCJkaXJlY3Rpb24kIiwic2V0RGlyZWN0aW9uIiwiZmFjaW5nTW9kZSIsIkNhbWVyYU1hbmFnZXIiLCJzZWxlY3REaXJlY3Rpb24iLCJmbGlwIiwibmV3RGlyZWN0aW9uIiwic2VsZWN0VGFyZ2V0UmVzb2x1dGlvbiIsInJlc29sdXRpb24iLCJzZXRQcmVmZXJyZWRDb2RlYyIsInB1Ymxpc2hWaWRlb1N0cmVhbSIsIk1pY3JvcGhvbmVNYW5hZ2VyU3RhdGUiLCJzcGVha2luZ1doaWxlTXV0ZWRTdWJqZWN0Iiwic3BlYWtpbmdXaGlsZU11dGVkJCIsInNwZWFraW5nV2hpbGVNdXRlZCIsInNldFNwZWFraW5nV2hpbGVNdXRlZCIsIkRFVEVDVElPTl9GUkVRVUVOQ1lfSU5fTVMiLCJBVURJT19MRVZFTF9USFJFU0hPTEQiLCJGRlRfU0laRSIsImNyZWF0ZVNvdW5kRGV0ZWN0b3IiLCJvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQiLCJkZXRlY3Rpb25GcmVxdWVuY3lJbk1zIiwiYXVkaW9MZXZlbFRocmVzaG9sZCIsImZmdFNpemUiLCJkZXN0cm95U3RyZWFtT25TdG9wIiwiYXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJjcmVhdGVBbmFseXNlciIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwiY29ubmVjdCIsImZyZXF1ZW5jeUJpbkNvdW50IiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJpc1NvdW5kRGV0ZWN0ZWQiLCJhdmVyYWdlZERhdGFWYWx1ZSIsInB2IiwiY3YiLCJwZXJjZW50YWdlIiwiUk5TcGVlY2hEZXRlY3RvciIsInBjMSIsInBjMiIsImFkZFRyYWNrIiwiYXVkaW9UcmFja3MiLCJvblNwZWFraW5nRGV0ZWN0ZWRTdGF0ZUNoYW5nZSIsImF1ZGlvTWVkaWFTb3VyY2VTdGF0cyIsIk1pY3JvcGhvbmVNYW5hZ2VyIiwic3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbiIsInN0YXJ0U3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uIiwicHVibGlzaEF1ZGlvU3RyZWFtIiwicm5TcGVlY2hEZXRlY3RvciIsInNvdW5kRGV0ZWN0b3JDbGVhbnVwIiwiU2NyZWVuU2hhcmVTdGF0ZSIsImF1ZGlvRW5hYmxlZFN1YmplY3QiLCJhdWRpb0VuYWJsZWQkIiwiYXVkaW9FbmFibGVkIiwic2V0QXVkaW9FbmFibGVkIiwiaXNFbmFibGVkIiwic2V0U2V0dGluZ3MiLCJTY3JlZW5TaGFyZU1hbmFnZXIiLCJlbmFibGVTY3JlZW5TaGFyZUF1ZGlvIiwiZGlzYWJsZVNjcmVlblNoYXJlQXVkaW8iLCJvZiIsInB1Ymxpc2hTY3JlZW5TaGFyZVN0cmVhbSIsIlNwZWFrZXJTdGF0ZSIsInZvbHVtZVN1YmplY3QiLCJpc0RldmljZVNlbGVjdGlvblN1cHBvcnRlZCIsInNldFZvbHVtZSIsIlNwZWFrZXJNYW5hZ2VyIiwic2V0UGFydGljaXBhbnRWb2x1bWUiLCJzdHJlYW1DbGllbnQiLCJjbGllbnRTdG9yZSIsIndhdGNoaW5nIiwiZHluYXNjYWxlTWFuYWdlciIsInRyYWNrU3Vic2NyaXB0aW9uc1N1YmplY3QiLCJyZWNvbm5lY3RBdHRlbXB0cyIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwibGVhdmVDYWxsSG9va3MiLCJzdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzIiwib2ZmSGFuZGxlciIsImNhbGxfY2lkIiwicmVnaXN0ZXJlZE9mZkhhbmRsZXIiLCJyZWplY3QiLCJhc3NlcnRDYWxsSm9pbmVkIiwiaGFzT3RoZXJQYXJ0aWNpcGFudHMiLCJzdGF0c1JlcG9ydGVyIiwic2Z1U3RhdHNSZXBvcnRlciIsImhvb2siLCJzY3JlZW5TaGFyZSIsInN0b3BPbkxlYXZlUHJvbWlzZXMiLCJzdHJlYW1DbGllbnRCYXNlUGF0aCIsInJpbmciLCJyaW5naW5nU3ViamVjdCIsIl9oYXNDb25uZWN0aW9uSUQiLCJhcHBseURldmljZUNvbmZpZyIsImdldE9yQ3JlYXRlIiwiYWNjZXB0IiwiaXNNaWdyYXRpbmciLCJNSUdSQVRJTkciLCJpc1JlY29ubmVjdGluZyIsIlJFQ09OTkVDVElORyIsInNmdVRva2VuIiwicHJldmlvdXNTZnVDbGllbnQiLCJyZWNvbm5lY3QiLCJzdHJhdGVneSIsImN1cnJlbnRTdGF0ZSIsIm1pZ3JhdGluZ19mcm9tIiwidW5yZWdpc3RlckdvQXdheSIsIlJFQ09OTkVDVElOR19GQUlMRUQiLCJ1bnN1YnNjcmliZU9ubGluZUV2ZW50Iiwib25saW5lIiwiY3VycmVudENhbGxpbmdTdGF0ZSIsInNob3VsZFJlY29ubmVjdCIsImlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0IiwidW5zdWJzY3JpYmVPZmZsaW5lRXZlbnQiLCJhdWRpb1NldHRpbmdzIiwib3B1c19kdHhfZW5hYmxlZCIsInJlZHVuZGFudF9jb2RpbmdfZW5hYmxlZCIsIndhaXRGb3JKb2luUmVzcG9uc2UiLCJjdXJyZW50UGFydGljaXBhbnRzIiwicGFydGljaXBhbnRMb29rdXAiLCJleGlzdGluZ1BhcnRpY2lwYW50IiwiaW5pdENhbWVyYSIsImluaXRNaWMiLCJhdWRpb1RyYWNrIiwic2NyZWVuU2hhcmVBdWRpb1RyYWNrIiwiY2hhbmdlcyIsImNoYW5nZSIsInByb3AiLCJzY3JlZW5TaGFyZURpbWVuc2lvbiIsInJlc2V0UmVhY3Rpb24iLCJjcml0ZXJpYSIsInNlbmRSZWFjdGlvbiIsIm11dGVTZWxmIiwibXlVc2VySWQiLCJtdXRlVXNlciIsIm11dGVPdGhlcnMiLCJ1c2VySWRzVG9NdXRlIiwidXNlcl9pZHMiLCJtdXRlQWxsVXNlcnMiLCJtdXRlX2FsbF91c2VycyIsInN0YXJ0UmVjb3JkaW5nIiwic3RvcFJlY29yZGluZyIsInN0YXJ0VHJhbnNjcmlwdGlvbiIsInN0b3BUcmFuc2NyaXB0aW9uIiwicmVxdWVzdFBlcm1pc3Npb25zIiwiY2FuUmVxdWVzdFBlcm1pc3Npb25zIiwiZ3JhbnRQZXJtaXNzaW9ucyIsInVwZGF0ZVVzZXJQZXJtaXNzaW9ucyIsImdyYW50X3Blcm1pc3Npb25zIiwicmV2b2tlUGVybWlzc2lvbnMiLCJyZXZva2VfcGVybWlzc2lvbnMiLCJnb0xpdmUiLCJzdG9wTGl2ZSIsInN0YXJ0SExTIiwic3RvcEhMUyIsInVwZGF0ZXMiLCJlbmRDYWxsIiwidW5waW4iLCJwaW5Gb3JFdmVyeW9uZSIsInVucGluRm9yRXZlcnlvbmUiLCJxdWVyeU1lbWJlcnMiLCJ1cGRhdGVDYWxsTWVtYmVycyIsInNjaGVkdWxlQXV0b0Ryb3AiLCJkcm9wVGltZW91dCIsInRpbWVvdXRJbk1zIiwiYXV0b19jYW5jZWxfdGltZW91dF9tcyIsInF1ZXJ5UmVjb3JkaW5ncyIsImNhbGxTZXNzaW9uSWQiLCJxdWVyeVRyYW5zY3JpcHRpb25zIiwiZ2V0Q2FsbFN0YXRzIiwiY2FsbFNlc3Npb25JRCIsInN1Ym1pdEZlZWRiYWNrIiwicmF0aW5nIiwidXNlclNlc3Npb25JZCIsInNka192ZXJzaW9uIiwic2VuZEN1c3RvbUV2ZW50IiwidW5iaW5kIiwiYmluZENhbGxUaHVtYm5haWxFbGVtZW50IiwiaW1hZ2VFbGVtZW50IiwiaGFuZGxlRXJyb3IiLCJzcmMiLCJmYWxsYmFja0ltYWdlU291cmNlIiwidGh1bWJuYWlsVXJsIiwiVVJMIiwiaW1hZ2VfdXJsIiwic2VhcmNoUGFyYW1zIiwiY2FsbFR5cGVDb25maWciLCJwYXJ0aWNpcGFudFNvcnRlciIsIklETEUiLCJyZWdpc3RlckVmZmVjdHMiLCJkZWJvdW5jZSIsInRpbWVyIiwicGVybWlzc2lvblRvVHJhY2tUeXBlIiwiaXNSaW5naW5nIiwiZGVmYXVsdERpcmVjdGlvbiIsImJhY2tlbmRTZXR0aW5nIiwiY2FtZXJhX2ZhY2luZyIsImNhbWVyYV9kZWZhdWx0X29uIiwibWljX2RlZmF1bHRfb24iLCJJbnNpZ2h0TWV0cmljcyIsImNvbm5lY3Rpb25TdGFydFRpbWVzdGFtcCIsIndzVG90YWxGYWlsdXJlcyIsIndzQ29uc2VjdXRpdmVGYWlsdXJlcyIsImluc3RhbmNlQ2xpZW50SWQiLCJwb3N0SW5zaWdodHMiLCJpbnNpZ2h0VHlwZSIsImluc2lnaHRzIiwibWF4QXR0ZW1wdHMiLCJheGlvcyIsImJ1aWxkV3NGYXRhbEluc2lnaHQiLCJjb25uZWN0aW9uIiwiYnVpbGRXc0Jhc2VJbnNpZ2h0IiwiY2xpZW50IiwicmVhZHlfc3RhdGUiLCJfYnVpbGRVcmwiLCJhcGlfa2V5Iiwic3RhcnRfdHMiLCJpbnNpZ2h0TWV0cmljcyIsImVuZF90cyIsImF1dGhfdHlwZSIsImdldEF1dGhUeXBlIiwidG9rZW5NYW5hZ2VyIiwidXNlcklEIiwidXNlcl9kZXRhaWxzIiwiX3VzZXIiLCJjbGllbnRfaWQiLCJjb25uZWN0aW9uSUQiLCJ3c19kZXRhaWxzIiwid3NfY29uc2VjdXRpdmVfZmFpbHVyZXMiLCJ3c190b3RhbF9mYWlsdXJlcyIsInJlcXVlc3RfaWQiLCJyZXF1ZXN0SUQiLCJ1c2VyX2FnZW50IiwiaW5zdGFuY2VfY2xpZW50X2lkIiwiYnVpbGRXc1N1Y2Nlc3NBZnRlckZhaWx1cmVJbnNpZ2h0IiwiaXNDbG9zZUV2ZW50IiwicmVzIiwiaXNFcnJvckV2ZW50IiwiU3RhYmxlV1NDb25uZWN0aW9uIiwiX2xvZyIsImV4dHJhIiwic2V0Q2xpZW50IiwiVVJMU2VhcmNoUGFyYW1zIiwiZ2V0VXNlckFnZW50Iiwid3NCYXNlVVJMIiwib25saW5lU3RhdHVzQ2hhbmdlZCIsIl9zZXRIZWFsdGgiLCJpc0hlYWx0aHkiLCJfcmVjb25uZWN0IiwiaW50ZXJ2YWwiLCJvbm9wZW4iLCJ3c0lEIiwiX2dldFRva2VuIiwiYXV0aE1lc3NhZ2UiLCJhdXRoZW50aWNhdGlvblNlbnQiLCJvbm1lc3NhZ2UiLCJpc1Jlc29sdmVkIiwicmVqZWN0UHJvbWlzZSIsIl9lcnJvckZyb21XU0V2ZW50IiwibGFzdEV2ZW50Iiwic2NoZWR1bGVOZXh0UGluZyIsInJlc29sdmVQcm9taXNlIiwiaXNDb25uZWN0aW5nIiwiY29uc2VjdXRpdmVGYWlsdXJlcyIsImlzU3RhdGljIiwiY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZiIsInJlZnJlc2hUb2tlbiIsIm9uY2xvc2UiLCJ3YXNDbGVhbiIsInRvdGFsRmFpbHVyZXMiLCJvbmVycm9yIiwiaGVhbHRoeSIsImRpc3BhdGNoSW1tZWRpYXRlbHkiLCJpc1dTRmFpbHVyZSIsInN0YXR1c0NvZGUiLCJTdGF0dXNDb2RlIiwiX3NldHVwQ29ubmVjdGlvblByb21pc2UiLCJjb25uZWN0aW9uT3BlbiIsImhlYWx0aENoZWNrVGltZW91dFJlZiIsImNsaWVudElEIiwicGluZ0ludGVydmFsIiwiaXNEaXNjb25uZWN0ZWQiLCJoZWFsdGhDaGVjayIsIl9jb25uZWN0IiwiX3dhaXRGb3JIZWFsdGh5IiwicmFjZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImlzQ2xvc2VkUHJvbWlzZSIsImVuYWJsZVdTRmFsbGJhY2siLCJpc1Rva2VuUmVhZHkiLCJ0b2tlblJlYWR5IiwibG9hZFRva2VuIiwid3NVUkwiLCJjb25uZWN0aW9uX2lkIiwicmVzb2x2ZUNvbm5lY3Rpb25JZCIsImVuYWJsZUluc2lnaHRzIiwicmVqZWN0Q29ubmVjdGlvbklkIiwiX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uIiwiaXNTdHJpbmciLCJhcnJheU9yU3RyaW5nIiwiaXNNYXBTdHJpbmdDYWxsYmFjayIsImNhbGxiYWNrIiwiY2hhckF0Iiwia1ZhbHVlIiwibWFwcGVkVmFsdWUiLCJlbmNvZGVCYXNlNjQiLCJmcm9tQnl0ZUFycmF5IiwiY2hhciIsImNoYXJDb2RlQXQiLCJkZWNvZGVCYXNlNjQiLCJmcm9tQ2hhckNvZGUiLCJMIiwieCIsIkEiLCJEZXZUb2tlbiIsIlVzZXJGcm9tVG9rZW4iLCJmcmFnbWVudHMiLCJiNjRQYXlsb2FkIiwiVG9rZW5NYW5hZ2VyIiwic2VjcmV0Iiwic2V0VG9rZW5PclByb3ZpZGVyIiwidG9rZW5PclByb3ZpZGVyIiwiaXNBbm9ueW1vdXMiLCJ2YWxpZGF0ZVRva2VuIiwidG9rZW5Qcm92aWRlciIsInJlc2V0IiwibG9hZFRva2VuUHJvbWlzZSIsInRva2VuVXNlcklkIiwiZ2V0VG9rZW4iLCJBUElFcnJvckNvZGVzIiwiaXNBUElFcnJvciIsImlzRXJyb3JSZXRyeWFibGUiLCJpc0Nvbm5lY3Rpb25JREVycm9yIiwiaXNFcnJvclJlc3BvbnNlIiwiQ29ubmVjdGlvblN0YXRlIiwiV1NDb25uZWN0aW9uRmFsbGJhY2siLCJfb25saW5lU3RhdHVzQ2hhbmdlZCIsIl9zZXRTdGF0ZSIsIkNsb3NlZCIsImNhbmNlbFRva2VuIiwiY2FuY2VsIiwiX3JlcSIsInJldHJ5IiwiQ2FuY2VsVG9rZW4iLCJkb0F4aW9zUmVxdWVzdCIsImJhc2VVUkwiLCJwdWJsaWNFbmRwb2ludCIsIl9wb2xsIiwiQ29ubmVjdGVkIiwiZXZlbnRzIiwiaXNDYW5jZWwiLCJEaXNjb25uZWN0ZWQiLCJDb25uZWN0aW5nIiwiX2J1aWxkV1NQYXlsb2FkIiwiSW5pdCIsIkhJTlRfVVJMIiwiaGludFVybCIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImFib3J0IiwiZmV0Y2giLCJhd3NQb3AiLCJTdHJlYW1DbGllbnQiLCJuZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciIsImRldlRva2VuIiwic2V0QmFzZVVSTCIsImhpbnQiLCJsb2NhdGlvbkhpbnQiLCJsb2NhdGlvbkhpbnRVcmwiLCJsb2NhdGlvbkhpbnRUaW1lb3V0IiwiX2dldENvbm5lY3Rpb25JRCIsIndzQ29ubmVjdGlvbiIsIndzRmFsbGJhY2siLCJjb25uZWN0VXNlciIsInVzZXJUb2tlbk9yUHJvdmlkZXIiLCJzZXRVc2VyUHJvbWlzZSIsIl9pc1VzaW5nU2VydmVyQXV0aCIsIm5vZGUiLCJhbGxvd1NlcnZlclNpZGVDb25uZWN0Iiwic2V0VG9rZW5Qcm9taXNlIiwiX3NldFRva2VuIiwiX3NldFVzZXIiLCJ3c1Byb21pc2UiLCJvcGVuQ29ubmVjdGlvbiIsInBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZSIsImNsb3NlQ29ubmVjdGlvbiIsImRpc2Nvbm5lY3RVc2VyIiwiY2xlYW5pbmdJbnRlcnZhbFJlZiIsImNvbm5lY3Rpb25JZFByb21pc2UiLCJfbm9ybWFsaXplRGF0ZSIsImJlZm9yZSIsImNvbm5lY3RHdWVzdFVzZXIiLCJndWVzdFVzZXJDcmVhdGVQcm9taXNlIiwiZmluYWxseSIsImFjY2Vzc190b2tlbiIsImNvbm5lY3RBbm9ueW1vdXNVc2VyIiwiX2xvZ0FwaVJlcXVlc3QiLCJfbG9nQXBpUmVzcG9uc2UiLCJfbG9nQXBpRXJyb3IiLCJyZXF1ZXN0Q29uZmlnIiwiX2VucmljaEF4aW9zT3B0aW9ucyIsImF4aW9zSW5zdGFuY2UiLCJwdXQiLCJoYW5kbGVSZXNwb25zZSIsImNsaWVudF9yZXF1ZXN0X2lkIiwiZXJyb3JGcm9tUmVzcG9uc2UiLCJyZWNlaXZlZF9hdCIsImxpc3RlbmVyIiwid2FybVVwIiwiX3NheUhpIiwiZGVmYXVsdFdTVGltZW91dFdpdGhGYWxsYmFjayIsImRlZmF1bHRXU1RpbWVvdXQiLCJtb2RlIiwiQXhpb3NIZWFkZXJzIiwic2V0VXNlckFnZW50IiwiYXV0aG9yaXphdGlvbiIsImF4aW9zUmVxdWVzdENvbmZpZyIsImNyZWF0ZUFib3J0Q29udHJvbGxlckZvck5leHRSZXF1ZXN0IiwiaW5wdXRPcHRpb25zIiwid2l0aENyZWRlbnRpYWxzIiwiaHR0cHNBZ2VudCIsImh0dHBzIiwiQWdlbnQiLCJrZWVwQWxpdmVNc2VjcyIsInByb2Nlc3MiLCJlbnYiLCJTVFJFQU1fTE9DQUxfVEVTVF9SVU4iLCJTVFJFQU1fTE9DQUxfVEVTVF9IT1NUIiwiU3RyZWFtVmlkZW9DbGllbnQiLCJhcGlLZXlPckFyZ3MiLCJldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyIiwiY29ubmVjdGlvblByb21pc2UiLCJkaXNjb25uZWN0aW9uUHJvbWlzZSIsIndyaXRlYWJsZVN0YXRlU3RvcmUiLCJjcmVhdGVHdWVzdFVzZXIiLCJxdWVyeUNhbGxzIiwid2F0Y2giLCJxdWVyeUNhbGxTdGF0cyIsImVkZ2VzIiwiYWRkRGV2aWNlIiwicHVzaF9wcm92aWRlciIsInB1c2hfcHJvdmlkZXJfbmFtZSIsInZvaXBfdG9rZW4iLCJyZW1vdmVEZXZpY2UiLCJvblJpbmdpbmdDYWxsIiwicmVhZE9ubHlTdGF0ZVN0b3JlIiwiY2FsbElkIiwiYXBpS2V5IiwiY29ubmVjdFVzZXJSZXNwb25zZSIsIm1lIiwiY2FsbHNUb1JlV2F0Y2giLCJmaWx0ZXJfY29uZGl0aW9ucyIsIiRpbiIsImZpZWxkIiwibmV3Q2FsbCIsInByZXZDYWxsIiwidGhlQ2FsbCIsImFkZFZvaXBEZXZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-filters-web/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@stream-io/video-filters-web/dist/index.es.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SegmentationLevel: () => (/* binding */ SegmentationLevel),\n/* harmony export */   createRenderer: () => (/* binding */ createRenderer),\n/* harmony export */   isPlatformSupported: () => (/* binding */ isPlatformSupported),\n/* harmony export */   loadTFLite: () => (/* binding */ loadTFLite)\n/* harmony export */ });\n/* harmony import */ var wasm_feature_detect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasm-feature-detect */ \"(ssr)/./node_modules/wasm-feature-detect/dist/esm/index.js\");\n\n\n/**\n * Checks if the current platform is a mobile device.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n */\nconst isMobile = () => /Mobi/i.test(navigator.userAgent);\n/**\n * Runs a check to see if the current platform supports\n * the necessary APIs required for the video filters.\n */\nconst isPlatformSupported = async () => typeof document !== 'undefined' &&\n    typeof window !== 'undefined' &&\n    typeof navigator !== 'undefined' &&\n    !isMobile() && // we don't support mobile devices yet due to performance issues\n    typeof WebAssembly !== 'undefined' &&\n    !!window.WebGL2RenderingContext && // WebGL2 is required for the video filters\n    !!document.createElement('canvas').getContext('webgl2') &&\n    (await (0,wasm_feature_detect__WEBPACK_IMPORTED_MODULE_0__.simd)()); // SIMD is required for the wasm module\n\n/**\n * Use it along with boyswan.glsl-literal VSCode extension\n * to get GLSL syntax highlighting.\n * https://marketplace.visualstudio.com/items?itemName=boyswan.glsl-literal\n *\n * On VSCode OSS, boyswan.glsl-literal requires slevesque.shader extension\n * to be installed as well.\n * https://marketplace.visualstudio.com/items?itemName=slevesque.shader\n */\nconst glsl = String.raw;\nfunction createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer) {\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    const texCoordAttributeLocation = gl.getAttribLocation(program, 'a_texCoord');\n    gl.enableVertexAttribArray(texCoordAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    return program;\n}\nfunction createProgram(gl, vertexShader, fragmentShader) {\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(`Could not link WebGL program: ${gl.getProgramInfoLog(program)}`);\n    }\n    return program;\n}\nfunction compileShader(gl, shaderType, shaderSource) {\n    const shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        throw new Error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`);\n    }\n    return shader;\n}\nfunction createTexture(gl, internalformat, width, height, minFilter = gl.NEAREST, magFilter = gl.NEAREST) {\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n    gl.texStorage2D(gl.TEXTURE_2D, 1, internalformat, width, height);\n    return texture;\n}\nasync function readPixelsAsync(gl, x, y, width, height, format, type, dest) {\n    const buf = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, width, height, format, type, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);\n    gl.deleteBuffer(buf);\n    return dest;\n}\nasync function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    const res = await clientWaitAsync(gl, sync);\n    gl.deleteSync(sync);\n    if (res !== gl.WAIT_FAILED) {\n        gl.bindBuffer(target, buffer);\n        gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);\n        gl.bindBuffer(target, null);\n    }\n}\nfunction clientWaitAsync(gl, sync) {\n    return new Promise((resolve) => {\n        function test() {\n            const res = gl.clientWaitSync(sync, 0, 0);\n            if (res === gl.WAIT_FAILED) {\n                resolve(res);\n                return;\n            }\n            if (res === gl.TIMEOUT_EXPIRED) {\n                setTimeout(test);\n                return;\n            }\n            resolve(res);\n        }\n        setTimeout(test);\n    });\n}\n\nfunction buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {\n    const blurPass = buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel);\n    const blendPass = buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas);\n    function render() {\n        blurPass.render();\n        blendPass.render();\n    }\n    function updateCoverage(coverage) {\n        blendPass.updateCoverage(coverage);\n    }\n    function cleanUp() {\n        blendPass.cleanUp();\n        blurPass.cleanUp();\n    }\n    return {\n        render,\n        updateCoverage,\n        cleanUp,\n    };\n}\nfunction buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {\n    const weights = blurLevel === 'low'\n        ? [0.227027027, 0.1545945946, 0.1016216216, 0.0340540541, 0.0142162162]\n        : blurLevel === 'medium'\n            ? [0.327027027, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162]\n            : [0.627027027, 0.3445945946, 0.2216216216, 0.0540540541, 0.0162162162];\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform vec2 u_texelSize;\n\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    const float offset[5] = float[](0.0, 1.0, 2.0, 3.0, 4.0);\n    const float weight[5] = float[](\n      ${weights.join(',')}\n    );\n\n    void main() {\n      vec4 centerColor = texture(u_inputFrame, v_texCoord);\n      float personMask = texture(u_personMask, v_texCoord).a;\n\n      vec4 frameColor = centerColor * weight[0] * (1.0 - personMask);\n\n      for (int i = 1; i < 5; i++) {\n        vec2 offset = vec2(offset[i]) * u_texelSize;\n\n        vec2 texCoord = v_texCoord + offset;\n        frameColor += texture(u_inputFrame, texCoord)\n           * weight[i]\n           * (1.0 - texture(u_personMask, texCoord).a);\n\n        texCoord = v_texCoord - offset;\n        frameColor += texture(u_inputFrame, texCoord)\n          * weight[i]\n          * (1.0 - texture(u_personMask, texCoord).a);\n      }\n      outColor = vec4(frameColor.rgb + (1.0 - frameColor.a) * centerColor.rgb, 1.0);\n    }\n  `;\n    const scale = 0.5;\n    const outputWidth = canvas.width * scale;\n    const outputHeight = canvas.height * scale;\n    const texelWidth = 1 / outputWidth;\n    const texelHeight = 1 / outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize');\n    const texture1 = createTexture(gl, gl.RGBA8, outputWidth, outputHeight, gl.NEAREST, \n    // @ts-expect-error types are incomplete\n    gl.LINEAR);\n    const texture2 = createTexture(gl, gl.RGBA8, outputWidth, outputHeight, gl.NEAREST, \n    // @ts-expect-error types are incomplete\n    gl.LINEAR);\n    const frameBuffer1 = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture1, 0);\n    const frameBuffer2 = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2, 0);\n    gl.useProgram(program);\n    gl.uniform1i(personMaskLocation, 1);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.uniform1i(inputFrameLocation, 0);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);\n        for (let i = 0; i < 3; i++) {\n            gl.uniform2f(texelSizeLocation, 0, texelHeight);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            gl.activeTexture(gl.TEXTURE2);\n            gl.bindTexture(gl.TEXTURE_2D, texture1);\n            gl.uniform1i(inputFrameLocation, 2);\n            gl.uniform2f(texelSizeLocation, texelWidth, 0);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            gl.bindTexture(gl.TEXTURE_2D, texture2);\n        }\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer2);\n        gl.deleteFramebuffer(frameBuffer1);\n        gl.deleteTexture(texture2);\n        gl.deleteTexture(texture1);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return {\n        render,\n        cleanUp,\n    };\n}\nfunction buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas) {\n    const vertexShaderSource = glsl `#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `;\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_blurredInputFrame;\n    uniform vec2 u_coverage;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    void main() {\n      vec3 color = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 blurredColor = texture(u_blurredInputFrame, v_texCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(mix(blurredColor, color, personMask), 1.0);\n    }\n  `;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const blurredInputFrame = gl.getUniformLocation(program, 'u_blurredInputFrame');\n    const coverageLocation = gl.getUniformLocation(program, 'u_coverage');\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(personMaskLocation, 1);\n    gl.uniform1i(blurredInputFrame, 2);\n    gl.uniform2f(coverageLocation, 0, 1);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateCoverage(coverage) {\n        gl.useProgram(program);\n        gl.uniform2f(coverageLocation, coverage[0], coverage[1]);\n    }\n    function cleanUp() {\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n    }\n    return {\n        render,\n        updateCoverage,\n        cleanUp,\n    };\n}\n\nfunction buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas) {\n    const vertexShaderSource = glsl `#version 300 es\n\n    uniform vec2 u_backgroundScale;\n    uniform vec2 u_backgroundOffset;\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n    out vec2 v_backgroundCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n      v_backgroundCoord = a_texCoord * u_backgroundScale + u_backgroundOffset;\n    }\n  `;\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_background;\n    uniform vec2 u_coverage;\n    uniform float u_lightWrapping;\n    uniform float u_blendMode;\n\n    in vec2 v_texCoord;\n    in vec2 v_backgroundCoord;\n\n    out vec4 outColor;\n\n    vec3 screen(vec3 a, vec3 b) {\n      return 1.0 - (1.0 - a) * (1.0 - b);\n    }\n\n    vec3 linearDodge(vec3 a, vec3 b) {\n      return a + b;\n    }\n\n    void main() {\n      vec3 frameColor = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 backgroundColor = texture(u_background, v_backgroundCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      float lightWrapMask = 1.0 - max(0.0, personMask - u_coverage.y) / (1.0 - u_coverage.y);\n      vec3 lightWrap = u_lightWrapping * lightWrapMask * backgroundColor;\n\n      frameColor = u_blendMode * linearDodge(frameColor, lightWrap)\n        + (1.0 - u_blendMode) * screen(frameColor, lightWrap);\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(frameColor * personMask + backgroundColor * (1.0 - personMask), 1.0);\n    }\n  `;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const outputRatio = outputWidth / outputHeight;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const backgroundScaleLocation = gl.getUniformLocation(program, 'u_backgroundScale');\n    const backgroundOffsetLocation = gl.getUniformLocation(program, 'u_backgroundOffset');\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const backgroundLocation = gl.getUniformLocation(program, 'u_background');\n    const coverageLocation = gl.getUniformLocation(program, 'u_coverage');\n    const lightWrappingLocation = gl.getUniformLocation(program, 'u_lightWrapping');\n    const blendModeLocation = gl.getUniformLocation(program, 'u_blendMode');\n    gl.useProgram(program);\n    gl.uniform2f(backgroundScaleLocation, 1, 1);\n    gl.uniform2f(backgroundOffsetLocation, 0, 0);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(personMaskLocation, 1);\n    gl.uniform2f(coverageLocation, 0, 1);\n    gl.uniform1f(lightWrappingLocation, 0);\n    gl.uniform1f(blendModeLocation, 0);\n    let backgroundTexture = null;\n    // TODO Find a better to handle background being loaded\n    if (backgroundImage?.complete) {\n        updateBackgroundImage(backgroundImage);\n    }\n    else if (backgroundImage) {\n        backgroundImage.onload = () => {\n            updateBackgroundImage(backgroundImage);\n        };\n    }\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);\n        if (backgroundTexture !== null) {\n            gl.activeTexture(gl.TEXTURE2);\n            gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);\n            // TODO Handle correctly the background not loaded yet\n            gl.uniform1i(backgroundLocation, 2);\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateBackgroundImage(bgImage) {\n        backgroundTexture = createTexture(gl, gl.RGBA8, bgImage.naturalWidth, bgImage.naturalHeight, \n        // @ts-expect-error types are incomplete\n        gl.LINEAR, gl.LINEAR);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, bgImage.naturalWidth, bgImage.naturalHeight, gl.RGBA, gl.UNSIGNED_BYTE, bgImage);\n        let xOffset = 0;\n        let yOffset = 0;\n        let backgroundWidth = bgImage.naturalWidth;\n        let backgroundHeight = bgImage.naturalHeight;\n        const backgroundRatio = backgroundWidth / backgroundHeight;\n        if (backgroundRatio < outputRatio) {\n            backgroundHeight = backgroundWidth / outputRatio;\n            yOffset = (bgImage.naturalHeight - backgroundHeight) / 2;\n        }\n        else {\n            backgroundWidth = backgroundHeight * outputRatio;\n            xOffset = (bgImage.naturalWidth - backgroundWidth) / 2;\n        }\n        const xScale = backgroundWidth / bgImage.naturalWidth;\n        const yScale = backgroundHeight / bgImage.naturalHeight;\n        xOffset /= bgImage.naturalWidth;\n        yOffset /= bgImage.naturalHeight;\n        gl.uniform2f(backgroundScaleLocation, xScale, yScale);\n        gl.uniform2f(backgroundOffsetLocation, xOffset, yOffset);\n    }\n    function updateCoverage(coverage) {\n        gl.useProgram(program);\n        gl.uniform2f(coverageLocation, coverage[0], coverage[1]);\n    }\n    function updateLightWrapping(lightWrapping) {\n        gl.useProgram(program);\n        gl.uniform1f(lightWrappingLocation, lightWrapping);\n    }\n    function updateBlendMode(blendMode) {\n        gl.useProgram(program);\n        gl.uniform1f(blendModeLocation, blendMode === 'screen' ? 0 : 1);\n    }\n    function cleanUp() {\n        gl.deleteTexture(backgroundTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n    }\n    return {\n        render,\n        updateCoverage,\n        updateLightWrapping,\n        updateBlendMode,\n        cleanUp,\n    };\n}\n\nfunction buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, inputTexture, outputTexture, canvas, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_segmentationMask;\n    uniform vec2 u_texelSize;\n    uniform float u_step;\n    uniform float u_radius;\n    uniform float u_offset;\n    uniform float u_sigmaTexel;\n    uniform float u_sigmaColor;\n\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    float gaussian(float x, float sigma) {\n      float coeff = -0.5 / (sigma * sigma * 4.0 + 1.0e-6);\n      return exp((x * x) * coeff);\n    }\n\n    void main() {\n      vec2 centerCoord = v_texCoord;\n      vec3 centerColor = texture(u_inputFrame, centerCoord).rgb;\n      float newVal = 0.0;\n\n      float spaceWeight = 0.0;\n      float colorWeight = 0.0;\n      float totalWeight = 0.0;\n\n      // Subsample kernel space.\n      for (float i = -u_radius + u_offset; i <= u_radius; i += u_step) {\n        for (float j = -u_radius + u_offset; j <= u_radius; j += u_step) {\n          vec2 shift = vec2(j, i) * u_texelSize;\n          vec2 coord = vec2(centerCoord + shift);\n          vec3 frameColor = texture(u_inputFrame, coord).rgb;\n          float outVal = texture(u_segmentationMask, coord).a;\n\n          spaceWeight = gaussian(distance(centerCoord, coord), u_sigmaTexel);\n          colorWeight = gaussian(distance(centerColor, frameColor), u_sigmaColor);\n          totalWeight += spaceWeight * colorWeight;\n\n          newVal += spaceWeight * colorWeight * outVal;\n        }\n      }\n      newVal /= totalWeight;\n\n      outColor = vec4(vec3(0.0), newVal);\n    }\n  `;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const texelWidth = 1 / outputWidth;\n    const texelHeight = 1 / outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const segmentationMaskLocation = gl.getUniformLocation(program, 'u_segmentationMask');\n    const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize');\n    const stepLocation = gl.getUniformLocation(program, 'u_step');\n    const radiusLocation = gl.getUniformLocation(program, 'u_radius');\n    const offsetLocation = gl.getUniformLocation(program, 'u_offset');\n    const sigmaTexelLocation = gl.getUniformLocation(program, 'u_sigmaTexel');\n    const sigmaColorLocation = gl.getUniformLocation(program, 'u_sigmaColor');\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(segmentationMaskLocation, 1);\n    gl.uniform2f(texelSizeLocation, texelWidth, texelHeight);\n    // Ensures default values are configured to prevent infinite\n    // loop in fragment shader\n    updateSigmaSpace(0);\n    updateSigmaColor(0);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateSigmaSpace(sigmaSpace) {\n        sigmaSpace *= Math.max(outputWidth / segmentationWidth, outputHeight / segmentationHeight);\n        const kSparsityFactor = 0.66; // Higher is sparser.\n        const step = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor);\n        const radius = sigmaSpace;\n        const offset = step > 1 ? step * 0.5 : 0;\n        const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace;\n        gl.useProgram(program);\n        gl.uniform1f(stepLocation, step);\n        gl.uniform1f(radiusLocation, radius);\n        gl.uniform1f(offsetLocation, offset);\n        gl.uniform1f(sigmaTexelLocation, sigmaTexel);\n    }\n    function updateSigmaColor(sigmaColor) {\n        gl.useProgram(program);\n        gl.uniform1f(sigmaColorLocation, sigmaColor);\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, updateSigmaSpace, updateSigmaColor, cleanUp };\n}\n\nfunction buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n    uniform sampler2D u_inputFrame;\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    void main() {\n      outColor = texture(u_inputFrame, v_texCoord);\n    }\n  `;\n    // TFLite memory will be accessed as float32\n    const tfliteInputMemoryOffset = tflite._getInputMemoryOffset() / 4;\n    const { width: outputWidth, height: outputHeight } = segmentationConfig;\n    const outputPixelCount = outputWidth * outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const outputTexture = createTexture(gl, gl.RGBA8, outputWidth, outputHeight);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    const outputPixels = new Uint8Array(outputPixelCount * 4);\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        // Downloads pixels asynchronously from GPU while rendering the current frame.\n        // The pixels will be available in the next frame render which results\n        // in offsets in the segmentation output but increases the frame rate.\n        readPixelsAsync(gl, 0, 0, outputWidth, outputHeight, gl.RGBA, gl.UNSIGNED_BYTE, outputPixels);\n        for (let i = 0; i < outputPixelCount; i++) {\n            const tfliteIndex = tfliteInputMemoryOffset + i * 3;\n            const outputIndex = i * 4;\n            tflite.HEAPF32[tfliteIndex] = outputPixels[outputIndex] / 255;\n            tflite.HEAPF32[tfliteIndex + 1] = outputPixels[outputIndex + 1] / 255;\n            tflite.HEAPF32[tfliteIndex + 2] = outputPixels[outputIndex + 2] / 255;\n        }\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteTexture(outputTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, cleanUp };\n}\n\nfunction buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, outputTexture, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputSegmentation;\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    void main() {\n      vec2 segmentation = texture(u_inputSegmentation, v_texCoord).rg;\n      float shift = max(segmentation.r, segmentation.g);\n      float backgroundExp = exp(segmentation.r - shift);\n      float personExp = exp(segmentation.g - shift);\n      outColor = vec4(vec3(0.0), personExp / (backgroundExp + personExp));\n    }\n  `;\n    // TFLite memory will be accessed as float32\n    const tfliteOutputMemoryOffset = tflite._getOutputMemoryOffset() / 4;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputLocation = gl.getUniformLocation(program, 'u_inputSegmentation');\n    const inputTexture = createTexture(gl, gl.RG32F, segmentationWidth, segmentationHeight);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    gl.useProgram(program);\n    gl.uniform1i(inputLocation, 1);\n    function render() {\n        gl.viewport(0, 0, segmentationWidth, segmentationHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, segmentationWidth, segmentationHeight, gl.RG, gl.FLOAT, tflite.HEAPF32, tfliteOutputMemoryOffset);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteTexture(inputTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, cleanUp };\n}\n\nfunction buildWebGL2Pipeline(videoSource, backgroundImage, blurLevel, backgroundFilter, canvas, tflite, segmentationConfig) {\n    const gl = canvas.getContext('webgl2');\n    if (!gl)\n        throw new Error('WebGL2 is not supported');\n    const { width: frameWidth, height: frameHeight } = videoSource;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const vertexShaderSource = glsl `#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n    out vec2 v_texCoord;\n\n    void main() {\n      gl_Position = vec4(a_position, 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const vertexArray = gl.createVertexArray();\n    gl.bindVertexArray(vertexArray);\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    const texCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    // We don't use texStorage2D here because texImage2D seems faster\n    // to upload video texture than texSubImage2D even though the latter\n    // is supposed to be the recommended way:\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_texstorage_to_create_textures\n    const inputFrameTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    // TODO Rename segmentation and person mask to be more specific\n    const segmentationTexture = createTexture(gl, gl.RGBA8, segmentationWidth, segmentationHeight);\n    const personMaskTexture = createTexture(gl, gl.RGBA8, frameWidth, frameHeight);\n    const resizingStage = buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig);\n    const loadSegmentationStage = buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationTexture, segmentationConfig);\n    const jointBilateralFilterStage = buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, segmentationTexture, personMaskTexture, canvas, segmentationConfig);\n    const backgroundStage = backgroundFilter === 'blur'\n        ? buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel || 'high')\n        : buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas);\n    function render() {\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);\n        // texImage2D seems faster than texSubImage2D to upload\n        // video texture\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoSource);\n        gl.bindVertexArray(vertexArray);\n        resizingStage.render();\n        tflite._runInference();\n        loadSegmentationStage.render();\n        jointBilateralFilterStage.render();\n        backgroundStage.render();\n    }\n    function updatePostProcessingConfig() {\n        jointBilateralFilterStage.updateSigmaSpace(1);\n        jointBilateralFilterStage.updateSigmaColor(0.1);\n        if (backgroundFilter === 'image') {\n            const backgroundImageStage = backgroundStage;\n            backgroundImageStage.updateCoverage([0.5, 0.75]);\n            backgroundImageStage.updateLightWrapping(0.3);\n            backgroundImageStage.updateBlendMode('screen');\n        }\n        else if (backgroundFilter === 'blur') {\n            const backgroundBlurStage = backgroundStage;\n            backgroundBlurStage.updateCoverage([0.5, 0.75]);\n        }\n        else {\n            // TODO Handle no background in a separate pipeline path\n            const backgroundImageStage = backgroundStage;\n            backgroundImageStage.updateCoverage([0, 0.9999]);\n            backgroundImageStage.updateLightWrapping(0);\n        }\n    }\n    function cleanUp() {\n        backgroundStage.cleanUp();\n        jointBilateralFilterStage.cleanUp();\n        loadSegmentationStage.cleanUp();\n        resizingStage.cleanUp();\n        gl.deleteTexture(personMaskTexture);\n        gl.deleteTexture(segmentationTexture);\n        gl.deleteTexture(inputFrameTexture);\n        gl.deleteBuffer(texCoordBuffer);\n        gl.deleteBuffer(positionBuffer);\n        gl.deleteVertexArray(vertexArray);\n        gl.deleteShader(vertexShader);\n    }\n    return { render, updatePostProcessingConfig, cleanUp };\n}\n\nvar SegmentationLevel;\n(function (SegmentationLevel) {\n    SegmentationLevel[\"LOW\"] = \"low\";\n    SegmentationLevel[\"HIGH\"] = \"high\";\n})(SegmentationLevel || (SegmentationLevel = {}));\nconst getSegmentationParams = (level) => {\n    if (level === SegmentationLevel.HIGH) {\n        return { width: 256, height: 144 };\n    }\n    return { width: 160, height: 96 };\n};\n\nfunction createRenderer(tflite, videoSource, targetCanvas, options) {\n    const { backgroundFilter, backgroundImage, backgroundBlurLevel, segmentationLevel = SegmentationLevel.HIGH, fps = 30, } = options;\n    if (backgroundFilter === 'image' && !backgroundImage) {\n        throw new Error(`backgroundImage element is required when backgroundFilter is image`);\n    }\n    const pipeline = buildWebGL2Pipeline(videoSource, backgroundImage, backgroundBlurLevel, backgroundFilter, targetCanvas, tflite, getSegmentationParams(segmentationLevel));\n    const id = setInterval(() => {\n        pipeline.render();\n        if (backgroundFilter === 'image') {\n            pipeline.updatePostProcessingConfig();\n        }\n    }, 1000 / (fps <= 0 ? 30 : fps));\n    return {\n        dispose: () => {\n            pipeline.cleanUp();\n            clearInterval(id);\n        },\n    };\n}\n\nconst createTFLiteSIMDModule = (__Module) => {\n  __Module = __Module || {};\n\n  var _scriptDir =\n    typeof document !== 'undefined' && document.currentScript\n      ? document.currentScript.src\n      : undefined;\n\n  var Module = typeof __Module != 'undefined' ? __Module : {};\n  var readyPromiseResolve, readyPromiseReject;\n  Module['ready'] = new Promise(function (resolve, reject) {\n    readyPromiseResolve = resolve;\n    readyPromiseReject = reject;\n  });\n  var moduleOverrides = Object.assign({}, Module);\n  var thisProgram = './this.program';\n  var quit_ = (status, toThrow) => {\n    throw toThrow;\n  };\n  var ENVIRONMENT_IS_WEB = true;\n  var scriptDirectory = '';\n\n  function locateFile(path) {\n    if (Module['locateFile']) {\n      return Module['locateFile'](path, scriptDirectory);\n    }\n    return scriptDirectory + path;\n  }\n\n  var readBinary;\n  {\n    if (typeof document != 'undefined' && document.currentScript) {\n      scriptDirectory = document.currentScript.src;\n    }\n    if (_scriptDir) {\n      scriptDirectory = _scriptDir;\n    }\n    if (scriptDirectory.indexOf('blob:') !== 0) {\n      scriptDirectory = scriptDirectory.substr(\n        0,\n        scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,\n      );\n    } else {\n      scriptDirectory = '';\n    }\n  }\n  var out = Module['print'] || console.log.bind(console);\n  var err = Module['printErr'] || console.warn.bind(console);\n  Object.assign(Module, moduleOverrides);\n  moduleOverrides = null;\n  if (Module['arguments']) Module['arguments'];\n  if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n  if (Module['quit']) quit_ = Module['quit'];\n  var wasmBinary;\n  if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n  var noExitRuntime = Module['noExitRuntime'] || true;\n  if (typeof WebAssembly != 'object') {\n    abort('no native wasm support detected');\n  }\n  var wasmMemory;\n  var ABORT = false;\n\n  var UTF8Decoder =\n    typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n    var endIdx = idx + maxBytesToRead;\n    var endPtr = idx;\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n    }\n    var str = '';\n    while (idx < endPtr) {\n      var u0 = heapOrArray[idx++];\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n      var u1 = heapOrArray[idx++] & 63;\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\n        continue;\n      }\n      var u2 = heapOrArray[idx++] & 63;\n      if ((u0 & 240) == 224) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u0 =\n          ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 65536;\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n      }\n    }\n    return str;\n  }\n\n  var buffer, HEAP8, HEAPU8, HEAPU32;\n\n  function updateGlobalBufferAndViews(buf) {\n    buffer = buf;\n    Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n    Module['HEAP16'] = new Int16Array(buf);\n    Module['HEAP32'] = new Int32Array(buf);\n    Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n    Module['HEAPU16'] = new Uint16Array(buf);\n    Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n    Module['HEAPF32'] = new Float32Array(buf);\n    Module['HEAPF64'] = new Float64Array(buf);\n  }\n\n  Module['INITIAL_MEMORY'] || 16777216;\n  var __ATPRERUN__ = [];\n  var __ATINIT__ = [];\n  var __ATPOSTRUN__ = [];\n\n  function keepRuntimeAlive() {\n    return noExitRuntime;\n  }\n\n  function preRun() {\n    if (Module['preRun']) {\n      if (typeof Module['preRun'] == 'function')\n        Module['preRun'] = [Module['preRun']];\n      while (Module['preRun'].length) {\n        addOnPreRun(Module['preRun'].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPRERUN__);\n  }\n\n  function initRuntime() {\n    callRuntimeCallbacks(__ATINIT__);\n  }\n\n  function postRun() {\n    if (Module['postRun']) {\n      if (typeof Module['postRun'] == 'function')\n        Module['postRun'] = [Module['postRun']];\n      while (Module['postRun'].length) {\n        addOnPostRun(Module['postRun'].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__);\n  }\n\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n  }\n\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n  }\n\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n  }\n\n  var runDependencies = 0;\n  var dependenciesFulfilled = null;\n\n  function addRunDependency(id) {\n    runDependencies++;\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies);\n    }\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies);\n    }\n    if (runDependencies == 0) {\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback();\n      }\n    }\n  }\n\n  function abort(what) {\n    {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n    }\n    what = 'Aborted(' + what + ')';\n    err(what);\n    ABORT = true;\n    what += '. Build with -sASSERTIONS for more info.';\n    var e = new WebAssembly.RuntimeError(what);\n    readyPromiseReject(e);\n    throw e;\n  }\n\n  var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n  function isDataURI(filename) {\n    return filename.startsWith(dataURIPrefix);\n  }\n\n  var wasmBinaryFile;\n  wasmBinaryFile = 'tflite-simd.wasm';\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile);\n  }\n\n  function getBinary(file) {\n    try {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) ;\n      throw 'both async and sync fetching of the wasm failed';\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n    } catch (err) {\n      abort(err);\n    }\n  }\n\n  function getBinaryPromise() {\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB )) {\n      if (typeof fetch == 'function') {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' })\n          .then(function (response) {\n            if (!response['ok']) {\n              throw (\n                \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\"\n              );\n            }\n            return response['arrayBuffer']();\n          })\n          .catch(function () {\n            return getBinary(wasmBinaryFile);\n          });\n      }\n    }\n    return Promise.resolve().then(function () {\n      return getBinary(wasmBinaryFile);\n    });\n  }\n\n  function createWasm() {\n    var info = {\n      env: asmLibraryArg,\n      wasi_snapshot_preview1: asmLibraryArg,\n    };\n\n    function receiveInstance(instance, module) {\n      var exports = instance.exports;\n      Module['asm'] = exports;\n      wasmMemory = Module['asm']['memory'];\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      Module['asm']['__indirect_function_table'];\n      addOnInit(Module['asm']['__wasm_call_ctors']);\n      removeRunDependency();\n    }\n\n    addRunDependency();\n\n    function receiveInstantiationResult(result) {\n      receiveInstance(result['instance']);\n    }\n\n    function instantiateArrayBuffer(receiver) {\n      return getBinaryPromise()\n        .then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        })\n        .then(function (instance) {\n          return instance;\n        })\n        .then(receiver, function (reason) {\n          err('failed to asynchronously prepare wasm: ' + reason);\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync() {\n      if (\n        !wasmBinary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(\n          function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiationResult, function (reason) {\n              err('wasm streaming compile failed: ' + reason);\n              err('falling back to ArrayBuffer instantiation');\n              return instantiateArrayBuffer(receiveInstantiationResult);\n            });\n          },\n        );\n      } else {\n        return instantiateArrayBuffer(receiveInstantiationResult);\n      }\n    }\n\n    if (Module['instantiateWasm']) {\n      try {\n        var exports = Module['instantiateWasm'](info, receiveInstance);\n        return exports;\n      } catch (e) {\n        err('Module.instantiateWasm callback failed with error: ' + e);\n        readyPromiseReject(e);\n      }\n    }\n    instantiateAsync().catch(readyPromiseReject);\n    return {};\n  }\n\n  function ExitStatus(status) {\n    this.name = 'ExitStatus';\n    this.message = 'Program terminated with exit(' + status + ')';\n    this.status = status;\n  }\n\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n      callbacks.shift()(Module);\n    }\n  }\n\n  function __dlinit(main_dso_handle) {}\n\n  var dlopenMissingError =\n    'To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking';\n\n  function __dlopen_js(filename, flag) {\n    abort(dlopenMissingError);\n  }\n\n  function __dlsym_js(handle, symbol) {\n    abort(dlopenMissingError);\n  }\n\n  var nowIsMonotonic = true;\n\n  function __emscripten_get_now_is_monotonic() {\n    return nowIsMonotonic;\n  }\n\n  function __mmap_js(len, prot, flags, fd, off, allocated) {\n    return -52;\n  }\n\n  function __munmap_js(addr, len, prot, flags, fd, offset) {}\n\n  function _abort() {\n    abort('');\n  }\n\n  function _emscripten_date_now() {\n    return Date.now();\n  }\n\n  function getHeapMax() {\n    return 2147483648;\n  }\n\n  function _emscripten_get_heap_max() {\n    return getHeapMax();\n  }\n\n  var _emscripten_get_now;\n  _emscripten_get_now = () => performance.now();\n\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.copyWithin(dest, src, src + num);\n  }\n\n  function emscripten_realloc_buffer(size) {\n    try {\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      return 1;\n    } catch (e) {}\n  }\n\n  function _emscripten_resize_heap(requestedSize) {\n    var oldSize = HEAPU8.length;\n    requestedSize = requestedSize >>> 0;\n    var maxHeapSize = getHeapMax();\n    if (requestedSize > maxHeapSize) {\n      return false;\n    }\n    let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(\n        overGrownHeapSize,\n        requestedSize + 100663296,\n      );\n      var newSize = Math.min(\n        maxHeapSize,\n        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536),\n      );\n      var replacement = emscripten_realloc_buffer(newSize);\n      if (replacement) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var ENV = {};\n\n  function getExecutableName() {\n    return thisProgram || './this.program';\n  }\n\n  function getEnvStrings() {\n    if (!getEnvStrings.strings) {\n      var lang =\n        (\n          (typeof navigator == 'object' &&\n            navigator.languages &&\n            navigator.languages[0]) ||\n          'C'\n        ).replace('-', '_') + '.UTF-8';\n      var env = {\n        USER: 'web_user',\n        LOGNAME: 'web_user',\n        PATH: '/',\n        PWD: '/',\n        HOME: '/home/web_user',\n        LANG: lang,\n        _: getExecutableName(),\n      };\n      for (var x in ENV) {\n        if (ENV[x] === undefined) delete env[x];\n        else env[x] = ENV[x];\n      }\n      var strings = [];\n      for (var x in env) {\n        strings.push(x + '=' + env[x]);\n      }\n      getEnvStrings.strings = strings;\n    }\n    return getEnvStrings.strings;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n    }\n    if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n  }\n\n  function _environ_get(__environ, environ_buf) {\n    var bufSize = 0;\n    getEnvStrings().forEach(function (string, i) {\n      var ptr = environ_buf + bufSize;\n      HEAPU32[(__environ + i * 4) >> 2] = ptr;\n      writeAsciiToMemory(string, ptr);\n      bufSize += string.length + 1;\n    });\n    return 0;\n  }\n\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\n    var strings = getEnvStrings();\n    HEAPU32[penviron_count >> 2] = strings.length;\n    var bufSize = 0;\n    strings.forEach(function (string) {\n      bufSize += string.length + 1;\n    });\n    HEAPU32[penviron_buf_size >> 2] = bufSize;\n    return 0;\n  }\n\n  function _proc_exit(code) {\n    if (!keepRuntimeAlive()) {\n      if (Module['onExit']) Module['onExit'](code);\n      ABORT = true;\n    }\n    quit_(code, new ExitStatus(code));\n  }\n\n  function exitJS(status, implicit) {\n    _proc_exit(status);\n  }\n\n  var _exit = exitJS;\n\n  function _fd_close(fd) {\n    return 52;\n  }\n\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n    return 70;\n  }\n\n  var printCharBuffers = [null, [], []];\n\n  function printChar(stream, curr) {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    var buffer = printCharBuffers[stream];\n    if (curr === 0 || curr === 10) {\n      (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n      buffer.length = 0;\n    } else {\n      buffer.push(curr);\n    }\n  }\n\n  function _fd_write(fd, iov, iovcnt, pnum) {\n    var num = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2];\n      var len = HEAPU32[(iov + 4) >> 2];\n      iov += 8;\n      for (var j = 0; j < len; j++) {\n        printChar(fd, HEAPU8[ptr + j]);\n      }\n      num += len;\n    }\n    HEAPU32[pnum >> 2] = num;\n    return 0;\n  }\n\n  function getRandomDevice() {\n    if (\n      typeof crypto == 'object' &&\n      typeof crypto['getRandomValues'] == 'function'\n    ) {\n      var randomBuffer = new Uint8Array(1);\n      return () => {\n        crypto.getRandomValues(randomBuffer);\n        return randomBuffer[0];\n      };\n    } else return () => abort('randomDevice');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function _getentropy(buffer, size) {\n    if (!_getentropy.randomDevice) {\n      _getentropy.randomDevice = getRandomDevice();\n    }\n    for (var i = 0; i < size; i++) {\n      HEAP8[(buffer + i) >> 0] = _getentropy.randomDevice();\n    }\n    return 0;\n  }\n\n  var asmLibraryArg = {\n    _dlinit: __dlinit,\n    _dlopen_js: __dlopen_js,\n    _dlsym_js: __dlsym_js,\n    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n    _mmap_js: __mmap_js,\n    _munmap_js: __munmap_js,\n    abort: _abort,\n    emscripten_date_now: _emscripten_date_now,\n    emscripten_get_heap_max: _emscripten_get_heap_max,\n    emscripten_get_now: _emscripten_get_now,\n    emscripten_memcpy_big: _emscripten_memcpy_big,\n    emscripten_resize_heap: _emscripten_resize_heap,\n    environ_get: _environ_get,\n    environ_sizes_get: _environ_sizes_get,\n    exit: _exit,\n    fd_close: _fd_close,\n    fd_seek: _fd_seek,\n    fd_write: _fd_write,\n    getentropy: _getentropy,\n  };\n  createWasm();\n  (Module['___wasm_call_ctors'] = function () {\n    return (Module['___wasm_call_ctors'] =\n      Module['asm']['__wasm_call_ctors']).apply(null, arguments);\n  });\n  (Module['_getModelBufferMemoryOffset'] =\n    function () {\n      return (Module[\n        '_getModelBufferMemoryOffset'\n      ] =\n        Module['asm']['getModelBufferMemoryOffset']).apply(null, arguments);\n    });\n  (Module['_getInputMemoryOffset'] = function () {\n    return (Module['_getInputMemoryOffset'] =\n      Module['asm']['getInputMemoryOffset']).apply(null, arguments);\n  });\n  (Module['_getInputHeight'] = function () {\n    return (Module['_getInputHeight'] =\n      Module['asm']['getInputHeight']).apply(null, arguments);\n  });\n  (Module['_getInputWidth'] = function () {\n    return (Module['_getInputWidth'] =\n      Module['asm']['getInputWidth']).apply(null, arguments);\n  });\n  (Module['_getInputChannelCount'] = function () {\n    return (Module['_getInputChannelCount'] =\n      Module['asm']['getInputChannelCount']).apply(null, arguments);\n  });\n  (Module['_getOutputMemoryOffset'] = function () {\n    return (Module['_getOutputMemoryOffset'] =\n      Module['asm']['getOutputMemoryOffset']).apply(null, arguments);\n  });\n  (Module['_getOutputHeight'] = function () {\n    return (Module['_getOutputHeight'] =\n      Module['asm']['getOutputHeight']).apply(null, arguments);\n  });\n  (Module['_getOutputWidth'] = function () {\n    return (Module['_getOutputWidth'] =\n      Module['asm']['getOutputWidth']).apply(null, arguments);\n  });\n  (Module['_getOutputChannelCount'] = function () {\n    return (Module['_getOutputChannelCount'] =\n      Module['asm']['getOutputChannelCount']).apply(null, arguments);\n  });\n  (Module['_loadModel'] = function () {\n    return (Module['_loadModel'] =\n      Module['asm']['loadModel']).apply(null, arguments);\n  });\n  (Module['_runInference'] = function () {\n    return (Module['_runInference'] =\n      Module['asm']['runInference']).apply(null, arguments);\n  });\n  (Module['_malloc'] = function () {\n    return (Module['_malloc'] = Module['asm']['malloc']).apply(\n      null,\n      arguments,\n    );\n  });\n  (Module['___errno_location'] = function () {\n    return (Module['___errno_location'] =\n      Module['asm']['__errno_location']).apply(null, arguments);\n  });\n  (Module['___dl_seterr'] = function () {\n    return (Module['___dl_seterr'] =\n      Module['asm']['__dl_seterr']).apply(null, arguments);\n  });\n  (Module['stackSave'] = function () {\n    return (Module['stackSave'] = Module['asm']['stackSave']).apply(\n      null,\n      arguments,\n    );\n  });\n  (Module['stackRestore'] = function () {\n    return (Module['stackRestore'] =\n      Module['asm']['stackRestore']).apply(null, arguments);\n  });\n  (Module['stackAlloc'] = function () {\n    return (Module['stackAlloc'] =\n      Module['asm']['stackAlloc']).apply(null, arguments);\n  });\n  (Module['dynCall_jjj'] = function () {\n    return (Module['dynCall_jjj'] =\n      Module['asm']['dynCall_jjj']).apply(null, arguments);\n  });\n  (Module['dynCall_jiii'] = function () {\n    return (Module['dynCall_jiii'] =\n      Module['asm']['dynCall_jiii']).apply(null, arguments);\n  });\n  (Module['dynCall_iiiijj'] = function () {\n    return (Module['dynCall_iiiijj'] =\n      Module['asm']['dynCall_iiiijj']).apply(null, arguments);\n  });\n  (Module['dynCall_viijj'] = function () {\n    return (Module['dynCall_viijj'] =\n      Module['asm']['dynCall_viijj']).apply(null, arguments);\n  });\n  (Module['dynCall_viiijjj'] = function () {\n    return (Module['dynCall_viiijjj'] =\n      Module['asm']['dynCall_viiijjj']).apply(null, arguments);\n  });\n  (Module['dynCall_iijjiiii'] = function () {\n    return (Module['dynCall_iijjiiii'] =\n      Module['asm']['dynCall_iijjiiii']).apply(null, arguments);\n  });\n  (Module['dynCall_jiji'] = function () {\n    return (Module['dynCall_jiji'] =\n      Module['asm']['dynCall_jiji']).apply(null, arguments);\n  });\n  var calledRun;\n  dependenciesFulfilled = function runCaller() {\n    if (!calledRun) run();\n    if (!calledRun) dependenciesFulfilled = runCaller;\n  };\n\n  function run(args) {\n    if (runDependencies > 0) {\n      return;\n    }\n    preRun();\n    if (runDependencies > 0) {\n      return;\n    }\n\n    function doRun() {\n      if (calledRun) return;\n      calledRun = true;\n      Module['calledRun'] = true;\n      if (ABORT) return;\n      initRuntime();\n      readyPromiseResolve(Module);\n      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n      postRun();\n    }\n\n    if (Module['setStatus']) {\n      Module['setStatus']('Running...');\n      setTimeout(function () {\n        setTimeout(function () {\n          Module['setStatus']('');\n        }, 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n  }\n\n  if (Module['preInit']) {\n    if (typeof Module['preInit'] == 'function')\n      Module['preInit'] = [Module['preInit']];\n    while (Module['preInit'].length > 0) {\n      Module['preInit'].pop()();\n    }\n  }\n  run();\n\n  return __Module.ready;\n};\n\nconst version = \"0.1.0\" ;\nconst packageName = \"@stream-io/video-filters-web\" ;\n\n// @ts-expect-error - module is not declared\n// This is a WebAssembly module compiled from the TensorFlow Lite C++ library.\nconst createTFLite = createTFLiteSIMDModule;\nconst loadTFLite = async (options = {}) => {\n    const { basePath = `https://unpkg.com/${packageName}@${version}/tf`, tfFilePath = `${basePath}/tflite/tflite-simd.wasm`, modelFilePath = `${basePath}/models/segm_full_v679.tflite`, } = options;\n    const [tfLite, model] = await Promise.all([\n        createTFLite({ locateFile: () => tfFilePath }),\n        fetchModel(modelFilePath),\n    ]);\n    const modelBufferOffset = tfLite._getModelBufferMemoryOffset();\n    tfLite.HEAPU8.set(new Uint8Array(model), modelBufferOffset);\n    tfLite._loadModel(model.byteLength);\n    return tfLite;\n};\nlet lastModelFilePath = '';\nlet modelFileCache;\nconst fetchModel = async (modelFilePath) => {\n    const model = modelFilePath === lastModelFilePath && modelFileCache\n        ? modelFileCache\n        : await fetch(modelFilePath).then((r) => r.arrayBuffer());\n    // Cache the model file for future use.\n    modelFileCache = model;\n    lastModelFilePath = modelFilePath;\n    return model;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1maWx0ZXJzLXdlYi9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUFJLEtBQUs7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDhCQUE4QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQXVEO0FBQ25FLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4vbm9kZV9tb2R1bGVzL0BzdHJlYW0taW8vdmlkZW8tZmlsdGVycy13ZWIvZGlzdC9pbmRleC5lcy5qcz8wMDg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNpbWQgfSBmcm9tICd3YXNtLWZlYXR1cmUtZGV0ZWN0JztcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcGxhdGZvcm0gaXMgYSBtb2JpbGUgZGV2aWNlLlxuICpcbiAqIFNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQnJvd3Nlcl9kZXRlY3Rpb25fdXNpbmdfdGhlX3VzZXJfYWdlbnRcbiAqL1xuY29uc3QgaXNNb2JpbGUgPSAoKSA9PiAvTW9iaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vKipcbiAqIFJ1bnMgYSBjaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgcGxhdGZvcm0gc3VwcG9ydHNcbiAqIHRoZSBuZWNlc3NhcnkgQVBJcyByZXF1aXJlZCBmb3IgdGhlIHZpZGVvIGZpbHRlcnMuXG4gKi9cbmNvbnN0IGlzUGxhdGZvcm1TdXBwb3J0ZWQgPSBhc3luYyAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICFpc01vYmlsZSgpICYmIC8vIHdlIGRvbid0IHN1cHBvcnQgbW9iaWxlIGRldmljZXMgeWV0IGR1ZSB0byBwZXJmb3JtYW5jZSBpc3N1ZXNcbiAgICB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgISF3aW5kb3cuV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAmJiAvLyBXZWJHTDIgaXMgcmVxdWlyZWQgZm9yIHRoZSB2aWRlbyBmaWx0ZXJzXG4gICAgISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCd3ZWJnbDInKSAmJlxuICAgIChhd2FpdCBzaW1kKCkpOyAvLyBTSU1EIGlzIHJlcXVpcmVkIGZvciB0aGUgd2FzbSBtb2R1bGVcblxuLyoqXG4gKiBVc2UgaXQgYWxvbmcgd2l0aCBib3lzd2FuLmdsc2wtbGl0ZXJhbCBWU0NvZGUgZXh0ZW5zaW9uXG4gKiB0byBnZXQgR0xTTCBzeW50YXggaGlnaGxpZ2h0aW5nLlxuICogaHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWJveXN3YW4uZ2xzbC1saXRlcmFsXG4gKlxuICogT24gVlNDb2RlIE9TUywgYm95c3dhbi5nbHNsLWxpdGVyYWwgcmVxdWlyZXMgc2xldmVzcXVlLnNoYWRlciBleHRlbnNpb25cbiAqIHRvIGJlIGluc3RhbGxlZCBhcyB3ZWxsLlxuICogaHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXNsZXZlc3F1ZS5zaGFkZXJcbiAqL1xuY29uc3QgZ2xzbCA9IFN0cmluZy5yYXc7XG5mdW5jdGlvbiBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24pO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGNvbnN0IHRleENvb3JkQXR0cmlidXRlTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90ZXhDb29yZCcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleENvb3JkQXR0cmlidXRlTG9jYXRpb24pO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhDb29yZEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXhDb29yZEF0dHJpYnV0ZUxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIHJldHVybiBwcm9ncmFtO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xuICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGxpbmsgV2ViR0wgcHJvZ3JhbTogJHtnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyYW07XG59XG5mdW5jdGlvbiBjb21waWxlU2hhZGVyKGdsLCBzaGFkZXJUeXBlLCBzaGFkZXJTb3VyY2UpIHtcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgY29tcGlsZSBzaGFkZXI6ICR7Z2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCwgaW50ZXJuYWxmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG1pbkZpbHRlciA9IGdsLk5FQVJFU1QsIG1hZ0ZpbHRlciA9IGdsLk5FQVJFU1QpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBtaW5GaWx0ZXIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBtYWdGaWx0ZXIpO1xuICAgIGdsLnRleFN0b3JhZ2UyRChnbC5URVhUVVJFXzJELCAxLCBpbnRlcm5hbGZvcm1hdCwgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59XG5hc3luYyBmdW5jdGlvbiByZWFkUGl4ZWxzQXN5bmMoZ2wsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgZGVzdCkge1xuICAgIGNvbnN0IGJ1ZiA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuUElYRUxfUEFDS19CVUZGRVIsIGJ1Zik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5QSVhFTF9QQUNLX0JVRkZFUiwgZGVzdC5ieXRlTGVuZ3RoLCBnbC5TVFJFQU1fUkVBRCk7XG4gICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIDApO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuUElYRUxfUEFDS19CVUZGRVIsIG51bGwpO1xuICAgIGF3YWl0IGdldEJ1ZmZlclN1YkRhdGFBc3luYyhnbCwgZ2wuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZiwgMCwgZGVzdCk7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKGJ1Zik7XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCdWZmZXJTdWJEYXRhQXN5bmMoZ2wsIHRhcmdldCwgYnVmZmVyLCBzcmNCeXRlT2Zmc2V0LCBkc3RCdWZmZXIsIGRzdE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgY29uc3Qgc3luYyA9IGdsLmZlbmNlU3luYyhnbC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwgMCk7XG4gICAgZ2wuZmx1c2goKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnRXYWl0QXN5bmMoZ2wsIHN5bmMpO1xuICAgIGdsLmRlbGV0ZVN5bmMoc3luYyk7XG4gICAgaWYgKHJlcyAhPT0gZ2wuV0FJVF9GQUlMRUQpIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcih0YXJnZXQsIGJ1ZmZlcik7XG4gICAgICAgIGdsLmdldEJ1ZmZlclN1YkRhdGEodGFyZ2V0LCBzcmNCeXRlT2Zmc2V0LCBkc3RCdWZmZXIsIGRzdE9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsaWVudFdhaXRBc3luYyhnbCwgc3luYykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZ2wuY2xpZW50V2FpdFN5bmMoc3luYywgMCwgMCk7XG4gICAgICAgICAgICBpZiAocmVzID09PSBnbC5XQUlUX0ZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzID09PSBnbC5USU1FT1VUX0VYUElSRUQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KHRlc3QpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZEJhY2tncm91bmRCbHVyU3RhZ2UoZ2wsIHZlcnRleFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBwZXJzb25NYXNrVGV4dHVyZSwgY2FudmFzLCBibHVyTGV2ZWwpIHtcbiAgICBjb25zdCBibHVyUGFzcyA9IGJ1aWxkQmx1clBhc3MoZ2wsIHZlcnRleFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBwZXJzb25NYXNrVGV4dHVyZSwgY2FudmFzLCBibHVyTGV2ZWwpO1xuICAgIGNvbnN0IGJsZW5kUGFzcyA9IGJ1aWxkQmxlbmRQYXNzKGdsLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIGNhbnZhcyk7XG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBibHVyUGFzcy5yZW5kZXIoKTtcbiAgICAgICAgYmxlbmRQYXNzLnJlbmRlcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb3ZlcmFnZShjb3ZlcmFnZSkge1xuICAgICAgICBibGVuZFBhc3MudXBkYXRlQ292ZXJhZ2UoY292ZXJhZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhblVwKCkge1xuICAgICAgICBibGVuZFBhc3MuY2xlYW5VcCgpO1xuICAgICAgICBibHVyUGFzcy5jbGVhblVwKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgdXBkYXRlQ292ZXJhZ2UsXG4gICAgICAgIGNsZWFuVXAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQmx1clBhc3MoZ2wsIHZlcnRleFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBwZXJzb25NYXNrVGV4dHVyZSwgY2FudmFzLCBibHVyTGV2ZWwpIHtcbiAgICBjb25zdCB3ZWlnaHRzID0gYmx1ckxldmVsID09PSAnbG93J1xuICAgICAgICA/IFswLjIyNzAyNzAyNywgMC4xNTQ1OTQ1OTQ2LCAwLjEwMTYyMTYyMTYsIDAuMDM0MDU0MDU0MSwgMC4wMTQyMTYyMTYyXVxuICAgICAgICA6IGJsdXJMZXZlbCA9PT0gJ21lZGl1bSdcbiAgICAgICAgICAgID8gWzAuMzI3MDI3MDI3LCAwLjE5NDU5NDU5NDYsIDAuMTIxNjIxNjIxNiwgMC4wNTQwNTQwNTQxLCAwLjAxNjIxNjIxNjJdXG4gICAgICAgICAgICA6IFswLjYyNzAyNzAyNywgMC4zNDQ1OTQ1OTQ2LCAwLjIyMTYyMTYyMTYsIDAuMDU0MDU0MDU0MSwgMC4wMTYyMTYyMTYyXTtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dEZyYW1lO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfcGVyc29uTWFzaztcbiAgICB1bmlmb3JtIHZlYzIgdV90ZXhlbFNpemU7XG5cbiAgICBpbiB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICBjb25zdCBmbG9hdCBvZmZzZXRbNV0gPSBmbG9hdFtdKDAuMCwgMS4wLCAyLjAsIDMuMCwgNC4wKTtcbiAgICBjb25zdCBmbG9hdCB3ZWlnaHRbNV0gPSBmbG9hdFtdKFxuICAgICAgJHt3ZWlnaHRzLmpvaW4oJywnKX1cbiAgICApO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCBjZW50ZXJDb2xvciA9IHRleHR1cmUodV9pbnB1dEZyYW1lLCB2X3RleENvb3JkKTtcbiAgICAgIGZsb2F0IHBlcnNvbk1hc2sgPSB0ZXh0dXJlKHVfcGVyc29uTWFzaywgdl90ZXhDb29yZCkuYTtcblxuICAgICAgdmVjNCBmcmFtZUNvbG9yID0gY2VudGVyQ29sb3IgKiB3ZWlnaHRbMF0gKiAoMS4wIC0gcGVyc29uTWFzayk7XG5cbiAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIHZlYzIgb2Zmc2V0ID0gdmVjMihvZmZzZXRbaV0pICogdV90ZXhlbFNpemU7XG5cbiAgICAgICAgdmVjMiB0ZXhDb29yZCA9IHZfdGV4Q29vcmQgKyBvZmZzZXQ7XG4gICAgICAgIGZyYW1lQ29sb3IgKz0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIHRleENvb3JkKVxuICAgICAgICAgICAqIHdlaWdodFtpXVxuICAgICAgICAgICAqICgxLjAgLSB0ZXh0dXJlKHVfcGVyc29uTWFzaywgdGV4Q29vcmQpLmEpO1xuXG4gICAgICAgIHRleENvb3JkID0gdl90ZXhDb29yZCAtIG9mZnNldDtcbiAgICAgICAgZnJhbWVDb2xvciArPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgdGV4Q29vcmQpXG4gICAgICAgICAgKiB3ZWlnaHRbaV1cbiAgICAgICAgICAqICgxLjAgLSB0ZXh0dXJlKHVfcGVyc29uTWFzaywgdGV4Q29vcmQpLmEpO1xuICAgICAgfVxuICAgICAgb3V0Q29sb3IgPSB2ZWM0KGZyYW1lQ29sb3IucmdiICsgKDEuMCAtIGZyYW1lQ29sb3IuYSkgKiBjZW50ZXJDb2xvci5yZ2IsIDEuMCk7XG4gICAgfVxuICBgO1xuICAgIGNvbnN0IHNjYWxlID0gMC41O1xuICAgIGNvbnN0IG91dHB1dFdpZHRoID0gY2FudmFzLndpZHRoICogc2NhbGU7XG4gICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gY2FudmFzLmhlaWdodCAqIHNjYWxlO1xuICAgIGNvbnN0IHRleGVsV2lkdGggPSAxIC8gb3V0cHV0V2lkdGg7XG4gICAgY29uc3QgdGV4ZWxIZWlnaHQgPSAxIC8gb3V0cHV0SGVpZ2h0O1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVBpcGVsaW5lU3RhZ2VQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGNvbnN0IGlucHV0RnJhbWVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9pbnB1dEZyYW1lJyk7XG4gICAgY29uc3QgcGVyc29uTWFza0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3BlcnNvbk1hc2snKTtcbiAgICBjb25zdCB0ZXhlbFNpemVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV90ZXhlbFNpemUnKTtcbiAgICBjb25zdCB0ZXh0dXJlMSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0LCBnbC5ORUFSRVNULCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGVzIGFyZSBpbmNvbXBsZXRlXG4gICAgZ2wuTElORUFSKTtcbiAgICBjb25zdCB0ZXh0dXJlMiA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0LCBnbC5ORUFSRVNULCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGVzIGFyZSBpbmNvbXBsZXRlXG4gICAgZ2wuTElORUFSKTtcbiAgICBjb25zdCBmcmFtZUJ1ZmZlcjEgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIxKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUxLCAwKTtcbiAgICBjb25zdCBmcmFtZUJ1ZmZlcjIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUyLCAwKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLnVuaWZvcm0xaShwZXJzb25NYXNrTG9jYXRpb24sIDEpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShpbnB1dEZyYW1lTG9jYXRpb24sIDApO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcGVyc29uTWFza1RleHR1cmUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHRleGVsU2l6ZUxvY2F0aW9uLCAwLCB0ZXhlbEhlaWdodCk7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyMSk7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTIpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZTEpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKGlucHV0RnJhbWVMb2NhdGlvbiwgMik7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmYodGV4ZWxTaXplTG9jYXRpb24sIHRleGVsV2lkdGgsIDApO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcjIpO1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIyKTtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIxKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlMik7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZTEpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXIsXG4gICAgICAgIGNsZWFuVXAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQmxlbmRQYXNzKGdsLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIGNhbnZhcykge1xuICAgIGNvbnN0IHZlcnRleFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgaW4gdmVjMiBhX3Bvc2l0aW9uO1xuICAgIGluIHZlYzIgYV90ZXhDb29yZDtcblxuICAgIG91dCB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAvLyBGbGlwcGluZyBZIGlzIHJlcXVpcmVkIHdoZW4gcmVuZGVyaW5nIHRvIGNhbnZhc1xuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24gKiB2ZWMyKDEuMCwgLTEuMCksIDAuMCwgMS4wKTtcbiAgICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dEZyYW1lO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfcGVyc29uTWFzaztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2JsdXJyZWRJbnB1dEZyYW1lO1xuICAgIHVuaWZvcm0gdmVjMiB1X2NvdmVyYWdlO1xuXG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuXG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMzIGNvbG9yID0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIHZfdGV4Q29vcmQpLnJnYjtcbiAgICAgIHZlYzMgYmx1cnJlZENvbG9yID0gdGV4dHVyZSh1X2JsdXJyZWRJbnB1dEZyYW1lLCB2X3RleENvb3JkKS5yZ2I7XG4gICAgICBmbG9hdCBwZXJzb25NYXNrID0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHZfdGV4Q29vcmQpLmE7XG4gICAgICBwZXJzb25NYXNrID0gc21vb3Roc3RlcCh1X2NvdmVyYWdlLngsIHVfY292ZXJhZ2UueSwgcGVyc29uTWFzayk7XG4gICAgICBvdXRDb2xvciA9IHZlYzQobWl4KGJsdXJyZWRDb2xvciwgY29sb3IsIHBlcnNvbk1hc2spLCAxLjApO1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCB7IHdpZHRoOiBvdXRwdXRXaWR0aCwgaGVpZ2h0OiBvdXRwdXRIZWlnaHQgfSA9IGNhbnZhcztcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVBpcGVsaW5lU3RhZ2VQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGNvbnN0IGlucHV0RnJhbWVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9pbnB1dEZyYW1lJyk7XG4gICAgY29uc3QgcGVyc29uTWFza0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3BlcnNvbk1hc2snKTtcbiAgICBjb25zdCBibHVycmVkSW5wdXRGcmFtZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9ibHVycmVkSW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IGNvdmVyYWdlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfY292ZXJhZ2UnKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLnVuaWZvcm0xaShpbnB1dEZyYW1lTG9jYXRpb24sIDApO1xuICAgIGdsLnVuaWZvcm0xaShwZXJzb25NYXNrTG9jYXRpb24sIDEpO1xuICAgIGdsLnVuaWZvcm0xaShibHVycmVkSW5wdXRGcmFtZSwgMik7XG4gICAgZ2wudW5pZm9ybTJmKGNvdmVyYWdlTG9jYXRpb24sIDAsIDEpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb3ZlcmFnZShjb3ZlcmFnZSkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMmYoY292ZXJhZ2VMb2NhdGlvbiwgY292ZXJhZ2VbMF0sIGNvdmVyYWdlWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgdXBkYXRlQ292ZXJhZ2UsXG4gICAgICAgIGNsZWFuVXAsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRCYWNrZ3JvdW5kSW1hZ2VTdGFnZShnbCwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBwZXJzb25NYXNrVGV4dHVyZSwgYmFja2dyb3VuZEltYWdlLCBjYW52YXMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIHVuaWZvcm0gdmVjMiB1X2JhY2tncm91bmRTY2FsZTtcbiAgICB1bmlmb3JtIHZlYzIgdV9iYWNrZ3JvdW5kT2Zmc2V0O1xuXG4gICAgaW4gdmVjMiBhX3Bvc2l0aW9uO1xuICAgIGluIHZlYzIgYV90ZXhDb29yZDtcblxuICAgIG91dCB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgb3V0IHZlYzIgdl9iYWNrZ3JvdW5kQ29vcmQ7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAvLyBGbGlwcGluZyBZIGlzIHJlcXVpcmVkIHdoZW4gcmVuZGVyaW5nIHRvIGNhbnZhc1xuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24gKiB2ZWMyKDEuMCwgLTEuMCksIDAuMCwgMS4wKTtcbiAgICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xuICAgICAgdl9iYWNrZ3JvdW5kQ29vcmQgPSBhX3RleENvb3JkICogdV9iYWNrZ3JvdW5kU2NhbGUgKyB1X2JhY2tncm91bmRPZmZzZXQ7XG4gICAgfVxuICBgO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyU291cmNlID0gZ2xzbCBgI3ZlcnNpb24gMzAwIGVzXG5cbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2lucHV0RnJhbWU7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9wZXJzb25NYXNrO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfYmFja2dyb3VuZDtcbiAgICB1bmlmb3JtIHZlYzIgdV9jb3ZlcmFnZTtcbiAgICB1bmlmb3JtIGZsb2F0IHVfbGlnaHRXcmFwcGluZztcbiAgICB1bmlmb3JtIGZsb2F0IHVfYmxlbmRNb2RlO1xuXG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuICAgIGluIHZlYzIgdl9iYWNrZ3JvdW5kQ29vcmQ7XG5cbiAgICBvdXQgdmVjNCBvdXRDb2xvcjtcblxuICAgIHZlYzMgc2NyZWVuKHZlYzMgYSwgdmVjMyBiKSB7XG4gICAgICByZXR1cm4gMS4wIC0gKDEuMCAtIGEpICogKDEuMCAtIGIpO1xuICAgIH1cblxuICAgIHZlYzMgbGluZWFyRG9kZ2UodmVjMyBhLCB2ZWMzIGIpIHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMzIGZyYW1lQ29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgdl90ZXhDb29yZCkucmdiO1xuICAgICAgdmVjMyBiYWNrZ3JvdW5kQ29sb3IgPSB0ZXh0dXJlKHVfYmFja2dyb3VuZCwgdl9iYWNrZ3JvdW5kQ29vcmQpLnJnYjtcbiAgICAgIGZsb2F0IHBlcnNvbk1hc2sgPSB0ZXh0dXJlKHVfcGVyc29uTWFzaywgdl90ZXhDb29yZCkuYTtcbiAgICAgIGZsb2F0IGxpZ2h0V3JhcE1hc2sgPSAxLjAgLSBtYXgoMC4wLCBwZXJzb25NYXNrIC0gdV9jb3ZlcmFnZS55KSAvICgxLjAgLSB1X2NvdmVyYWdlLnkpO1xuICAgICAgdmVjMyBsaWdodFdyYXAgPSB1X2xpZ2h0V3JhcHBpbmcgKiBsaWdodFdyYXBNYXNrICogYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICBmcmFtZUNvbG9yID0gdV9ibGVuZE1vZGUgKiBsaW5lYXJEb2RnZShmcmFtZUNvbG9yLCBsaWdodFdyYXApXG4gICAgICAgICsgKDEuMCAtIHVfYmxlbmRNb2RlKSAqIHNjcmVlbihmcmFtZUNvbG9yLCBsaWdodFdyYXApO1xuICAgICAgcGVyc29uTWFzayA9IHNtb290aHN0ZXAodV9jb3ZlcmFnZS54LCB1X2NvdmVyYWdlLnksIHBlcnNvbk1hc2spO1xuICAgICAgb3V0Q29sb3IgPSB2ZWM0KGZyYW1lQ29sb3IgKiBwZXJzb25NYXNrICsgYmFja2dyb3VuZENvbG9yICogKDEuMCAtIHBlcnNvbk1hc2spLCAxLjApO1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCB7IHdpZHRoOiBvdXRwdXRXaWR0aCwgaGVpZ2h0OiBvdXRwdXRIZWlnaHQgfSA9IGNhbnZhcztcbiAgICBjb25zdCBvdXRwdXRSYXRpbyA9IG91dHB1dFdpZHRoIC8gb3V0cHV0SGVpZ2h0O1xuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUGlwZWxpbmVTdGFnZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlcik7XG4gICAgY29uc3QgYmFja2dyb3VuZFNjYWxlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfYmFja2dyb3VuZFNjYWxlJyk7XG4gICAgY29uc3QgYmFja2dyb3VuZE9mZnNldExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2JhY2tncm91bmRPZmZzZXQnKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IHBlcnNvbk1hc2tMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9wZXJzb25NYXNrJyk7XG4gICAgY29uc3QgYmFja2dyb3VuZExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2JhY2tncm91bmQnKTtcbiAgICBjb25zdCBjb3ZlcmFnZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2NvdmVyYWdlJyk7XG4gICAgY29uc3QgbGlnaHRXcmFwcGluZ0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2xpZ2h0V3JhcHBpbmcnKTtcbiAgICBjb25zdCBibGVuZE1vZGVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9ibGVuZE1vZGUnKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLnVuaWZvcm0yZihiYWNrZ3JvdW5kU2NhbGVMb2NhdGlvbiwgMSwgMSk7XG4gICAgZ2wudW5pZm9ybTJmKGJhY2tncm91bmRPZmZzZXRMb2NhdGlvbiwgMCwgMCk7XG4gICAgZ2wudW5pZm9ybTFpKGlucHV0RnJhbWVMb2NhdGlvbiwgMCk7XG4gICAgZ2wudW5pZm9ybTFpKHBlcnNvbk1hc2tMb2NhdGlvbiwgMSk7XG4gICAgZ2wudW5pZm9ybTJmKGNvdmVyYWdlTG9jYXRpb24sIDAsIDEpO1xuICAgIGdsLnVuaWZvcm0xZihsaWdodFdyYXBwaW5nTG9jYXRpb24sIDApO1xuICAgIGdsLnVuaWZvcm0xZihibGVuZE1vZGVMb2NhdGlvbiwgMCk7XG4gICAgbGV0IGJhY2tncm91bmRUZXh0dXJlID0gbnVsbDtcbiAgICAvLyBUT0RPIEZpbmQgYSBiZXR0ZXIgdG8gaGFuZGxlIGJhY2tncm91bmQgYmVpbmcgbG9hZGVkXG4gICAgaWYgKGJhY2tncm91bmRJbWFnZT8uY29tcGxldGUpIHtcbiAgICAgICAgdXBkYXRlQmFja2dyb3VuZEltYWdlKGJhY2tncm91bmRJbWFnZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlQmFja2dyb3VuZEltYWdlKGJhY2tncm91bmRJbWFnZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBwZXJzb25NYXNrVGV4dHVyZSk7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kVGV4dHVyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMik7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBiYWNrZ3JvdW5kVGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBUT0RPIEhhbmRsZSBjb3JyZWN0bHkgdGhlIGJhY2tncm91bmQgbm90IGxvYWRlZCB5ZXRcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShiYWNrZ3JvdW5kTG9jYXRpb24sIDIpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVCYWNrZ3JvdW5kSW1hZ2UoYmdJbWFnZSkge1xuICAgICAgICBiYWNrZ3JvdW5kVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBiZ0ltYWdlLm5hdHVyYWxXaWR0aCwgYmdJbWFnZS5uYXR1cmFsSGVpZ2h0LCBcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlcyBhcmUgaW5jb21wbGV0ZVxuICAgICAgICBnbC5MSU5FQVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgYmdJbWFnZS5uYXR1cmFsV2lkdGgsIGJnSW1hZ2UubmF0dXJhbEhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgYmdJbWFnZSk7XG4gICAgICAgIGxldCB4T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHlPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgYmFja2dyb3VuZFdpZHRoID0gYmdJbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgIGxldCBiYWNrZ3JvdW5kSGVpZ2h0ID0gYmdJbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kUmF0aW8gPSBiYWNrZ3JvdW5kV2lkdGggLyBiYWNrZ3JvdW5kSGVpZ2h0O1xuICAgICAgICBpZiAoYmFja2dyb3VuZFJhdGlvIDwgb3V0cHV0UmF0aW8pIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRIZWlnaHQgPSBiYWNrZ3JvdW5kV2lkdGggLyBvdXRwdXRSYXRpbztcbiAgICAgICAgICAgIHlPZmZzZXQgPSAoYmdJbWFnZS5uYXR1cmFsSGVpZ2h0IC0gYmFja2dyb3VuZEhlaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFja2dyb3VuZFdpZHRoID0gYmFja2dyb3VuZEhlaWdodCAqIG91dHB1dFJhdGlvO1xuICAgICAgICAgICAgeE9mZnNldCA9IChiZ0ltYWdlLm5hdHVyYWxXaWR0aCAtIGJhY2tncm91bmRXaWR0aCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IGJhY2tncm91bmRXaWR0aCAvIGJnSW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICBjb25zdCB5U2NhbGUgPSBiYWNrZ3JvdW5kSGVpZ2h0IC8gYmdJbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB4T2Zmc2V0IC89IGJnSW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICB5T2Zmc2V0IC89IGJnSW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgZ2wudW5pZm9ybTJmKGJhY2tncm91bmRTY2FsZUxvY2F0aW9uLCB4U2NhbGUsIHlTY2FsZSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZihiYWNrZ3JvdW5kT2Zmc2V0TG9jYXRpb24sIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb3ZlcmFnZShjb3ZlcmFnZSkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMmYoY292ZXJhZ2VMb2NhdGlvbiwgY292ZXJhZ2VbMF0sIGNvdmVyYWdlWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTGlnaHRXcmFwcGluZyhsaWdodFdyYXBwaW5nKSB7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihsaWdodFdyYXBwaW5nTG9jYXRpb24sIGxpZ2h0V3JhcHBpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVCbGVuZE1vZGUoYmxlbmRNb2RlKSB7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihibGVuZE1vZGVMb2NhdGlvbiwgYmxlbmRNb2RlID09PSAnc2NyZWVuJyA/IDAgOiAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShiYWNrZ3JvdW5kVGV4dHVyZSk7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXIsXG4gICAgICAgIHVwZGF0ZUNvdmVyYWdlLFxuICAgICAgICB1cGRhdGVMaWdodFdyYXBwaW5nLFxuICAgICAgICB1cGRhdGVCbGVuZE1vZGUsXG4gICAgICAgIGNsZWFuVXAsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRKb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgaW5wdXRUZXh0dXJlLCBvdXRwdXRUZXh0dXJlLCBjYW52YXMsIHNlZ21lbnRhdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyU291cmNlID0gZ2xzbCBgI3ZlcnNpb24gMzAwIGVzXG5cbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2lucHV0RnJhbWU7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9zZWdtZW50YXRpb25NYXNrO1xuICAgIHVuaWZvcm0gdmVjMiB1X3RleGVsU2l6ZTtcbiAgICB1bmlmb3JtIGZsb2F0IHVfc3RlcDtcbiAgICB1bmlmb3JtIGZsb2F0IHVfcmFkaXVzO1xuICAgIHVuaWZvcm0gZmxvYXQgdV9vZmZzZXQ7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3NpZ21hVGV4ZWw7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3NpZ21hQ29sb3I7XG5cbiAgICBpbiB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICBmbG9hdCBnYXVzc2lhbihmbG9hdCB4LCBmbG9hdCBzaWdtYSkge1xuICAgICAgZmxvYXQgY29lZmYgPSAtMC41IC8gKHNpZ21hICogc2lnbWEgKiA0LjAgKyAxLjBlLTYpO1xuICAgICAgcmV0dXJuIGV4cCgoeCAqIHgpICogY29lZmYpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzIgY2VudGVyQ29vcmQgPSB2X3RleENvb3JkO1xuICAgICAgdmVjMyBjZW50ZXJDb2xvciA9IHRleHR1cmUodV9pbnB1dEZyYW1lLCBjZW50ZXJDb29yZCkucmdiO1xuICAgICAgZmxvYXQgbmV3VmFsID0gMC4wO1xuXG4gICAgICBmbG9hdCBzcGFjZVdlaWdodCA9IDAuMDtcbiAgICAgIGZsb2F0IGNvbG9yV2VpZ2h0ID0gMC4wO1xuICAgICAgZmxvYXQgdG90YWxXZWlnaHQgPSAwLjA7XG5cbiAgICAgIC8vIFN1YnNhbXBsZSBrZXJuZWwgc3BhY2UuXG4gICAgICBmb3IgKGZsb2F0IGkgPSAtdV9yYWRpdXMgKyB1X29mZnNldDsgaSA8PSB1X3JhZGl1czsgaSArPSB1X3N0ZXApIHtcbiAgICAgICAgZm9yIChmbG9hdCBqID0gLXVfcmFkaXVzICsgdV9vZmZzZXQ7IGogPD0gdV9yYWRpdXM7IGogKz0gdV9zdGVwKSB7XG4gICAgICAgICAgdmVjMiBzaGlmdCA9IHZlYzIoaiwgaSkgKiB1X3RleGVsU2l6ZTtcbiAgICAgICAgICB2ZWMyIGNvb3JkID0gdmVjMihjZW50ZXJDb29yZCArIHNoaWZ0KTtcbiAgICAgICAgICB2ZWMzIGZyYW1lQ29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgY29vcmQpLnJnYjtcbiAgICAgICAgICBmbG9hdCBvdXRWYWwgPSB0ZXh0dXJlKHVfc2VnbWVudGF0aW9uTWFzaywgY29vcmQpLmE7XG5cbiAgICAgICAgICBzcGFjZVdlaWdodCA9IGdhdXNzaWFuKGRpc3RhbmNlKGNlbnRlckNvb3JkLCBjb29yZCksIHVfc2lnbWFUZXhlbCk7XG4gICAgICAgICAgY29sb3JXZWlnaHQgPSBnYXVzc2lhbihkaXN0YW5jZShjZW50ZXJDb2xvciwgZnJhbWVDb2xvciksIHVfc2lnbWFDb2xvcik7XG4gICAgICAgICAgdG90YWxXZWlnaHQgKz0gc3BhY2VXZWlnaHQgKiBjb2xvcldlaWdodDtcblxuICAgICAgICAgIG5ld1ZhbCArPSBzcGFjZVdlaWdodCAqIGNvbG9yV2VpZ2h0ICogb3V0VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdWYWwgLz0gdG90YWxXZWlnaHQ7XG5cbiAgICAgIG91dENvbG9yID0gdmVjNCh2ZWMzKDAuMCksIG5ld1ZhbCk7XG4gICAgfVxuICBgO1xuICAgIGNvbnN0IHsgd2lkdGg6IHNlZ21lbnRhdGlvbldpZHRoLCBoZWlnaHQ6IHNlZ21lbnRhdGlvbkhlaWdodCB9ID0gc2VnbWVudGF0aW9uQ29uZmlnO1xuICAgIGNvbnN0IHsgd2lkdGg6IG91dHB1dFdpZHRoLCBoZWlnaHQ6IG91dHB1dEhlaWdodCB9ID0gY2FudmFzO1xuICAgIGNvbnN0IHRleGVsV2lkdGggPSAxIC8gb3V0cHV0V2lkdGg7XG4gICAgY29uc3QgdGV4ZWxIZWlnaHQgPSAxIC8gb3V0cHV0SGVpZ2h0O1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVBpcGVsaW5lU3RhZ2VQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGNvbnN0IGlucHV0RnJhbWVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9pbnB1dEZyYW1lJyk7XG4gICAgY29uc3Qgc2VnbWVudGF0aW9uTWFza0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NlZ21lbnRhdGlvbk1hc2snKTtcbiAgICBjb25zdCB0ZXhlbFNpemVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV90ZXhlbFNpemUnKTtcbiAgICBjb25zdCBzdGVwTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc3RlcCcpO1xuICAgIGNvbnN0IHJhZGl1c0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhZGl1cycpO1xuICAgIGNvbnN0IG9mZnNldExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X29mZnNldCcpO1xuICAgIGNvbnN0IHNpZ21hVGV4ZWxMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zaWdtYVRleGVsJyk7XG4gICAgY29uc3Qgc2lnbWFDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NpZ21hQ29sb3InKTtcbiAgICBjb25zdCBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBvdXRwdXRUZXh0dXJlLCAwKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLnVuaWZvcm0xaShpbnB1dEZyYW1lTG9jYXRpb24sIDApO1xuICAgIGdsLnVuaWZvcm0xaShzZWdtZW50YXRpb25NYXNrTG9jYXRpb24sIDEpO1xuICAgIGdsLnVuaWZvcm0yZih0ZXhlbFNpemVMb2NhdGlvbiwgdGV4ZWxXaWR0aCwgdGV4ZWxIZWlnaHQpO1xuICAgIC8vIEVuc3VyZXMgZGVmYXVsdCB2YWx1ZXMgYXJlIGNvbmZpZ3VyZWQgdG8gcHJldmVudCBpbmZpbml0ZVxuICAgIC8vIGxvb3AgaW4gZnJhZ21lbnQgc2hhZGVyXG4gICAgdXBkYXRlU2lnbWFTcGFjZSgwKTtcbiAgICB1cGRhdGVTaWdtYUNvbG9yKDApO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpZ21hU3BhY2Uoc2lnbWFTcGFjZSkge1xuICAgICAgICBzaWdtYVNwYWNlICo9IE1hdGgubWF4KG91dHB1dFdpZHRoIC8gc2VnbWVudGF0aW9uV2lkdGgsIG91dHB1dEhlaWdodCAvIHNlZ21lbnRhdGlvbkhlaWdodCk7XG4gICAgICAgIGNvbnN0IGtTcGFyc2l0eUZhY3RvciA9IDAuNjY7IC8vIEhpZ2hlciBpcyBzcGFyc2VyLlxuICAgICAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5zcXJ0KHNpZ21hU3BhY2UpICoga1NwYXJzaXR5RmFjdG9yKTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gc2lnbWFTcGFjZTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RlcCA+IDEgPyBzdGVwICogMC41IDogMDtcbiAgICAgICAgY29uc3Qgc2lnbWFUZXhlbCA9IE1hdGgubWF4KHRleGVsV2lkdGgsIHRleGVsSGVpZ2h0KSAqIHNpZ21hU3BhY2U7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzdGVwTG9jYXRpb24sIHN0ZXApO1xuICAgICAgICBnbC51bmlmb3JtMWYocmFkaXVzTG9jYXRpb24sIHJhZGl1cyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihvZmZzZXRMb2NhdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNpZ21hVGV4ZWxMb2NhdGlvbiwgc2lnbWFUZXhlbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpZ21hQ29sb3Ioc2lnbWFDb2xvcikge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2lnbWFDb2xvckxvY2F0aW9uLCBzaWdtYUNvbG9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4geyByZW5kZXIsIHVwZGF0ZVNpZ21hU3BhY2UsIHVwZGF0ZVNpZ21hQ29sb3IsIGNsZWFuVXAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZXNpemluZ1N0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgdGZsaXRlLCBzZWdtZW50YXRpb25Db25maWcpIHtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXRGcmFtZTtcbiAgICBpbiB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBvdXRDb2xvciA9IHRleHR1cmUodV9pbnB1dEZyYW1lLCB2X3RleENvb3JkKTtcbiAgICB9XG4gIGA7XG4gICAgLy8gVEZMaXRlIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkIGFzIGZsb2F0MzJcbiAgICBjb25zdCB0ZmxpdGVJbnB1dE1lbW9yeU9mZnNldCA9IHRmbGl0ZS5fZ2V0SW5wdXRNZW1vcnlPZmZzZXQoKSAvIDQ7XG4gICAgY29uc3QgeyB3aWR0aDogb3V0cHV0V2lkdGgsIGhlaWdodDogb3V0cHV0SGVpZ2h0IH0gPSBzZWdtZW50YXRpb25Db25maWc7XG4gICAgY29uc3Qgb3V0cHV0UGl4ZWxDb3VudCA9IG91dHB1dFdpZHRoICogb3V0cHV0SGVpZ2h0O1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVBpcGVsaW5lU3RhZ2VQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGNvbnN0IGlucHV0RnJhbWVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9pbnB1dEZyYW1lJyk7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICBjb25zdCBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBvdXRwdXRUZXh0dXJlLCAwKTtcbiAgICBjb25zdCBvdXRwdXRQaXhlbHMgPSBuZXcgVWludDhBcnJheShvdXRwdXRQaXhlbENvdW50ICogNCk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMWkoaW5wdXRGcmFtZUxvY2F0aW9uLCAwKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgICAgIC8vIERvd25sb2FkcyBwaXhlbHMgYXN5bmNocm9ub3VzbHkgZnJvbSBHUFUgd2hpbGUgcmVuZGVyaW5nIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAgICAvLyBUaGUgcGl4ZWxzIHdpbGwgYmUgYXZhaWxhYmxlIGluIHRoZSBuZXh0IGZyYW1lIHJlbmRlciB3aGljaCByZXN1bHRzXG4gICAgICAgIC8vIGluIG9mZnNldHMgaW4gdGhlIHNlZ21lbnRhdGlvbiBvdXRwdXQgYnV0IGluY3JlYXNlcyB0aGUgZnJhbWUgcmF0ZS5cbiAgICAgICAgcmVhZFBpeGVsc0FzeW5jKGdsLCAwLCAwLCBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBvdXRwdXRQaXhlbHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFBpeGVsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGZsaXRlSW5kZXggPSB0ZmxpdGVJbnB1dE1lbW9yeU9mZnNldCArIGkgKiAzO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBpICogNDtcbiAgICAgICAgICAgIHRmbGl0ZS5IRUFQRjMyW3RmbGl0ZUluZGV4XSA9IG91dHB1dFBpeGVsc1tvdXRwdXRJbmRleF0gLyAyNTU7XG4gICAgICAgICAgICB0ZmxpdGUuSEVBUEYzMlt0ZmxpdGVJbmRleCArIDFdID0gb3V0cHV0UGl4ZWxzW291dHB1dEluZGV4ICsgMV0gLyAyNTU7XG4gICAgICAgICAgICB0ZmxpdGUuSEVBUEYzMlt0ZmxpdGVJbmRleCArIDJdID0gb3V0cHV0UGl4ZWxzW291dHB1dEluZGV4ICsgMl0gLyAyNTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKG91dHB1dFRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4geyByZW5kZXIsIGNsZWFuVXAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTb2Z0bWF4U3RhZ2UoZ2wsIHZlcnRleFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCB0ZmxpdGUsIG91dHB1dFRleHR1cmUsIHNlZ21lbnRhdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyU291cmNlID0gZ2xzbCBgI3ZlcnNpb24gMzAwIGVzXG5cbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2lucHV0U2VnbWVudGF0aW9uO1xuICAgIGluIHZlYzIgdl90ZXhDb29yZDtcbiAgICBvdXQgdmVjNCBvdXRDb2xvcjtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzIgc2VnbWVudGF0aW9uID0gdGV4dHVyZSh1X2lucHV0U2VnbWVudGF0aW9uLCB2X3RleENvb3JkKS5yZztcbiAgICAgIGZsb2F0IHNoaWZ0ID0gbWF4KHNlZ21lbnRhdGlvbi5yLCBzZWdtZW50YXRpb24uZyk7XG4gICAgICBmbG9hdCBiYWNrZ3JvdW5kRXhwID0gZXhwKHNlZ21lbnRhdGlvbi5yIC0gc2hpZnQpO1xuICAgICAgZmxvYXQgcGVyc29uRXhwID0gZXhwKHNlZ21lbnRhdGlvbi5nIC0gc2hpZnQpO1xuICAgICAgb3V0Q29sb3IgPSB2ZWM0KHZlYzMoMC4wKSwgcGVyc29uRXhwIC8gKGJhY2tncm91bmRFeHAgKyBwZXJzb25FeHApKTtcbiAgICB9XG4gIGA7XG4gICAgLy8gVEZMaXRlIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkIGFzIGZsb2F0MzJcbiAgICBjb25zdCB0ZmxpdGVPdXRwdXRNZW1vcnlPZmZzZXQgPSB0ZmxpdGUuX2dldE91dHB1dE1lbW9yeU9mZnNldCgpIC8gNDtcbiAgICBjb25zdCB7IHdpZHRoOiBzZWdtZW50YXRpb25XaWR0aCwgaGVpZ2h0OiBzZWdtZW50YXRpb25IZWlnaHQgfSA9IHNlZ21lbnRhdGlvbkNvbmZpZztcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2lucHV0U2VnbWVudGF0aW9uJyk7XG4gICAgY29uc3QgaW5wdXRUZXh0dXJlID0gY3JlYXRlVGV4dHVyZShnbCwgZ2wuUkczMkYsIHNlZ21lbnRhdGlvbldpZHRoLCBzZWdtZW50YXRpb25IZWlnaHQpO1xuICAgIGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIG91dHB1dFRleHR1cmUsIDApO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZ2wudW5pZm9ybTFpKGlucHV0TG9jYXRpb24sIDEpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgc2VnbWVudGF0aW9uV2lkdGgsIHNlZ21lbnRhdGlvbkhlaWdodCk7XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUpO1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHNlZ21lbnRhdGlvbldpZHRoLCBzZWdtZW50YXRpb25IZWlnaHQsIGdsLlJHLCBnbC5GTE9BVCwgdGZsaXRlLkhFQVBGMzIsIHRmbGl0ZU91dHB1dE1lbW9yeU9mZnNldCk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKGlucHV0VGV4dHVyZSk7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgfVxuICAgIHJldHVybiB7IHJlbmRlciwgY2xlYW5VcCB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFdlYkdMMlBpcGVsaW5lKHZpZGVvU291cmNlLCBiYWNrZ3JvdW5kSW1hZ2UsIGJsdXJMZXZlbCwgYmFja2dyb3VuZEZpbHRlciwgY2FudmFzLCB0ZmxpdGUsIHNlZ21lbnRhdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICAgIGlmICghZ2wpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCB7IHdpZHRoOiBmcmFtZVdpZHRoLCBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gPSB2aWRlb1NvdXJjZTtcbiAgICBjb25zdCB7IHdpZHRoOiBzZWdtZW50YXRpb25XaWR0aCwgaGVpZ2h0OiBzZWdtZW50YXRpb25IZWlnaHQgfSA9IHNlZ21lbnRhdGlvbkNvbmZpZztcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIGluIHZlYzIgYV9wb3NpdGlvbjtcbiAgICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XG4gICAgb3V0IHZlYzIgdl90ZXhDb29yZDtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcbiAgICB9XG4gIGA7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlKTtcbiAgICBjb25zdCB2ZXJ0ZXhBcnJheSA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KHZlcnRleEFycmF5KTtcbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWy0xLjAsIC0xLjAsIDEuMCwgLTEuMCwgLTEuMCwgMS4wLCAxLjAsIDEuMF0pLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgY29uc3QgdGV4Q29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAxLjAsIDEuMF0pLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgLy8gV2UgZG9uJ3QgdXNlIHRleFN0b3JhZ2UyRCBoZXJlIGJlY2F1c2UgdGV4SW1hZ2UyRCBzZWVtcyBmYXN0ZXJcbiAgICAvLyB0byB1cGxvYWQgdmlkZW8gdGV4dHVyZSB0aGFuIHRleFN1YkltYWdlMkQgZXZlbiB0aG91Z2ggdGhlIGxhdHRlclxuICAgIC8vIGlzIHN1cHBvc2VkIHRvIGJlIHRoZSByZWNvbW1lbmRlZCB3YXk6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9XZWJHTF9iZXN0X3ByYWN0aWNlcyN1c2VfdGV4c3RvcmFnZV90b19jcmVhdGVfdGV4dHVyZXNcbiAgICBjb25zdCBpbnB1dEZyYW1lVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dEZyYW1lVGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAvLyBUT0RPIFJlbmFtZSBzZWdtZW50YXRpb24gYW5kIHBlcnNvbiBtYXNrIHRvIGJlIG1vcmUgc3BlY2lmaWNcbiAgICBjb25zdCBzZWdtZW50YXRpb25UZXh0dXJlID0gY3JlYXRlVGV4dHVyZShnbCwgZ2wuUkdCQTgsIHNlZ21lbnRhdGlvbldpZHRoLCBzZWdtZW50YXRpb25IZWlnaHQpO1xuICAgIGNvbnN0IHBlcnNvbk1hc2tUZXh0dXJlID0gY3JlYXRlVGV4dHVyZShnbCwgZ2wuUkdCQTgsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcbiAgICBjb25zdCByZXNpemluZ1N0YWdlID0gYnVpbGRSZXNpemluZ1N0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgdGZsaXRlLCBzZWdtZW50YXRpb25Db25maWcpO1xuICAgIGNvbnN0IGxvYWRTZWdtZW50YXRpb25TdGFnZSA9IGJ1aWxkU29mdG1heFN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgdGZsaXRlLCBzZWdtZW50YXRpb25UZXh0dXJlLCBzZWdtZW50YXRpb25Db25maWcpO1xuICAgIGNvbnN0IGpvaW50QmlsYXRlcmFsRmlsdGVyU3RhZ2UgPSBidWlsZEpvaW50QmlsYXRlcmFsRmlsdGVyU3RhZ2UoZ2wsIHZlcnRleFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBzZWdtZW50YXRpb25UZXh0dXJlLCBwZXJzb25NYXNrVGV4dHVyZSwgY2FudmFzLCBzZWdtZW50YXRpb25Db25maWcpO1xuICAgIGNvbnN0IGJhY2tncm91bmRTdGFnZSA9IGJhY2tncm91bmRGaWx0ZXIgPT09ICdibHVyJ1xuICAgICAgICA/IGJ1aWxkQmFja2dyb3VuZEJsdXJTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIHBlcnNvbk1hc2tUZXh0dXJlLCBjYW52YXMsIGJsdXJMZXZlbCB8fCAnaGlnaCcpXG4gICAgICAgIDogYnVpbGRCYWNrZ3JvdW5kSW1hZ2VTdGFnZShnbCwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBwZXJzb25NYXNrVGV4dHVyZSwgYmFja2dyb3VuZEltYWdlLCBjYW52YXMpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0RnJhbWVUZXh0dXJlKTtcbiAgICAgICAgLy8gdGV4SW1hZ2UyRCBzZWVtcyBmYXN0ZXIgdGhhbiB0ZXhTdWJJbWFnZTJEIHRvIHVwbG9hZFxuICAgICAgICAvLyB2aWRlbyB0ZXh0dXJlXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdmlkZW9Tb3VyY2UpO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmVydGV4QXJyYXkpO1xuICAgICAgICByZXNpemluZ1N0YWdlLnJlbmRlcigpO1xuICAgICAgICB0ZmxpdGUuX3J1bkluZmVyZW5jZSgpO1xuICAgICAgICBsb2FkU2VnbWVudGF0aW9uU3RhZ2UucmVuZGVyKCk7XG4gICAgICAgIGpvaW50QmlsYXRlcmFsRmlsdGVyU3RhZ2UucmVuZGVyKCk7XG4gICAgICAgIGJhY2tncm91bmRTdGFnZS5yZW5kZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zdFByb2Nlc3NpbmdDb25maWcoKSB7XG4gICAgICAgIGpvaW50QmlsYXRlcmFsRmlsdGVyU3RhZ2UudXBkYXRlU2lnbWFTcGFjZSgxKTtcbiAgICAgICAgam9pbnRCaWxhdGVyYWxGaWx0ZXJTdGFnZS51cGRhdGVTaWdtYUNvbG9yKDAuMSk7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kRmlsdGVyID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kSW1hZ2VTdGFnZSA9IGJhY2tncm91bmRTdGFnZTtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZVN0YWdlLnVwZGF0ZUNvdmVyYWdlKFswLjUsIDAuNzVdKTtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZVN0YWdlLnVwZGF0ZUxpZ2h0V3JhcHBpbmcoMC4zKTtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZVN0YWdlLnVwZGF0ZUJsZW5kTW9kZSgnc2NyZWVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmFja2dyb3VuZEZpbHRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kQmx1clN0YWdlID0gYmFja2dyb3VuZFN0YWdlO1xuICAgICAgICAgICAgYmFja2dyb3VuZEJsdXJTdGFnZS51cGRhdGVDb3ZlcmFnZShbMC41LCAwLjc1XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPIEhhbmRsZSBubyBiYWNrZ3JvdW5kIGluIGEgc2VwYXJhdGUgcGlwZWxpbmUgcGF0aFxuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZEltYWdlU3RhZ2UgPSBiYWNrZ3JvdW5kU3RhZ2U7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVDb3ZlcmFnZShbMCwgMC45OTk5XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVMaWdodFdyYXBwaW5nKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGJhY2tncm91bmRTdGFnZS5jbGVhblVwKCk7XG4gICAgICAgIGpvaW50QmlsYXRlcmFsRmlsdGVyU3RhZ2UuY2xlYW5VcCgpO1xuICAgICAgICBsb2FkU2VnbWVudGF0aW9uU3RhZ2UuY2xlYW5VcCgpO1xuICAgICAgICByZXNpemluZ1N0YWdlLmNsZWFuVXAoKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwZXJzb25NYXNrVGV4dHVyZSk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoc2VnbWVudGF0aW9uVGV4dHVyZSk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoaW5wdXRGcmFtZVRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVCdWZmZXIodGV4Q29vcmRCdWZmZXIpO1xuICAgICAgICBnbC5kZWxldGVCdWZmZXIocG9zaXRpb25CdWZmZXIpO1xuICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2ZXJ0ZXhBcnJheSk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4geyByZW5kZXIsIHVwZGF0ZVBvc3RQcm9jZXNzaW5nQ29uZmlnLCBjbGVhblVwIH07XG59XG5cbnZhciBTZWdtZW50YXRpb25MZXZlbDtcbihmdW5jdGlvbiAoU2VnbWVudGF0aW9uTGV2ZWwpIHtcbiAgICBTZWdtZW50YXRpb25MZXZlbFtcIkxPV1wiXSA9IFwibG93XCI7XG4gICAgU2VnbWVudGF0aW9uTGV2ZWxbXCJISUdIXCJdID0gXCJoaWdoXCI7XG59KShTZWdtZW50YXRpb25MZXZlbCB8fCAoU2VnbWVudGF0aW9uTGV2ZWwgPSB7fSkpO1xuY29uc3QgZ2V0U2VnbWVudGF0aW9uUGFyYW1zID0gKGxldmVsKSA9PiB7XG4gICAgaWYgKGxldmVsID09PSBTZWdtZW50YXRpb25MZXZlbC5ISUdIKSB7XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAyNTYsIGhlaWdodDogMTQ0IH07XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoOiAxNjAsIGhlaWdodDogOTYgfTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKHRmbGl0ZSwgdmlkZW9Tb3VyY2UsIHRhcmdldENhbnZhcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZEZpbHRlciwgYmFja2dyb3VuZEltYWdlLCBiYWNrZ3JvdW5kQmx1ckxldmVsLCBzZWdtZW50YXRpb25MZXZlbCA9IFNlZ21lbnRhdGlvbkxldmVsLkhJR0gsIGZwcyA9IDMwLCB9ID0gb3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZEZpbHRlciA9PT0gJ2ltYWdlJyAmJiAhYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFja2dyb3VuZEltYWdlIGVsZW1lbnQgaXMgcmVxdWlyZWQgd2hlbiBiYWNrZ3JvdW5kRmlsdGVyIGlzIGltYWdlYCk7XG4gICAgfVxuICAgIGNvbnN0IHBpcGVsaW5lID0gYnVpbGRXZWJHTDJQaXBlbGluZSh2aWRlb1NvdXJjZSwgYmFja2dyb3VuZEltYWdlLCBiYWNrZ3JvdW5kQmx1ckxldmVsLCBiYWNrZ3JvdW5kRmlsdGVyLCB0YXJnZXRDYW52YXMsIHRmbGl0ZSwgZ2V0U2VnbWVudGF0aW9uUGFyYW1zKHNlZ21lbnRhdGlvbkxldmVsKSk7XG4gICAgY29uc3QgaWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHBpcGVsaW5lLnJlbmRlcigpO1xuICAgICAgICBpZiAoYmFja2dyb3VuZEZpbHRlciA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgcGlwZWxpbmUudXBkYXRlUG9zdFByb2Nlc3NpbmdDb25maWcoKTtcbiAgICAgICAgfVxuICAgIH0sIDEwMDAgLyAoZnBzIDw9IDAgPyAzMCA6IGZwcykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIHBpcGVsaW5lLmNsZWFuVXAoKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IGNyZWF0ZVRGTGl0ZVNJTURNb2R1bGUgPSAoX19Nb2R1bGUpID0+IHtcbiAgX19Nb2R1bGUgPSBfX01vZHVsZSB8fCB7fTtcblxuICB2YXIgX3NjcmlwdERpciA9XG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0XG4gICAgICA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgTW9kdWxlID0gdHlwZW9mIF9fTW9kdWxlICE9ICd1bmRlZmluZWQnID8gX19Nb2R1bGUgOiB7fTtcbiAgdmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDtcbiAgTW9kdWxlWydyZWFkeSddID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIHZhciBtb2R1bGVPdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKHt9LCBNb2R1bGUpO1xuICB2YXIgdGhpc1Byb2dyYW0gPSAnLi90aGlzLnByb2dyYW0nO1xuICB2YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gICAgdGhyb3cgdG9UaHJvdztcbiAgfTtcbiAgdmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHRydWU7XG4gIHZhciBzY3JpcHREaXJlY3RvcnkgPSAnJztcblxuICBmdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiAgICBpZiAoTW9kdWxlWydsb2NhdGVGaWxlJ10pIHtcbiAgICAgIHJldHVybiBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcbiAgfVxuXG4gIHZhciByZWFkQmluYXJ5O1xuICB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgICB9XG4gICAgaWYgKF9zY3JpcHREaXIpIHtcbiAgICAgIHNjcmlwdERpcmVjdG9yeSA9IF9zY3JpcHREaXI7XG4gICAgfVxuICAgIGlmIChzY3JpcHREaXJlY3RvcnkuaW5kZXhPZignYmxvYjonKSAhPT0gMCkge1xuICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gc2NyaXB0RGlyZWN0b3J5LnN1YnN0cihcbiAgICAgICAgMCxcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5LnJlcGxhY2UoL1s/I10uKi8sICcnKS5sYXN0SW5kZXhPZignLycpICsgMSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICAgIH1cbiAgfVxuICB2YXIgb3V0ID0gTW9kdWxlWydwcmludCddIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gIHZhciBlcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ10gfHwgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gIE9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuICBtb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuICBpZiAoTW9kdWxlWydhcmd1bWVudHMnXSkgTW9kdWxlWydhcmd1bWVudHMnXTtcbiAgaWYgKE1vZHVsZVsndGhpc1Byb2dyYW0nXSkgdGhpc1Byb2dyYW0gPSBNb2R1bGVbJ3RoaXNQcm9ncmFtJ107XG4gIGlmIChNb2R1bGVbJ3F1aXQnXSkgcXVpdF8gPSBNb2R1bGVbJ3F1aXQnXTtcbiAgdmFyIHdhc21CaW5hcnk7XG4gIGlmIChNb2R1bGVbJ3dhc21CaW5hcnknXSkgd2FzbUJpbmFyeSA9IE1vZHVsZVsnd2FzbUJpbmFyeSddO1xuICB2YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVsnbm9FeGl0UnVudGltZSddIHx8IHRydWU7XG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT0gJ29iamVjdCcpIHtcbiAgICBhYm9ydCgnbm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCcpO1xuICB9XG4gIHZhciB3YXNtTWVtb3J5O1xuICB2YXIgQUJPUlQgPSBmYWxzZTtcblxuICB2YXIgVVRGOERlY29kZXIgPVxuICAgIHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpIDogdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXBPckFycmF5LCBpZHgsIG1heEJ5dGVzVG9SZWFkKSB7XG4gICAgdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkO1xuICAgIHZhciBlbmRQdHIgPSBpZHg7XG4gICAgd2hpbGUgKGhlYXBPckFycmF5W2VuZFB0cl0gJiYgIShlbmRQdHIgPj0gZW5kSWR4KSkgKytlbmRQdHI7XG4gICAgaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIGhlYXBPckFycmF5LmJ1ZmZlciAmJiBVVEY4RGVjb2Rlcikge1xuICAgICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuICAgIH1cbiAgICB2YXIgc3RyID0gJyc7XG4gICAgd2hpbGUgKGlkeCA8IGVuZFB0cikge1xuICAgICAgdmFyIHUwID0gaGVhcE9yQXJyYXlbaWR4KytdO1xuICAgICAgaWYgKCEodTAgJiAxMjgpKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgIGlmICgodTAgJiAyMjQpID09IDE5Mikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciB1MiA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgaWYgKCh1MCAmIDI0MCkgPT0gMjI0KSB7XG4gICAgICAgIHUwID0gKCh1MCAmIDE1KSA8PCAxMikgfCAodTEgPDwgNikgfCB1MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHUwID1cbiAgICAgICAgICAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IChoZWFwT3JBcnJheVtpZHgrK10gJiA2Myk7XG4gICAgICB9XG4gICAgICBpZiAodTAgPCA2NTUzNikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2ggPSB1MCAtIDY1NTM2O1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IChjaCA+PiAxMCksIDU2MzIwIHwgKGNoICYgMTAyMykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGJ1ZmZlciwgSEVBUDgsIEhFQVBVOCwgSEVBUFUzMjtcblxuICBmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpIHtcbiAgICBidWZmZXIgPSBidWY7XG4gICAgTW9kdWxlWydIRUFQOCddID0gSEVBUDggPSBuZXcgSW50OEFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQMTYnXSA9IG5ldyBJbnQxNkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQMzInXSA9IG5ldyBJbnQzMkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQVTgnXSA9IEhFQVBVOCA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQVTE2J10gPSBuZXcgVWludDE2QXJyYXkoYnVmKTtcbiAgICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmKTtcbiAgICBNb2R1bGVbJ0hFQVBGMzInXSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmKTtcbiAgICBNb2R1bGVbJ0hFQVBGNjQnXSA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmKTtcbiAgfVxuXG4gIE1vZHVsZVsnSU5JVElBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjtcbiAgdmFyIF9fQVRQUkVSVU5fXyA9IFtdO1xuICB2YXIgX19BVElOSVRfXyA9IFtdO1xuICB2YXIgX19BVFBPU1RSVU5fXyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGtlZXBSdW50aW1lQWxpdmUoKSB7XG4gICAgcmV0dXJuIG5vRXhpdFJ1bnRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVSdW4oKSB7XG4gICAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcbiAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVSdW4nXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBNb2R1bGVbJ3ByZVJ1biddID0gW01vZHVsZVsncHJlUnVuJ11dO1xuICAgICAgd2hpbGUgKE1vZHVsZVsncHJlUnVuJ10ubGVuZ3RoKSB7XG4gICAgICAgIGFkZE9uUHJlUnVuKE1vZHVsZVsncHJlUnVuJ10uc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0UnVudGltZSgpIHtcbiAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RSdW4oKSB7XG4gICAgaWYgKE1vZHVsZVsncG9zdFJ1biddKSB7XG4gICAgICBpZiAodHlwZW9mIE1vZHVsZVsncG9zdFJ1biddID09ICdmdW5jdGlvbicpXG4gICAgICAgIE1vZHVsZVsncG9zdFJ1biddID0gW01vZHVsZVsncG9zdFJ1biddXTtcbiAgICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgICAgYWRkT25Qb3N0UnVuKE1vZHVsZVsncG9zdFJ1biddLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7XG4gICAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkT25Jbml0KGNiKSB7XG4gICAgX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xuICAgIF9fQVRQT1NUUlVOX18udW5zaGlmdChjYik7XG4gIH1cblxuICB2YXIgcnVuRGVwZW5kZW5jaWVzID0gMDtcbiAgdmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICAgIHJ1bkRlcGVuZGVuY2llcysrO1xuICAgIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gICAgcnVuRGVwZW5kZW5jaWVzLS07XG4gICAgaWYgKE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKSB7XG4gICAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICAgIGlmIChkZXBlbmRlbmNpZXNGdWxmaWxsZWQpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xuICAgICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcbiAgICB7XG4gICAgICBpZiAoTW9kdWxlWydvbkFib3J0J10pIHtcbiAgICAgICAgTW9kdWxlWydvbkFib3J0J10od2hhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoYXQgPSAnQWJvcnRlZCgnICsgd2hhdCArICcpJztcbiAgICBlcnIod2hhdCk7XG4gICAgQUJPUlQgPSB0cnVlO1xuICAgIHdoYXQgKz0gJy4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby4nO1xuICAgIHZhciBlID0gbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtcbiAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIHZhciBkYXRhVVJJUHJlZml4ID0gJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwnO1xuXG4gIGZ1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSkge1xuICAgIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xuICB9XG5cbiAgdmFyIHdhc21CaW5hcnlGaWxlO1xuICB3YXNtQmluYXJ5RmlsZSA9ICd0ZmxpdGUtc2ltZC53YXNtJztcbiAgaWYgKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICAgd2FzbUJpbmFyeUZpbGUgPSBsb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmaWxlID09IHdhc21CaW5hcnlGaWxlICYmIHdhc21CaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWRCaW5hcnkpIDtcbiAgICAgIHRocm93ICdib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZCc7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgYWJvcnQoZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCkge1xuICAgIGlmICghd2FzbUJpbmFyeSAmJiAoRU5WSVJPTk1FTlRfSVNfV0VCICkpIHtcbiAgICAgIGlmICh0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSlcbiAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHtcbiAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgIFwiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIgKyB3YXNtQmluYXJ5RmlsZSArIFwiJ1wiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2FycmF5QnVmZmVyJ10oKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXYXNtKCkge1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgZW52OiBhc21MaWJyYXJ5QXJnLFxuICAgICAgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTogYXNtTGlicmFyeUFyZyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICAgIHZhciBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgICAgIE1vZHVsZVsnYXNtJ10gPSBleHBvcnRzO1xuICAgICAgd2FzbU1lbW9yeSA9IE1vZHVsZVsnYXNtJ11bJ21lbW9yeSddO1xuICAgICAgdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpO1xuICAgICAgTW9kdWxlWydhc20nXVsnX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZSddO1xuICAgICAgYWRkT25Jbml0KE1vZHVsZVsnYXNtJ11bJ19fd2FzbV9jYWxsX2N0b3JzJ10pO1xuICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgpO1xuICAgIH1cblxuICAgIGFkZFJ1bkRlcGVuZGVuY3koKTtcblxuICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCkge1xuICAgICAgcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFsnaW5zdGFuY2UnXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcikge1xuICAgICAgcmV0dXJuIGdldEJpbmFyeVByb21pc2UoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW5mbyk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4ocmVjZWl2ZXIsIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBlcnIoJ2ZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICcgKyByZWFzb24pO1xuICAgICAgICAgIGFib3J0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKSB7XG4gICAgICBpZiAoXG4gICAgICAgICF3YXNtQmluYXJ5ICYmXG4gICAgICAgIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpICYmXG4gICAgICAgIHR5cGVvZiBmZXRjaCA9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgIGVycignd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICcgKyByZWFzb24pO1xuICAgICAgICAgICAgICBlcnIoJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBleHBvcnRzID0gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyKCdNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZSk7XG4gICAgICAgIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFudGlhdGVBc3luYygpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLm5hbWUgPSAnRXhpdFN0YXR1cyc7XG4gICAgdGhpcy5tZXNzYWdlID0gJ1Byb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJyArIHN0YXR1cyArICcpJztcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkoTW9kdWxlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX2RsaW5pdChtYWluX2Rzb19oYW5kbGUpIHt9XG5cbiAgdmFyIGRsb3Blbk1pc3NpbmdFcnJvciA9XG4gICAgJ1RvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nJztcblxuICBmdW5jdGlvbiBfX2Rsb3Blbl9qcyhmaWxlbmFtZSwgZmxhZykge1xuICAgIGFib3J0KGRsb3Blbk1pc3NpbmdFcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBfX2Rsc3ltX2pzKGhhbmRsZSwgc3ltYm9sKSB7XG4gICAgYWJvcnQoZGxvcGVuTWlzc2luZ0Vycm9yKTtcbiAgfVxuXG4gIHZhciBub3dJc01vbm90b25pYyA9IHRydWU7XG5cbiAgZnVuY3Rpb24gX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKCkge1xuICAgIHJldHVybiBub3dJc01vbm90b25pYztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9fbW1hcF9qcyhsZW4sIHByb3QsIGZsYWdzLCBmZCwgb2ZmLCBhbGxvY2F0ZWQpIHtcbiAgICByZXR1cm4gLTUyO1xuICB9XG5cbiAgZnVuY3Rpb24gX19tdW5tYXBfanMoYWRkciwgbGVuLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCkge31cblxuICBmdW5jdGlvbiBfYWJvcnQoKSB7XG4gICAgYWJvcnQoJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZGF0ZV9ub3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIZWFwTWF4KCkge1xuICAgIHJldHVybiAyMTQ3NDgzNjQ4O1xuICB9XG5cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4KCkge1xuICAgIHJldHVybiBnZXRIZWFwTWF4KCk7XG4gIH1cblxuICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztcbiAgX2Vtc2NyaXB0ZW5fZ2V0X25vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHtcbiAgICBIRUFQVTguY29weVdpdGhpbihkZXN0LCBzcmMsIHNyYyArIG51bSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKHNpemUpIHtcbiAgICB0cnkge1xuICAgICAgd2FzbU1lbW9yeS5ncm93KChzaXplIC0gYnVmZmVyLmJ5dGVMZW5ndGggKyA2NTUzNSkgPj4+IDE2KTtcbiAgICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcChyZXF1ZXN0ZWRTaXplKSB7XG4gICAgdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuICAgIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuICAgIHZhciBtYXhIZWFwU2l6ZSA9IGdldEhlYXBNYXgoKTtcbiAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBhbGlnblVwID0gKHgsIG11bHRpcGxlKSA9PiB4ICsgKChtdWx0aXBsZSAtICh4ICUgbXVsdGlwbGUpKSAlIG11bHRpcGxlKTtcbiAgICBmb3IgKHZhciBjdXREb3duID0gMTsgY3V0RG93biA8PSA0OyBjdXREb3duICo9IDIpIHtcbiAgICAgIHZhciBvdmVyR3Jvd25IZWFwU2l6ZSA9IG9sZFNpemUgKiAoMSArIDAuMiAvIGN1dERvd24pO1xuICAgICAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihcbiAgICAgICAgb3Zlckdyb3duSGVhcFNpemUsXG4gICAgICAgIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYsXG4gICAgICApO1xuICAgICAgdmFyIG5ld1NpemUgPSBNYXRoLm1pbihcbiAgICAgICAgbWF4SGVhcFNpemUsXG4gICAgICAgIGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSwgb3Zlckdyb3duSGVhcFNpemUpLCA2NTUzNiksXG4gICAgICApO1xuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihuZXdTaXplKTtcbiAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIEVOViA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzUHJvZ3JhbSB8fCAnLi90aGlzLnByb2dyYW0nO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RW52U3RyaW5ncygpIHtcbiAgICBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICAgICAgdmFyIGxhbmcgPVxuICAgICAgICAoXG4gICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci5sYW5ndWFnZXMgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0pIHx8XG4gICAgICAgICAgJ0MnXG4gICAgICAgICkucmVwbGFjZSgnLScsICdfJykgKyAnLlVURi04JztcbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIFVTRVI6ICd3ZWJfdXNlcicsXG4gICAgICAgIExPR05BTUU6ICd3ZWJfdXNlcicsXG4gICAgICAgIFBBVEg6ICcvJyxcbiAgICAgICAgUFdEOiAnLycsXG4gICAgICAgIEhPTUU6ICcvaG9tZS93ZWJfdXNlcicsXG4gICAgICAgIExBTkc6IGxhbmcsXG4gICAgICAgIF86IGdldEV4ZWN1dGFibGVOYW1lKCksXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgeCBpbiBFTlYpIHtcbiAgICAgICAgaWYgKEVOVlt4XSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgZW52W3hdO1xuICAgICAgICBlbHNlIGVudlt4XSA9IEVOVlt4XTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICBmb3IgKHZhciB4IGluIGVudikge1xuICAgICAgICBzdHJpbmdzLnB1c2goeCArICc9JyArIGVudlt4XSk7XG4gICAgICB9XG4gICAgICBnZXRFbnZTdHJpbmdzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0ciwgYnVmZmVyLCBkb250QWRkTnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICBIRUFQOFtidWZmZXIrKyA+PiAwXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICBpZiAoIWRvbnRBZGROdWxsKSBIRUFQOFtidWZmZXIgPj4gMF0gPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Vudmlyb25fZ2V0KF9fZW52aXJvbiwgZW52aXJvbl9idWYpIHtcbiAgICB2YXIgYnVmU2l6ZSA9IDA7XG4gICAgZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKHN0cmluZywgaSkge1xuICAgICAgdmFyIHB0ciA9IGVudmlyb25fYnVmICsgYnVmU2l6ZTtcbiAgICAgIEhFQVBVMzJbKF9fZW52aXJvbiArIGkgKiA0KSA+PiAyXSA9IHB0cjtcbiAgICAgIHdyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcsIHB0cik7XG4gICAgICBidWZTaXplICs9IHN0cmluZy5sZW5ndGggKyAxO1xuICAgIH0pO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Vudmlyb25fc2l6ZXNfZ2V0KHBlbnZpcm9uX2NvdW50LCBwZW52aXJvbl9idWZfc2l6ZSkge1xuICAgIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuICAgIEhFQVBVMzJbcGVudmlyb25fY291bnQgPj4gMl0gPSBzdHJpbmdzLmxlbmd0aDtcbiAgICB2YXIgYnVmU2l6ZSA9IDA7XG4gICAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgfSk7XG4gICAgSEVBUFUzMltwZW52aXJvbl9idWZfc2l6ZSA+PiAyXSA9IGJ1ZlNpemU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiBfcHJvY19leGl0KGNvZGUpIHtcbiAgICBpZiAoIWtlZXBSdW50aW1lQWxpdmUoKSkge1xuICAgICAgaWYgKE1vZHVsZVsnb25FeGl0J10pIE1vZHVsZVsnb25FeGl0J10oY29kZSk7XG4gICAgICBBQk9SVCA9IHRydWU7XG4gICAgfVxuICAgIHF1aXRfKGNvZGUsIG5ldyBFeGl0U3RhdHVzKGNvZGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4aXRKUyhzdGF0dXMsIGltcGxpY2l0KSB7XG4gICAgX3Byb2NfZXhpdChzdGF0dXMpO1xuICB9XG5cbiAgdmFyIF9leGl0ID0gZXhpdEpTO1xuXG4gIGZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuICAgIHJldHVybiA1MjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9mZF9zZWVrKGZkLCBvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCwgd2hlbmNlLCBuZXdPZmZzZXQpIHtcbiAgICByZXR1cm4gNzA7XG4gIH1cblxuICB2YXIgcHJpbnRDaGFyQnVmZmVycyA9IFtudWxsLCBbXSwgW11dO1xuXG4gIGZ1bmN0aW9uIHByaW50Q2hhcihzdHJlYW0sIGN1cnIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIHZhciBidWZmZXIgPSBwcmludENoYXJCdWZmZXJzW3N0cmVhbV07XG4gICAgaWYgKGN1cnIgPT09IDAgfHwgY3VyciA9PT0gMTApIHtcbiAgICAgIChzdHJlYW0gPT09IDEgPyBvdXQgOiBlcnIpKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwgMCkpO1xuICAgICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9mZF93cml0ZShmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiAgICB2YXIgbnVtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICB2YXIgcHRyID0gSEVBUFUzMltpb3YgPj4gMl07XG4gICAgICB2YXIgbGVuID0gSEVBUFUzMlsoaW92ICsgNCkgPj4gMl07XG4gICAgICBpb3YgKz0gODtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgcHJpbnRDaGFyKGZkLCBIRUFQVThbcHRyICsgal0pO1xuICAgICAgfVxuICAgICAgbnVtICs9IGxlbjtcbiAgICB9XG4gICAgSEVBUFUzMltwbnVtID4+IDJdID0gbnVtO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmFuZG9tRGV2aWNlKCkge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBjcnlwdG8gPT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBjcnlwdG9bJ2dldFJhbmRvbVZhbHVlcyddID09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHZhciByYW5kb21CdWZmZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHJhbmRvbUJ1ZmZlclswXTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHJldHVybiAoKSA9PiBhYm9ydCgncmFuZG9tRGV2aWNlJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICBmdW5jdGlvbiBfZ2V0ZW50cm9weShidWZmZXIsIHNpemUpIHtcbiAgICBpZiAoIV9nZXRlbnRyb3B5LnJhbmRvbURldmljZSkge1xuICAgICAgX2dldGVudHJvcHkucmFuZG9tRGV2aWNlID0gZ2V0UmFuZG9tRGV2aWNlKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBIRUFQOFsoYnVmZmVyICsgaSkgPj4gMF0gPSBfZ2V0ZW50cm9weS5yYW5kb21EZXZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgYXNtTGlicmFyeUFyZyA9IHtcbiAgICBfZGxpbml0OiBfX2RsaW5pdCxcbiAgICBfZGxvcGVuX2pzOiBfX2Rsb3Blbl9qcyxcbiAgICBfZGxzeW1fanM6IF9fZGxzeW1fanMsXG4gICAgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWM6IF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyxcbiAgICBfbW1hcF9qczogX19tbWFwX2pzLFxuICAgIF9tdW5tYXBfanM6IF9fbXVubWFwX2pzLFxuICAgIGFib3J0OiBfYWJvcnQsXG4gICAgZW1zY3JpcHRlbl9kYXRlX25vdzogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gICAgZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXg6IF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCxcbiAgICBlbXNjcmlwdGVuX2dldF9ub3c6IF9lbXNjcmlwdGVuX2dldF9ub3csXG4gICAgZW1zY3JpcHRlbl9tZW1jcHlfYmlnOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFxuICAgIGVtc2NyaXB0ZW5fcmVzaXplX2hlYXA6IF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwLFxuICAgIGVudmlyb25fZ2V0OiBfZW52aXJvbl9nZXQsXG4gICAgZW52aXJvbl9zaXplc19nZXQ6IF9lbnZpcm9uX3NpemVzX2dldCxcbiAgICBleGl0OiBfZXhpdCxcbiAgICBmZF9jbG9zZTogX2ZkX2Nsb3NlLFxuICAgIGZkX3NlZWs6IF9mZF9zZWVrLFxuICAgIGZkX3dyaXRlOiBfZmRfd3JpdGUsXG4gICAgZ2V0ZW50cm9weTogX2dldGVudHJvcHksXG4gIH07XG4gIGNyZWF0ZVdhc20oKTtcbiAgKE1vZHVsZVsnX19fd2FzbV9jYWxsX2N0b3JzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19fX3dhc21fY2FsbF9jdG9ycyddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ19fd2FzbV9jYWxsX2N0b3JzJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0TW9kZWxCdWZmZXJNZW1vcnlPZmZzZXQnXSA9XG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChNb2R1bGVbXG4gICAgICAgICdfZ2V0TW9kZWxCdWZmZXJNZW1vcnlPZmZzZXQnXG4gICAgICBdID1cbiAgICAgICAgTW9kdWxlWydhc20nXVsnZ2V0TW9kZWxCdWZmZXJNZW1vcnlPZmZzZXQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgKE1vZHVsZVsnX2dldElucHV0TWVtb3J5T2Zmc2V0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRJbnB1dE1lbW9yeU9mZnNldCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldElucHV0TWVtb3J5T2Zmc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0SW5wdXRIZWlnaHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnX2dldElucHV0SGVpZ2h0J10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZ2V0SW5wdXRIZWlnaHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19nZXRJbnB1dFdpZHRoJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRJbnB1dFdpZHRoJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZ2V0SW5wdXRXaWR0aCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldElucHV0Q2hhbm5lbENvdW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRJbnB1dENoYW5uZWxDb3VudCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldElucHV0Q2hhbm5lbENvdW50J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0T3V0cHV0TWVtb3J5T2Zmc2V0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRPdXRwdXRNZW1vcnlPZmZzZXQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRPdXRwdXRNZW1vcnlPZmZzZXQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19nZXRPdXRwdXRIZWlnaHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnX2dldE91dHB1dEhlaWdodCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldE91dHB1dEhlaWdodCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldE91dHB1dFdpZHRoJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRPdXRwdXRXaWR0aCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldE91dHB1dFdpZHRoJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0T3V0cHV0Q2hhbm5lbENvdW50J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRPdXRwdXRDaGFubmVsQ291bnQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRPdXRwdXRDaGFubmVsQ291bnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19sb2FkTW9kZWwnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnX2xvYWRNb2RlbCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2xvYWRNb2RlbCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX3J1bkluZmVyZW5jZSddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfcnVuSW5mZXJlbmNlJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsncnVuSW5mZXJlbmNlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfbWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19tYWxsb2MnXSA9IE1vZHVsZVsnYXNtJ11bJ21hbGxvYyddKS5hcHBseShcbiAgICAgIG51bGwsXG4gICAgICBhcmd1bWVudHMsXG4gICAgKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnX19lcnJub19sb2NhdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX19fZGxfc2V0ZXJyJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19fX2RsX3NldGVyciddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ19fZGxfc2V0ZXJyJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydzdGFja1NhdmUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnc3RhY2tTYXZlJ10gPSBNb2R1bGVbJ2FzbSddWydzdGFja1NhdmUnXSkuYXBwbHkoXG4gICAgICBudWxsLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gIH0pO1xuICAoTW9kdWxlWydzdGFja1Jlc3RvcmUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnc3RhY2tSZXN0b3JlJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnc3RhY2tSZXN0b3JlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydzdGFja0FsbG9jJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ3N0YWNrQWxsb2MnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydzdGFja0FsbG9jJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydkeW5DYWxsX2pqaiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydkeW5DYWxsX2pqaiddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfampqJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydkeW5DYWxsX2ppaWknXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnZHluQ2FsbF9qaWlpJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZHluQ2FsbF9qaWlpJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydkeW5DYWxsX2lpaWlqaiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydkeW5DYWxsX2lpaWlqaiddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWlpaWpqJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydkeW5DYWxsX3ZpaWpqJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfdmlpamonXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpaWpqJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydkeW5DYWxsX3ZpaWlqamonXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnZHluQ2FsbF92aWlpampqJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWlpampqJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydkeW5DYWxsX2lpamppaWlpJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfaWlqamlpaWknXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2lpamppaWlpJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydkeW5DYWxsX2ppamknXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnZHluQ2FsbF9qaWppJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZHluQ2FsbF9qaWppJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICB2YXIgY2FsbGVkUnVuO1xuICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gICAgaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuICAgIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcnVuKGFyZ3MpIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcmVSdW4oKTtcbiAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvUnVuKCkge1xuICAgICAgaWYgKGNhbGxlZFJ1bikgcmV0dXJuO1xuICAgICAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgICAgIE1vZHVsZVsnY2FsbGVkUnVuJ10gPSB0cnVlO1xuICAgICAgaWYgKEFCT1JUKSByZXR1cm47XG4gICAgICBpbml0UnVudGltZSgpO1xuICAgICAgcmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO1xuICAgICAgaWYgKE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSkgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKCk7XG4gICAgICBwb3N0UnVuKCk7XG4gICAgfVxuXG4gICAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcbiAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJ1J1bm5pbmcuLi4nKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCcnKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIGRvUnVuKCk7XG4gICAgICB9LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9SdW4oKTtcbiAgICB9XG4gIH1cblxuICBpZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlSW5pdCddID09ICdmdW5jdGlvbicpXG4gICAgICBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07XG4gICAgd2hpbGUgKE1vZHVsZVsncHJlSW5pdCddLmxlbmd0aCA+IDApIHtcbiAgICAgIE1vZHVsZVsncHJlSW5pdCddLnBvcCgpKCk7XG4gICAgfVxuICB9XG4gIHJ1bigpO1xuXG4gIHJldHVybiBfX01vZHVsZS5yZWFkeTtcbn07XG5cbmNvbnN0IHZlcnNpb24gPSBcIjAuMS4wXCIgO1xuY29uc3QgcGFja2FnZU5hbWUgPSBcIkBzdHJlYW0taW8vdmlkZW8tZmlsdGVycy13ZWJcIiA7XG5cbi8vIEB0cy1leHBlY3QtZXJyb3IgLSBtb2R1bGUgaXMgbm90IGRlY2xhcmVkXG4vLyBUaGlzIGlzIGEgV2ViQXNzZW1ibHkgbW9kdWxlIGNvbXBpbGVkIGZyb20gdGhlIFRlbnNvckZsb3cgTGl0ZSBDKysgbGlicmFyeS5cbmNvbnN0IGNyZWF0ZVRGTGl0ZSA9IGNyZWF0ZVRGTGl0ZVNJTURNb2R1bGU7XG5jb25zdCBsb2FkVEZMaXRlID0gYXN5bmMgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgYmFzZVBhdGggPSBgaHR0cHM6Ly91bnBrZy5jb20vJHtwYWNrYWdlTmFtZX1AJHt2ZXJzaW9ufS90ZmAsIHRmRmlsZVBhdGggPSBgJHtiYXNlUGF0aH0vdGZsaXRlL3RmbGl0ZS1zaW1kLndhc21gLCBtb2RlbEZpbGVQYXRoID0gYCR7YmFzZVBhdGh9L21vZGVscy9zZWdtX2Z1bGxfdjY3OS50ZmxpdGVgLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBbdGZMaXRlLCBtb2RlbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGNyZWF0ZVRGTGl0ZSh7IGxvY2F0ZUZpbGU6ICgpID0+IHRmRmlsZVBhdGggfSksXG4gICAgICAgIGZldGNoTW9kZWwobW9kZWxGaWxlUGF0aCksXG4gICAgXSk7XG4gICAgY29uc3QgbW9kZWxCdWZmZXJPZmZzZXQgPSB0ZkxpdGUuX2dldE1vZGVsQnVmZmVyTWVtb3J5T2Zmc2V0KCk7XG4gICAgdGZMaXRlLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkobW9kZWwpLCBtb2RlbEJ1ZmZlck9mZnNldCk7XG4gICAgdGZMaXRlLl9sb2FkTW9kZWwobW9kZWwuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHRmTGl0ZTtcbn07XG5sZXQgbGFzdE1vZGVsRmlsZVBhdGggPSAnJztcbmxldCBtb2RlbEZpbGVDYWNoZTtcbmNvbnN0IGZldGNoTW9kZWwgPSBhc3luYyAobW9kZWxGaWxlUGF0aCkgPT4ge1xuICAgIGNvbnN0IG1vZGVsID0gbW9kZWxGaWxlUGF0aCA9PT0gbGFzdE1vZGVsRmlsZVBhdGggJiYgbW9kZWxGaWxlQ2FjaGVcbiAgICAgICAgPyBtb2RlbEZpbGVDYWNoZVxuICAgICAgICA6IGF3YWl0IGZldGNoKG1vZGVsRmlsZVBhdGgpLnRoZW4oKHIpID0+IHIuYXJyYXlCdWZmZXIoKSk7XG4gICAgLy8gQ2FjaGUgdGhlIG1vZGVsIGZpbGUgZm9yIGZ1dHVyZSB1c2UuXG4gICAgbW9kZWxGaWxlQ2FjaGUgPSBtb2RlbDtcbiAgICBsYXN0TW9kZWxGaWxlUGF0aCA9IG1vZGVsRmlsZVBhdGg7XG4gICAgcmV0dXJuIG1vZGVsO1xufTtcblxuZXhwb3J0IHsgU2VnbWVudGF0aW9uTGV2ZWwsIGNyZWF0ZVJlbmRlcmVyLCBpc1BsYXRmb3JtU3VwcG9ydGVkLCBsb2FkVEZMaXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-filters-web/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-bindings/dist/index.es.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LANGUAGE: () => (/* binding */ DEFAULT_LANGUAGE),\n/* harmony export */   DEFAULT_NAMESPACE: () => (/* binding */ DEFAULT_NAMESPACE),\n/* harmony export */   Restricted: () => (/* binding */ Restricted),\n/* harmony export */   StreamCallProvider: () => (/* binding */ StreamCallProvider),\n/* harmony export */   StreamI18n: () => (/* binding */ StreamI18n),\n/* harmony export */   StreamI18nProvider: () => (/* binding */ StreamI18nProvider),\n/* harmony export */   StreamVideoProvider: () => (/* binding */ StreamVideoProvider),\n/* harmony export */   defaultTranslationFunction: () => (/* binding */ defaultTranslationFunction),\n/* harmony export */   mapToRegistry: () => (/* binding */ mapToRegistry),\n/* harmony export */   useCall: () => (/* binding */ useCall),\n/* harmony export */   useCallStateHooks: () => (/* binding */ useCallStateHooks),\n/* harmony export */   useCalls: () => (/* binding */ useCalls),\n/* harmony export */   useConnectedUser: () => (/* binding */ useConnectedUser),\n/* harmony export */   useCreateI18n: () => (/* binding */ useCreateI18n),\n/* harmony export */   useI18n: () => (/* binding */ useI18n),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStreamVideoClient: () => (/* binding */ useStreamVideoClient)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var i18next__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! i18next */ \"(ssr)/./node_modules/i18next/dist/esm/i18next.js\");\n/* harmony import */ var _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stream-io/video-client */ \"(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\");\n\n\n\n\n\nconst StreamCallContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * A provider for the call object.\n */\nconst StreamCallProvider = (props) => {\n    const { call, children } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamCallContext.Provider, { value: call, children: children }));\n};\n/**\n * A hook to get the call object from the closest provider.\n */\nconst useCall = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamCallContext);\n};\n\nconst mapToRegistry = (translationsMap, namespace) => Object.entries(translationsMap).reduce((acc, [lng, translations]) => {\n    acc[lng] = { [namespace]: translations };\n    return acc;\n}, {});\n\nconst DEFAULT_LANGUAGE = 'en';\nconst DEFAULT_NAMESPACE = 'stream-video';\nconst DEFAULT_CONFIG = {\n    debug: false,\n    currentLanguage: DEFAULT_LANGUAGE,\n    fallbackLanguage: false,\n};\nconst DEFAULT_TRANSLATIONS_REGISTRY = mapToRegistry({}, DEFAULT_NAMESPACE);\nconst defaultTranslationFunction = (key) => key;\nclass StreamI18n {\n    /** Simple logger function */\n    constructor(options = {}) {\n        /** Translator function that converts the provided string into its equivalent in the current language. */\n        this.t = defaultTranslationFunction;\n        this.init = async () => {\n            try {\n                this.t = await this.i18nInstance.init();\n            }\n            catch (e) {\n                console.error(`Failed to initialize translations: ${JSON.stringify(e)}`);\n            }\n            return this;\n        };\n        this.changeLanguage = async (language, onChange) => {\n            if (!this._checkIsInitialized())\n                return;\n            // i18next detects the language, if none provided, but it is better\n            // to show this detection here explicitly\n            const browserLanguage = typeof window !== 'undefined' && window.navigator\n                ? window.navigator.language\n                : undefined;\n            await this.i18nInstance.changeLanguage(language || browserLanguage);\n            onChange?.(this.currentLanguage);\n        };\n        this.registerTranslationsForLanguage = ({ lng, translations, }) => {\n            if (!this._checkIsInitialized())\n                return;\n            this.i18nInstance.addResourceBundle(lng, DEFAULT_NAMESPACE, translations, true, true);\n        };\n        this._checkIsInitialized = () => {\n            if (!this.i18nInstance.isInitialized) {\n                console.warn('I18n instance is not initialized. Call yourStreamI18nInstance.init().');\n            }\n            return this.i18nInstance.isInitialized;\n        };\n        const { debug = DEFAULT_CONFIG.debug, currentLanguage = DEFAULT_CONFIG.currentLanguage, fallbackLanguage = DEFAULT_CONFIG.fallbackLanguage, translationsOverrides, } = options;\n        this.i18nInstance = i18next__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createInstance({\n            debug,\n            defaultNS: DEFAULT_NAMESPACE,\n            fallbackLng: fallbackLanguage,\n            interpolation: { escapeValue: false },\n            keySeparator: false,\n            lng: currentLanguage,\n            nsSeparator: false,\n            parseMissingKeyHandler: (key) => {\n                return key;\n            },\n            resources: DEFAULT_TRANSLATIONS_REGISTRY,\n        });\n        if (translationsOverrides) {\n            this.i18nInstance.on('initialized', () => {\n                Object.entries(translationsOverrides).forEach(([lng, translations]) => {\n                    this.registerTranslationsForLanguage({ lng, translations });\n                });\n            });\n        }\n    }\n    get currentLanguage() {\n        this._checkIsInitialized();\n        return this.i18nInstance.language;\n    }\n    get isInitialized() {\n        return this.i18nInstance.isInitialized;\n    }\n}\n\nconst StreamI18nContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    t: defaultTranslationFunction,\n});\nconst StreamI18nProvider = ({ children, ...createI18nParams }) => {\n    const { i18n, t } = useCreateI18n(createI18nParams);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamI18nContext.Provider, { value: { t, i18n }, children: children }));\n};\nconst useCreateI18n = ({ i18nInstance, language, fallbackLanguage, translationsOverrides, }) => {\n    const [i18n] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => i18nInstance ||\n        new StreamI18n({\n            currentLanguage: language,\n            fallbackLanguage,\n            translationsOverrides,\n        }));\n    const [t, setTranslationFn] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => defaultTranslationFunction);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const { isInitialized } = i18n;\n        if (!isInitialized) {\n            i18n.init().then((_i18n) => setTranslationFn(() => _i18n.i18nInstance.t));\n            return;\n        }\n        if (language && i18n?.currentLanguage !== language) {\n            i18n.changeLanguage(language).catch((err) => {\n                console.log('Error while changing language', err);\n            });\n        }\n    }, [i18n, i18nInstance, language, translationsOverrides]);\n    return { i18n, t };\n};\nconst useI18n = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamI18nContext);\n\nconst StreamVideoContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * StreamVideo is a provider component which should be used to wrap the entire application.\n * It provides the client object to all children components and initializes the i18n instance.\n *  @param PropsWithChildren<StreamVideoProps>\n *  @category Client State\n */\nconst StreamVideoProvider = ({ children, client, i18nInstance, language, translationsOverrides, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamVideoContext.Provider, { value: client, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamI18nProvider, { i18nInstance: i18nInstance, language: language, translationsOverrides: translationsOverrides, children: children }) }));\n};\n/**\n *\n * @returns\n *\n * @category Client State\n */\nconst useStreamVideoClient = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamVideoContext);\n};\n\n/**\n * Utility hook which provides the current value of the given observable.\n * @internal\n */\nconst useObservableValue = (observable$) => {\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__.RxUtils.getCurrentValue(observable$));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const subscription = observable$.subscribe(setValue);\n        return () => {\n            subscription.unsubscribe();\n        };\n    }, [observable$]);\n    return value;\n};\n\n/**\n * Checks whether we are using React Native\n */\nconst isReactNative = () => {\n    if (typeof navigator === 'undefined')\n        return false;\n    return navigator.product?.toLowerCase() === 'reactnative';\n};\n\n/**\n * Utility hook, which provides the current call's state.\n *\n * @category Call State\n */\nconst useCallState = () => {\n    const call = useCall();\n    // return an empty and unlinked CallState object if there is no call in the provider\n    // this ensures that the hooks always return a value and many null checks can be avoided\n    if (!call) {\n        const message = 'You are using useCallState() outside a Call context. ' +\n            'Please wrap your component in <StreamCall /> and provide a \"call\" instance.';\n        console.warn(message);\n        return new _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__.CallState();\n    }\n    return call.state;\n};\n/**\n * Utility hook which provides information whether the current call is being recorded. It will return `true` if the call is being recorded.\n *\n * @category Call State\n */\nconst useIsCallRecordingInProgress = () => {\n    const { recording$ } = useCallState();\n    return useObservableValue(recording$);\n};\n/**\n * Utility hook which provides information whether the current call is broadcasting.\n *\n * @category Call State\n */\nconst useIsCallHLSBroadcastingInProgress = () => {\n    const { egress$ } = useCallState();\n    const egress = useObservableValue(egress$);\n    if (!egress)\n        return false;\n    return egress.broadcasting;\n};\n/**\n * Utility hook which provides information whether the current call is live.\n *\n * @category Call State\n */\nconst useIsCallLive = () => {\n    const { backstage$ } = useCallState();\n    const isBackstageOn = useObservableValue(backstage$);\n    return !isBackstageOn;\n};\n/**\n * Returns the list of blocked users in the current call.\n */\nconst useCallBlockedUserIds = () => {\n    const { blockedUserIds$ } = useCallState();\n    return useObservableValue(blockedUserIds$);\n};\n/**\n * Returns the timestamp when this call was created.\n */\nconst useCallCreatedAt = () => {\n    const { createdAt$ } = useCallState();\n    return useObservableValue(createdAt$);\n};\n/**\n * Returns the timestamp when this call was ended.\n */\nconst useCallEndedAt = () => {\n    const { endedAt$ } = useCallState();\n    return useObservableValue(endedAt$);\n};\n/**\n * Returns the timestamp telling when the call is scheduled to start.\n */\nconst useCallStartsAt = () => {\n    const { startsAt$ } = useCallState();\n    return useObservableValue(startsAt$);\n};\n/**\n * Returns the timestamp when this call was updated.\n */\nconst useCallUpdatedAt = () => {\n    const { updatedAt$ } = useCallState();\n    return useObservableValue(updatedAt$);\n};\n/**\n * Returns the information about the call's creator.\n */\nconst useCallCreatedBy = () => {\n    const { createdBy$ } = useCallState();\n    return useObservableValue(createdBy$);\n};\n/**\n * Returns the call's custom data.\n */\nconst useCallCustomData = () => {\n    const { custom$ } = useCallState();\n    return useObservableValue(custom$);\n};\n/**\n * Returns the call's Egress information.\n */\nconst useCallEgress = () => {\n    const { egress$ } = useCallState();\n    return useObservableValue(egress$);\n};\n/**\n * Returns the call's Ingress information.\n */\nconst useCallIngress = () => {\n    const { ingress$ } = useCallState();\n    return useObservableValue(ingress$);\n};\n/**\n * Returns the data for the current call session.\n */\nconst useCallSession = () => {\n    const { session$ } = useCallState();\n    return useObservableValue(session$);\n};\n/**\n * Returns the call's settings.\n */\nconst useCallSettings = () => {\n    const { settings$ } = useCallState();\n    return useObservableValue(settings$);\n};\n/**\n * Returns whether the call has transcribing enabled.\n */\nconst useIsCallTranscribingInProgress = () => {\n    const { transcribing$ } = useCallState();\n    return useObservableValue(transcribing$);\n};\n/**\n * Returns information about the user who has marked this call as ended.\n */\nconst useCallEndedBy = () => {\n    const { endedBy$ } = useCallState();\n    return useObservableValue(endedBy$);\n};\n/**\n * Utility hook which provides a boolean indicating whether there is\n * a participant in the current call which shares their screen.\n *\n * @category Call State\n */\nconst useHasOngoingScreenShare = () => {\n    const { hasOngoingScreenShare$ } = useCallState();\n    return useObservableValue(hasOngoingScreenShare$);\n};\n/**\n * Utility hook which provides the latest stats report of the current call.\n *\n * The latest stats report of the current call.\n * When stats gathering is enabled, this observable will emit a new value\n * at a regular (configurable) interval.\n *\n * Consumers of this observable can implement their own batching logic\n * in case they want to show historical stats data.\n *\n * @category Call State\n */\nconst useCallStatsReport = () => {\n    const { callStatsReport$ } = useCallState();\n    return useObservableValue(callStatsReport$);\n};\n/**\n * Utility hook which provides the dominant speaker of the current call.\n *\n * @category Call State\n */\nconst useDominantSpeaker = () => {\n    const { dominantSpeaker$ } = useCallState();\n    return useObservableValue(dominantSpeaker$);\n};\n/**\n * Utility hook which provides a list of call members.\n *\n * @category Call State\n */\nconst useCallMembers = () => {\n    const { members$ } = useCallState();\n    return useObservableValue(members$);\n};\n/**\n * Utility hook providing the current calling state of the call. For example, `RINGING` or `JOINED`.\n *\n * @category Call State\n */\nconst useCallCallingState = () => {\n    const { callingState$ } = useCallState();\n    return useObservableValue(callingState$);\n};\n/**\n * Utility hook providing the actual start time of the current session.\n * Useful for calculating the call duration.\n *\n * @category Call State\n */\nconst useCallStartedAt = () => {\n    const { startedAt$ } = useCallState();\n    return useObservableValue(startedAt$);\n};\n/**\n * A hook which provides a list of all participants that have joined an active call.\n *\n * @category Call State\n *\n * @param options.sortBy - A comparator function to sort the participants by.\n * Make sure to memoize output of the `combineComparators` function\n * (or keep it out of component's scope if possible) before passing it down to this property.\n */\nconst useParticipants = ({ sortBy, } = {}) => {\n    const { participants$ } = useCallState();\n    const participants = useObservableValue(participants$);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        if (sortBy) {\n            return [...participants].sort(sortBy);\n        }\n        return participants;\n    }, [participants, sortBy]);\n};\n/**\n * A hook which provides a StreamVideoLocalParticipant object.\n * It signals that I have joined a call.\n *\n * @category Call State\n */\nconst useLocalParticipant = () => {\n    const { localParticipant$ } = useCallState();\n    return useObservableValue(localParticipant$);\n};\n/**\n * A hook which provides a list of all other participants than me that have joined an active call.\n *\n * @category Call State\n */\nconst useRemoteParticipants = () => {\n    const { remoteParticipants$ } = useCallState();\n    return useObservableValue(remoteParticipants$);\n};\n/**\n * Returns the approximate participant count of the active call.\n * This includes the anonymous users as well, and it is computed on the server.\n *\n * @category Call State\n */\nconst useParticipantCount = () => {\n    const { participantCount$ } = useCallState();\n    return useObservableValue(participantCount$);\n};\n/**\n * Returns the approximate anonymous participant count of the active call.\n * The regular participants are not included in this count. It is computed on the server.\n *\n * @category Call State\n */\nconst useAnonymousParticipantCount = () => {\n    const { anonymousParticipantCount$ } = useCallState();\n    return useObservableValue(anonymousParticipantCount$);\n};\n/**\n * Returns the generated thumbnail of the current call, if enabled in settings.\n */\nconst useCallThumbnail = () => {\n    const { thumbnails$ } = useCallState();\n    return useObservableValue(thumbnails$);\n};\n/**\n * A hook which returns the local participant's own capabilities.\n */\nconst useOwnCapabilities = () => {\n    const { ownCapabilities$ } = useCallState();\n    return useObservableValue(ownCapabilities$);\n};\n/**\n * Hook that returns true if the local participant has all the given permissions.\n *\n * @param permissions the permissions to check.\n */\nconst useHasPermissions = (...permissions) => {\n    const capabilities = useOwnCapabilities();\n    return permissions.every((permission) => capabilities?.includes(permission));\n};\n/**\n * Returns the camera state of the current call.\n *\n * @category Camera Manager State\n *\n */\nconst useCameraState = () => {\n    const call = useCall();\n    const { camera } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => camera.listDevices(), [camera]);\n    const { state } = camera;\n    const status = useObservableValue(state.status$);\n    const direction = useObservableValue(state.direction$);\n    const mediaStream = useObservableValue(state.mediaStream$);\n    const selectedDevice = useObservableValue(state.selectedDevice$);\n    const devices = useObservableValue(devices$);\n    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);\n    const isMute = status !== 'enabled';\n    return {\n        camera,\n        status,\n        isEnabled: status === 'enabled',\n        direction,\n        mediaStream,\n        devices,\n        hasBrowserPermission,\n        selectedDevice,\n        isMute,\n    };\n};\n/**\n * Returns the microphone state of the current call.\n *\n * @category Microphone Manager State\n */\nconst useMicrophoneState = () => {\n    const call = useCall();\n    const { microphone } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => microphone.listDevices(), [microphone]);\n    const { state } = microphone;\n    const status = useObservableValue(state.status$);\n    const mediaStream = useObservableValue(state.mediaStream$);\n    const selectedDevice = useObservableValue(state.selectedDevice$);\n    const devices = useObservableValue(devices$);\n    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);\n    const isSpeakingWhileMuted = useObservableValue(state.speakingWhileMuted$);\n    const isMute = status !== 'enabled';\n    return {\n        microphone,\n        status,\n        isEnabled: status === 'enabled',\n        mediaStream,\n        devices,\n        selectedDevice,\n        hasBrowserPermission,\n        isSpeakingWhileMuted,\n        isMute,\n    };\n};\n/**\n * Returns the speaker state of the current call.\n *\n * Note: This hook is not supported in React Native\n */\nconst useSpeakerState = () => {\n    if (isReactNative()) {\n        throw new Error('This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details');\n    }\n    const call = useCall();\n    const { speaker } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => speaker.listDevices(), [speaker]);\n    const devices = useObservableValue(devices$);\n    const selectedDevice = useObservableValue(speaker.state.selectedDevice$);\n    return {\n        speaker,\n        devices,\n        selectedDevice,\n        isDeviceSelectionSupported: speaker.state.isDeviceSelectionSupported,\n    };\n};\n/**\n * Returns the Screen Share state of the current call.\n */\nconst useScreenShareState = () => {\n    const call = useCall();\n    const { screenShare } = call;\n    const status = useObservableValue(screenShare.state.status$);\n    const mediaStream = useObservableValue(screenShare.state.mediaStream$);\n    const isMute = status !== 'enabled';\n    return {\n        screenShare,\n        mediaStream,\n        status,\n        isMute,\n    };\n};\n\nvar CallStateHooks = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    useAnonymousParticipantCount: useAnonymousParticipantCount,\n    useCallBlockedUserIds: useCallBlockedUserIds,\n    useCallCallingState: useCallCallingState,\n    useCallCreatedAt: useCallCreatedAt,\n    useCallCreatedBy: useCallCreatedBy,\n    useCallCustomData: useCallCustomData,\n    useCallEgress: useCallEgress,\n    useCallEndedAt: useCallEndedAt,\n    useCallEndedBy: useCallEndedBy,\n    useCallIngress: useCallIngress,\n    useCallMembers: useCallMembers,\n    useCallSession: useCallSession,\n    useCallSettings: useCallSettings,\n    useCallStartedAt: useCallStartedAt,\n    useCallStartsAt: useCallStartsAt,\n    useCallState: useCallState,\n    useCallStatsReport: useCallStatsReport,\n    useCallThumbnail: useCallThumbnail,\n    useCallUpdatedAt: useCallUpdatedAt,\n    useCameraState: useCameraState,\n    useDominantSpeaker: useDominantSpeaker,\n    useHasOngoingScreenShare: useHasOngoingScreenShare,\n    useHasPermissions: useHasPermissions,\n    useIsCallHLSBroadcastingInProgress: useIsCallHLSBroadcastingInProgress,\n    useIsCallLive: useIsCallLive,\n    useIsCallRecordingInProgress: useIsCallRecordingInProgress,\n    useIsCallTranscribingInProgress: useIsCallTranscribingInProgress,\n    useLocalParticipant: useLocalParticipant,\n    useMicrophoneState: useMicrophoneState,\n    useOwnCapabilities: useOwnCapabilities,\n    useParticipantCount: useParticipantCount,\n    useParticipants: useParticipants,\n    useRemoteParticipants: useRemoteParticipants,\n    useScreenShareState: useScreenShareState,\n    useSpeakerState: useSpeakerState\n});\n\n/**\n * Utility hook which provides access to client's state store.\n */\nconst useStore = () => {\n    const client = useStreamVideoClient();\n    if (!client) {\n        throw new Error(`StreamVideoClient isn't initialized or this hook is called outside of <StreamVideo> context.`);\n    }\n    return client.readOnlyStateStore;\n};\n/**\n * Utility hook which provides a list of all notifications about created calls.\n * In the ring call settings, these calls can be outgoing (I have called somebody)\n * or incoming (somebody has called me).\n *\n * @category Client State\n */\nconst useCalls = () => {\n    const { calls$ } = useStore();\n    return useObservableValue(calls$);\n};\n/**\n * Returns the current connected user.\n *\n * @category Client State\n */\nconst useConnectedUser = () => {\n    const { connectedUser$ } = useStore();\n    return useObservableValue(connectedUser$);\n};\n\n/**\n * A hook-alike function that exposes all call state hooks.\n *\n * @category Call State\n */\nconst useCallStateHooks = () => CallStateHooks;\n\nconst Restricted = ({ canRequestOnly, hasPermissionsOnly, requiredGrants, requireAll = true, children, }) => {\n    const call = useCall();\n    const { useCallSettings, useOwnCapabilities } = useCallStateHooks();\n    const ownCapabilities = useOwnCapabilities();\n    const settings = useCallSettings();\n    const hasPermissions = requiredGrants[requireAll ? 'every' : 'some']((capability) => ownCapabilities?.includes(capability));\n    if (hasPermissionsOnly)\n        return hasPermissions ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children }) : null;\n    const canRequest = requiredGrants.some((capability) => call?.permissionsContext.canRequest(capability, settings));\n    if (canRequestOnly)\n        return canRequest ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children }) : null;\n    if (hasPermissions || canRequest)\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children });\n    return null;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1iaW5kaW5ncy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtEO0FBQzhCO0FBQ2xEO0FBQytCOztBQUU3RCwwQkFBMEIsb0RBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLHNEQUFHLCtCQUErQixpQ0FBaUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQVU7QUFDckI7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2SkFBNko7QUFDN0ssNEJBQTRCLDhEQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1CQUFtQjtBQUM5RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixvREFBYTtBQUN2QztBQUNBLENBQUM7QUFDRCw4QkFBOEIsK0JBQStCO0FBQzdELFlBQVksVUFBVTtBQUN0QixZQUFZLHNEQUFHLCtCQUErQixTQUFTLFNBQVMsc0JBQXNCO0FBQ3RGO0FBQ0EseUJBQXlCLGtFQUFrRTtBQUMzRixtQkFBbUIsK0NBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDLCtDQUFRO0FBQzFDLElBQUksZ0RBQVM7QUFDYixnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBLHNCQUFzQixpREFBVTs7QUFFaEMsMkJBQTJCLG9EQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrRUFBa0U7QUFDakcsWUFBWSxzREFBRyxnQ0FBZ0MseUJBQXlCLHNEQUFHLHVCQUF1QixrSEFBa0gsR0FBRztBQUN2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpREFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFRLE9BQU8sNERBQU87QUFDcEQsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVSxJQUFJO0FBQ3pDLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixxQkFBcUIsOENBQU87QUFDNUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIscUJBQXFCLDhDQUFPO0FBQzVCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLHFCQUFxQiw4Q0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrRkFBa0Y7QUFDeEc7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBRyxDQUFDLHVEQUFRLElBQUksb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQUcsQ0FBQyx1REFBUSxJQUFJLG9CQUFvQjtBQUNoRTtBQUNBLGVBQWUsc0RBQUcsQ0FBQyx1REFBUSxJQUFJLG9CQUFvQjtBQUNuRDtBQUNBOztBQUUrUjtBQUMvUiIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYW1zcGFjZS8uL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL3ZpZGVvLXJlYWN0LWJpbmRpbmdzL2Rpc3QvaW5kZXguZXMuanM/ODczMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBpMThuZXh0IGZyb20gJ2kxOG5leHQnO1xuaW1wb3J0IHsgUnhVdGlscywgQ2FsbFN0YXRlIH0gZnJvbSAnQHN0cmVhbS1pby92aWRlby1jbGllbnQnO1xuXG5jb25zdCBTdHJlYW1DYWxsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKlxuICogQSBwcm92aWRlciBmb3IgdGhlIGNhbGwgb2JqZWN0LlxuICovXG5jb25zdCBTdHJlYW1DYWxsUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNhbGwsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChTdHJlYW1DYWxsQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2FsbCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG4vKipcbiAqIEEgaG9vayB0byBnZXQgdGhlIGNhbGwgb2JqZWN0IGZyb20gdGhlIGNsb3Nlc3QgcHJvdmlkZXIuXG4gKi9cbmNvbnN0IHVzZUNhbGwgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoU3RyZWFtQ2FsbENvbnRleHQpO1xufTtcblxuY29uc3QgbWFwVG9SZWdpc3RyeSA9ICh0cmFuc2xhdGlvbnNNYXAsIG5hbWVzcGFjZSkgPT4gT2JqZWN0LmVudHJpZXModHJhbnNsYXRpb25zTWFwKS5yZWR1Y2UoKGFjYywgW2xuZywgdHJhbnNsYXRpb25zXSkgPT4ge1xuICAgIGFjY1tsbmddID0geyBbbmFtZXNwYWNlXTogdHJhbnNsYXRpb25zIH07XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcblxuY29uc3QgREVGQVVMVF9MQU5HVUFHRSA9ICdlbic7XG5jb25zdCBERUZBVUxUX05BTUVTUEFDRSA9ICdzdHJlYW0tdmlkZW8nO1xuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGN1cnJlbnRMYW5ndWFnZTogREVGQVVMVF9MQU5HVUFHRSxcbiAgICBmYWxsYmFja0xhbmd1YWdlOiBmYWxzZSxcbn07XG5jb25zdCBERUZBVUxUX1RSQU5TTEFUSU9OU19SRUdJU1RSWSA9IG1hcFRvUmVnaXN0cnkoe30sIERFRkFVTFRfTkFNRVNQQUNFKTtcbmNvbnN0IGRlZmF1bHRUcmFuc2xhdGlvbkZ1bmN0aW9uID0gKGtleSkgPT4ga2V5O1xuY2xhc3MgU3RyZWFtSTE4biB7XG4gICAgLyoqIFNpbXBsZSBsb2dnZXIgZnVuY3Rpb24gKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgLyoqIFRyYW5zbGF0b3IgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyB0aGUgcHJvdmlkZWQgc3RyaW5nIGludG8gaXRzIGVxdWl2YWxlbnQgaW4gdGhlIGN1cnJlbnQgbGFuZ3VhZ2UuICovXG4gICAgICAgIHRoaXMudCA9IGRlZmF1bHRUcmFuc2xhdGlvbkZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IGF3YWl0IHRoaXMuaTE4bkluc3RhbmNlLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgdHJhbnNsYXRpb25zOiAke0pTT04uc3RyaW5naWZ5KGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbmdlTGFuZ3VhZ2UgPSBhc3luYyAobGFuZ3VhZ2UsIG9uQ2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NoZWNrSXNJbml0aWFsaXplZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGkxOG5leHQgZGV0ZWN0cyB0aGUgbGFuZ3VhZ2UsIGlmIG5vbmUgcHJvdmlkZWQsIGJ1dCBpdCBpcyBiZXR0ZXJcbiAgICAgICAgICAgIC8vIHRvIHNob3cgdGhpcyBkZXRlY3Rpb24gaGVyZSBleHBsaWNpdGx5XG4gICAgICAgICAgICBjb25zdCBicm93c2VyTGFuZ3VhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yXG4gICAgICAgICAgICAgICAgPyB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmkxOG5JbnN0YW5jZS5jaGFuZ2VMYW5ndWFnZShsYW5ndWFnZSB8fCBicm93c2VyTGFuZ3VhZ2UpO1xuICAgICAgICAgICAgb25DaGFuZ2U/Lih0aGlzLmN1cnJlbnRMYW5ndWFnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVnaXN0ZXJUcmFuc2xhdGlvbnNGb3JMYW5ndWFnZSA9ICh7IGxuZywgdHJhbnNsYXRpb25zLCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NoZWNrSXNJbml0aWFsaXplZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaTE4bkluc3RhbmNlLmFkZFJlc291cmNlQnVuZGxlKGxuZywgREVGQVVMVF9OQU1FU1BBQ0UsIHRyYW5zbGF0aW9ucywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NoZWNrSXNJbml0aWFsaXplZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pMThuSW5zdGFuY2UuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSTE4biBpbnN0YW5jZSBpcyBub3QgaW5pdGlhbGl6ZWQuIENhbGwgeW91clN0cmVhbUkxOG5JbnN0YW5jZS5pbml0KCkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pMThuSW5zdGFuY2UuaXNJbml0aWFsaXplZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBkZWJ1ZyA9IERFRkFVTFRfQ09ORklHLmRlYnVnLCBjdXJyZW50TGFuZ3VhZ2UgPSBERUZBVUxUX0NPTkZJRy5jdXJyZW50TGFuZ3VhZ2UsIGZhbGxiYWNrTGFuZ3VhZ2UgPSBERUZBVUxUX0NPTkZJRy5mYWxsYmFja0xhbmd1YWdlLCB0cmFuc2xhdGlvbnNPdmVycmlkZXMsIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmkxOG5JbnN0YW5jZSA9IGkxOG5leHQuY3JlYXRlSW5zdGFuY2Uoe1xuICAgICAgICAgICAgZGVidWcsXG4gICAgICAgICAgICBkZWZhdWx0TlM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZmFsbGJhY2tMbmc6IGZhbGxiYWNrTGFuZ3VhZ2UsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiB7IGVzY2FwZVZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAga2V5U2VwYXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGxuZzogY3VycmVudExhbmd1YWdlLFxuICAgICAgICAgICAgbnNTZXBhcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VNaXNzaW5nS2V5SGFuZGxlcjogKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzb3VyY2VzOiBERUZBVUxUX1RSQU5TTEFUSU9OU19SRUdJU1RSWSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0cmFuc2xhdGlvbnNPdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bkluc3RhbmNlLm9uKCdpbml0aWFsaXplZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh0cmFuc2xhdGlvbnNPdmVycmlkZXMpLmZvckVhY2goKFtsbmcsIHRyYW5zbGF0aW9uc10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlclRyYW5zbGF0aW9uc0Zvckxhbmd1YWdlKHsgbG5nLCB0cmFuc2xhdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY3VycmVudExhbmd1YWdlKCkge1xuICAgICAgICB0aGlzLl9jaGVja0lzSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaTE4bkluc3RhbmNlLmxhbmd1YWdlO1xuICAgIH1cbiAgICBnZXQgaXNJbml0aWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaTE4bkluc3RhbmNlLmlzSW5pdGlhbGl6ZWQ7XG4gICAgfVxufVxuXG5jb25zdCBTdHJlYW1JMThuQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIHQ6IGRlZmF1bHRUcmFuc2xhdGlvbkZ1bmN0aW9uLFxufSk7XG5jb25zdCBTdHJlYW1JMThuUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgLi4uY3JlYXRlSTE4blBhcmFtcyB9KSA9PiB7XG4gICAgY29uc3QgeyBpMThuLCB0IH0gPSB1c2VDcmVhdGVJMThuKGNyZWF0ZUkxOG5QYXJhbXMpO1xuICAgIHJldHVybiAoanN4KFN0cmVhbUkxOG5Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IHQsIGkxOG4gfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5jb25zdCB1c2VDcmVhdGVJMThuID0gKHsgaTE4bkluc3RhbmNlLCBsYW5ndWFnZSwgZmFsbGJhY2tMYW5ndWFnZSwgdHJhbnNsYXRpb25zT3ZlcnJpZGVzLCB9KSA9PiB7XG4gICAgY29uc3QgW2kxOG5dID0gdXNlU3RhdGUoKCkgPT4gaTE4bkluc3RhbmNlIHx8XG4gICAgICAgIG5ldyBTdHJlYW1JMThuKHtcbiAgICAgICAgICAgIGN1cnJlbnRMYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgICAgICBmYWxsYmFja0xhbmd1YWdlLFxuICAgICAgICAgICAgdHJhbnNsYXRpb25zT3ZlcnJpZGVzLFxuICAgICAgICB9KSk7XG4gICAgY29uc3QgW3QsIHNldFRyYW5zbGF0aW9uRm5dID0gdXNlU3RhdGUoKCkgPT4gZGVmYXVsdFRyYW5zbGF0aW9uRnVuY3Rpb24pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaXNJbml0aWFsaXplZCB9ID0gaTE4bjtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpMThuLmluaXQoKS50aGVuKChfaTE4bikgPT4gc2V0VHJhbnNsYXRpb25GbigoKSA9PiBfaTE4bi5pMThuSW5zdGFuY2UudCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5ndWFnZSAmJiBpMThuPy5jdXJyZW50TGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XG4gICAgICAgICAgICBpMThuLmNoYW5nZUxhbmd1YWdlKGxhbmd1YWdlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHdoaWxlIGNoYW5naW5nIGxhbmd1YWdlJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2kxOG4sIGkxOG5JbnN0YW5jZSwgbGFuZ3VhZ2UsIHRyYW5zbGF0aW9uc092ZXJyaWRlc10pO1xuICAgIHJldHVybiB7IGkxOG4sIHQgfTtcbn07XG5jb25zdCB1c2VJMThuID0gKCkgPT4gdXNlQ29udGV4dChTdHJlYW1JMThuQ29udGV4dCk7XG5cbmNvbnN0IFN0cmVhbVZpZGVvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKlxuICogU3RyZWFtVmlkZW8gaXMgYSBwcm92aWRlciBjb21wb25lbnQgd2hpY2ggc2hvdWxkIGJlIHVzZWQgdG8gd3JhcCB0aGUgZW50aXJlIGFwcGxpY2F0aW9uLlxuICogSXQgcHJvdmlkZXMgdGhlIGNsaWVudCBvYmplY3QgdG8gYWxsIGNoaWxkcmVuIGNvbXBvbmVudHMgYW5kIGluaXRpYWxpemVzIHRoZSBpMThuIGluc3RhbmNlLlxuICogIEBwYXJhbSBQcm9wc1dpdGhDaGlsZHJlbjxTdHJlYW1WaWRlb1Byb3BzPlxuICogIEBjYXRlZ29yeSBDbGllbnQgU3RhdGVcbiAqL1xuY29uc3QgU3RyZWFtVmlkZW9Qcm92aWRlciA9ICh7IGNoaWxkcmVuLCBjbGllbnQsIGkxOG5JbnN0YW5jZSwgbGFuZ3VhZ2UsIHRyYW5zbGF0aW9uc092ZXJyaWRlcywgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFN0cmVhbVZpZGVvQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2xpZW50LCBjaGlsZHJlbjoganN4KFN0cmVhbUkxOG5Qcm92aWRlciwgeyBpMThuSW5zdGFuY2U6IGkxOG5JbnN0YW5jZSwgbGFuZ3VhZ2U6IGxhbmd1YWdlLCB0cmFuc2xhdGlvbnNPdmVycmlkZXM6IHRyYW5zbGF0aW9uc092ZXJyaWRlcywgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn07XG4vKipcbiAqXG4gKiBAcmV0dXJuc1xuICpcbiAqIEBjYXRlZ29yeSBDbGllbnQgU3RhdGVcbiAqL1xuY29uc3QgdXNlU3RyZWFtVmlkZW9DbGllbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoU3RyZWFtVmlkZW9Db250ZXh0KTtcbn07XG5cbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBnaXZlbiBvYnNlcnZhYmxlLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHVzZU9ic2VydmFibGVWYWx1ZSA9IChvYnNlcnZhYmxlJCkgPT4ge1xuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoKCkgPT4gUnhVdGlscy5nZXRDdXJyZW50VmFsdWUob2JzZXJ2YWJsZSQpKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlJC5zdWJzY3JpYmUoc2V0VmFsdWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW29ic2VydmFibGUkXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB3ZSBhcmUgdXNpbmcgUmVhY3QgTmF0aXZlXG4gKi9cbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5wcm9kdWN0Py50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGhvb2ssIHdoaWNoIHByb3ZpZGVzIHRoZSBjdXJyZW50IGNhbGwncyBzdGF0ZS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VDYWxsU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICAvLyByZXR1cm4gYW4gZW1wdHkgYW5kIHVubGlua2VkIENhbGxTdGF0ZSBvYmplY3QgaWYgdGhlcmUgaXMgbm8gY2FsbCBpbiB0aGUgcHJvdmlkZXJcbiAgICAvLyB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgaG9va3MgYWx3YXlzIHJldHVybiBhIHZhbHVlIGFuZCBtYW55IG51bGwgY2hlY2tzIGNhbiBiZSBhdm9pZGVkXG4gICAgaWYgKCFjYWxsKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnWW91IGFyZSB1c2luZyB1c2VDYWxsU3RhdGUoKSBvdXRzaWRlIGEgQ2FsbCBjb250ZXh0LiAnICtcbiAgICAgICAgICAgICdQbGVhc2Ugd3JhcCB5b3VyIGNvbXBvbmVudCBpbiA8U3RyZWFtQ2FsbCAvPiBhbmQgcHJvdmlkZSBhIFwiY2FsbFwiIGluc3RhbmNlLic7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsU3RhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGwuc3RhdGU7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgaW5mb3JtYXRpb24gd2hldGhlciB0aGUgY3VycmVudCBjYWxsIGlzIGJlaW5nIHJlY29yZGVkLiBJdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGNhbGwgaXMgYmVpbmcgcmVjb3JkZWQuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHJlY29yZGluZyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUocmVjb3JkaW5nJCk7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgaW5mb3JtYXRpb24gd2hldGhlciB0aGUgY3VycmVudCBjYWxsIGlzIGJyb2FkY2FzdGluZy5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VJc0NhbGxITFNCcm9hZGNhc3RpbmdJblByb2dyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZWdyZXNzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgY29uc3QgZWdyZXNzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKGVncmVzcyQpO1xuICAgIGlmICghZWdyZXNzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGVncmVzcy5icm9hZGNhc3Rpbmc7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgaW5mb3JtYXRpb24gd2hldGhlciB0aGUgY3VycmVudCBjYWxsIGlzIGxpdmUuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlSXNDYWxsTGl2ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGJhY2tzdGFnZSQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIGNvbnN0IGlzQmFja3N0YWdlT24gPSB1c2VPYnNlcnZhYmxlVmFsdWUoYmFja3N0YWdlJCk7XG4gICAgcmV0dXJuICFpc0JhY2tzdGFnZU9uO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiBibG9ja2VkIHVzZXJzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gKi9cbmNvbnN0IHVzZUNhbGxCbG9ja2VkVXNlcklkcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGJsb2NrZWRVc2VySWRzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShibG9ja2VkVXNlcklkcyQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdGltZXN0YW1wIHdoZW4gdGhpcyBjYWxsIHdhcyBjcmVhdGVkLlxuICovXG5jb25zdCB1c2VDYWxsQ3JlYXRlZEF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY3JlYXRlZEF0JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShjcmVhdGVkQXQkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHRpbWVzdGFtcCB3aGVuIHRoaXMgY2FsbCB3YXMgZW5kZWQuXG4gKi9cbmNvbnN0IHVzZUNhbGxFbmRlZEF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZW5kZWRBdCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoZW5kZWRBdCQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdGltZXN0YW1wIHRlbGxpbmcgd2hlbiB0aGUgY2FsbCBpcyBzY2hlZHVsZWQgdG8gc3RhcnQuXG4gKi9cbmNvbnN0IHVzZUNhbGxTdGFydHNBdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0YXJ0c0F0JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShzdGFydHNBdCQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdGltZXN0YW1wIHdoZW4gdGhpcyBjYWxsIHdhcyB1cGRhdGVkLlxuICovXG5jb25zdCB1c2VDYWxsVXBkYXRlZEF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdXBkYXRlZEF0JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZSh1cGRhdGVkQXQkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsJ3MgY3JlYXRvci5cbiAqL1xuY29uc3QgdXNlQ2FsbENyZWF0ZWRCeSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNyZWF0ZWRCeSQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY3JlYXRlZEJ5JCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWxsJ3MgY3VzdG9tIGRhdGEuXG4gKi9cbmNvbnN0IHVzZUNhbGxDdXN0b21EYXRhID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VzdG9tJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShjdXN0b20kKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGNhbGwncyBFZ3Jlc3MgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IHVzZUNhbGxFZ3Jlc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBlZ3Jlc3MkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGVncmVzcyQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY2FsbCdzIEluZ3Jlc3MgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IHVzZUNhbGxJbmdyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaW5ncmVzcyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoaW5ncmVzcyQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSBmb3IgdGhlIGN1cnJlbnQgY2FsbCBzZXNzaW9uLlxuICovXG5jb25zdCB1c2VDYWxsU2Vzc2lvbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHNlc3Npb24kIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHNlc3Npb24kKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGNhbGwncyBzZXR0aW5ncy5cbiAqL1xuY29uc3QgdXNlQ2FsbFNldHRpbmdzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc2V0dGluZ3MkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHNldHRpbmdzJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGNhbGwgaGFzIHRyYW5zY3JpYmluZyBlbmFibGVkLlxuICovXG5jb25zdCB1c2VJc0NhbGxUcmFuc2NyaWJpbmdJblByb2dyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdHJhbnNjcmliaW5nJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZSh0cmFuc2NyaWJpbmckKTtcbn07XG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgd2hvIGhhcyBtYXJrZWQgdGhpcyBjYWxsIGFzIGVuZGVkLlxuICovXG5jb25zdCB1c2VDYWxsRW5kZWRCeSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGVuZGVkQnkkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGVuZGVkQnkkKTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzXG4gKiBhIHBhcnRpY2lwYW50IGluIHRoZSBjdXJyZW50IGNhbGwgd2hpY2ggc2hhcmVzIHRoZWlyIHNjcmVlbi5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VIYXNPbmdvaW5nU2NyZWVuU2hhcmUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoYXNPbmdvaW5nU2NyZWVuU2hhcmUkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGhhc09uZ29pbmdTY3JlZW5TaGFyZSQpO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIHRoZSBsYXRlc3Qgc3RhdHMgcmVwb3J0IG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKlxuICogVGhlIGxhdGVzdCBzdGF0cyByZXBvcnQgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqIFdoZW4gc3RhdHMgZ2F0aGVyaW5nIGlzIGVuYWJsZWQsIHRoaXMgb2JzZXJ2YWJsZSB3aWxsIGVtaXQgYSBuZXcgdmFsdWVcbiAqIGF0IGEgcmVndWxhciAoY29uZmlndXJhYmxlKSBpbnRlcnZhbC5cbiAqXG4gKiBDb25zdW1lcnMgb2YgdGhpcyBvYnNlcnZhYmxlIGNhbiBpbXBsZW1lbnQgdGhlaXIgb3duIGJhdGNoaW5nIGxvZ2ljXG4gKiBpbiBjYXNlIHRoZXkgd2FudCB0byBzaG93IGhpc3RvcmljYWwgc3RhdHMgZGF0YS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VDYWxsU3RhdHNSZXBvcnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjYWxsU3RhdHNSZXBvcnQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGNhbGxTdGF0c1JlcG9ydCQpO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIHRoZSBkb21pbmFudCBzcGVha2VyIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlRG9taW5hbnRTcGVha2VyID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZG9taW5hbnRTcGVha2VyJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShkb21pbmFudFNwZWFrZXIkKTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyBhIGxpc3Qgb2YgY2FsbCBtZW1iZXJzLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxNZW1iZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbWVtYmVycyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUobWVtYmVycyQpO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHByb3ZpZGluZyB0aGUgY3VycmVudCBjYWxsaW5nIHN0YXRlIG9mIHRoZSBjYWxsLiBGb3IgZXhhbXBsZSwgYFJJTkdJTkdgIG9yIGBKT0lORURgLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxDYWxsaW5nU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjYWxsaW5nU3RhdGUkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGNhbGxpbmdTdGF0ZSQpO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHByb3ZpZGluZyB0aGUgYWN0dWFsIHN0YXJ0IHRpbWUgb2YgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAqIFVzZWZ1bCBmb3IgY2FsY3VsYXRpbmcgdGhlIGNhbGwgZHVyYXRpb24uXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ2FsbFN0YXJ0ZWRBdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0YXJ0ZWRBdCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhcnRlZEF0JCk7XG59O1xuLyoqXG4gKiBBIGhvb2sgd2hpY2ggcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYXJ0aWNpcGFudHMgdGhhdCBoYXZlIGpvaW5lZCBhbiBhY3RpdmUgY2FsbC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICpcbiAqIEBwYXJhbSBvcHRpb25zLnNvcnRCeSAtIEEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBzb3J0IHRoZSBwYXJ0aWNpcGFudHMgYnkuXG4gKiBNYWtlIHN1cmUgdG8gbWVtb2l6ZSBvdXRwdXQgb2YgdGhlIGBjb21iaW5lQ29tcGFyYXRvcnNgIGZ1bmN0aW9uXG4gKiAob3Iga2VlcCBpdCBvdXQgb2YgY29tcG9uZW50J3Mgc2NvcGUgaWYgcG9zc2libGUpIGJlZm9yZSBwYXNzaW5nIGl0IGRvd24gdG8gdGhpcyBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgdXNlUGFydGljaXBhbnRzID0gKHsgc29ydEJ5LCB9ID0ge30pID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50cyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHVzZU9ic2VydmFibGVWYWx1ZShwYXJ0aWNpcGFudHMkKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzb3J0QnkpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucGFydGljaXBhbnRzXS5zb3J0KHNvcnRCeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50cztcbiAgICB9LCBbcGFydGljaXBhbnRzLCBzb3J0QnldKTtcbn07XG4vKipcbiAqIEEgaG9vayB3aGljaCBwcm92aWRlcyBhIFN0cmVhbVZpZGVvTG9jYWxQYXJ0aWNpcGFudCBvYmplY3QuXG4gKiBJdCBzaWduYWxzIHRoYXQgSSBoYXZlIGpvaW5lZCBhIGNhbGwuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlTG9jYWxQYXJ0aWNpcGFudCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGxvY2FsUGFydGljaXBhbnQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGxvY2FsUGFydGljaXBhbnQkKTtcbn07XG4vKipcbiAqIEEgaG9vayB3aGljaCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIG90aGVyIHBhcnRpY2lwYW50cyB0aGFuIG1lIHRoYXQgaGF2ZSBqb2luZWQgYW4gYWN0aXZlIGNhbGwuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlUmVtb3RlUGFydGljaXBhbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVtb3RlUGFydGljaXBhbnRzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShyZW1vdGVQYXJ0aWNpcGFudHMkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGFwcHJveGltYXRlIHBhcnRpY2lwYW50IGNvdW50IG9mIHRoZSBhY3RpdmUgY2FsbC5cbiAqIFRoaXMgaW5jbHVkZXMgdGhlIGFub255bW91cyB1c2VycyBhcyB3ZWxsLCBhbmQgaXQgaXMgY29tcHV0ZWQgb24gdGhlIHNlcnZlci5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VQYXJ0aWNpcGFudENvdW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnRDb3VudCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUocGFydGljaXBhbnRDb3VudCQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYXBwcm94aW1hdGUgYW5vbnltb3VzIHBhcnRpY2lwYW50IGNvdW50IG9mIHRoZSBhY3RpdmUgY2FsbC5cbiAqIFRoZSByZWd1bGFyIHBhcnRpY2lwYW50cyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgY291bnQuIEl0IGlzIGNvbXB1dGVkIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlQW5vbnltb3VzUGFydGljaXBhbnRDb3VudCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGFub255bW91c1BhcnRpY2lwYW50Q291bnQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGFub255bW91c1BhcnRpY2lwYW50Q291bnQkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCB0aHVtYm5haWwgb2YgdGhlIGN1cnJlbnQgY2FsbCwgaWYgZW5hYmxlZCBpbiBzZXR0aW5ncy5cbiAqL1xuY29uc3QgdXNlQ2FsbFRodW1ibmFpbCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHRodW1ibmFpbHMkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHRodW1ibmFpbHMkKTtcbn07XG4vKipcbiAqIEEgaG9vayB3aGljaCByZXR1cm5zIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCdzIG93biBjYXBhYmlsaXRpZXMuXG4gKi9cbmNvbnN0IHVzZU93bkNhcGFiaWxpdGllcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IG93bkNhcGFiaWxpdGllcyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUob3duQ2FwYWJpbGl0aWVzJCk7XG59O1xuLyoqXG4gKiBIb29rIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCBoYXMgYWxsIHRoZSBnaXZlbiBwZXJtaXNzaW9ucy5cbiAqXG4gKiBAcGFyYW0gcGVybWlzc2lvbnMgdGhlIHBlcm1pc3Npb25zIHRvIGNoZWNrLlxuICovXG5jb25zdCB1c2VIYXNQZXJtaXNzaW9ucyA9ICguLi5wZXJtaXNzaW9ucykgPT4ge1xuICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHVzZU93bkNhcGFiaWxpdGllcygpO1xuICAgIHJldHVybiBwZXJtaXNzaW9ucy5ldmVyeSgocGVybWlzc2lvbikgPT4gY2FwYWJpbGl0aWVzPy5pbmNsdWRlcyhwZXJtaXNzaW9uKSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYW1lcmEgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FtZXJhIE1hbmFnZXIgU3RhdGVcbiAqXG4gKi9cbmNvbnN0IHVzZUNhbWVyYVN0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyBjYW1lcmEgfSA9IGNhbGw7XG4gICAgY29uc3QgZGV2aWNlcyQgPSB1c2VNZW1vKCgpID0+IGNhbWVyYS5saXN0RGV2aWNlcygpLCBbY2FtZXJhXSk7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2FtZXJhO1xuICAgIGNvbnN0IHN0YXR1cyA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5zdGF0dXMkKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuZGlyZWN0aW9uJCk7XG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUubWVkaWFTdHJlYW0kKTtcbiAgICBjb25zdCBzZWxlY3RlZERldmljZSA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5zZWxlY3RlZERldmljZSQpO1xuICAgIGNvbnN0IGRldmljZXMgPSB1c2VPYnNlcnZhYmxlVmFsdWUoZGV2aWNlcyQpO1xuICAgIGNvbnN0IGhhc0Jyb3dzZXJQZXJtaXNzaW9uID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLmhhc0Jyb3dzZXJQZXJtaXNzaW9uJCk7XG4gICAgY29uc3QgaXNNdXRlID0gc3RhdHVzICE9PSAnZW5hYmxlZCc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGlzRW5hYmxlZDogc3RhdHVzID09PSAnZW5hYmxlZCcsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbWVkaWFTdHJlYW0sXG4gICAgICAgIGRldmljZXMsXG4gICAgICAgIGhhc0Jyb3dzZXJQZXJtaXNzaW9uLFxuICAgICAgICBzZWxlY3RlZERldmljZSxcbiAgICAgICAgaXNNdXRlLFxuICAgIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaWNyb3Bob25lIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKlxuICogQGNhdGVnb3J5IE1pY3JvcGhvbmUgTWFuYWdlciBTdGF0ZVxuICovXG5jb25zdCB1c2VNaWNyb3Bob25lU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IG1pY3JvcGhvbmUgfSA9IGNhbGw7XG4gICAgY29uc3QgZGV2aWNlcyQgPSB1c2VNZW1vKCgpID0+IG1pY3JvcGhvbmUubGlzdERldmljZXMoKSwgW21pY3JvcGhvbmVdKTtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBtaWNyb3Bob25lO1xuICAgIGNvbnN0IHN0YXR1cyA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5zdGF0dXMkKTtcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5tZWRpYVN0cmVhbSQpO1xuICAgIGNvbnN0IHNlbGVjdGVkRGV2aWNlID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLnNlbGVjdGVkRGV2aWNlJCk7XG4gICAgY29uc3QgZGV2aWNlcyA9IHVzZU9ic2VydmFibGVWYWx1ZShkZXZpY2VzJCk7XG4gICAgY29uc3QgaGFzQnJvd3NlclBlcm1pc3Npb24gPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuaGFzQnJvd3NlclBlcm1pc3Npb24kKTtcbiAgICBjb25zdCBpc1NwZWFraW5nV2hpbGVNdXRlZCA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5zcGVha2luZ1doaWxlTXV0ZWQkKTtcbiAgICBjb25zdCBpc011dGUgPSBzdGF0dXMgIT09ICdlbmFibGVkJztcbiAgICByZXR1cm4ge1xuICAgICAgICBtaWNyb3Bob25lLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGlzRW5hYmxlZDogc3RhdHVzID09PSAnZW5hYmxlZCcsXG4gICAgICAgIG1lZGlhU3RyZWFtLFxuICAgICAgICBkZXZpY2VzLFxuICAgICAgICBzZWxlY3RlZERldmljZSxcbiAgICAgICAgaGFzQnJvd3NlclBlcm1pc3Npb24sXG4gICAgICAgIGlzU3BlYWtpbmdXaGlsZU11dGVkLFxuICAgICAgICBpc011dGUsXG4gICAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHNwZWFrZXIgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqXG4gKiBOb3RlOiBUaGlzIGhvb2sgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmVcbiAqL1xuY29uc3QgdXNlU3BlYWtlclN0YXRlID0gKCkgPT4ge1xuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmUuIFBsZWFzZSB2aXNpdCBodHRwczovL2dldHN0cmVhbS5pby92aWRlby9kb2NzL3JlYWN0bmF0aXZlL2NvcmUvY2FtZXJhLWFuZC1taWNyb3Bob25lLyNzcGVha2VyLW1hbmFnZW1lbnQgZm9yIG1vcmUgZGV0YWlscycpO1xuICAgIH1cbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgc3BlYWtlciB9ID0gY2FsbDtcbiAgICBjb25zdCBkZXZpY2VzJCA9IHVzZU1lbW8oKCkgPT4gc3BlYWtlci5saXN0RGV2aWNlcygpLCBbc3BlYWtlcl0pO1xuICAgIGNvbnN0IGRldmljZXMgPSB1c2VPYnNlcnZhYmxlVmFsdWUoZGV2aWNlcyQpO1xuICAgIGNvbnN0IHNlbGVjdGVkRGV2aWNlID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHNwZWFrZXIuc3RhdGUuc2VsZWN0ZWREZXZpY2UkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzcGVha2VyLFxuICAgICAgICBkZXZpY2VzLFxuICAgICAgICBzZWxlY3RlZERldmljZSxcbiAgICAgICAgaXNEZXZpY2VTZWxlY3Rpb25TdXBwb3J0ZWQ6IHNwZWFrZXIuc3RhdGUuaXNEZXZpY2VTZWxlY3Rpb25TdXBwb3J0ZWQsXG4gICAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIFNjcmVlbiBTaGFyZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBjYWxsLlxuICovXG5jb25zdCB1c2VTY3JlZW5TaGFyZVN0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyBzY3JlZW5TaGFyZSB9ID0gY2FsbDtcbiAgICBjb25zdCBzdGF0dXMgPSB1c2VPYnNlcnZhYmxlVmFsdWUoc2NyZWVuU2hhcmUuc3RhdGUuc3RhdHVzJCk7XG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSB1c2VPYnNlcnZhYmxlVmFsdWUoc2NyZWVuU2hhcmUuc3RhdGUubWVkaWFTdHJlYW0kKTtcbiAgICBjb25zdCBpc011dGUgPSBzdGF0dXMgIT09ICdlbmFibGVkJztcbiAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5TaGFyZSxcbiAgICAgICAgbWVkaWFTdHJlYW0sXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgaXNNdXRlLFxuICAgIH07XG59O1xuXG52YXIgQ2FsbFN0YXRlSG9va3MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVzZUFub255bW91c1BhcnRpY2lwYW50Q291bnQ6IHVzZUFub255bW91c1BhcnRpY2lwYW50Q291bnQsXG4gICAgdXNlQ2FsbEJsb2NrZWRVc2VySWRzOiB1c2VDYWxsQmxvY2tlZFVzZXJJZHMsXG4gICAgdXNlQ2FsbENhbGxpbmdTdGF0ZTogdXNlQ2FsbENhbGxpbmdTdGF0ZSxcbiAgICB1c2VDYWxsQ3JlYXRlZEF0OiB1c2VDYWxsQ3JlYXRlZEF0LFxuICAgIHVzZUNhbGxDcmVhdGVkQnk6IHVzZUNhbGxDcmVhdGVkQnksXG4gICAgdXNlQ2FsbEN1c3RvbURhdGE6IHVzZUNhbGxDdXN0b21EYXRhLFxuICAgIHVzZUNhbGxFZ3Jlc3M6IHVzZUNhbGxFZ3Jlc3MsXG4gICAgdXNlQ2FsbEVuZGVkQXQ6IHVzZUNhbGxFbmRlZEF0LFxuICAgIHVzZUNhbGxFbmRlZEJ5OiB1c2VDYWxsRW5kZWRCeSxcbiAgICB1c2VDYWxsSW5ncmVzczogdXNlQ2FsbEluZ3Jlc3MsXG4gICAgdXNlQ2FsbE1lbWJlcnM6IHVzZUNhbGxNZW1iZXJzLFxuICAgIHVzZUNhbGxTZXNzaW9uOiB1c2VDYWxsU2Vzc2lvbixcbiAgICB1c2VDYWxsU2V0dGluZ3M6IHVzZUNhbGxTZXR0aW5ncyxcbiAgICB1c2VDYWxsU3RhcnRlZEF0OiB1c2VDYWxsU3RhcnRlZEF0LFxuICAgIHVzZUNhbGxTdGFydHNBdDogdXNlQ2FsbFN0YXJ0c0F0LFxuICAgIHVzZUNhbGxTdGF0ZTogdXNlQ2FsbFN0YXRlLFxuICAgIHVzZUNhbGxTdGF0c1JlcG9ydDogdXNlQ2FsbFN0YXRzUmVwb3J0LFxuICAgIHVzZUNhbGxUaHVtYm5haWw6IHVzZUNhbGxUaHVtYm5haWwsXG4gICAgdXNlQ2FsbFVwZGF0ZWRBdDogdXNlQ2FsbFVwZGF0ZWRBdCxcbiAgICB1c2VDYW1lcmFTdGF0ZTogdXNlQ2FtZXJhU3RhdGUsXG4gICAgdXNlRG9taW5hbnRTcGVha2VyOiB1c2VEb21pbmFudFNwZWFrZXIsXG4gICAgdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlOiB1c2VIYXNPbmdvaW5nU2NyZWVuU2hhcmUsXG4gICAgdXNlSGFzUGVybWlzc2lvbnM6IHVzZUhhc1Blcm1pc3Npb25zLFxuICAgIHVzZUlzQ2FsbEhMU0Jyb2FkY2FzdGluZ0luUHJvZ3Jlc3M6IHVzZUlzQ2FsbEhMU0Jyb2FkY2FzdGluZ0luUHJvZ3Jlc3MsXG4gICAgdXNlSXNDYWxsTGl2ZTogdXNlSXNDYWxsTGl2ZSxcbiAgICB1c2VJc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzOiB1c2VJc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzLFxuICAgIHVzZUlzQ2FsbFRyYW5zY3JpYmluZ0luUHJvZ3Jlc3M6IHVzZUlzQ2FsbFRyYW5zY3JpYmluZ0luUHJvZ3Jlc3MsXG4gICAgdXNlTG9jYWxQYXJ0aWNpcGFudDogdXNlTG9jYWxQYXJ0aWNpcGFudCxcbiAgICB1c2VNaWNyb3Bob25lU3RhdGU6IHVzZU1pY3JvcGhvbmVTdGF0ZSxcbiAgICB1c2VPd25DYXBhYmlsaXRpZXM6IHVzZU93bkNhcGFiaWxpdGllcyxcbiAgICB1c2VQYXJ0aWNpcGFudENvdW50OiB1c2VQYXJ0aWNpcGFudENvdW50LFxuICAgIHVzZVBhcnRpY2lwYW50czogdXNlUGFydGljaXBhbnRzLFxuICAgIHVzZVJlbW90ZVBhcnRpY2lwYW50czogdXNlUmVtb3RlUGFydGljaXBhbnRzLFxuICAgIHVzZVNjcmVlblNoYXJlU3RhdGU6IHVzZVNjcmVlblNoYXJlU3RhdGUsXG4gICAgdXNlU3BlYWtlclN0YXRlOiB1c2VTcGVha2VyU3RhdGVcbn0pO1xuXG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyBhY2Nlc3MgdG8gY2xpZW50J3Mgc3RhdGUgc3RvcmUuXG4gKi9cbmNvbnN0IHVzZVN0b3JlID0gKCkgPT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHVzZVN0cmVhbVZpZGVvQ2xpZW50KCk7XG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJlYW1WaWRlb0NsaWVudCBpc24ndCBpbml0aWFsaXplZCBvciB0aGlzIGhvb2sgaXMgY2FsbGVkIG91dHNpZGUgb2YgPFN0cmVhbVZpZGVvPiBjb250ZXh0LmApO1xuICAgIH1cbiAgICByZXR1cm4gY2xpZW50LnJlYWRPbmx5U3RhdGVTdG9yZTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIG5vdGlmaWNhdGlvbnMgYWJvdXQgY3JlYXRlZCBjYWxscy5cbiAqIEluIHRoZSByaW5nIGNhbGwgc2V0dGluZ3MsIHRoZXNlIGNhbGxzIGNhbiBiZSBvdXRnb2luZyAoSSBoYXZlIGNhbGxlZCBzb21lYm9keSlcbiAqIG9yIGluY29taW5nIChzb21lYm9keSBoYXMgY2FsbGVkIG1lKS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50IFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2FsbHMkIH0gPSB1c2VTdG9yZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY2FsbHMkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGVkIHVzZXIuXG4gKlxuICogQGNhdGVnb3J5IENsaWVudCBTdGF0ZVxuICovXG5jb25zdCB1c2VDb25uZWN0ZWRVc2VyID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29ubmVjdGVkVXNlciQgfSA9IHVzZVN0b3JlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShjb25uZWN0ZWRVc2VyJCk7XG59O1xuXG4vKipcbiAqIEEgaG9vay1hbGlrZSBmdW5jdGlvbiB0aGF0IGV4cG9zZXMgYWxsIGNhbGwgc3RhdGUgaG9va3MuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ2FsbFN0YXRlSG9va3MgPSAoKSA9PiBDYWxsU3RhdGVIb29rcztcblxuY29uc3QgUmVzdHJpY3RlZCA9ICh7IGNhblJlcXVlc3RPbmx5LCBoYXNQZXJtaXNzaW9uc09ubHksIHJlcXVpcmVkR3JhbnRzLCByZXF1aXJlQWxsID0gdHJ1ZSwgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlQ2FsbFNldHRpbmdzLCB1c2VPd25DYXBhYmlsaXRpZXMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3Qgb3duQ2FwYWJpbGl0aWVzID0gdXNlT3duQ2FwYWJpbGl0aWVzKCk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB1c2VDYWxsU2V0dGluZ3MoKTtcbiAgICBjb25zdCBoYXNQZXJtaXNzaW9ucyA9IHJlcXVpcmVkR3JhbnRzW3JlcXVpcmVBbGwgPyAnZXZlcnknIDogJ3NvbWUnXSgoY2FwYWJpbGl0eSkgPT4gb3duQ2FwYWJpbGl0aWVzPy5pbmNsdWRlcyhjYXBhYmlsaXR5KSk7XG4gICAgaWYgKGhhc1Blcm1pc3Npb25zT25seSlcbiAgICAgICAgcmV0dXJuIGhhc1Blcm1pc3Npb25zID8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSA6IG51bGw7XG4gICAgY29uc3QgY2FuUmVxdWVzdCA9IHJlcXVpcmVkR3JhbnRzLnNvbWUoKGNhcGFiaWxpdHkpID0+IGNhbGw/LnBlcm1pc3Npb25zQ29udGV4dC5jYW5SZXF1ZXN0KGNhcGFiaWxpdHksIHNldHRpbmdzKSk7XG4gICAgaWYgKGNhblJlcXVlc3RPbmx5KVxuICAgICAgICByZXR1cm4gY2FuUmVxdWVzdCA/IGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkgOiBudWxsO1xuICAgIGlmIChoYXNQZXJtaXNzaW9ucyB8fCBjYW5SZXF1ZXN0KVxuICAgICAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCB7IERFRkFVTFRfTEFOR1VBR0UsIERFRkFVTFRfTkFNRVNQQUNFLCBSZXN0cmljdGVkLCBTdHJlYW1DYWxsUHJvdmlkZXIsIFN0cmVhbUkxOG4sIFN0cmVhbUkxOG5Qcm92aWRlciwgU3RyZWFtVmlkZW9Qcm92aWRlciwgZGVmYXVsdFRyYW5zbGF0aW9uRnVuY3Rpb24sIG1hcFRvUmVnaXN0cnksIHVzZUNhbGwsIHVzZUNhbGxTdGF0ZUhvb2tzLCB1c2VDYWxscywgdXNlQ29ubmVjdGVkVXNlciwgdXNlQ3JlYXRlSTE4biwgdXNlSTE4biwgdXNlU3RvcmUsIHVzZVN0cmVhbVZpZGVvQ2xpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-react-sdk/dist/index.es.js":
/*!******************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-sdk/dist/index.es.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AcceptCallButton: () => (/* binding */ AcceptCallButton),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AudioSettingsDefaultDeviceEnum),\n/* harmony export */   AudioSettingsRequestDefaultDeviceEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   Avatar: () => (/* binding */ Avatar),\n/* harmony export */   AvatarFallback: () => (/* binding */ AvatarFallback),\n/* harmony export */   AxiosError: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AxiosError),\n/* harmony export */   BackgroundFiltersProvider: () => (/* binding */ BackgroundFiltersProvider),\n/* harmony export */   BaseVideo: () => (/* binding */ BaseVideo),\n/* harmony export */   Browsers: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers),\n/* harmony export */   Call: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Call),\n/* harmony export */   CallControls: () => (/* binding */ CallControls),\n/* harmony export */   CallParticipantListing: () => (/* binding */ CallParticipantListing),\n/* harmony export */   CallParticipantListingItem: () => (/* binding */ CallParticipantListingItem),\n/* harmony export */   CallParticipantsList: () => (/* binding */ CallParticipantsList),\n/* harmony export */   CallPreview: () => (/* binding */ CallPreview),\n/* harmony export */   CallRecordingList: () => (/* binding */ CallRecordingList),\n/* harmony export */   CallRecordingListHeader: () => (/* binding */ CallRecordingListHeader),\n/* harmony export */   CallRecordingListItem: () => (/* binding */ CallRecordingListItem),\n/* harmony export */   CallState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallState),\n/* harmony export */   CallStats: () => (/* binding */ CallStats),\n/* harmony export */   CallStatsButton: () => (/* binding */ CallStatsButton),\n/* harmony export */   CallStatsLatencyChart: () => (/* binding */ CallStatsLatencyChart),\n/* harmony export */   CallType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallType),\n/* harmony export */   CallTypes: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallTypes),\n/* harmony export */   CallingState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState),\n/* harmony export */   CameraManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CameraManager),\n/* harmony export */   CameraManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CameraManagerState),\n/* harmony export */   CancelCallButton: () => (/* binding */ CancelCallButton),\n/* harmony export */   CancelCallConfirmButton: () => (/* binding */ CancelCallConfirmButton),\n/* harmony export */   CompositeButton: () => (/* binding */ CompositeButton),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CreateDeviceRequestPushProviderEnum),\n/* harmony export */   DEFAULT_LANGUAGE: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LANGUAGE),\n/* harmony export */   DEFAULT_NAMESPACE: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_NAMESPACE),\n/* harmony export */   DebounceType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.DebounceType),\n/* harmony export */   DefaultParticipantViewUI: () => (/* binding */ DefaultParticipantViewUI),\n/* harmony export */   DefaultReactionsMenu: () => (/* binding */ DefaultReactionsMenu),\n/* harmony export */   DefaultScreenShareOverlay: () => (/* binding */ DefaultScreenShareOverlay),\n/* harmony export */   DefaultVideoPlaceholder: () => (/* binding */ DefaultVideoPlaceholder),\n/* harmony export */   DeviceSelector: () => (/* binding */ DeviceSelector),\n/* harmony export */   DeviceSelectorAudioInput: () => (/* binding */ DeviceSelectorAudioInput),\n/* harmony export */   DeviceSelectorAudioOutput: () => (/* binding */ DeviceSelectorAudioOutput),\n/* harmony export */   DeviceSelectorVideo: () => (/* binding */ DeviceSelectorVideo),\n/* harmony export */   DeviceSettings: () => (/* binding */ DeviceSettings),\n/* harmony export */   DropDownSelect: () => (/* binding */ DropDownSelect),\n/* harmony export */   DropDownSelectOption: () => (/* binding */ DropDownSelectOption),\n/* harmony export */   DynascaleManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.DynascaleManager),\n/* harmony export */   EmptyCallRecordingListing: () => (/* binding */ EmptyCallRecordingListing),\n/* harmony export */   ErrorFromResponse: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ErrorFromResponse),\n/* harmony export */   GenericMenu: () => (/* binding */ GenericMenu),\n/* harmony export */   GenericMenuButtonItem: () => (/* binding */ GenericMenuButtonItem),\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   IconButton: () => (/* binding */ IconButton),\n/* harmony export */   InputMediaDeviceManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.InputMediaDeviceManager),\n/* harmony export */   InputMediaDeviceManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.InputMediaDeviceManagerState),\n/* harmony export */   LivestreamLayout: () => (/* binding */ LivestreamLayout),\n/* harmony export */   LoadingCallRecordingListing: () => (/* binding */ LoadingCallRecordingListing),\n/* harmony export */   LoadingIndicator: () => (/* binding */ LoadingIndicator),\n/* harmony export */   MenuToggle: () => (/* binding */ MenuToggle),\n/* harmony export */   MenuVisualType: () => (/* binding */ MenuVisualType),\n/* harmony export */   MicrophoneManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.MicrophoneManager),\n/* harmony export */   MicrophoneManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.MicrophoneManagerState),\n/* harmony export */   Notification: () => (/* binding */ Notification),\n/* harmony export */   OwnCapability: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability),\n/* harmony export */   PaginatedGridLayout: () => (/* binding */ PaginatedGridLayout),\n/* harmony export */   ParticipantActionsContextMenu: () => (/* binding */ ParticipantActionsContextMenu),\n/* harmony export */   ParticipantDetails: () => (/* binding */ ParticipantDetails),\n/* harmony export */   ParticipantView: () => (/* binding */ ParticipantView),\n/* harmony export */   ParticipantViewContext: () => (/* binding */ ParticipantViewContext),\n/* harmony export */   ParticipantsAudio: () => (/* binding */ ParticipantsAudio),\n/* harmony export */   PermissionNotification: () => (/* binding */ PermissionNotification),\n/* harmony export */   PermissionRequestList: () => (/* binding */ PermissionRequestList),\n/* harmony export */   PermissionRequests: () => (/* binding */ PermissionRequests),\n/* harmony export */   ReactionsButton: () => (/* binding */ ReactionsButton),\n/* harmony export */   RecordCallButton: () => (/* binding */ RecordCallButton),\n/* harmony export */   RecordCallConfirmationButton: () => (/* binding */ RecordCallConfirmationButton),\n/* harmony export */   RecordSettingsRequestModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RecordSettingsRequestModeEnum),\n/* harmony export */   RecordSettingsRequestQualityEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RecordSettingsRequestQualityEnum),\n/* harmony export */   RecordingInProgressNotification: () => (/* binding */ RecordingInProgressNotification),\n/* harmony export */   Restricted: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted),\n/* harmony export */   RingingCall: () => (/* binding */ RingingCall),\n/* harmony export */   RingingCallControls: () => (/* binding */ RingingCallControls),\n/* harmony export */   RxUtils: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RxUtils),\n/* harmony export */   ScreenShareButton: () => (/* binding */ ScreenShareButton),\n/* harmony export */   ScreenShareManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ScreenShareManager),\n/* harmony export */   ScreenShareState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ScreenShareState),\n/* harmony export */   SearchInput: () => (/* binding */ SearchInput),\n/* harmony export */   SearchResults: () => (/* binding */ SearchResults),\n/* harmony export */   SfuEvents: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuEvents),\n/* harmony export */   SfuModels: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels),\n/* harmony export */   SpeakerLayout: () => (/* binding */ SpeakerLayout),\n/* harmony export */   SpeakerManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SpeakerManager),\n/* harmony export */   SpeakerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SpeakerState),\n/* harmony export */   SpeakingWhileMutedNotification: () => (/* binding */ SpeakingWhileMutedNotification),\n/* harmony export */   SpeechIndicator: () => (/* binding */ SpeechIndicator),\n/* harmony export */   StatCard: () => (/* binding */ StatCard),\n/* harmony export */   StatCardExplanation: () => (/* binding */ StatCardExplanation),\n/* harmony export */   StatsTag: () => (/* binding */ StatsTag),\n/* harmony export */   Statuses: () => (/* binding */ Statuses),\n/* harmony export */   StreamCall: () => (/* binding */ StreamCall),\n/* harmony export */   StreamCallProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamCallProvider),\n/* harmony export */   StreamI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamI18n),\n/* harmony export */   StreamI18nProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamI18nProvider),\n/* harmony export */   StreamSfuClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamSfuClient),\n/* harmony export */   StreamTheme: () => (/* binding */ StreamTheme),\n/* harmony export */   StreamVideo: () => (/* binding */ StreamVideo),\n/* harmony export */   StreamVideoClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoClient),\n/* harmony export */   StreamVideoProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamVideoProvider),\n/* harmony export */   StreamVideoReadOnlyStateStore: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoReadOnlyStateStore),\n/* harmony export */   StreamVideoWriteableStateStore: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoWriteableStateStore),\n/* harmony export */   TextButton: () => (/* binding */ TextButton),\n/* harmony export */   ToggleAudioOutputButton: () => (/* binding */ ToggleAudioOutputButton),\n/* harmony export */   ToggleAudioPreviewButton: () => (/* binding */ ToggleAudioPreviewButton),\n/* harmony export */   ToggleAudioPublishingButton: () => (/* binding */ ToggleAudioPublishingButton),\n/* harmony export */   ToggleVideoPreviewButton: () => (/* binding */ ToggleVideoPreviewButton),\n/* harmony export */   ToggleVideoPublishingButton: () => (/* binding */ ToggleVideoPublishingButton),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.TranscriptionSettingsModeEnum),\n/* harmony export */   TranscriptionSettingsRequestModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.TranscriptionSettingsRequestModeEnum),\n/* harmony export */   Video: () => (/* binding */ Video$1),\n/* harmony export */   VideoPreview: () => (/* binding */ VideoPreview),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoSettingsRequestCameraFacingEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VideoSettingsRequestCameraFacingEnum),\n/* harmony export */   ViewportTracker: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ViewportTracker),\n/* harmony export */   VisibilityState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VisibilityState),\n/* harmony export */   WithTooltip: () => (/* binding */ WithTooltip),\n/* harmony export */   checkIfAudioOutputChangeSupported: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.checkIfAudioOutputChangeSupported),\n/* harmony export */   combineComparators: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.combineComparators),\n/* harmony export */   conditional: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.conditional),\n/* harmony export */   createSoundDetector: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.createSoundDetector),\n/* harmony export */   defaultReactions: () => (/* binding */ defaultReactions),\n/* harmony export */   defaultSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.defaultSortPreset),\n/* harmony export */   defaultTranslationFunction: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.defaultTranslationFunction),\n/* harmony export */   descending: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.descending),\n/* harmony export */   deviceIds$: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.deviceIds$),\n/* harmony export */   disposeOfMediaStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.disposeOfMediaStream),\n/* harmony export */   dominantSpeaker: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.dominantSpeaker),\n/* harmony export */   getAudioDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioDevices),\n/* harmony export */   getAudioOutputDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioOutputDevices),\n/* harmony export */   getAudioStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioStream),\n/* harmony export */   getClientDetails: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getClientDetails),\n/* harmony export */   getDeviceInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getDeviceInfo),\n/* harmony export */   getLogger: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getLogger),\n/* harmony export */   getOSInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getOSInfo),\n/* harmony export */   getScreenShareStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getScreenShareStream),\n/* harmony export */   getSdkInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getSdkInfo),\n/* harmony export */   getVideoDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getVideoDevices),\n/* harmony export */   getVideoStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getVideoStream),\n/* harmony export */   getWebRTCInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getWebRTCInfo),\n/* harmony export */   livestreamOrAudioRoomSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.livestreamOrAudioRoomSortPreset),\n/* harmony export */   logLevels: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.logLevels),\n/* harmony export */   logToConsole: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.logToConsole),\n/* harmony export */   mapToRegistry: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.mapToRegistry),\n/* harmony export */   name: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.name),\n/* harmony export */   noopComparator: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.noopComparator),\n/* harmony export */   paginatedLayoutSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.paginatedLayoutSortPreset),\n/* harmony export */   pinned: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.pinned),\n/* harmony export */   publishingAudio: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.publishingAudio),\n/* harmony export */   publishingVideo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.publishingVideo),\n/* harmony export */   reactionType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.reactionType),\n/* harmony export */   role: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.role),\n/* harmony export */   screenSharing: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.screenSharing),\n/* harmony export */   setDeviceInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setDeviceInfo),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setLogLevel),\n/* harmony export */   setLogger: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setLogger),\n/* harmony export */   setOSInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setOSInfo),\n/* harmony export */   setSdkInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setSdkInfo),\n/* harmony export */   setWebRTCInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setWebRTCInfo),\n/* harmony export */   speakerLayoutSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speakerLayoutSortPreset),\n/* harmony export */   speaking: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speaking),\n/* harmony export */   translations: () => (/* binding */ translations),\n/* harmony export */   useBackgroundFilters: () => (/* binding */ useBackgroundFilters),\n/* harmony export */   useCall: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall),\n/* harmony export */   useCallStateHooks: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks),\n/* harmony export */   useCalls: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCalls),\n/* harmony export */   useConnectedUser: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser),\n/* harmony export */   useCreateI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCreateI18n),\n/* harmony export */   useHorizontalScrollPosition: () => (/* binding */ useHorizontalScrollPosition),\n/* harmony export */   useI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n),\n/* harmony export */   useMenuContext: () => (/* binding */ useMenuContext),\n/* harmony export */   useParticipantViewContext: () => (/* binding */ useParticipantViewContext),\n/* harmony export */   usePersistedDevicePreferences: () => (/* binding */ usePersistedDevicePreferences),\n/* harmony export */   useRequestPermission: () => (/* binding */ useRequestPermission),\n/* harmony export */   useStore: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useStore),\n/* harmony export */   useStreamVideoClient: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useStreamVideoClient),\n/* harmony export */   useTrackElementVisibility: () => (/* binding */ useTrackElementVisibility),\n/* harmony export */   useVerticalScrollPosition: () => (/* binding */ useVerticalScrollPosition)\n/* harmony export */ });\n/* harmony import */ var _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stream-io/video-client */ \"(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\");\n/* harmony import */ var _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stream-io/video-react-bindings */ \"(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stream-io/video-filters-web */ \"(ssr)/./node_modules/@stream-io/video-filters-web/dist/index.es.js\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-chartjs-2 */ \"(ssr)/./node_modules/react-chartjs-2/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst Audio = ({ participant, trackType = 'audioTrack', ...rest }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [audioElement, setAudioElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const { userId, sessionId } = participant;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !audioElement)\n            return;\n        const cleanup = call.bindAudioElement(audioElement, sessionId, trackType);\n        return () => {\n            cleanup?.();\n        };\n    }, [call, sessionId, audioElement, trackType]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"audio\", { autoPlay: true, ...rest, ref: setAudioElement, \"data-user-id\": userId, \"data-session-id\": sessionId, \"data-track-type\": trackType }));\n};\n\nconst ParticipantsAudio = (props) => {\n    const { participants, audioProps } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: participants.map((participant) => {\n            if (participant.isLocalParticipant)\n                return null;\n            const { publishedTracks, audioStream, screenShareAudioStream, sessionId, } = participant;\n            const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n            const audioTrackElement = hasAudio && audioStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { ...audioProps, trackType: \"audioTrack\", participant: participant }));\n            const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n            const screenShareAudioTrackElement = hasScreenShareAudio &&\n                screenShareAudioStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { ...audioProps, trackType: \"screenShareAudioTrack\", participant: participant }));\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId));\n        }) }));\n};\n\nconst ParticipantViewContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(undefined);\nconst useParticipantViewContext = () => (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ParticipantViewContext);\n\nconst Avatar = ({ imageSrc, name, style, className, ...rest }) => {\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(!imageSrc || error) && name && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(AvatarFallback, { className: className, style: style, names: [name] })), imageSrc && !error && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { onError: () => setError(true), alt: \"avatar\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__avatar', className), src: imageSrc, style: style, ...rest }))] }));\n};\nconst AvatarFallback = ({ className, names, style, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__avatar--initials-fallback', className), style: style, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { children: [names[0][0], names[1]?.[0]] }) }));\n};\n\n/**\n * The context for the background filters.\n */\nconst BackgroundFiltersContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(undefined);\n/**\n * A hook to access the background filters context API.\n */\nconst useBackgroundFilters = () => {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(BackgroundFiltersContext);\n    if (!context) {\n        throw new Error('useBackgroundFilters must be used within a BackgroundFiltersProvider');\n    }\n    return context;\n};\n/**\n * A provider component that enables the use of background filters in your app.\n *\n * Please make sure you have the `@stream-io/video-filters-web` package installed\n * in your project before using this component.\n */\nconst BackgroundFiltersProvider = (props) => {\n    const { children, isBlurringEnabled = true, backgroundImages = [], backgroundFilter: bgFilterFromProps = undefined, backgroundImage: bgImageFromProps = undefined, backgroundBlurLevel: bgBlurLevelFromProps = 'high', tfFilePath, modelFilePath, basePath, } = props;\n    const [backgroundFilter, setBackgroundFilter] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(bgFilterFromProps);\n    const [backgroundImage, setBackgroundImage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(bgImageFromProps);\n    const [backgroundBlurLevel, setBackgroundBlurLevel] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(bgBlurLevelFromProps);\n    const applyBackgroundImageFilter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((imageUrl) => {\n        setBackgroundFilter('image');\n        setBackgroundImage(imageUrl);\n    }, []);\n    const applyBackgroundBlurFilter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((blurLevel = 'high') => {\n        setBackgroundFilter('blur');\n        setBackgroundBlurLevel(blurLevel);\n    }, []);\n    const disableBackgroundFilter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n        setBackgroundFilter(undefined);\n        setBackgroundImage(undefined);\n        setBackgroundBlurLevel('high');\n    }, []);\n    const [isSupported, setIsSupported] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        (0,_stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__.isPlatformSupported)().then(setIsSupported);\n    }, []);\n    const [tfLite, setTfLite] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // don't try to load TFLite if the platform is not supported\n        if (!isSupported)\n            return;\n        (0,_stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__.loadTFLite)({ basePath, modelFilePath, tfFilePath })\n            .then(setTfLite)\n            .catch((err) => console.error('Failed to load TFLite', err));\n    }, [basePath, isSupported, modelFilePath, tfFilePath]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(BackgroundFiltersContext.Provider, { value: {\n            isSupported,\n            isReady: !!tfLite,\n            backgroundImage,\n            backgroundBlurLevel,\n            backgroundFilter,\n            disableBackgroundFilter,\n            applyBackgroundBlurFilter,\n            applyBackgroundImageFilter,\n            backgroundImages,\n            isBlurringEnabled,\n            tfFilePath,\n            modelFilePath,\n            basePath,\n        }, children: [children, tfLite && backgroundFilter && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BackgroundFilters, { tfLite: tfLite })] }));\n};\nconst BackgroundFilters = (props) => {\n    const { tfLite } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { backgroundImage, backgroundFilter } = useBackgroundFilters();\n    const [videoRef, setVideoRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [bgImageRef, setBgImageRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [canvasRef, setCanvasRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(1920);\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(1080);\n    const resolveFilterRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    const [mediaStream, setMediaStream] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    const registerFilterRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(Promise.resolve(async () => { }));\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !backgroundFilter)\n            return;\n        registerFilterRef.current = registerFilterRef.current.then(() => call.camera.registerFilter(async (ms) => {\n            return new Promise((resolve) => {\n                setMediaStream(ms);\n                resolveFilterRef.current = resolve;\n            });\n        }));\n        return () => {\n            registerFilterRef.current\n                .then((unregister) => unregister())\n                .then(() => setMediaStream(undefined))\n                .catch((err) => console.error('Failed to unregister filter', err));\n        };\n    }, [backgroundFilter, call]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!mediaStream || !videoRef || !canvasRef)\n            return;\n        const handleOnPlay = () => {\n            const [track] = mediaStream.getVideoTracks();\n            if (track) {\n                const { width: w = 0, height: h = 0 } = track.getSettings();\n                setWidth(w);\n                setHeight(h);\n            }\n            const resolveFilter = resolveFilterRef.current;\n            if (!resolveFilter)\n                return;\n            const filter = canvasRef.captureStream();\n            resolveFilter(filter);\n        };\n        videoRef.addEventListener('play', handleOnPlay);\n        videoRef.srcObject = mediaStream;\n        videoRef.play().catch((err) => console.error('Failed to play video', err));\n        return () => {\n            videoRef.removeEventListener('play', handleOnPlay);\n            videoRef.srcObject = null;\n        };\n    }, [canvasRef, mediaStream, videoRef]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__background-filters\", style: {\n            width: `${width}px`,\n            height: `${height}px`,\n        }, children: [mediaStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderPipeline, { tfLite: tfLite, videoRef: videoRef, canvasRef: canvasRef, backgroundImageRef: bgImageRef })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__background-filters__video', height > width && 'str-video__background-filters__video--tall'), ref: setVideoRef, autoPlay: true, playsInline: true, controls: false, width: width, height: height, muted: true, loop: true }), backgroundImage && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { className: \"str-video__background-filters__background-image\", alt: \"Background\", ref: setBgImageRef, src: backgroundImage, width: width, height: height }, backgroundImage)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", { className: \"str-video__background-filters__target-canvas\", width: width, height: height, ref: setCanvasRef }, `key-${width}${height}`)] }));\n};\nconst RenderPipeline = (props) => {\n    const { tfLite, videoRef, canvasRef, backgroundImageRef } = props;\n    const { backgroundFilter, backgroundBlurLevel } = useBackgroundFilters();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoRef || !canvasRef || !backgroundFilter)\n            return;\n        if (backgroundFilter === 'image' && !backgroundImageRef)\n            return;\n        const renderer = (0,_stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__.createRenderer)(tfLite, videoRef, canvasRef, {\n            backgroundFilter,\n            backgroundImage: backgroundImageRef ?? undefined,\n            backgroundBlurLevel,\n        });\n        return () => {\n            renderer.dispose();\n        };\n    }, [\n        backgroundBlurLevel,\n        backgroundFilter,\n        backgroundImageRef,\n        canvasRef,\n        tfLite,\n        videoRef,\n    ]);\n    return null;\n};\n\nconst useFloatingUIPreset = ({ placement, strategy, offset: offsetInPx = 10, }) => {\n    const { refs, x, y, update, elements: { domReference, floating }, } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useFloating)({\n        placement,\n        strategy,\n        middleware: [\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.offset)(offsetInPx),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.shift)(),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.flip)(),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.size)({\n                padding: 10,\n                apply: ({ availableHeight, elements }) => {\n                    Object.assign(elements.floating.style, {\n                        maxHeight: `${availableHeight}px`,\n                    });\n                },\n            }),\n        ],\n    });\n    // handle window resizing\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!domReference || !floating)\n            return;\n        const cleanup = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.autoUpdate)(domReference, floating, update);\n        return () => cleanup();\n    }, [domReference, floating, update]);\n    return { refs, x, y, domReference, floating, strategy };\n};\n\n/**\n * This hook will persist the device settings to local storage.\n *\n * @param key the key to use for local storage.\n */\nconst usePersistDevicePreferences = (key) => {\n    const { useMicrophoneState, useCameraState, useSpeakerState, useCallSettings, } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const mic = useMicrophoneState();\n    const camera = useCameraState();\n    const speaker = useSpeakerState();\n    const settings = useCallSettings();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !settings)\n            return;\n        if (call.state.callingState === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.LEFT)\n            return;\n        try {\n            const hasPreferences = !!window.localStorage.getItem(key);\n            const { audio, video } = settings;\n            const defaultDevice = 'default';\n            const preferences = {\n                mic: {\n                    selectedDeviceId: mic.selectedDevice || defaultDevice,\n                    muted: hasPreferences ? mic.isMute : !audio.mic_default_on,\n                },\n                camera: {\n                    selectedDeviceId: camera.selectedDevice || defaultDevice,\n                    muted: hasPreferences ? camera.isMute : !video.camera_default_on,\n                },\n                speaker: {\n                    selectedDeviceId: speaker.selectedDevice || defaultDevice,\n                    muted: false,\n                },\n            };\n            window.localStorage.setItem(key, JSON.stringify(preferences));\n        }\n        catch (err) {\n            console.warn('Failed to save device preferences', err);\n        }\n    }, [\n        call,\n        camera.isMute,\n        camera.selectedDevice,\n        key,\n        mic.isMute,\n        mic.selectedDevice,\n        settings,\n        speaker.selectedDevice,\n    ]);\n};\n/**\n * This hook will apply the device settings from local storage.\n *\n * @param key the key to use for local storage.\n */\nconst useApplyDevicePreferences = (key) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const settings = useCallSettings();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !settings)\n            return;\n        const apply = async () => {\n            const initMic = async (setting) => {\n                await call.microphone.select(setting.selectedDeviceId);\n                if (setting.muted) {\n                    await call.microphone.disable();\n                }\n                else {\n                    await call.microphone.enable();\n                }\n            };\n            const initCamera = async (setting) => {\n                await call.camera.select(setting.selectedDeviceId);\n                if (setting.muted) {\n                    await call.camera.disable();\n                }\n                else {\n                    await call.camera.enable();\n                }\n            };\n            const initSpeaker = (setting) => {\n                call.speaker.select(setting.selectedDeviceId);\n            };\n            let preferences = null;\n            try {\n                preferences = JSON.parse(window.localStorage.getItem(key));\n            }\n            catch (err) {\n                console.warn('Failed to load device preferences', err);\n            }\n            if (preferences) {\n                await initMic(preferences.mic);\n                await initCamera(preferences.camera);\n                initSpeaker(preferences.speaker);\n            }\n            else {\n                const { audio, video } = settings;\n                if (audio.mic_default_on)\n                    await call.microphone.enable();\n                if (video.camera_default_on)\n                    await call.camera.enable();\n            }\n        };\n        apply().catch((err) => {\n            console.warn('Failed to apply device preferences', err);\n        });\n    }, [call, key, settings]);\n};\n/**\n * This hook will apply and persist the device preferences from local storage.\n *\n * @param key the key to use for local storage.\n */\nconst usePersistedDevicePreferences = (key = '@stream-io/device-preferences') => {\n    useApplyDevicePreferences(key);\n    usePersistDevicePreferences(key);\n};\n\nconst SCROLL_THRESHOLD = 10;\n/**\n * Hook which observes element's scroll position and returns text value based on the\n * position of the scrollbar (`top`, `bottom`, `between` and `null` if no scrollbar is available)\n */\nconst useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {\n    const [scrollPosition, setScrollPosition] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!scrollElement)\n            return;\n        const scrollHandler = () => {\n            const element = scrollElement;\n            const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;\n            if (!hasVerticalScrollbar)\n                return setScrollPosition(null);\n            const isAtTheTop = element.scrollTop <= threshold;\n            if (isAtTheTop)\n                return setScrollPosition('top');\n            const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;\n            if (isAtTheBottom)\n                return setScrollPosition('bottom');\n            setScrollPosition('between');\n        };\n        const resizeObserver = new ResizeObserver(scrollHandler);\n        resizeObserver.observe(scrollElement);\n        scrollElement.addEventListener('scroll', scrollHandler);\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollHandler);\n            resizeObserver.disconnect();\n        };\n    }, [scrollElement, threshold]);\n    return scrollPosition;\n};\nconst useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {\n    const [scrollPosition, setScrollPosition] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!scrollElement)\n            return;\n        const scrollHandler = () => {\n            const element = scrollElement;\n            const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;\n            if (!hasHorizontalScrollbar)\n                return setScrollPosition(null);\n            const isAtTheStart = element.scrollLeft <= threshold;\n            if (isAtTheStart)\n                return setScrollPosition('start');\n            const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;\n            if (isAtTheEnd)\n                return setScrollPosition('end');\n            setScrollPosition('between');\n        };\n        const resizeObserver = new ResizeObserver(scrollHandler);\n        resizeObserver.observe(scrollElement);\n        scrollElement.addEventListener('scroll', scrollHandler);\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollHandler);\n            resizeObserver.disconnect();\n        };\n    }, [scrollElement, threshold]);\n    return scrollPosition;\n};\n\nconst useToggleCallRecording = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useIsCallRecordingInProgress } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isCallRecordingInProgress = useIsCallRecordingInProgress();\n    const [isAwaitingResponse, setIsAwaitingResponse] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    // TODO: add permissions\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // we wait until call.recording_started/stopped event to flips the\n        // `isCallRecordingInProgress` state variable.\n        // Once the flip happens, we remove the loading indicator\n        setIsAwaitingResponse((isAwaiting) => {\n            if (isAwaiting)\n                return false;\n            return isAwaiting;\n        });\n    }, [isCallRecordingInProgress]);\n    const toggleCallRecording = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n        try {\n            setIsAwaitingResponse(true);\n            if (isCallRecordingInProgress) {\n                await call?.stopRecording();\n            }\n            else {\n                await call?.startRecording();\n            }\n        }\n        catch (e) {\n            console.error(`Failed start recording`, e);\n        }\n    }, [call, isCallRecordingInProgress]);\n    return { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress };\n};\n\nconst useRequestPermission = (permission) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const hasPermission = useHasPermissions(permission);\n    const [isAwaitingPermission, setIsAwaitingPermission] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false); // TODO: load with possibly pending state\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        const reset = () => setIsAwaitingPermission(false);\n        if (hasPermission)\n            reset();\n    }, [hasPermission]);\n    const requestPermission = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n        if (hasPermission)\n            return true;\n        const canRequestPermission = !!call?.permissionsContext.canRequest(permission);\n        if (isAwaitingPermission || !canRequestPermission)\n            return false;\n        setIsAwaitingPermission(true);\n        try {\n            await call?.requestPermissions({\n                permissions: [permission],\n            });\n        }\n        catch (error) {\n            setIsAwaitingPermission(false);\n            throw new Error(`requestPermission failed: ${error}`);\n        }\n        return false;\n    }, [call, hasPermission, isAwaitingPermission, permission]);\n    return {\n        requestPermission,\n        hasPermission,\n        canRequestPermission: !!call?.permissionsContext.canRequest(permission),\n        isAwaitingPermission,\n    };\n};\n\nvar MenuVisualType;\n(function (MenuVisualType) {\n    MenuVisualType[\"PORTAL\"] = \"portal\";\n    MenuVisualType[\"MENU\"] = \"menu\";\n})(MenuVisualType || (MenuVisualType = {}));\n/**\n * Used to provide utility APIs to the components rendered inside the portal.\n */\nconst MenuContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\n/**\n * Access to the closes MenuContext.\n */\nconst useMenuContext = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(MenuContext);\n};\nconst MenuPortal = ({ children, refs, }) => {\n    const portalId = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => `str-video-portal-${Math.random().toString(36).substring(2, 9)}`, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { id: portalId, className: \"str-video__portal\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingOverlay, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingPortal, { id: portalId, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__portal-content\", ref: refs.setFloating, children: children }) }) })] }));\n};\nconst MenuToggle = ({ ToggleButton, placement = 'top-start', strategy = 'absolute', offset, visualType = MenuVisualType.MENU, children, }) => {\n    const [menuShown, setMenuShown] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const { floating, domReference, refs, x, y } = useFloatingUIPreset({\n        placement,\n        strategy,\n        offset,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        const handleClick = (event) => {\n            if (!floating && domReference?.contains(event.target)) {\n                setMenuShown(true);\n            }\n            else if (floating && !floating?.contains(event.target)) {\n                setMenuShown(false);\n            }\n        };\n        const handleKeyDown = (event) => {\n            if (event.key.toLowerCase() === 'escape' &&\n                !event.altKey &&\n                !event.ctrlKey) {\n                setMenuShown(false);\n            }\n        };\n        document?.addEventListener('click', handleClick, { capture: true });\n        document?.addEventListener('keydown', handleKeyDown);\n        return () => {\n            document?.removeEventListener('click', handleClick, { capture: true });\n            document?.removeEventListener('keydown', handleKeyDown);\n        };\n    }, [floating, domReference]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [menuShown && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuPortal, { refs: refs, children: children })) : visualType === MenuVisualType.MENU ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__menu-container\", ref: refs.setFloating, style: {\n                        position: strategy,\n                        top: y ?? 0,\n                        left: x ?? 0,\n                        overflowY: 'auto',\n                    }, children: children })) : null })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleButton, { menuShown: menuShown, ref: refs.setReference })] }));\n};\n\nconst GenericMenu = ({ children, onItemClick, }) => {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__generic-menu\", ref: ref, onClick: (e) => {\n            if (onItemClick &&\n                e.target !== ref.current &&\n                ref.current?.contains(e.target)) {\n                onItemClick(e);\n            }\n        }, children: children }));\n};\nconst GenericMenuButtonItem = ({ children, ...rest }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"li\", { className: \"str-video__generic-menu--item\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { ...rest, children: children }) }));\n};\n\nconst Icon = ({ className, icon }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__icon', icon && `str-video__icon--${icon}`, className) }));\n\nconst IconButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function IconButton(props, ref) {\n    const { icon, enabled, variant, onClick, className, ...rest } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-controls__button', className, {\n            [`str-video__call-controls__button--variant-${variant}`]: variant,\n            'str-video__call-controls__button--enabled': enabled,\n        }), onClick: (e) => {\n            e.preventDefault();\n            onClick?.(e);\n        }, ref: ref, ...rest, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: icon }) }));\n});\n\nconst isComponentType = (elementOrComponent) => {\n    return elementOrComponent === null\n        ? false\n        : !(0,react__WEBPACK_IMPORTED_MODULE_3__.isValidElement)(elementOrComponent);\n};\n\nconst chunk = (array, size) => {\n    const chunkCount = Math.ceil(array.length / size);\n    return Array.from({ length: chunkCount }, (_, index) => array.slice(size * index, size * index + size));\n};\n\nconst applyElementToRef = (ref, element) => {\n    if (!ref)\n        return;\n    if (typeof ref === 'function')\n        return ref(element);\n    ref.current = element;\n};\n\nconst CompositeButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function CompositeButton({ caption, children, className, active, Menu, menuPlacement, menuOffset, title, ToggleMenuButton = DefaultToggleMenuButton, variant, onClick, ...restButtonProps }, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__composite-button', className, {\n            'str-video__composite-button--caption': caption,\n            'str-video__composite-button--menu': Menu,\n        }), title: title, ref: ref, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__composite-button__button-group', {\n                    'str-video__composite-button__button-group--active': active,\n                    'str-video__composite-button__button-group--active-primary': active && variant === 'primary',\n                    'str-video__composite-button__button-group--active-secondary': active && variant === 'secondary',\n                }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { type: \"button\", className: \"str-video__composite-button__button\", onClick: (e) => {\n                            e.preventDefault();\n                            onClick?.(e);\n                        }, ...restButtonProps, children: children }), Menu && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton, children: isComponentType(Menu) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Menu, {}) : Menu }))] }), caption && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__composite-button__caption\", children: caption }))] }));\n});\nconst DefaultToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function DefaultToggleMenuButton({ menuShown }, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__menu-toggle-button', {\n            'str-video__menu-toggle-button--active': menuShown,\n        }), icon: menuShown ? 'caret-down' : 'caret-up', ref: ref }));\n});\n\nconst TextButton = ({ children, ...rest }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { ...rest, className: \"str-video__text-button\", children: children }));\n};\n\nconst AcceptCallButton = ({ disabled, onAccept, onClick, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.join();\n            onAccept?.();\n        }\n    }, [onClick, onAccept, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: disabled, icon: \"call-accept\", variant: \"success\", \"data-testid\": \"accept-call-button\", onClick: handleClick }));\n};\n\nconst Notification = (props) => {\n    const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = 'top', iconClassName = 'str-video__notification__icon', close, } = props;\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement,\n        strategy: 'absolute',\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!isVisible || !visibilityTimeout || !resetIsVisible)\n            return;\n        const timeout = setTimeout(() => {\n            resetIsVisible();\n        }, visibilityTimeout);\n        return () => clearTimeout(timeout);\n    }, [isVisible, resetIsVisible, visibilityTimeout]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: refs.setReference, children: [isVisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__notification\", ref: refs.setFloating, style: {\n                    position: strategy,\n                    top: y ?? 0,\n                    left: x ?? 0,\n                    overflowY: 'auto',\n                }, children: [iconClassName && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"i\", { className: iconClassName }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__notification__message\", children: message }), close ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"i\", { className: \"str-video__icon str-video__icon--close str-video__notification__close\", onClick: close })) : null] })), children] }));\n};\n\nconst PermissionNotification = (props) => {\n    const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children, } = props;\n    const { useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const hasPermission = useHasPermissions(permission);\n    const prevHasPermission = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(hasPermission);\n    const [showNotification, setShowNotification] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (hasPermission && !prevHasPermission.current) {\n            setShowNotification('granted');\n            prevHasPermission.current = true;\n        }\n        else if (!hasPermission && prevHasPermission.current) {\n            setShowNotification('revoked');\n            prevHasPermission.current = false;\n        }\n    }, [hasPermission]);\n    const resetIsVisible = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => setShowNotification(undefined), []);\n    if (isAwaitingApproval) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children: children }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: !!showNotification, visibilityTimeout: visibilityTimeout, resetIsVisible: resetIsVisible, message: showNotification === 'granted' ? messageApproved : messageRevoked, children: children }));\n};\n\nconst SpeakingWhileMutedNotification = ({ children, text, placement, }) => {\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { isSpeakingWhileMuted } = useMicrophoneState();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const message = text ?? t('You are muted. Unmute to speak.');\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { message: message, isVisible: isSpeakingWhileMuted, placement: placement || 'top-start', children: children }));\n};\n\nconst RecordingInProgressNotification = ({ children, text, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { isCallRecordingInProgress } = useToggleCallRecording();\n    const [isVisible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const message = text ?? t('Recording in progress...');\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (isCallRecordingInProgress) {\n            setVisible(true);\n        }\n        else {\n            setVisible(false);\n        }\n    }, [isCallRecordingInProgress]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { message: message, iconClassName: \"str-video__icon str-video__icon--recording-on\", isVisible: isVisible, placement: \"top-start\", close: () => setVisible(false), children: children }));\n};\n\nconst LoadingIndicator = ({ className, type = 'spinner', text, tooltip, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__loading-indicator', className), title: tooltip, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__loading-indicator__icon', type) }), text && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__loading-indicator-text\", children: text })] }));\n};\n\nconst RecordEndConfirmation = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();\n    const { close } = useMenuContext();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__confirmation\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-on\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"h2\", { className: \"str-video__end-recording__heading\", children: t('End recording') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__end-recording__description\", children: t('Are you sure you want end the recording?') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__actions\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { variant: \"secondary\", onClick: close, children: t('Cancel') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { variant: \"primary\", onClick: toggleCallRecording, children: isAwaitingResponse ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, {}) : t('End recording') })] })] }));\n};\nconst ToggleEndRecordingMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleEndRecordingMenuButton(props, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: true, variant: \"secondary\", \"data-testid\": \"recording-stop-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-off\" }) }));\n});\nconst RecordCallConfirmationButton = ({ caption, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();\n    if (isCallRecordingInProgress) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n                _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n                _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n            ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RecordEndConfirmation, {}) }) }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n        ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption: caption, title: caption || t('Record call'), variant: \"secondary\", \"data-testid\": \"recording-start-button\", onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, { tooltip: t('Waiting for recording to start...') })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-off\" })) }) }));\n};\nconst RecordCallButton = ({ caption }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();\n    let title = caption || t('Record call');\n    if (isAwaitingResponse) {\n        title = isCallRecordingInProgress\n            ? t('Waiting for recording to stop...')\n            : t('Waiting for recording to start...');\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n        ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption: caption, variant: \"secondary\", \"data-testid\": isCallRecordingInProgress\n                ? 'recording-stop-button'\n                : 'recording-start-button', title: title, onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, {})) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isCallRecordingInProgress ? 'recording-on' : 'recording-off' })) }) }));\n};\n\nconst defaultEmojiReactionMap = {\n    ':like:': '',\n    ':raise-hand:': '',\n    ':fireworks:': '',\n    ':dislike:': '',\n    ':heart:': '',\n    ':smile:': '',\n};\nconst Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !reaction)\n            return;\n        const timeoutId = setTimeout(() => {\n            call.resetReaction(sessionId);\n        }, hideAfterTimeoutInMs);\n        return () => {\n            clearTimeout(timeoutId);\n        };\n    }, [call, hideAfterTimeoutInMs, reaction, sessionId]);\n    if (!reaction)\n        return null;\n    const { emoji_code: emojiCode } = reaction;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__reaction\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__reaction__emoji\", children: emojiCode && emojiReactionMap[emojiCode] }) }));\n};\n\nconst defaultReactions = [\n    {\n        type: 'reaction',\n        emoji_code: ':like:',\n    },\n    {\n        // TODO OL: use `prompt` type?\n        type: 'raised-hand',\n        emoji_code: ':raise-hand:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':fireworks:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':dislike:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':heart:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':smile:',\n    },\n];\nconst ReactionsButton = ({ reactions = defaultReactions, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.CREATE_REACTION], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top\", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultReactionsMenu, { reactions: reactions }) }) }));\n};\nconst ToggleReactionsMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleReactionsMenuButton({ menuShown }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: menuShown, variant: \"primary\", title: t('Reactions'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"reactions\" }) }));\n});\nconst DefaultReactionsMenu = ({ reactions, layout = 'horizontal', }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__reactions-menu', {\n            'str-video__reactions-menu--horizontal': layout === 'horizontal',\n            'str-video__reactions-menu--vertical': layout === 'vertical',\n        }), children: reactions.map((reaction) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { type: \"button\", className: \"str-video__reactions-menu__button\", onClick: () => {\n                call?.sendReaction(reaction);\n            }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code))) }));\n};\n\nconst ScreenShareButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption } = props;\n    const { useHasOngoingScreenShare, useScreenShareState, useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isSomeoneScreenSharing = useHasOngoingScreenShare();\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE);\n    const callSettings = useCallSettings();\n    const isScreenSharingAllowed = callSettings?.screensharing.enabled;\n    const { screenShare, isMute: amIScreenSharing } = useScreenShareState();\n    const disableScreenShareButton = amIScreenSharing\n        ? isSomeoneScreenSharing || isScreenSharingAllowed === false\n        : false;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your screen.'), messageAwaitingApproval: t('Awaiting for an approval to share screen.'), messageRevoked: t('You can no longer share your screen.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isSomeoneScreenSharing, caption: caption, title: caption || t('Share screen'), variant: \"primary\", \"data-testid\": isSomeoneScreenSharing\n                    ? 'screen-share-stop-button'\n                    : 'screen-share-start-button', disabled: disableScreenShareButton, onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await screenShare.toggle();\n                    }\n                }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isSomeoneScreenSharing ? 'screen-share-on' : 'screen-share-off' }) }) }) }));\n};\n\nconst SelectContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nconst Select = (props) => {\n    const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp, } = props;\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [activeIndex, setActiveIndex] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [selectedIndex, setSelectedIndex] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(defaultSelectedIndex);\n    const [selectedLabel, setSelectedLabel] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(defaultSelectedLabel);\n    const { refs, context } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useFloating)({\n        placement: 'bottom-start',\n        open: isOpen,\n        onOpenChange: setIsOpen,\n        whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.autoUpdate,\n        middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.flip)()],\n    });\n    const elementsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    const labelsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    const handleSelect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index) => {\n        setSelectedIndex(index);\n        handleSelectProp(index || 0);\n        setIsOpen(false);\n        if (index !== null) {\n            setSelectedLabel(labelsRef.current[index]);\n        }\n    }, [handleSelectProp]);\n    const handleTypeaheadMatch = (index) => {\n        if (isOpen) {\n            setActiveIndex(index);\n        }\n        else {\n            handleSelect(index);\n        }\n    };\n    const listNav = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useListNavigation)(context, {\n        listRef: elementsRef,\n        activeIndex,\n        selectedIndex,\n        onNavigate: setActiveIndex,\n    });\n    const typeahead = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useTypeahead)(context, {\n        listRef: labelsRef,\n        activeIndex,\n        selectedIndex,\n        onMatch: handleTypeaheadMatch,\n    });\n    const click = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useClick)(context);\n    const dismiss = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useDismiss)(context);\n    const role = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useRole)(context, { role: 'listbox' });\n    const { getReferenceProps, getFloatingProps, getItemProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useInteractions)([listNav, typeahead, click, dismiss, role]);\n    const selectContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        activeIndex,\n        selectedIndex,\n        getItemProps,\n        handleSelect,\n    }), [activeIndex, selectedIndex, getItemProps, handleSelect]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__dropdown\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__dropdown-selected\", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", { className: \"str-video__dropdown-selected__label\", children: [icon && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-selected__icon\", icon: icon })), selectedLabel] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-selected__chevron\", icon: isOpen ? 'chevron-up' : 'chevron-down' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectContext.Provider, { value: selectContext, children: isOpen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingFocusManager, { context: context, modal: false, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__dropdown-list\", ref: refs.setFloating, ...getFloatingProps(), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingList, { elementsRef: elementsRef, labelsRef: labelsRef, children: children }) }) })) })] }));\n};\nconst DropDownSelectOption = (props) => {\n    const { selected, label, icon } = props;\n    const { getItemProps, handleSelect } = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectContext);\n    const { ref, index } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useListItem)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__dropdown-option', {\n            'str-video__dropdown-option--selected': selected,\n        }), ref: ref, ...getItemProps({\n            onClick: () => handleSelect(index),\n        }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-icon\", icon: icon }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__dropdown-label\", children: label })] }));\n};\nconst DropDownSelect = (props) => {\n    const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex, } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Select, { icon: icon, handleSelect: handleSelect, defaultSelectedIndex: defaultSelectedIndex, defaultSelectedLabel: defaultSelectedLabel, children: children }));\n};\n\nconst DeviceSelectorOption = ({ disabled, id, label, onChange, name, selected, defaultChecked, value, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__device-settings__option', {\n            'str-video__device-settings__option--selected': selected,\n            'str-video__device-settings__option--disabled': disabled,\n        }), htmlFor: id, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", { type: \"radio\", name: name, onChange: onChange, value: value, id: id, checked: selected, defaultChecked: defaultChecked, disabled: disabled }), label] }));\n};\nconst DeviceSelectorList = (props) => {\n    const { devices = [], selectedDeviceId: selectedDeviceFromProps, title, type, onChange, } = props;\n    // sometimes the browser (Chrome) will report the system-default device\n    // with an id of 'default'. In case when it doesn't, we'll select the first\n    // available device.\n    let selectedDeviceId = selectedDeviceFromProps;\n    if (devices.length > 0 &&\n        !devices.find((d) => d.deviceId === selectedDeviceId)) {\n        selectedDeviceId = devices[0].deviceId;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings__device-kind\", children: [title && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__device-settings__device-selector-title\", children: title })), !devices.length ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorOption, { id: `${type}--default`, label: \"Default\", name: type, defaultChecked: true, value: \"default\" })) : (devices.map((device) => {\n                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e) => {\n                        onChange?.(e.target.value);\n                    }, name: type, selected: device.deviceId === selectedDeviceId || devices.length === 1 }, device.deviceId));\n            }))] }));\n};\nconst DeviceSelectorDropdown = (props) => {\n    const { devices = [], selectedDeviceId: selectedDeviceFromProps, title, onChange, icon, } = props;\n    // sometimes the browser (Chrome) will report the system-default device\n    // with an id of 'default'. In case when it doesn't, we'll select the first\n    // available device.\n    let selectedDeviceId = selectedDeviceFromProps;\n    if (devices.length > 0 &&\n        !devices.find((d) => d.deviceId === selectedDeviceId)) {\n        selectedDeviceId = devices[0].deviceId;\n    }\n    const selectedIndex = devices.findIndex((d) => d.deviceId === selectedDeviceId);\n    const handleSelect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index) => {\n        onChange?.(devices[index].deviceId);\n    }, [devices, onChange]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings__device-kind\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__device-settings__device-selector-title\", children: title }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropDownSelect, { icon: icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: devices[selectedIndex]?.label, handleSelect: handleSelect, children: devices.map((device) => {\n                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropDownSelectOption, { icon: icon, label: device.label, selected: device.deviceId === selectedDeviceId || devices.length === 1 }, device.deviceId));\n                }) })] }));\n};\nconst DeviceSelector = (props) => {\n    const { visualType = 'list', icon, placeholder, ...rest } = props;\n    if (visualType === 'list') {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorList, { ...rest });\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorDropdown, { ...rest, icon: icon, placeholder: placeholder }));\n};\n\nconst DeviceSelectorAudioInput = ({ title, visualType, }) => {\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, selectedDevice, devices } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: \"audioinput\", onChange: async (deviceId) => {\n            await microphone.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"mic\" }));\n};\nconst DeviceSelectorAudioOutput = ({ title, visualType, }) => {\n    const { useSpeakerState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState();\n    if (!isDeviceSelectionSupported)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices, type: \"audiooutput\", selectedDeviceId: selectedDevice, onChange: (deviceId) => {\n            speaker.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"speaker\" }));\n};\n\nconst DeviceSelectorVideo = ({ title, visualType, }) => {\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, devices, selectedDevice } = useCameraState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices || [], type: \"videoinput\", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {\n            await camera.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"camera\" }));\n};\n\nconst DeviceSettings = ({ visualType = MenuVisualType.MENU, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleDeviceSettingsMenuButton, visualType: visualType, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Menu, {}) }));\n};\nconst Menu = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorVideo, { title: t('Select a Camera') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioInput, { title: t('Select a Mic') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioOutput, { title: t('Select Speakers') })] }));\n};\nconst ToggleDeviceSettingsMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleDeviceSettingsMenuButton({ menuShown }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__device-settings__button', {\n            'str-video__device-settings__button--active': menuShown,\n        }), title: t('Toggle device menu'), icon: \"device-settings\", ref: ref }));\n});\n\nconst ToggleAudioPreviewButton = (props) => {\n    const { caption, Menu, menuPlacement, ...restCompositeButtonProps } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, isMute, hasBrowserPermission } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!hasBrowserPermission && 'str-video__device-unavailable'), variant: \"secondary\", title: !hasBrowserPermission\n            ? t('Check your browser audio permissions')\n            : caption || t('Mic'), disabled: !hasBrowserPermission, \"data-testid\": isMute ? 'preview-audio-unmute-button' : 'preview-audio-mute-button', onClick: () => microphone.toggle(), Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: !isMute ? 'mic' : 'mic-off' }), !hasBrowserPermission && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", title: t('Check your browser audio permissions'), children: \"!\" }))] }));\n};\nconst ToggleAudioPublishingButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioInput, { visualType: \"list\" }), menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO);\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, isMute, hasBrowserPermission } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now speak.'), messageAwaitingApproval: t('Awaiting for an approval to speak.'), messageRevoked: t('You can no longer speak.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, title: !hasPermission\n                    ? t('You have no permission to share your audio')\n                    : !hasBrowserPermission\n                        ? t('Check your browser mic permissions')\n                        : caption || t('Mic'), variant: \"secondary\", disabled: !hasBrowserPermission || !hasPermission, \"data-testid\": isMute ? 'audio-unmute-button' : 'audio-mute-button', onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await microphone.toggle();\n                    }\n                }, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isMute ? 'mic-off' : 'mic' }), (!hasBrowserPermission || !hasPermission) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", children: \"!\" }))] }) }) }));\n};\n\nconst ToggleVideoPreviewButton = (props) => {\n    const { caption, Menu = DeviceSelectorVideo, menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, isMute, hasBrowserPermission } = useCameraState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!hasBrowserPermission && 'str-video__device-unavailable'), title: !hasBrowserPermission\n            ? t('Check your browser video permissions')\n            : caption || t('Video'), variant: \"secondary\", \"data-testid\": isMute ? 'preview-video-unmute-button' : 'preview-video-mute-button', onClick: () => camera.toggle(), disabled: !hasBrowserPermission, Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: !isMute ? 'camera' : 'camera-off' }), !hasBrowserPermission && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", title: t('Check your browser video permissions'), children: \"!\" }))] }));\n};\nconst ToggleVideoPublishingButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorVideo, { visualType: \"list\" }), menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO);\n    const { useCameraState, useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, isMute, hasBrowserPermission } = useCameraState();\n    const callSettings = useCallSettings();\n    const isPublishingVideoAllowed = callSettings?.video.enabled;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your video.'), messageAwaitingApproval: t('Awaiting for an approval to share your video.'), messageRevoked: t('You can no longer share your video.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, variant: \"secondary\", title: !hasPermission\n                    ? t('You have no permission to share your video')\n                    : !hasBrowserPermission\n                        ? t('Check your browser video permissions')\n                        : !isPublishingVideoAllowed\n                            ? t('Video publishing is disabled by the system')\n                            : caption || t('Video'), disabled: !hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed, \"data-testid\": isMute ? 'video-unmute-button' : 'video-mute-button', onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await camera.toggle();\n                    }\n                }, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isMute ? 'camera-off' : 'camera' }), (!hasBrowserPermission ||\n                        !hasPermission ||\n                        !isPublishingVideoAllowed) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", children: \"!\" }))] }) }) }));\n};\n\nconst EndCallMenu = (props) => {\n    const { onLeave, onEnd } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-call__confirmation\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { className: \"str-video__button str-video__end-call__leave\", type: \"button\", \"data-testid\": \"leave-call-button\", onClick: onLeave, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__button__icon str-video__end-call__leave-icon\", icon: \"logout\" }), t('Leave call')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.END_CALL], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { className: \"str-video__button str-video__end-call__end\", type: \"button\", \"data-testid\": \"end-call-for-all-button\", onClick: onEnd, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__button__icon str-video__end-call__end-icon\", icon: \"call-end\" }), t('End call for all')] }) })] }));\n};\nconst CancelCallToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function CancelCallToggleMenuButton(props, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"call-end\", variant: \"danger\", title: t('Leave call'), \"data-testid\": \"leave-call-button\", ref: ref }));\n});\nconst CancelCallConfirmButton = ({ onClick, onLeave, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const handleLeave = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.leave();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    const handleEndCall = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.endCall();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top-start\", ToggleButton: CancelCallToggleMenuButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) }));\n};\nconst CancelCallButton = ({ disabled, onClick, onLeave, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.leave();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: disabled, icon: \"call-end\", variant: \"danger\", title: t('Leave call'), \"data-testid\": \"cancel-call-button\", onClick: handleClick }));\n};\n\nconst CallControls = ({ onLeave }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-controls\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RecordCallButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ReactionsButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ScreenShareButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SpeakingWhileMutedNotification, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleAudioPublishingButton, {}) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleVideoPublishingButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { onLeave: onLeave })] }));\n\nchart_js__WEBPACK_IMPORTED_MODULE_9__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_9__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_9__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_9__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_9__.PointElement);\nconst CallStatsLatencyChart = (props) => {\n    const { values } = props;\n    let max = 0;\n    const data = {\n        labels: values.map((point) => {\n            const date = new Date(point.x * 1000);\n            return `${date.getHours()}:${date.getMinutes()}`;\n        }),\n        datasets: [\n            {\n                data: values.map((point) => {\n                    const { y } = point;\n                    max = Math.max(max, y);\n                    return point;\n                }),\n                borderColor: '#00e2a1',\n                backgroundColor: '#00e2a1',\n            },\n        ],\n    };\n    const options = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n        return {\n            maintainAspectRatio: false,\n            animation: {\n                duration: 0,\n            },\n            elements: {\n                line: {\n                    borderWidth: 1,\n                },\n                point: {\n                    radius: 2,\n                },\n            },\n            scales: {\n                y: {\n                    position: 'right',\n                    stacked: true,\n                    min: 0,\n                    max: Math.max(180, Math.ceil((max + 10) / 10) * 10),\n                    grid: {\n                        display: true,\n                        color: '#979ca0',\n                    },\n                    ticks: {\n                        stepSize: 30,\n                    },\n                },\n                x: {\n                    grid: {\n                        display: false,\n                    },\n                    ticks: {\n                        display: false,\n                    },\n                },\n            },\n        };\n    }, [max]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats-line-chart-container\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_chartjs_2__WEBPACK_IMPORTED_MODULE_10__.Line, { options: options, data: data, className: \"str-video__call-stats__latencychart\" }) }));\n};\n\nvar Statuses;\n(function (Statuses) {\n    Statuses[\"GOOD\"] = \"Good\";\n    Statuses[\"OK\"] = \"Ok\";\n    Statuses[\"BAD\"] = \"Bad\";\n})(Statuses || (Statuses = {}));\nconst statsStatus = ({ value, lowBound, highBound, }) => {\n    if (value <= lowBound) {\n        return Statuses.GOOD;\n    }\n    if (value >= lowBound && value <= highBound) {\n        return Statuses.OK;\n    }\n    if (value >= highBound) {\n        return Statuses.BAD;\n    }\n    return Statuses.GOOD;\n};\nconst CallStats = (props) => {\n    const { latencyLowBound = 75, latencyHighBound = 400 } = props;\n    const [latencyBuffer, setLatencyBuffer] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n        const now = Date.now();\n        return Array.from({ length: 20 }, (_, i) => ({ x: now + i, y: 0 }));\n    });\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const [publishBitrate, setPublishBitrate] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('-');\n    const [subscribeBitrate, setSubscribeBitrate] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('-');\n    const previousStats = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    const { useCallStatsReport } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callStatsReport = useCallStatsReport();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!callStatsReport)\n            return;\n        if (!previousStats.current) {\n            previousStats.current = callStatsReport;\n            return;\n        }\n        const previousCallStatsReport = previousStats.current;\n        setPublishBitrate(() => {\n            return calculatePublishBitrate(previousCallStatsReport, callStatsReport);\n        });\n        setSubscribeBitrate(() => {\n            return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);\n        });\n        setLatencyBuffer((latencyBuf) => {\n            const newLatencyBuffer = latencyBuf.slice(-19);\n            newLatencyBuffer.push({\n                x: callStatsReport.timestamp,\n                y: callStatsReport.publisherStats.averageRoundTripTimeInMs,\n            });\n            return newLatencyBuffer;\n        });\n        previousStats.current = callStatsReport;\n    }, [callStatsReport]);\n    const latencyComparison = {\n        lowBound: latencyLowBound,\n        highBound: latencyHighBound,\n        value: callStatsReport?.publisherStats.averageRoundTripTimeInMs || 0,\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats\", children: callStatsReport && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"h3\", { className: \"str-video__call-stats__heading\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-stats__icon\", icon: \"call-latency\" }), t('Call Latency')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-stats__description\", children: t('Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__latencychart\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallStatsLatencyChart, { values: latencyBuffer }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"h3\", { className: \"str-video__call-stats__heading\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-stats__icon\", icon: \"network-quality\" }), t('Call performance')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-stats__description\", children: t('Review the key data points below to assess call performance') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-container\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Region\", value: callStatsReport.datacenter }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Latency\", value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receive jitter\", value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {\n                                ...latencyComparison,\n                                value: callStatsReport.subscriberStats.averageJitterInMs,\n                            } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish jitter\", value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {\n                                ...latencyComparison,\n                                value: callStatsReport.publisherStats.averageJitterInMs,\n                            } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish resolution\", value: toFrameSize(callStatsReport.publisherStats) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish quality drop reason\", value: callStatsReport.publisherStats.qualityLimitationReasons }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receiving resolution\", value: toFrameSize(callStatsReport.subscriberStats) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receive quality drop reason\", value: callStatsReport.subscriberStats.qualityLimitationReasons }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish bitrate\", value: publishBitrate }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receiving bitrate\", value: subscribeBitrate })] })] })) }));\n};\nconst StatCardExplanation = (props) => {\n    const { description } = props;\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const { refs, floatingStyles, context } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useFloating)({\n        open: isOpen,\n        onOpenChange: setIsOpen,\n    });\n    const hover = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useHover)(context);\n    const { getReferenceProps, getFloatingProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useInteractions)([hover]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-explanation\", ref: refs.setReference, ...getReferenceProps(), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-explanation__icon\", icon: \"info\" }) }), isOpen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-explanation__description\", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description }))] }));\n};\nconst StatsTag = ({ children, status = Statuses.GOOD, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-stats__tag', {\n            'str-video__call-stats__tag--good': status === Statuses.GOOD,\n            'str-video__call-stats__tag--ok': status === Statuses.OK,\n            'str-video__call-stats__tag--bad': status === Statuses.BAD,\n        }), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__tag__text\", children: children }) }));\n};\nconst StatCard = (props) => {\n    const { label, value, description, comparison } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const status = comparison ? statsStatus(comparison) : undefined;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-content\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-label\", children: [label, description && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCardExplanation, { description: description })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__card-value\", children: value })] }), comparison && status && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatsTag, { status: status, children: t(status) })] }));\n};\nconst toFrameSize = (stats) => {\n    const { highestFrameWidth: w, highestFrameHeight: h, highestFramesPerSecond: fps, } = stats;\n    let size = `-`;\n    if (w && h) {\n        size = `${w}x${h}`;\n        if (fps) {\n            size += `@${fps}fps.`;\n        }\n    }\n    return size;\n};\nconst calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {\n    const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp, }, } = previousCallStatsReport;\n    const { publisherStats: { totalBytesSent, timestamp }, } = callStatsReport;\n    const bytesSent = totalBytesSent - previousTotalBytesSent;\n    const timeElapsed = timestamp - previousTimestamp;\n    return `${((bytesSent * 8) / timeElapsed).toFixed(2)} kbps`;\n};\nconst calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {\n    const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp, }, } = previousCallStatsReport;\n    const { subscriberStats: { totalBytesReceived, timestamp }, } = callStatsReport;\n    const bytesReceived = totalBytesReceived - previousTotalBytesReceived;\n    const timeElapsed = timestamp - previousTimestamp;\n    return `${((bytesReceived * 8) / timeElapsed).toFixed(2)} kbps`;\n};\n\nconst CallStatsButton = () => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top-end\", ToggleButton: ToggleMenuButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallStats, {}) }));\nconst ToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleMenuButton(props, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, menuShown } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: menuShown, caption: caption, title: caption || t('Statistics'), \"data-testid\": \"stats-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"stats\" }) }));\n});\n\nconst ToggleAudioOutputButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = DeviceSelectorAudioOutput, menuPlacement = 'top', } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { Menu: Menu, menuPlacement: menuPlacement, caption: caption, title: caption || t('Speakers'), \"data-testid\": \"audio-output-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"speaker\" }) }));\n};\n\nconst BlockedUserListing = ({ data }) => {\n    if (!data.length)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing\", children: data.map((userId) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlockedUserListingItem, { userId: userId }, userId))) }) }));\n};\nconst BlockedUserListingItem = ({ userId }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const unblockUserClickHandler = () => {\n        if (userId)\n            call?.unblockUser(userId);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing-item__display-name\", children: userId }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.BLOCK_USERS], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(TextButton, { onClick: unblockUserClickHandler, children: \"Unblock\" }) })] }));\n};\n\nconst CallParticipantListHeader = ({ onClose, }) => {\n    const { useParticipants, useAnonymousParticipantCount } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants();\n    const anonymousParticipantCount = useAnonymousParticipantCount();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list-header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list-header__title\", children: [t('Participants'), ' ', (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__participant-list-header__title-count\", children: [\"[\", participants.length, \"]\"] }), anonymousParticipantCount > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-list-header__title-anonymous\", children: t('Anonymous', { count: anonymousParticipantCount }) }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: onClose, className: \"str-video__participant-list-header__close-button\", icon: \"close\" })] }));\n};\n\nconst Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = 'top', visible = false, }) => {\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement: tooltipPlacement,\n        strategy: 'absolute',\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        refs.setReference(referenceElement);\n    }, [referenceElement, refs]);\n    if (!visible)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__tooltip', tooltipClassName), ref: refs.setFloating, style: {\n            position: strategy,\n            top: y ?? 0,\n            left: x ?? 0,\n            overflowY: 'auto',\n        }, children: children }));\n};\n\nconst useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave, } = {}) => {\n    const [tooltipVisible, setTooltipVisible] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const handleMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((e) => {\n        setTooltipVisible(true);\n        onMouseEnter?.(e);\n    }, [onMouseEnter]);\n    const handleMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((e) => {\n        setTooltipVisible(false);\n        onMouseLeave?.(e);\n    }, [onMouseLeave]);\n    return { handleMouseEnter, handleMouseLeave, tooltipVisible };\n};\n\n// todo: duplicate of CallParticipantList.tsx#MediaIndicator - refactor to a single component\nconst WithTooltip = ({ title, tooltipClassName, tooltipPlacement, ...props }) => {\n    const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();\n    const [tooltipAnchor, setTooltipAnchor] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipVisible, tooltipClassName: tooltipClassName, tooltipPlacement: tooltipPlacement, children: title || '' }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] }));\n};\n\nconst CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName, }) => {\n    const isAudioOn = participant.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const isVideoOn = participant.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const isPinned = !!participant.pin;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Avatar, { name: participant.name, imageSrc: participant.image }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DisplayName, { participant: participant }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item__media-indicator-group\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: isAudioOn ? t('Microphone on') : t('Microphone off'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isAudioOn ? 'mic' : 'mic-off'}`) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: isVideoOn ? t('Camera on') : t('Camera off'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isVideoOn ? 'camera' : 'camera-off'}`) }), isPinned && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: t('Pinned'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', 'str-video__participant-listing-item__icon-pinned') })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleButton$2, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantViewContext.Provider, { value: { participant, trackType: 'none' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantActionsContextMenu, {}) }) })] })] }));\n};\nconst MediaIndicator = (props) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(WithTooltip, { ...props }));\nconst DefaultDisplayName = ({ participant }) => {\n    const connectedUser = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const meFlag = participant.userId === connectedUser?.id ? t('Me') : '';\n    const nameOrId = participant.name || participant.userId || t('Unknown');\n    let displayName;\n    if (!participant.name) {\n        displayName = meFlag || nameOrId || t('Unknown');\n    }\n    else if (meFlag) {\n        displayName = `${nameOrId} (${meFlag})`;\n    }\n    else {\n        displayName = nameOrId;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(WithTooltip, { className: \"str-video__participant-listing-item__display-name\", title: displayName, children: displayName }));\n};\nconst ToggleButton$2 = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"ellipsis\", ref: ref });\n});\n\nconst CallParticipantListing = ({ data, }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing\", children: data.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListingItem, { participant: participant }, participant.sessionId))) }));\n\nconst EmptyParticipantSearchList = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-list--empty\", children: t('No participants found') }));\n};\n\nconst SearchInput = ({ exitSearch, isActive, ...rest }) => {\n    const [inputElement, setInputElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!inputElement)\n            return;\n        const handleKeyDown = (e) => {\n            if (e.key.toLowerCase() === 'escape')\n                exitSearch();\n        };\n        inputElement.addEventListener('keydown', handleKeyDown);\n        return () => {\n            inputElement.removeEventListener('keydown', handleKeyDown);\n        };\n    }, [exitSearch, inputElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__search-input__container', {\n            'str-video__search-input__container--active': isActive,\n        }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", { placeholder: \"Search\", ...rest, ref: setInputElement }), isActive ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: \"str-video__search-input__clear-btn\", onClick: exitSearch, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__search-input__icon--active\" }) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__search-input__icon\" }))] }));\n};\n\nconst SearchResults = ({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList, }) => {\n    if (searchQueryInProgress) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__search-results--loading\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator$1, {}) }));\n    }\n    if (!searchResults.length) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EmptySearchResultComponent, {});\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResultList, { data: searchResults });\n};\n\nconst useSearch = ({ debounceInterval, searchFn, searchQuery = '', }) => {\n    const [searchResults, setSearchResults] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [searchQueryInProgress, setSearchQueryInProgress] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!searchQuery.length) {\n            setSearchQueryInProgress(false);\n            setSearchResults([]);\n            return;\n        }\n        setSearchQueryInProgress(true);\n        const timeout = setTimeout(async () => {\n            try {\n                const results = await searchFn(searchQuery);\n                setSearchResults(results);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            finally {\n                setSearchQueryInProgress(false);\n            }\n        }, debounceInterval);\n        return () => {\n            clearTimeout(timeout);\n        };\n    }, [debounceInterval, searchFn, searchQuery]);\n    return {\n        searchQueryInProgress,\n        searchResults,\n    };\n};\n\nconst UserListTypes = {\n    active: 'Active users',\n    blocked: 'Blocked users',\n};\nconst DEFAULT_DEBOUNCE_SEARCH_INTERVAL = 200;\nconst CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval, }) => {\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('');\n    const [userListType, setUserListType] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('active');\n    const exitSearch = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => setSearchQuery(''), []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListHeader, { onClose: onClose }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch: exitSearch, isActive: !!searchQuery }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListContentHeader, { userListType: userListType, setUserListType: setUserListType }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list__content\", children: [userListType === 'active' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ActiveUsersSearchResults, { searchQuery: searchQuery, activeUsersSearchFn: activeUsersSearchFn, debounceSearchInterval: debounceSearchInterval })), userListType === 'blocked' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlockedUsersSearchResults, { searchQuery: searchQuery, blockedUsersSearchFn: blockedUsersSearchFn, debounceSearchInterval: debounceSearchInterval }))] })] }));\n};\nconst CallParticipantListContentHeader = ({ userListType, setUserListType, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const muteAll = () => {\n        call?.muteAllUsers('audio');\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list__content-header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-list__content-header-title\", children: userListType === 'active' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(TextButton, { onClick: muteAll, children: \"Mute all\" }) })) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleButton$1, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenu, { children: Object.keys(UserListTypes).map((lt) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { \"aria-selected\": lt === userListType, onClick: () => setUserListType(lt), children: UserListTypes[lt] }, lt))) }) })] }));\n};\nconst ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, }) => {\n    const { useParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants({ sortBy: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.name });\n    const activeUsersSearchFn = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((queryString) => {\n        const queryRegExp = new RegExp(queryString, 'i');\n        return Promise.resolve(participants.filter((participant) => {\n            return participant.name.match(queryRegExp);\n        }));\n    }, [participants]);\n    const { searchQueryInProgress, searchResults } = useSearch({\n        searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,\n        debounceInterval: debounceSearchInterval,\n        searchQuery,\n    });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing }));\n};\nconst BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, searchQuery, }) => {\n    const { useCallBlockedUserIds } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const blockedUsers = useCallBlockedUserIds();\n    const blockedUsersSearchFn = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((queryString) => {\n        const queryRegExp = new RegExp(queryString, 'i');\n        return Promise.resolve(blockedUsers.filter((blockedUser) => {\n            return blockedUser.match(queryRegExp);\n        }));\n    }, [blockedUsers]);\n    const { searchQueryInProgress, searchResults } = useSearch({\n        searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,\n        debounceInterval: debounceSearchInterval,\n        searchQuery,\n    });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing }));\n};\nconst ToggleButton$1 = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"filter\", ref: ref });\n});\n\nconst CallPreview = (props) => {\n    const { className, style } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallThumbnail } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const thumbnail = useCallThumbnail();\n    const [imageRef, setImageRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!imageRef || !call)\n            return;\n        const cleanup = call.bindCallThumbnailElement(imageRef);\n        return () => cleanup();\n    }, [imageRef, call]);\n    if (!thumbnail)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-preview', className), style: style, alt: \"Call Preview Thumbnail\", ref: setImageRef }));\n};\n\nconst CallRecordingListHeader = ({ callRecordings, onRefresh, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__title\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { children: t('Call Recordings') }), callRecordings.length ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { children: [\"(\", callRecordings.length, \")\"] }) : null] }), onRefresh && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"refresh\", title: t('Refresh'), onClick: onRefresh }))] }));\n};\n\nconst dateFormat = (date) => {\n    const format = new Date(date);\n    return format.toTimeString().split(' ')[0];\n};\nconst CallRecordingListItem = ({ recording, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"li\", { className: \"str-video__call-recording-list__item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__filename\", children: recording.filename }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__time\", children: dateFormat(recording.start_time) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__time\", children: dateFormat(recording.end_time) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__download\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"a\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-recording-list-item__action-button', 'str-video__call-recording-list-item__action-button--download'), role: \"button\", href: recording.url, download: recording.filename, title: \"Download the recording\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"download\" }) }) })] }));\n};\n\nconst EmptyCallRecordingListing = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__listing str-video__call-recording-list__listing--empty\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__listing--icon-empty\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-recording-list__listing--text-empty\", children: \"No recordings available\" })] }));\n};\n\nconst LoadingCallRecordingListing = ({ callRecordings, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [callRecordings.map((recording) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListItem, { recording: recording }, recording.filename))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, { text: \"Recording getting ready\" })] }));\n};\n\nconst CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListHeader$1, { callRecordings: callRecordings, onRefresh: onRefresh }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__listing\", children: loading ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingCallRecordingList, { callRecordings: callRecordings })) : callRecordings.length ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__call-recording-list__list\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"li\", { className: \"str-video__call-recording-list__item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__filename\", children: \"Name\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__time\", children: \"Start time\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__time\", children: \"End time\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__download\" })] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__call-recording-list__list\", children: callRecordings.map((recording) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListItem$1, { recording: recording }, recording.filename))) })] })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EmptyCallRecordingList, {})) })] }));\n};\n\nconst RingingCallControls = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallCallingState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callCallingState = useCallCallingState();\n    if (!call)\n        return null;\n    const buttonsDisabled = callCallingState !== _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__pending-call-controls\", children: call.isCreatedByMe ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { disabled: buttonsDisabled })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(AcceptCallButton, { disabled: buttonsDisabled }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { onClick: () => call.leave({ reject: true }), disabled: buttonsDisabled })] })) }));\n};\n\nconst CALLING_STATE_TO_LABEL = {\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINING]: 'Joining',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING]: 'Ringing',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.MIGRATING]: 'Migrating',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RECONNECTING]: 'Re-connecting',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RECONNECTING_FAILED]: 'Failed',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.OFFLINE]: 'No internet connection',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.IDLE]: '',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.UNKNOWN]: '',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINED]: 'Joined',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.LEFT]: 'Left call',\n};\nconst RingingCall = (props) => {\n    const { includeSelf = false, totalMembersToShow = 3 } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useCallCallingState, useCallMembers } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callingState = useCallCallingState();\n    const members = useCallMembers();\n    const connectedUser = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser)();\n    if (!call)\n        return null;\n    // take the first N members to show their avatars\n    const membersToShow = (members || [])\n        .slice(0, totalMembersToShow)\n        .map(({ user }) => user)\n        .filter((user) => user.id !== connectedUser?.id || includeSelf);\n    if (includeSelf &&\n        !membersToShow.find((user) => user.id === connectedUser?.id)) {\n        // if the current user is not in the initial batch of members,\n        // replace the first item in membersToShow array with the current user\n        const self = members.find(({ user }) => user.id === connectedUser?.id);\n        if (self) {\n            membersToShow.splice(0, 1, self.user);\n        }\n    }\n    const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-panel str-video__call-panel--ringing\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-panel__members-list\", children: membersToShow.map((user) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-panel__member-box\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Avatar, { name: user.name, imageSrc: user.image }), user.name && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__member_details\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__member_name\", children: user.name }) }))] }, user.id))) }), callingStateLabel && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-panel__calling-state-label\", children: t(callingStateLabel) })), [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING, _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINING].includes(callingState) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RingingCallControls, {}))] }));\n};\n\nconst byNameOrId = (a, b) => {\n    if (a.name && b.name && a.name < b.name)\n        return -1;\n    if (a.name && b.name && a.name > b.name)\n        return 1;\n    if (a.id < b.id)\n        return -1;\n    if (a.id > b.id)\n        return 1;\n    return 0;\n};\nconst PermissionRequests = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useLocalParticipant, useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const localParticipant = useLocalParticipant();\n    const [expanded, setExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [permissionRequests, setPermissionRequests] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const canUpdateCallPermissions = useHasPermissions(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.UPDATE_CALL_PERMISSIONS);\n    const localUserId = localParticipant?.userId;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !canUpdateCallPermissions)\n            return;\n        return call.on('call.permission_request', (event) => {\n            if (event.user.id !== localUserId) {\n                setPermissionRequests((requests) => [...requests, event].sort((a, b) => byNameOrId(a.user, b.user)));\n            }\n        });\n    }, [call, canUpdateCallPermissions, localUserId]);\n    const handleUpdatePermission = (request, type) => {\n        return async () => {\n            const { user, permissions } = request;\n            switch (type) {\n                case 'grant':\n                    await call?.grantPermissions(user.id, permissions);\n                    break;\n                case 'revoke':\n                    await call?.revokePermissions(user.id, permissions);\n                    break;\n            }\n            setPermissionRequests((requests) => requests.filter((r) => r !== request));\n        };\n    };\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement: 'bottom',\n        strategy: 'absolute',\n    });\n    // don't render anything if there are no permission requests\n    if (permissionRequests.length === 0)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-requests\", ref: refs.setReference, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-requests__notification\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__permission-requests__notification__message\", children: [permissionRequests.length, \" pending permission requests\"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { type: \"button\", onClick: () => {\n                            setExpanded((e) => !e);\n                        }, children: expanded ? 'Hide requests' : 'Show requests' })] }), expanded && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionRequestList, { ref: refs.setFloating, style: {\n                    position: strategy,\n                    top: y ?? 0,\n                    left: x ?? 0,\n                    overflowY: 'auto',\n                }, permissionRequests: permissionRequests, handleUpdatePermission: handleUpdatePermission }))] }));\n};\nconst PermissionRequestList = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function PermissionRequestList(props, ref) {\n    const { permissionRequests, handleUpdatePermission, ...rest } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__permission-requests-list\", ref: ref, ...rest, children: permissionRequests.map((request, reqIndex) => {\n            const { user, permissions } = request;\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: permissions.map((permission) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-request\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__permission-request__message\", children: messageForPermission(user.name || user.id, permission, t) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--allow\", type: \"button\", onClick: handleUpdatePermission(request, 'grant'), children: t('Allow') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--reject\", type: \"button\", onClick: handleUpdatePermission(request, 'revoke'), children: t('Revoke') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--reject\", type: \"button\", onClick: handleUpdatePermission(request, 'dismiss'), children: t('Dismiss') })] }, permission))) }, `${user.id}/${reqIndex}`));\n        }) }));\n});\nconst Button = (props) => {\n    const { className, ...rest } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__permission-request__button', className), ...rest }));\n};\nconst messageForPermission = (userName, permission, t) => {\n    switch (permission) {\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO:\n            return t('{{ userName }} is requesting to speak', { userName });\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO:\n            return t('{{ userName }} is requesting to share their camera', {\n                userName,\n            });\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE:\n            return t('{{ userName }} is requesting to present their screen', {\n                userName,\n            });\n        default:\n            return t('{{ userName }} is requesting permission: {{ permission }}', {\n                userName,\n                permission,\n            });\n    }\n};\n\nconst StreamTheme = ({ as: Component = 'div', className, children, ...props }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Component, { ...props, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video', className), children: children }));\n};\n\nconst DefaultVideoPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function DefaultVideoPlaceholder({ participant, style }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const name = participant.name || participant.userId;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__video-placeholder\", style: style, ref: ref, children: [(!participant.image || error) &&\n                (name ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(InitialsFallback, { name: name })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__video-placeholder__no-video-label\", children: t('Video is disabled') }))), participant.image && !error && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { onError: () => setError(true), alt: \"video-placeholder\", className: \"str-video__video-placeholder__avatar\", src: participant.image }))] }));\n});\nconst InitialsFallback = (props) => {\n    const { name } = props;\n    const initials = name\n        .split(' ')\n        .slice(0, 2)\n        .map((n) => n[0])\n        .join('');\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__video-placeholder__initials-fallback\", children: initials }));\n};\n\nconst Video$1 = ({ trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder, refs, ...rest }) => {\n    const { sessionId, videoStream, screenShareStream, publishedTracks, viewportVisibilityState, isLocalParticipant, userId, } = participant;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [videoElement, setVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    // start with true, will flip once the video starts playing\n    const [isVideoPaused, setIsVideoPaused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    const [isWideMode, setIsWideMode] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    const stream = trackType === 'videoTrack'\n        ? videoStream\n        : trackType === 'screenShareTrack'\n            ? screenShareStream\n            : undefined;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(() => {\n        if (!call || !videoElement || trackType === 'none')\n            return;\n        const cleanup = call.bindVideoElement(videoElement, sessionId, trackType);\n        return () => {\n            cleanup?.();\n        };\n    }, [call, trackType, sessionId, videoElement]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!stream || !videoElement)\n            return;\n        const [track] = stream.getVideoTracks();\n        if (!track)\n            return;\n        const handlePlayPause = () => {\n            setIsVideoPaused(videoElement.paused);\n            const { width = 0, height = 0 } = track.getSettings();\n            setIsWideMode(width >= height);\n        };\n        // playback may have started before we had a chance to\n        // attach the 'play/pause' event listener, so we set the state\n        // here to make sure it's in sync\n        setIsVideoPaused(videoElement.paused);\n        videoElement.addEventListener('play', handlePlayPause);\n        videoElement.addEventListener('pause', handlePlayPause);\n        track.addEventListener('unmute', handlePlayPause);\n        return () => {\n            videoElement.removeEventListener('play', handlePlayPause);\n            videoElement.removeEventListener('pause', handlePlayPause);\n            track.removeEventListener('unmute', handlePlayPause);\n            // reset the 'pause' state once we unmount the video element\n            setIsVideoPaused(true);\n        };\n    }, [stream, videoElement]);\n    if (!call)\n        return null;\n    const isPublishingTrack = trackType === 'videoTrack'\n        ? publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO)\n        : trackType === 'screenShareTrack'\n            ? publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE)\n            : false;\n    const isInvisible = trackType === 'none' ||\n        viewportVisibilityState?.[trackType] === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VisibilityState.INVISIBLE;\n    const hasNoVideoOrInvisible = !isPublishingTrack || isInvisible;\n    const mirrorVideo = isLocalParticipant && trackType === 'videoTrack';\n    const isScreenShareTrack = trackType === 'screenShareTrack';\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [!hasNoVideoOrInvisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { ...rest, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video', className, {\n                    'str-video__video--not-playing': isVideoPaused,\n                    'str-video__video--tall': !isWideMode,\n                    'str-video__video--mirror': mirrorVideo,\n                    'str-video__video--screen-share': isScreenShareTrack,\n                }), \"data-user-id\": userId, \"data-session-id\": sessionId, ref: (element) => {\n                    setVideoElement(element);\n                    refs?.setVideoElement?.(element);\n                } })), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VideoPlaceholder, { style: { position: 'absolute' }, participant: participant, ref: refs?.setVideoPlaceholderElement }))] }));\n};\n\n/**\n * @description Extends video element with `stream` property\n * (`srcObject`) to reactively handle stream changes\n */\nconst BaseVideo = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function BaseVideo({ stream, ...rest }, ref) {\n    const [videoElement, setVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoElement || !stream)\n            return;\n        if (stream === videoElement.srcObject)\n            return;\n        videoElement.srcObject = stream;\n        if (_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers.isSafari() || _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers.isFirefox()) {\n            // Firefox and Safari have some timing issue\n            setTimeout(() => {\n                videoElement.srcObject = stream;\n                videoElement.play().catch((e) => {\n                    console.error(`Failed to play stream`, e);\n                });\n            }, 0);\n        }\n        return () => {\n            videoElement.pause();\n            videoElement.srcObject = null;\n        };\n    }, [stream, videoElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {\n            applyElementToRef(ref, element);\n            setVideoElement(element);\n        } }));\n});\n\nconst DefaultDisabledVideoPreview = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str_video__video-preview__disabled-video-preview\", children: t('Video is disabled') }));\n};\nconst DefaultNoCameraPreview = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str_video__video-preview__no-camera-preview\", children: t('No camera found') }));\n};\nconst VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator, }) => {\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { devices, status, isMute, mediaStream } = useCameraState();\n    let contents;\n    if (isMute && devices?.length === 0) {\n        contents = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(NoCameraPreview, {});\n    }\n    else if (status === 'enabled') {\n        const loading = !mediaStream;\n        contents = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [mediaStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BaseVideo, { stream: mediaStream, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video-preview', {\n                        'str-video__video-preview--mirror': mirror,\n                        'str-video__video-preview--loading': loading,\n                    }) })), loading && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StartingCameraPreview, {})] }));\n    }\n    else {\n        contents = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DisabledVideoPreview, {});\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video-preview-container', className), children: contents }));\n};\n\nconst ParticipantActionsContextMenu = () => {\n    const { participant, participantViewElement, videoElement } = useParticipantViewContext();\n    const [fullscreenModeOn, setFullscreenModeOn] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!!document.fullscreenElement);\n    const [pictureInPictureElement, setPictureInPictureElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(document.pictureInPictureElement);\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { pin, publishedTracks, sessionId, userId } = participant;\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const hasScreenShare = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n    const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n    const blockUser = () => call?.blockUser(userId);\n    const muteAudio = () => call?.muteUser(userId, 'audio');\n    const muteVideo = () => call?.muteUser(userId, 'video');\n    const muteScreenShare = () => call?.muteUser(userId, 'screenshare');\n    const muteScreenShareAudio = () => call?.muteUser(userId, 'screenshare_audio');\n    const grantPermission = (permission) => () => {\n        call?.updateUserPermissions({\n            user_id: userId,\n            grant_permissions: [permission],\n        });\n    };\n    const revokePermission = (permission) => () => {\n        call?.updateUserPermissions({\n            user_id: userId,\n            revoke_permissions: [permission],\n        });\n    };\n    const toggleParticipantPin = () => {\n        if (pin) {\n            call?.unpin(sessionId);\n        }\n        else {\n            call?.pin(sessionId);\n        }\n    };\n    const pinForEveryone = () => {\n        call\n            ?.pinForEveryone({\n            user_id: userId,\n            session_id: sessionId,\n        })\n            .catch((err) => {\n            console.error(`Failed to pin participant ${userId}`, err);\n        });\n    };\n    const unpinForEveryone = () => {\n        call\n            ?.unpinForEveryone({\n            user_id: userId,\n            session_id: sessionId,\n        })\n            .catch((err) => {\n            console.error(`Failed to unpin participant ${userId}`, err);\n        });\n    };\n    const toggleFullscreenMode = () => {\n        if (!fullscreenModeOn) {\n            return participantViewElement?.requestFullscreen().catch(console.error);\n        }\n        return document.exitFullscreen().catch(console.error);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // handles the case when fullscreen mode is toggled externally,\n        // e.g., by pressing ESC key or some other keyboard shortcut\n        const handleFullscreenChange = () => {\n            setFullscreenModeOn(!!document.fullscreenElement);\n        };\n        document.addEventListener('fullscreenchange', handleFullscreenChange);\n        return () => {\n            document.removeEventListener('fullscreenchange', handleFullscreenChange);\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoElement)\n            return;\n        const handlePiP = () => {\n            setPictureInPictureElement(document.pictureInPictureElement);\n        };\n        videoElement.addEventListener('enterpictureinpicture', handlePiP);\n        videoElement.addEventListener('leavepictureinpicture', handlePiP);\n        return () => {\n            videoElement.removeEventListener('enterpictureinpicture', handlePiP);\n            videoElement.removeEventListener('leavepictureinpicture', handlePiP);\n        };\n    }, [videoElement]);\n    const togglePictureInPicture = () => {\n        if (videoElement && pictureInPictureElement !== videoElement) {\n            return videoElement\n                .requestPictureInPicture()\n                .catch(console.error);\n        }\n        return document.exitPictureInPicture().catch(console.error);\n    };\n    const { close } = useMenuContext() || {};\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenu, { onItemClick: close, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), pin ? t('Unpin') : t('Pin')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.PIN_FOR_EVERYONE], children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), t('Pin for everyone')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), t('Unpin for everyone')] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.BLOCK_USERS], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: blockUser, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"not-allowed\" }), t('Block')] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.MUTE_USERS], children: [hasVideo && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteVideo, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"camera-off-outline\" }), t('Turn off video')] })), hasScreenShare && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShare, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"screen-share-off\" }), t('Turn off screen share')] })), hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteAudio, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"no-audio\" }), t('Mute audio')] })), hasScreenShareAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"no-audio\" }), t('Mute screen share audio')] }))] }), participantViewElement && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t('{{ direction }} fullscreen', {\n                    direction: fullscreenModeOn ? t('Leave') : t('Enter'),\n                }) })), videoElement && document.pictureInPictureEnabled && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t('{{ direction }} picture-in-picture', {\n                    direction: pictureInPictureElement === videoElement\n                        ? t('Leave')\n                        : t('Enter'),\n                }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.UPDATE_CALL_PERMISSIONS], children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO), children: t('Allow audio') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO), children: t('Allow video') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE), children: t('Allow screen sharing') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO), children: t('Disable audio') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO), children: t('Disable video') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE), children: t('Disable screen sharing') })] })] }));\n};\n\nconst useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const manager = propsDynascaleManager ?? call?.dynascaleManager;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!trackedElement || !manager || !call || trackType === 'none')\n            return;\n        const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);\n        return () => {\n            unobserve();\n        };\n    }, [trackedElement, manager, call, sessionId, trackType]);\n};\n\nconst ToggleButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"ellipsis\", ref: ref });\n});\nconst DefaultScreenShareOverlay = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const stopScreenShare = () => {\n        call?.screenShare.disable();\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__screen-share-overlay\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"screen-share-off\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__screen-share-overlay__title\", children: t('You are presenting your screen') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { onClick: stopScreenShare, className: \"str-video__screen-share-overlay__button\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"close\" }), \" \", t('Stop Screen Sharing')] })] }));\n};\nconst DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = 'bottom-start', showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu, }) => {\n    const { participant, trackType } = useParticipantViewContext();\n    const { publishedTracks } = participant;\n    const hasScreenShare = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n    if (participant.isLocalParticipant &&\n        hasScreenShare &&\n        trackType === 'screenShareTrack') {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultScreenShareOverlay, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [showMenuButton && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { strategy: \"fixed\", placement: menuPlacement, ToggleButton: ToggleButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantActionsContextMenu$1, {}) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Reaction, { participant: participant }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));\n};\nconst ParticipantDetails = ({ indicatorsVisible = true, }) => {\n    const { participant } = useParticipantViewContext();\n    const { isLocalParticipant, connectionQuality, publishedTracks, pin, sessionId, name, userId, } = participant;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const connectionQualityAsString = !!connectionQuality &&\n        _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.ConnectionQuality[connectionQuality].toLowerCase();\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const canUnpin = !!pin && pin.isLocalPin;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-details\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__participant-details__name\", children: [name || userId, indicatorsVisible && !hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-details__name--audio-muted\" })), indicatorsVisible && !hasVideo && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-details__name--video-muted\" })), indicatorsVisible && canUnpin && (\n                        // TODO: remove this monstrosity once we have a proper design\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { title: t('Unpin'), onClick: () => call?.unpin(sessionId), className: \"str-video__participant-details__name--pinned\" })), indicatorsVisible && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SpeechIndicator, {})] }) }), indicatorsVisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: isLocalParticipant &&\n                    connectionQuality === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.ConnectionQuality.POOR, message: t('Poor connection quality'), children: connectionQualityAsString && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-details__connection-quality', `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString })) }))] }));\n};\nconst SpeechIndicator = () => {\n    const { participant } = useParticipantViewContext();\n    const { isSpeaking, isDominantSpeaker } = participant;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__speech-indicator', isSpeaking && 'str-video__speech-indicator--speaking', isDominantSpeaker && 'str-video__speech-indicator--dominant'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" })] }));\n};\n\nconst ParticipantView = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ParticipantView({ participant, trackType = 'videoTrack', muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }, ref) {\n    const { isLocalParticipant, isSpeaking, isDominantSpeaker, publishedTracks, sessionId, } = participant;\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n    const [trackedElement, setTrackedElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [contextVideoElement, setContextVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    // TODO: allow to pass custom ViewportTracker instance from props\n    useTrackElementVisibility({\n        sessionId,\n        trackedElement,\n        trackType,\n    });\n    const participantViewContextValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        participant,\n        participantViewElement: trackedElement,\n        videoElement: contextVideoElement,\n        videoPlaceholderElement: contextVideoPlaceholderElement,\n        trackType,\n    }), [\n        contextVideoElement,\n        contextVideoPlaceholderElement,\n        participant,\n        trackedElement,\n        trackType,\n    ]);\n    const videoRefs = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        setVideoElement: (element) => {\n            setVideoElement?.(element);\n            setContextVideoElement(element);\n        },\n        setVideoPlaceholderElement: (element) => {\n            setVideoPlaceholderElement?.(element);\n            setContextVideoPlaceholderElement(element);\n        },\n    }), [setVideoElement, setVideoPlaceholderElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { \"data-testid\": \"participant-view\", ref: (element) => {\n            applyElementToRef(ref, element);\n            setTrackedElement(element);\n        }, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-view', isDominantSpeaker && 'str-video__participant-view--dominant-speaker', isSpeaking && 'str-video__participant-view--speaking', !hasVideo && 'str-video__participant-view--no-video', !hasAudio && 'str-video__participant-view--no-audio', className), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { participant: participant, trackType: \"audioTrack\" })), hasScreenShareAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { participant: participant, trackType: \"screenShareAudioTrack\" }))] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Video$1, { VideoPlaceholder: VideoPlaceholder, participant: participant, trackType: trackType, refs: videoRefs, autoPlay: true }), isComponentType(ParticipantViewUI) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantViewUI, {})) : (ParticipantViewUI)] }) }));\n});\n\n// re-exporting the StreamCallProvider as StreamCall\nconst StreamCall = _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamCallProvider;\n\nvar Joining = \"Joining\";\nvar Mic = \"Mic\";\nvar Ringing = \"Ringing\";\nvar Speakers = \"Speakers\";\nvar Video = \"Video\";\nvar Live = \"Live\";\nvar Reactions = \"Reactions\";\nvar Statistics = \"Statistics\";\nvar Invite = \"Invite\";\nvar Join = \"Join\";\nvar You = \"You\";\nvar Me = \"Me\";\nvar Unknown = \"Unknown\";\nvar Refresh = \"Refresh\";\nvar Allow = \"Allow\";\nvar Revoke = \"Revoke\";\nvar Dismiss = \"Dismiss\";\nvar Pinned = \"Pinned\";\nvar Unpin = \"Unpin\";\nvar Pin = \"Pin\";\nvar Block = \"Block\";\nvar Enter = \"Enter\";\nvar Leave = \"Leave\";\nvar Participants = \"Participants\";\nvar Anonymous = \", and ({{ count }}) anonymous\";\nvar en = {\n\tJoining: Joining,\n\tMic: Mic,\n\t\"No internet connection\": \"No internet connection\",\n\t\"Re-connecting\": \"Re-connecting\",\n\tRinging: Ringing,\n\t\"Screen Share\": \"Screen Share\",\n\t\"Select a Camera\": \"Select a Camera\",\n\t\"Select a Mic\": \"Select a Mic\",\n\t\"Select Speakers\": \"Select Speakers\",\n\tSpeakers: Speakers,\n\tVideo: Video,\n\t\"You are muted. Unmute to speak.\": \"You are muted. Unmute to speak.\",\n\tLive: Live,\n\t\"You can now speak.\": \"You can now speak.\",\n\t\"Awaiting for an approval to speak.\": \"Awaiting for an approval to speak.\",\n\t\"You can no longer speak.\": \"You can no longer speak.\",\n\t\"You can now share your video.\": \"You can now share your video.\",\n\t\"Awaiting for an approval to share your video.\": \"Awaiting for an approval to share your video.\",\n\t\"You can no longer share your video.\": \"You can no longer share your video.\",\n\t\"Waiting for recording to stop...\": \"Waiting for recording to stop...\",\n\t\"Waiting for recording to start...\": \"Waiting for recording to start...\",\n\t\"Record call\": \"Record call\",\n\tReactions: Reactions,\n\tStatistics: Statistics,\n\t\"You can now share your screen.\": \"You can now share your screen.\",\n\t\"Awaiting for an approval to share screen.\": \"Awaiting for an approval to share screen.\",\n\t\"You can no longer share your screen.\": \"You can no longer share your screen.\",\n\t\"Share screen\": \"Share screen\",\n\t\"Incoming Call...\": \"Incoming Call...\",\n\t\"Calling...\": \"Calling...\",\n\t\"Mute All\": \"Mute All\",\n\tInvite: Invite,\n\tJoin: Join,\n\tYou: You,\n\tMe: Me,\n\tUnknown: Unknown,\n\t\"Toggle device menu\": \"Toggle device menu\",\n\t\"Call Recordings\": \"Call Recordings\",\n\tRefresh: Refresh,\n\t\"Check your browser video permissions\": \"Check your browser video permissions\",\n\t\"Video publishing is disabled by the system\": \"Video publishing is disabled by the system\",\n\t\"You have no permission to share your video\": \"You have no permission to share your video\",\n\t\"You have no permission to share your audio\": \"You have no permission to share your audio\",\n\t\"You are presenting your screen\": \"You are presenting your screen\",\n\t\"Stop Screen Sharing\": \"Stop Screen Sharing\",\n\tAllow: Allow,\n\tRevoke: Revoke,\n\tDismiss: Dismiss,\n\t\"Microphone on\": \"Microphone on\",\n\t\"Microphone off\": \"Microphone off\",\n\t\"Camera on\": \"Camera on\",\n\t\"Camera off\": \"Camera off\",\n\t\"No camera found\": \"No camera found\",\n\t\"Video is disabled\": \"Video is disabled\",\n\tPinned: Pinned,\n\tUnpin: Unpin,\n\tPin: Pin,\n\t\"Pin for everyone\": \"Pin for everyone\",\n\t\"Unpin for everyone\": \"Unpin for everyone\",\n\tBlock: Block,\n\t\"Turn off video\": \"Turn off video\",\n\t\"Turn off screen share\": \"Turn off screen share\",\n\t\"Mute audio\": \"Mute audio\",\n\t\"Mute screen share audio\": \"Mute screen share audio\",\n\t\"Allow audio\": \"Allow audio\",\n\t\"Allow video\": \"Allow video\",\n\t\"Allow screen sharing\": \"Allow screen sharing\",\n\t\"Disable audio\": \"Disable audio\",\n\t\"Disable video\": \"Disable video\",\n\t\"Disable screen sharing\": \"Disable screen sharing\",\n\tEnter: Enter,\n\tLeave: Leave,\n\t\"Leave call\": \"Leave call\",\n\t\"End call for all\": \"End call for all\",\n\t\"{{ direction }} fullscreen\": \"{{ direction }} fullscreen\",\n\t\"{{ direction }} picture-in-picture\": \"{{ direction }} picture-in-picture\",\n\t\"Dominant Speaker\": \"Dominant Speaker\",\n\t\"Poor connection quality\": \"Poor connection quality. Please check your internet connection.\",\n\tParticipants: Participants,\n\tAnonymous: Anonymous,\n\t\"No participants found\": \"No participants found\",\n\t\"Participants ({{ numberOfParticipants }})\": \"Participants ({{ numberOfParticipants }})\",\n\t\"{{ userName }} is sharing their screen\": \"{{ userName }} is sharing their screen\",\n\t\"{{ userName }} is requesting to speak\": \"{{ userName }} is requesting to speak\",\n\t\"{{ userName }} is requesting to share their camera\": \"{{ userName }} is requesting to share their camera\",\n\t\"{{ userName }} is requesting to present their screen\": \"{{ userName }} is requesting to present their screen\",\n\t\"{{ userName }} is requesting permission: {{ permission }}\": \"{{ userName }} is requesting permission: {{ permission }}\"\n};\n\nconst translations = { en };\n\nconst StreamVideo = (props) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamVideoProvider, { translationsOverrides: translations, ...props }));\n};\n\nconst usePaginatedLayoutSortPreset = (call) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call)\n            return;\n        call.setSortParticipantsBy(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.paginatedLayoutSortPreset);\n        return () => {\n            resetSortPreset(call);\n        };\n    }, [call]);\n};\nconst useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call)\n            return;\n        // always show the remote participant in the spotlight\n        if (isOneOnOneCall) {\n            call.setSortParticipantsBy((0,_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.combineComparators)(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.screenSharing, loggedIn));\n        }\n        else {\n            call.setSortParticipantsBy(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speakerLayoutSortPreset);\n        }\n        return () => {\n            resetSortPreset(call);\n        };\n    }, [call, isOneOnOneCall]);\n};\nconst resetSortPreset = (call) => {\n    // reset the sorting to the default for the call type\n    const callConfig = _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallTypes.get(call.type);\n    call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.defaultSortPreset);\n};\nconst loggedIn = (a, b) => {\n    if (a.isLocalParticipant)\n        return 1;\n    if (b.isLocalParticipant)\n        return -1;\n    return 0;\n};\n\nconst LivestreamLayout = (props) => {\n    const { useParticipants, useRemoteParticipants, useHasOngoingScreenShare } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [currentSpeaker, ...otherParticipants] = useParticipants();\n    const remoteParticipants = useRemoteParticipants();\n    const hasOngoingScreenShare = useHasOngoingScreenShare();\n    const presenter = hasOngoingScreenShare\n        ? hasScreenShare$1(currentSpeaker) && currentSpeaker\n        : otherParticipants.find(hasScreenShare$1);\n    usePaginatedLayoutSortPreset(call);\n    const Overlay = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showSpeakerName: props.showSpeakerName }));\n    const { floatingParticipantProps } = props;\n    const FloatingParticipantOverlay = hasOngoingScreenShare && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantOverlay\n    // these elements aren't needed for the video feed\n    , { \n        // these elements aren't needed for the video feed\n        showParticipantCount: floatingParticipantProps?.showParticipantCount ?? false, showDuration: floatingParticipantProps?.showDuration ?? false, showLiveBadge: floatingParticipantProps?.showLiveBadge ?? false, showSpeakerName: floatingParticipantProps?.showSpeakerName ?? true }));\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__livestream-layout__wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { className: \"str-video__livestream-layout__screen-share\", participant: presenter, ParticipantViewUI: Overlay, trackType: \"screenShareTrack\", muteAudio // audio is rendered by ParticipantsAudio\n                : true })), currentSpeaker && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(hasOngoingScreenShare &&\n                    (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__livestream-layout__floating-participant', `str-video__livestream-layout__floating-participant--${floatingParticipantProps?.position ?? 'top-right'}`)), participant: currentSpeaker, ParticipantViewUI: FloatingParticipantOverlay || Overlay, muteAudio // audio is rendered by ParticipantsAudio\n                : true }))] }));\n};\nconst hasScreenShare$1 = (p) => !!p?.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\nconst ParticipantOverlay = (props) => {\n    const { enableFullScreen = true, showParticipantCount = true, showDuration = true, showLiveBadge = true, showSpeakerName = false, } = props;\n    const { participant } = useParticipantViewContext();\n    const { useParticipantCount } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participantCount = useParticipantCount();\n    const duration = useUpdateCallDuration();\n    const toggleFullScreen = useToggleFullScreen();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__livestream-layout__overlay\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__livestream-layout__overlay__bar\", children: [showLiveBadge && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__live-badge\", children: t('Live') })), showParticipantCount && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__viewers-count\", children: participantCount })), showSpeakerName && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__speaker-name\", title: participant.name || participant.userId || '', children: participant.name || participant.userId || '' })), showDuration && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__duration\", children: formatDuration(duration) })), enableFullScreen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__go-fullscreen\", onClick: toggleFullScreen }))] }) }));\n};\nconst useUpdateCallDuration = () => {\n    const { useIsCallLive, useCallSession } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isCallLive = useIsCallLive();\n    const session = useCallSession();\n    const [duration, setDuration] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n        if (!session || !session.live_started_at)\n            return 0;\n        const liveStartTime = new Date(session.live_started_at);\n        const now = new Date();\n        return Math.floor((now.getTime() - liveStartTime.getTime()) / 1000);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!isCallLive)\n            return;\n        const interval = setInterval(() => {\n            setDuration((d) => d + 1);\n        }, 1000);\n        return () => {\n            clearInterval(interval);\n        };\n    }, [isCallLive]);\n    return duration;\n};\nconst useToggleFullScreen = () => {\n    const { participantViewElement } = useParticipantViewContext();\n    const [isFullscreen, setIsFullscreen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n        if (isFullscreen) {\n            document.exitFullscreen().then(() => {\n                setIsFullscreen(false);\n            });\n        }\n        else {\n            participantViewElement?.requestFullscreen().then(() => {\n                setIsFullscreen(true);\n            });\n        }\n    }, [isFullscreen, participantViewElement]);\n};\nconst formatDuration = (durationInMs) => {\n    const days = Math.floor(durationInMs / 86400);\n    const hours = Math.floor(durationInMs / 3600);\n    const minutes = Math.floor((durationInMs % 3600) / 60);\n    const seconds = durationInMs % 60;\n    return `${days ? days + ' ' : ''}${hours ? hours + ':' : ''}${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\n\nconst GROUP_SIZE = 16;\nconst PaginatedGridLayoutGroup = ({ group, VideoPlaceholder, ParticipantViewUI, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__paginated-grid-layout__group', {\n            'str-video__paginated-grid-layout--one': group.length === 1,\n            'str-video__paginated-grid-layout--two-four': group.length >= 2 && group.length <= 4,\n            'str-video__paginated-grid-layout--five-nine': group.length >= 5 && group.length <= 9,\n        }), children: group.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participant, muteAudio: true, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId))) }));\n};\nconst PaginatedGridLayout = ({ groupSize = GROUP_SIZE, excludeLocalParticipant = false, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }) => {\n    const [page, setPage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(0);\n    const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement,] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useParticipants, useRemoteParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants();\n    // used to render audio elements\n    const remoteParticipants = useRemoteParticipants();\n    usePaginatedLayoutSortPreset(call);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!paginatedGridLayoutWrapperElement || !call)\n            return;\n        const cleanup = call.setViewport(paginatedGridLayoutWrapperElement);\n        return () => cleanup();\n    }, [paginatedGridLayoutWrapperElement, call]);\n    // only used to render video elements\n    const participantGroups = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => chunk(excludeLocalParticipant ? remoteParticipants : participants, groupSize), [excludeLocalParticipant, remoteParticipants, participants, groupSize]);\n    const pageCount = participantGroups.length;\n    // update page when page count is reduced and selected page no longer exists\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (page > pageCount - 1) {\n            setPage(Math.max(0, pageCount - 1));\n        }\n    }, [page, pageCount]);\n    const selectedGroup = participantGroups[page];\n    if (!call)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__paginated-grid-layout__wrapper\", ref: setPaginatedGridLayoutWrapperElement, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__paginated-grid-layout\", children: [pageArrowsVisible && pageCount > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"caret-left\", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) })), selectedGroup && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PaginatedGridLayoutGroup, { group: participantGroups[page], VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI })), pageArrowsVisible && pageCount > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: page === pageCount - 1, icon: \"caret-right\", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) }))] })] }));\n};\n\nconst useCalculateHardLimit = (\n/**\n * Element that stretches to 100% of the whole layout component\n */\nwrapperElement, \n/**\n * Element that directly hosts individual `ParticipantView` (or wrapper) elements\n */\nhostElement, limit) => {\n    const [calculatedLimit, setCalculatedLimit] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        vertical: typeof limit === 'number' ? limit : null,\n        horizontal: typeof limit === 'number' ? limit : null,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!hostElement ||\n            !wrapperElement ||\n            typeof limit === 'number' ||\n            typeof limit === 'undefined')\n            return;\n        let childWidth = null;\n        let childHeight = null;\n        const resizeObserver = new ResizeObserver((entries, observer) => {\n            // this part should ideally run as little times as possible\n            // get child measurements and disconnect\n            // does not consider dynamically sized children\n            // this hook is for SpeakerLayout use only, where children in the bar are fixed size\n            if (entries.length > 1) {\n                const child = hostElement.firstChild;\n                if (child) {\n                    childHeight = child.clientHeight;\n                    childWidth = child.clientWidth;\n                    observer.unobserve(hostElement);\n                }\n            }\n            // keep the state at { vertical: 1, horizontal: 1 }\n            // until we get the proper child measurements\n            if (childHeight === null || childWidth === null)\n                return;\n            const vertical = Math.floor(wrapperElement.clientHeight / childHeight);\n            const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);\n            setCalculatedLimit((pv) => {\n                if (pv.vertical !== vertical || pv.horizontal !== horizontal)\n                    return { vertical, horizontal };\n                return pv;\n            });\n        });\n        resizeObserver.observe(wrapperElement);\n        resizeObserver.observe(hostElement);\n        return () => {\n            resizeObserver.disconnect();\n        };\n    }, [hostElement, limit, wrapperElement]);\n    return calculatedLimit;\n};\n\nconst DefaultParticipantViewUIBar = () => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultParticipantViewUI, { menuPlacement: \"top-end\" }));\nconst DefaultParticipantViewUISpotlight = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultParticipantViewUI, {});\nconst SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUISpotlight, VideoPlaceholder, participantsBarPosition = 'bottom', participantsBarLimit, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useParticipants, useRemoteParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const [participantInSpotlight, ...otherParticipants] = useParticipants();\n    const remoteParticipants = useRemoteParticipants();\n    const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [participantsBarElement, setParticipantsBarElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [buttonsWrapperElement, setButtonsWrapperElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const isSpeakerScreenSharing = hasScreenShare(participantInSpotlight);\n    const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);\n    const isVertical = participantsBarPosition === 'left' || participantsBarPosition === 'right';\n    const isHorizontal = participantsBarPosition === 'top' || participantsBarPosition === 'bottom';\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!participantsBarWrapperElement || !call)\n            return;\n        const cleanup = call.setViewport(participantsBarWrapperElement);\n        return () => cleanup();\n    }, [participantsBarWrapperElement, call]);\n    const isOneOnOneCall = otherParticipants.length === 1;\n    useSpeakerLayoutSortPreset(call, isOneOnOneCall);\n    let participantsWithAppliedLimit = otherParticipants;\n    const hardLimitToApply = isVertical\n        ? hardLimit.vertical\n        : hardLimit.horizontal;\n    if (typeof participantsBarLimit !== 'undefined' &&\n        hardLimitToApply !== null) {\n        participantsWithAppliedLimit = otherParticipants.slice(0, \n        // subtract 1 if speaker is sharing screen as\n        // that one is rendered independently from otherParticipants array\n        hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0));\n    }\n    if (!call)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__speaker-layout__wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__speaker-layout', participantsBarPosition &&\n                    `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__spotlight\", children: participantInSpotlight && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participantInSpotlight, muteAudio: true, trackType: isSpeakerScreenSharing ? 'screenShareTrack' : 'videoTrack', ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder: VideoPlaceholder })) }), participantsWithAppliedLimit.length > 0 && participantsBarPosition && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: setButtonsWrapperElement, className: \"str-video__speaker-layout__participants-bar-buttons-wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participants-bar-wrapper\", ref: setParticipantsBarWrapperElement, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: setParticipantsBarElement, className: \"str-video__speaker-layout__participants-bar\", children: [isSpeakerScreenSharing && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participant-tile\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, muteAudio: true }) }, participantInSpotlight.sessionId)), participantsWithAppliedLimit.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participant-tile\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, muteAudio: true }) }, participant.sessionId)))] }) }), isVertical && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement })), isHorizontal && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement }))] }))] })] }));\n};\nconst HorizontalScrollButtons = ({ scrollWrapper, }) => {\n    const scrollPosition = useHorizontalScrollPosition(scrollWrapper);\n    const scrollStartClickHandler = () => {\n        scrollWrapper?.scrollBy({ left: -150, behavior: 'smooth' });\n    };\n    const scrollEndClickHandler = () => {\n        scrollWrapper?.scrollBy({ left: 150, behavior: 'smooth' });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [scrollPosition && scrollPosition !== 'start' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollStartClickHandler, icon: \"caret-left\", className: \"str-video__speaker-layout__participants-bar--button-left\" })), scrollPosition && scrollPosition !== 'end' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollEndClickHandler, icon: \"caret-right\", className: \"str-video__speaker-layout__participants-bar--button-right\" }))] }));\n};\nconst VerticalScrollButtons = ({ scrollWrapper, }) => {\n    const scrollPosition = useVerticalScrollPosition(scrollWrapper);\n    const scrollTopClickHandler = () => {\n        scrollWrapper?.scrollBy({ top: -150, behavior: 'smooth' });\n    };\n    const scrollBottomClickHandler = () => {\n        scrollWrapper?.scrollBy({ top: 150, behavior: 'smooth' });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [scrollPosition && scrollPosition !== 'top' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollTopClickHandler, icon: \"caret-up\", className: \"str-video__speaker-layout__participants-bar--button-top\" })), scrollPosition && scrollPosition !== 'bottom' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollBottomClickHandler, icon: \"caret-down\", className: \"str-video__speaker-layout__participants-bar--button-bottom\" }))] }));\n};\nconst hasScreenShare = (p) => !!p?.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n\nconst [major, minor, patch] = (\"0.6.7\" ).split('.');\n(0,_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setSdkInfo)({\n    type: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.SdkType.REACT,\n    major,\n    minor,\n    patch,\n});\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtUDtBQUMzTTtBQUNxSDtBQUM3RztBQUNRO0FBQ2tIO0FBQ2xKO0FBQ3VFO0FBQ3NLO0FBQzdLO0FBQ2pEOztBQUV2QyxpQkFBaUIsZ0RBQWdEO0FBQ2pFLGlCQUFpQix3RUFBTztBQUN4Qiw0Q0FBNEMsK0NBQVE7QUFDcEQsWUFBWSxvQkFBb0I7QUFDaEMsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHNEQUFHLFlBQVksbUlBQW1JO0FBQzlKOztBQUVBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkMsWUFBWSxzREFBRyxDQUFDLHVEQUFRLElBQUk7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixtRUFBbUU7QUFDdkYsc0RBQXNELDhEQUFTO0FBQy9ELGtFQUFrRSxzREFBRyxVQUFVLGtFQUFrRTtBQUNqSixpRUFBaUUsOERBQVM7QUFDMUU7QUFDQSwyQ0FBMkMsc0RBQUcsVUFBVSw2RUFBNkU7QUFDckksb0JBQW9CLHVEQUFJLENBQUMsMkNBQVUsSUFBSSw2REFBNkQ7QUFDcEcsU0FBUyxHQUFHO0FBQ1o7O0FBRUEsK0JBQStCLG9EQUFhO0FBQzVDLHdDQUF3QyxpREFBVTs7QUFFbEQsa0JBQWtCLDJDQUEyQztBQUM3RCw4QkFBOEIsK0NBQVE7QUFDdEMsWUFBWSx1REFBSSxDQUFDLHVEQUFRLElBQUks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QUNBLENBQUM7O0FBRTR1RDtBQUM3dUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWFtc3BhY2UvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9pbmRleC5lcy5qcz9kOWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNmdU1vZGVscywgQ2FsbGluZ1N0YXRlLCBPd25DYXBhYmlsaXR5LCBuYW1lLCBWaXNpYmlsaXR5U3RhdGUsIEJyb3dzZXJzLCBwYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0LCBjb21iaW5lQ29tcGFyYXRvcnMsIHNjcmVlblNoYXJpbmcsIHNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0LCBDYWxsVHlwZXMsIGRlZmF1bHRTb3J0UHJlc2V0LCBzZXRTZGtJbmZvIH0gZnJvbSAnQHN0cmVhbS1pby92aWRlby1jbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnQHN0cmVhbS1pby92aWRlby1jbGllbnQnO1xuaW1wb3J0IHsgdXNlQ2FsbCwgdXNlQ2FsbFN0YXRlSG9va3MsIHVzZUkxOG4sIFJlc3RyaWN0ZWQsIHVzZUNvbm5lY3RlZFVzZXIsIFN0cmVhbUNhbGxQcm92aWRlciwgU3RyZWFtVmlkZW9Qcm92aWRlciB9IGZyb20gJ0BzdHJlYW0taW8vdmlkZW8tcmVhY3QtYmluZGluZ3MnO1xuZXhwb3J0ICogZnJvbSAnQHN0cmVhbS1pby92aWRlby1yZWFjdC1iaW5kaW5ncyc7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50LCBqc3hzIH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgRnJhZ21lbnQgYXMgRnJhZ21lbnQkMSwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlTWVtbywgZm9yd2FyZFJlZiwgaXNWYWxpZEVsZW1lbnQsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybVN1cHBvcnRlZCwgbG9hZFRGTGl0ZSwgY3JlYXRlUmVuZGVyZXIgfSBmcm9tICdAc3RyZWFtLWlvL3ZpZGVvLWZpbHRlcnMtd2ViJztcbmltcG9ydCB7IHVzZUZsb2F0aW5nLCBvZmZzZXQsIHNoaWZ0LCBmbGlwLCBzaXplLCBhdXRvVXBkYXRlLCBGbG9hdGluZ092ZXJsYXksIEZsb2F0aW5nUG9ydGFsLCB1c2VMaXN0SXRlbSwgdXNlTGlzdE5hdmlnYXRpb24sIHVzZVR5cGVhaGVhZCwgdXNlQ2xpY2ssIHVzZURpc21pc3MsIHVzZVJvbGUsIHVzZUludGVyYWN0aW9ucywgRmxvYXRpbmdGb2N1c01hbmFnZXIsIEZsb2F0aW5nTGlzdCwgdXNlSG92ZXIgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QnO1xuaW1wb3J0IHsgQ2hhcnQsIENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBMaW5lRWxlbWVudCwgUG9pbnRFbGVtZW50IH0gZnJvbSAnY2hhcnQuanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJ3JlYWN0LWNoYXJ0anMtMic7XG5cbmNvbnN0IEF1ZGlvID0gKHsgcGFydGljaXBhbnQsIHRyYWNrVHlwZSA9ICdhdWRpb1RyYWNrJywgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBbYXVkaW9FbGVtZW50LCBzZXRBdWRpb0VsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyB1c2VySWQsIHNlc3Npb25JZCB9ID0gcGFydGljaXBhbnQ7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsIHx8ICFhdWRpb0VsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBjYWxsLmJpbmRBdWRpb0VsZW1lbnQoYXVkaW9FbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwPy4oKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY2FsbCwgc2Vzc2lvbklkLCBhdWRpb0VsZW1lbnQsIHRyYWNrVHlwZV0pO1xuICAgIHJldHVybiAoanN4KFwiYXVkaW9cIiwgeyBhdXRvUGxheTogdHJ1ZSwgLi4ucmVzdCwgcmVmOiBzZXRBdWRpb0VsZW1lbnQsIFwiZGF0YS11c2VyLWlkXCI6IHVzZXJJZCwgXCJkYXRhLXNlc3Npb24taWRcIjogc2Vzc2lvbklkLCBcImRhdGEtdHJhY2stdHlwZVwiOiB0cmFja1R5cGUgfSkpO1xufTtcblxuY29uc3QgUGFydGljaXBhbnRzQXVkaW8gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50cywgYXVkaW9Qcm9wcyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IHBhcnRpY2lwYW50cy5tYXAoKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgeyBwdWJsaXNoZWRUcmFja3MsIGF1ZGlvU3RyZWFtLCBzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtLCBzZXNzaW9uSWQsIH0gPSBwYXJ0aWNpcGFudDtcbiAgICAgICAgICAgIGNvbnN0IGhhc0F1ZGlvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuQVVESU8pO1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja0VsZW1lbnQgPSBoYXNBdWRpbyAmJiBhdWRpb1N0cmVhbSAmJiAoanN4KEF1ZGlvLCB7IC4uLmF1ZGlvUHJvcHMsIHRyYWNrVHlwZTogXCJhdWRpb1RyYWNrXCIsIHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCB9KSk7XG4gICAgICAgICAgICBjb25zdCBoYXNTY3JlZW5TaGFyZUF1ZGlvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmVlblNoYXJlQXVkaW9UcmFja0VsZW1lbnQgPSBoYXNTY3JlZW5TaGFyZUF1ZGlvICYmXG4gICAgICAgICAgICAgICAgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbSAmJiAoanN4KEF1ZGlvLCB7IC4uLmF1ZGlvUHJvcHMsIHRyYWNrVHlwZTogXCJzY3JlZW5TaGFyZUF1ZGlvVHJhY2tcIiwgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50IH0pKTtcbiAgICAgICAgICAgIHJldHVybiAoanN4cyhGcmFnbWVudCQxLCB7IGNoaWxkcmVuOiBbYXVkaW9UcmFja0VsZW1lbnQsIHNjcmVlblNoYXJlQXVkaW9UcmFja0VsZW1lbnRdIH0sIHNlc3Npb25JZCkpO1xuICAgICAgICB9KSB9KSk7XG59O1xuXG5jb25zdCBQYXJ0aWNpcGFudFZpZXdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgdXNlUGFydGljaXBhbnRWaWV3Q29udGV4dCA9ICgpID0+IHVzZUNvbnRleHQoUGFydGljaXBhbnRWaWV3Q29udGV4dCk7XG5cbmNvbnN0IEF2YXRhciA9ICh7IGltYWdlU3JjLCBuYW1lLCBzdHlsZSwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pID0+IHtcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFsoIWltYWdlU3JjIHx8IGVycm9yKSAmJiBuYW1lICYmIChqc3goQXZhdGFyRmFsbGJhY2ssIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHN0eWxlOiBzdHlsZSwgbmFtZXM6IFtuYW1lXSB9KSksIGltYWdlU3JjICYmICFlcnJvciAmJiAoanN4KFwiaW1nXCIsIHsgb25FcnJvcjogKCkgPT4gc2V0RXJyb3IodHJ1ZSksIGFsdDogXCJhdmF0YXJcIiwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2F2YXRhcicsIGNsYXNzTmFtZSksIHNyYzogaW1hZ2VTcmMsIHN0eWxlOiBzdHlsZSwgLi4ucmVzdCB9KSldIH0pKTtcbn07XG5jb25zdCBBdmF0YXJGYWxsYmFjayA9ICh7IGNsYXNzTmFtZSwgbmFtZXMsIHN0eWxlLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fYXZhdGFyLS1pbml0aWFscy1mYWxsYmFjaycsIGNsYXNzTmFtZSksIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgeyBjaGlsZHJlbjogW25hbWVzWzBdWzBdLCBuYW1lc1sxXT8uWzBdXSB9KSB9KSk7XG59O1xuXG4vKipcbiAqIFRoZSBjb250ZXh0IGZvciB0aGUgYmFja2dyb3VuZCBmaWx0ZXJzLlxuICovXG5jb25zdCBCYWNrZ3JvdW5kRmlsdGVyc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKipcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIGJhY2tncm91bmQgZmlsdGVycyBjb250ZXh0IEFQSS5cbiAqL1xuY29uc3QgdXNlQmFja2dyb3VuZEZpbHRlcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQmFja2dyb3VuZEZpbHRlcnNDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VCYWNrZ3JvdW5kRmlsdGVycyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmFja2dyb3VuZEZpbHRlcnNQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn07XG4vKipcbiAqIEEgcHJvdmlkZXIgY29tcG9uZW50IHRoYXQgZW5hYmxlcyB0aGUgdXNlIG9mIGJhY2tncm91bmQgZmlsdGVycyBpbiB5b3VyIGFwcC5cbiAqXG4gKiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIHRoZSBgQHN0cmVhbS1pby92aWRlby1maWx0ZXJzLXdlYmAgcGFja2FnZSBpbnN0YWxsZWRcbiAqIGluIHlvdXIgcHJvamVjdCBiZWZvcmUgdXNpbmcgdGhpcyBjb21wb25lbnQuXG4gKi9cbmNvbnN0IEJhY2tncm91bmRGaWx0ZXJzUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBpc0JsdXJyaW5nRW5hYmxlZCA9IHRydWUsIGJhY2tncm91bmRJbWFnZXMgPSBbXSwgYmFja2dyb3VuZEZpbHRlcjogYmdGaWx0ZXJGcm9tUHJvcHMgPSB1bmRlZmluZWQsIGJhY2tncm91bmRJbWFnZTogYmdJbWFnZUZyb21Qcm9wcyA9IHVuZGVmaW5lZCwgYmFja2dyb3VuZEJsdXJMZXZlbDogYmdCbHVyTGV2ZWxGcm9tUHJvcHMgPSAnaGlnaCcsIHRmRmlsZVBhdGgsIG1vZGVsRmlsZVBhdGgsIGJhc2VQYXRoLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2JhY2tncm91bmRGaWx0ZXIsIHNldEJhY2tncm91bmRGaWx0ZXJdID0gdXNlU3RhdGUoYmdGaWx0ZXJGcm9tUHJvcHMpO1xuICAgIGNvbnN0IFtiYWNrZ3JvdW5kSW1hZ2UsIHNldEJhY2tncm91bmRJbWFnZV0gPSB1c2VTdGF0ZShiZ0ltYWdlRnJvbVByb3BzKTtcbiAgICBjb25zdCBbYmFja2dyb3VuZEJsdXJMZXZlbCwgc2V0QmFja2dyb3VuZEJsdXJMZXZlbF0gPSB1c2VTdGF0ZShiZ0JsdXJMZXZlbEZyb21Qcm9wcyk7XG4gICAgY29uc3QgYXBwbHlCYWNrZ3JvdW5kSW1hZ2VGaWx0ZXIgPSB1c2VDYWxsYmFjaygoaW1hZ2VVcmwpID0+IHtcbiAgICAgICAgc2V0QmFja2dyb3VuZEZpbHRlcignaW1hZ2UnKTtcbiAgICAgICAgc2V0QmFja2dyb3VuZEltYWdlKGltYWdlVXJsKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgYXBwbHlCYWNrZ3JvdW5kQmx1ckZpbHRlciA9IHVzZUNhbGxiYWNrKChibHVyTGV2ZWwgPSAnaGlnaCcpID0+IHtcbiAgICAgICAgc2V0QmFja2dyb3VuZEZpbHRlcignYmx1cicpO1xuICAgICAgICBzZXRCYWNrZ3JvdW5kQmx1ckxldmVsKGJsdXJMZXZlbCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGRpc2FibGVCYWNrZ3JvdW5kRmlsdGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRCYWNrZ3JvdW5kRmlsdGVyKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldEJhY2tncm91bmRJbWFnZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRCYWNrZ3JvdW5kQmx1ckxldmVsKCdoaWdoJyk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IFtpc1N1cHBvcnRlZCwgc2V0SXNTdXBwb3J0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzUGxhdGZvcm1TdXBwb3J0ZWQoKS50aGVuKHNldElzU3VwcG9ydGVkKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgW3RmTGl0ZSwgc2V0VGZMaXRlXSA9IHVzZVN0YXRlKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gZG9uJ3QgdHJ5IHRvIGxvYWQgVEZMaXRlIGlmIHRoZSBwbGF0Zm9ybSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIGlmICghaXNTdXBwb3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxvYWRURkxpdGUoeyBiYXNlUGF0aCwgbW9kZWxGaWxlUGF0aCwgdGZGaWxlUGF0aCB9KVxuICAgICAgICAgICAgLnRoZW4oc2V0VGZMaXRlKVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIFRGTGl0ZScsIGVycikpO1xuICAgIH0sIFtiYXNlUGF0aCwgaXNTdXBwb3J0ZWQsIG1vZGVsRmlsZVBhdGgsIHRmRmlsZVBhdGhdKTtcbiAgICByZXR1cm4gKGpzeHMoQmFja2dyb3VuZEZpbHRlcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7XG4gICAgICAgICAgICBpc1N1cHBvcnRlZCxcbiAgICAgICAgICAgIGlzUmVhZHk6ICEhdGZMaXRlLFxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlLFxuICAgICAgICAgICAgYmFja2dyb3VuZEJsdXJMZXZlbCxcbiAgICAgICAgICAgIGJhY2tncm91bmRGaWx0ZXIsXG4gICAgICAgICAgICBkaXNhYmxlQmFja2dyb3VuZEZpbHRlcixcbiAgICAgICAgICAgIGFwcGx5QmFja2dyb3VuZEJsdXJGaWx0ZXIsXG4gICAgICAgICAgICBhcHBseUJhY2tncm91bmRJbWFnZUZpbHRlcixcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZXMsXG4gICAgICAgICAgICBpc0JsdXJyaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIHRmRmlsZVBhdGgsXG4gICAgICAgICAgICBtb2RlbEZpbGVQYXRoLFxuICAgICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBbY2hpbGRyZW4sIHRmTGl0ZSAmJiBiYWNrZ3JvdW5kRmlsdGVyICYmIGpzeChCYWNrZ3JvdW5kRmlsdGVycywgeyB0ZkxpdGU6IHRmTGl0ZSB9KV0gfSkpO1xufTtcbmNvbnN0IEJhY2tncm91bmRGaWx0ZXJzID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB0ZkxpdGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kSW1hZ2UsIGJhY2tncm91bmRGaWx0ZXIgfSA9IHVzZUJhY2tncm91bmRGaWx0ZXJzKCk7XG4gICAgY29uc3QgW3ZpZGVvUmVmLCBzZXRWaWRlb1JlZl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbYmdJbWFnZVJlZiwgc2V0QmdJbWFnZVJlZl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY2FudmFzUmVmLCBzZXRDYW52YXNSZWZdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3dpZHRoLCBzZXRXaWR0aF0gPSB1c2VTdGF0ZSgxOTIwKTtcbiAgICBjb25zdCBbaGVpZ2h0LCBzZXRIZWlnaHRdID0gdXNlU3RhdGUoMTA4MCk7XG4gICAgY29uc3QgcmVzb2x2ZUZpbHRlclJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IFttZWRpYVN0cmVhbSwgc2V0TWVkaWFTdHJlYW1dID0gdXNlU3RhdGUoKTtcbiAgICBjb25zdCByZWdpc3RlckZpbHRlclJlZiA9IHVzZVJlZihQcm9taXNlLnJlc29sdmUoYXN5bmMgKCkgPT4geyB9KSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsIHx8ICFiYWNrZ3JvdW5kRmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZWdpc3RlckZpbHRlclJlZi5jdXJyZW50ID0gcmVnaXN0ZXJGaWx0ZXJSZWYuY3VycmVudC50aGVuKCgpID0+IGNhbGwuY2FtZXJhLnJlZ2lzdGVyRmlsdGVyKGFzeW5jIChtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0TWVkaWFTdHJlYW0obXMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaWx0ZXJSZWYuY3VycmVudCA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVnaXN0ZXJGaWx0ZXJSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIC50aGVuKCh1bnJlZ2lzdGVyKSA9PiB1bnJlZ2lzdGVyKCkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gc2V0TWVkaWFTdHJlYW0odW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVucmVnaXN0ZXIgZmlsdGVyJywgZXJyKSk7XG4gICAgICAgIH07XG4gICAgfSwgW2JhY2tncm91bmRGaWx0ZXIsIGNhbGxdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1lZGlhU3RyZWFtIHx8ICF2aWRlb1JlZiB8fCAhY2FudmFzUmVmKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVPblBsYXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbdHJhY2tdID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGg6IHcgPSAwLCBoZWlnaHQ6IGggPSAwIH0gPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHNldFdpZHRoKHcpO1xuICAgICAgICAgICAgICAgIHNldEhlaWdodChoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVGaWx0ZXIgPSByZXNvbHZlRmlsdGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVGaWx0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gY2FudmFzUmVmLmNhcHR1cmVTdHJlYW0oKTtcbiAgICAgICAgICAgIHJlc29sdmVGaWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmlkZW9SZWYuYWRkRXZlbnRMaXN0ZW5lcigncGxheScsIGhhbmRsZU9uUGxheSk7XG4gICAgICAgIHZpZGVvUmVmLnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgICAgICB2aWRlb1JlZi5wbGF5KCkuY2F0Y2goKGVycikgPT4gY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBsYXkgdmlkZW8nLCBlcnIpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvUmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXknLCBoYW5kbGVPblBsYXkpO1xuICAgICAgICAgICAgdmlkZW9SZWYuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LCBbY2FudmFzUmVmLCBtZWRpYVN0cmVhbSwgdmlkZW9SZWZdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19iYWNrZ3JvdW5kLWZpbHRlcnNcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgICAgICAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBbbWVkaWFTdHJlYW0gJiYgKGpzeChSZW5kZXJQaXBlbGluZSwgeyB0ZkxpdGU6IHRmTGl0ZSwgdmlkZW9SZWY6IHZpZGVvUmVmLCBjYW52YXNSZWY6IGNhbnZhc1JlZiwgYmFja2dyb3VuZEltYWdlUmVmOiBiZ0ltYWdlUmVmIH0pKSwganN4KFwidmlkZW9cIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fYmFja2dyb3VuZC1maWx0ZXJzX192aWRlbycsIGhlaWdodCA+IHdpZHRoICYmICdzdHItdmlkZW9fX2JhY2tncm91bmQtZmlsdGVyc19fdmlkZW8tLXRhbGwnKSwgcmVmOiBzZXRWaWRlb1JlZiwgYXV0b1BsYXk6IHRydWUsIHBsYXlzSW5saW5lOiB0cnVlLCBjb250cm9sczogZmFsc2UsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIG11dGVkOiB0cnVlLCBsb29wOiB0cnVlIH0pLCBiYWNrZ3JvdW5kSW1hZ2UgJiYgKGpzeChcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2JhY2tncm91bmQtZmlsdGVyc19fYmFja2dyb3VuZC1pbWFnZVwiLCBhbHQ6IFwiQmFja2dyb3VuZFwiLCByZWY6IHNldEJnSW1hZ2VSZWYsIHNyYzogYmFja2dyb3VuZEltYWdlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIGJhY2tncm91bmRJbWFnZSkpLCBqc3goXCJjYW52YXNcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19iYWNrZ3JvdW5kLWZpbHRlcnNfX3RhcmdldC1jYW52YXNcIiwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgcmVmOiBzZXRDYW52YXNSZWYgfSwgYGtleS0ke3dpZHRofSR7aGVpZ2h0fWApXSB9KSk7XG59O1xuY29uc3QgUmVuZGVyUGlwZWxpbmUgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHRmTGl0ZSwgdmlkZW9SZWYsIGNhbnZhc1JlZiwgYmFja2dyb3VuZEltYWdlUmVmIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGJhY2tncm91bmRGaWx0ZXIsIGJhY2tncm91bmRCbHVyTGV2ZWwgfSA9IHVzZUJhY2tncm91bmRGaWx0ZXJzKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF2aWRlb1JlZiB8fCAhY2FudmFzUmVmIHx8ICFiYWNrZ3JvdW5kRmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYmFja2dyb3VuZEZpbHRlciA9PT0gJ2ltYWdlJyAmJiAhYmFja2dyb3VuZEltYWdlUmVmKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHRmTGl0ZSwgdmlkZW9SZWYsIGNhbnZhc1JlZiwge1xuICAgICAgICAgICAgYmFja2dyb3VuZEZpbHRlcixcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYmFja2dyb3VuZEltYWdlUmVmID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJhY2tncm91bmRCbHVyTGV2ZWwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgYmFja2dyb3VuZEJsdXJMZXZlbCxcbiAgICAgICAgYmFja2dyb3VuZEZpbHRlcixcbiAgICAgICAgYmFja2dyb3VuZEltYWdlUmVmLFxuICAgICAgICBjYW52YXNSZWYsXG4gICAgICAgIHRmTGl0ZSxcbiAgICAgICAgdmlkZW9SZWYsXG4gICAgXSk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCB1c2VGbG9hdGluZ1VJUHJlc2V0ID0gKHsgcGxhY2VtZW50LCBzdHJhdGVneSwgb2Zmc2V0OiBvZmZzZXRJblB4ID0gMTAsIH0pID0+IHtcbiAgICBjb25zdCB7IHJlZnMsIHgsIHksIHVwZGF0ZSwgZWxlbWVudHM6IHsgZG9tUmVmZXJlbmNlLCBmbG9hdGluZyB9LCB9ID0gdXNlRmxvYXRpbmcoe1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgICAgICBvZmZzZXQob2Zmc2V0SW5QeCksXG4gICAgICAgICAgICBzaGlmdCgpLFxuICAgICAgICAgICAgZmxpcCgpLFxuICAgICAgICAgICAgc2l6ZSh7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogMTAsXG4gICAgICAgICAgICAgICAgYXBwbHk6ICh7IGF2YWlsYWJsZUhlaWdodCwgZWxlbWVudHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnRzLmZsb2F0aW5nLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IGAke2F2YWlsYWJsZUhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICB9KTtcbiAgICAvLyBoYW5kbGUgd2luZG93IHJlc2l6aW5nXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkb21SZWZlcmVuY2UgfHwgIWZsb2F0aW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gYXV0b1VwZGF0ZShkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYW51cCgpO1xuICAgIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGVdKTtcbiAgICByZXR1cm4geyByZWZzLCB4LCB5LCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBzdHJhdGVneSB9O1xufTtcblxuLyoqXG4gKiBUaGlzIGhvb2sgd2lsbCBwZXJzaXN0IHRoZSBkZXZpY2Ugc2V0dGluZ3MgdG8gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGZvciBsb2NhbCBzdG9yYWdlLlxuICovXG5jb25zdCB1c2VQZXJzaXN0RGV2aWNlUHJlZmVyZW5jZXMgPSAoa2V5KSA9PiB7XG4gICAgY29uc3QgeyB1c2VNaWNyb3Bob25lU3RhdGUsIHVzZUNhbWVyYVN0YXRlLCB1c2VTcGVha2VyU3RhdGUsIHVzZUNhbGxTZXR0aW5ncywgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBtaWMgPSB1c2VNaWNyb3Bob25lU3RhdGUoKTtcbiAgICBjb25zdCBjYW1lcmEgPSB1c2VDYW1lcmFTdGF0ZSgpO1xuICAgIGNvbnN0IHNwZWFrZXIgPSB1c2VTcGVha2VyU3RhdGUoKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHVzZUNhbGxTZXR0aW5ncygpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbCB8fCAhc2V0dGluZ3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjYWxsLnN0YXRlLmNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkxFRlQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYXNQcmVmZXJlbmNlcyA9ICEhd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBjb25zdCB7IGF1ZGlvLCB2aWRlbyB9ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0RGV2aWNlID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgY29uc3QgcHJlZmVyZW5jZXMgPSB7XG4gICAgICAgICAgICAgICAgbWljOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRGV2aWNlSWQ6IG1pYy5zZWxlY3RlZERldmljZSB8fCBkZWZhdWx0RGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBtdXRlZDogaGFzUHJlZmVyZW5jZXMgPyBtaWMuaXNNdXRlIDogIWF1ZGlvLm1pY19kZWZhdWx0X29uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FtZXJhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRGV2aWNlSWQ6IGNhbWVyYS5zZWxlY3RlZERldmljZSB8fCBkZWZhdWx0RGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBtdXRlZDogaGFzUHJlZmVyZW5jZXMgPyBjYW1lcmEuaXNNdXRlIDogIXZpZGVvLmNhbWVyYV9kZWZhdWx0X29uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3BlYWtlcjoge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZERldmljZUlkOiBzcGVha2VyLnNlbGVjdGVkRGV2aWNlIHx8IGRlZmF1bHREZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgIG11dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHByZWZlcmVuY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBkZXZpY2UgcHJlZmVyZW5jZXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBjYWxsLFxuICAgICAgICBjYW1lcmEuaXNNdXRlLFxuICAgICAgICBjYW1lcmEuc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgIGtleSxcbiAgICAgICAgbWljLmlzTXV0ZSxcbiAgICAgICAgbWljLnNlbGVjdGVkRGV2aWNlLFxuICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgc3BlYWtlci5zZWxlY3RlZERldmljZSxcbiAgICBdKTtcbn07XG4vKipcbiAqIFRoaXMgaG9vayB3aWxsIGFwcGx5IHRoZSBkZXZpY2Ugc2V0dGluZ3MgZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UgZm9yIGxvY2FsIHN0b3JhZ2UuXG4gKi9cbmNvbnN0IHVzZUFwcGx5RGV2aWNlUHJlZmVyZW5jZXMgPSAoa2V5KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxTZXR0aW5ncyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHVzZUNhbGxTZXR0aW5ncygpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbCB8fCAhc2V0dGluZ3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGFwcGx5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5pdE1pYyA9IGFzeW5jIChzZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5taWNyb3Bob25lLnNlbGVjdChzZXR0aW5nLnNlbGVjdGVkRGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLm1pY3JvcGhvbmUuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRDYW1lcmEgPSBhc3luYyAoc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLnNlbGVjdChzZXR0aW5nLnNlbGVjdGVkRGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpbml0U3BlYWtlciA9IChzZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbC5zcGVha2VyLnNlbGVjdChzZXR0aW5nLnNlbGVjdGVkRGV2aWNlSWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwcmVmZXJlbmNlcyA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzID0gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBkZXZpY2UgcHJlZmVyZW5jZXMnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaW5pdE1pYyhwcmVmZXJlbmNlcy5taWMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGluaXRDYW1lcmEocHJlZmVyZW5jZXMuY2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpbml0U3BlYWtlcihwcmVmZXJlbmNlcy5zcGVha2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXVkaW8sIHZpZGVvIH0gPSBzZXR0aW5ncztcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW8ubWljX2RlZmF1bHRfb24pXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8uY2FtZXJhX2RlZmF1bHRfb24pXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhcHBseSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGFwcGx5IGRldmljZSBwcmVmZXJlbmNlcycsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIFtjYWxsLCBrZXksIHNldHRpbmdzXSk7XG59O1xuLyoqXG4gKiBUaGlzIGhvb2sgd2lsbCBhcHBseSBhbmQgcGVyc2lzdCB0aGUgZGV2aWNlIHByZWZlcmVuY2VzIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGZvciBsb2NhbCBzdG9yYWdlLlxuICovXG5jb25zdCB1c2VQZXJzaXN0ZWREZXZpY2VQcmVmZXJlbmNlcyA9IChrZXkgPSAnQHN0cmVhbS1pby9kZXZpY2UtcHJlZmVyZW5jZXMnKSA9PiB7XG4gICAgdXNlQXBwbHlEZXZpY2VQcmVmZXJlbmNlcyhrZXkpO1xuICAgIHVzZVBlcnNpc3REZXZpY2VQcmVmZXJlbmNlcyhrZXkpO1xufTtcblxuY29uc3QgU0NST0xMX1RIUkVTSE9MRCA9IDEwO1xuLyoqXG4gKiBIb29rIHdoaWNoIG9ic2VydmVzIGVsZW1lbnQncyBzY3JvbGwgcG9zaXRpb24gYW5kIHJldHVybnMgdGV4dCB2YWx1ZSBiYXNlZCBvbiB0aGVcbiAqIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGxiYXIgKGB0b3BgLCBgYm90dG9tYCwgYGJldHdlZW5gIGFuZCBgbnVsbGAgaWYgbm8gc2Nyb2xsYmFyIGlzIGF2YWlsYWJsZSlcbiAqL1xuY29uc3QgdXNlVmVydGljYWxTY3JvbGxQb3NpdGlvbiA9IChzY3JvbGxFbGVtZW50LCB0aHJlc2hvbGQgPSBTQ1JPTExfVEhSRVNIT0xEKSA9PiB7XG4gICAgY29uc3QgW3Njcm9sbFBvc2l0aW9uLCBzZXRTY3JvbGxQb3NpdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXNjcm9sbEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGhhc1ZlcnRpY2FsU2Nyb2xsYmFyID0gZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGlmICghaGFzVmVydGljYWxTY3JvbGxiYXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFNjcm9sbFBvc2l0aW9uKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgaXNBdFRoZVRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wIDw9IHRocmVzaG9sZDtcbiAgICAgICAgICAgIGlmIChpc0F0VGhlVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbigndG9wJyk7XG4gICAgICAgICAgICBjb25zdCBpc0F0VGhlQm90dG9tID0gTWF0aC5hYnMoZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBlbGVtZW50LnNjcm9sbFRvcCAtIGVsZW1lbnQuY2xpZW50SGVpZ2h0KSA8PSB0aHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoaXNBdFRoZUJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0U2Nyb2xsUG9zaXRpb24oJ2JvdHRvbScpO1xuICAgICAgICAgICAgc2V0U2Nyb2xsUG9zaXRpb24oJ2JldHdlZW4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgIHNjcm9sbEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzY3JvbGxFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtzY3JvbGxFbGVtZW50LCB0aHJlc2hvbGRdKTtcbiAgICByZXR1cm4gc2Nyb2xsUG9zaXRpb247XG59O1xuY29uc3QgdXNlSG9yaXpvbnRhbFNjcm9sbFBvc2l0aW9uID0gKHNjcm9sbEVsZW1lbnQsIHRocmVzaG9sZCA9IFNDUk9MTF9USFJFU0hPTEQpID0+IHtcbiAgICBjb25zdCBbc2Nyb2xsUG9zaXRpb24sIHNldFNjcm9sbFBvc2l0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc2Nyb2xsRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2Nyb2xsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgaGFzSG9yaXpvbnRhbFNjcm9sbGJhciA9IGVsZW1lbnQuc2Nyb2xsV2lkdGggPiBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgaWYgKCFoYXNIb3Jpem9udGFsU2Nyb2xsYmFyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbihudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQXRUaGVTdGFydCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCA8PSB0aHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoaXNBdFRoZVN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbignc3RhcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQXRUaGVFbmQgPSBNYXRoLmFicyhlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5zY3JvbGxMZWZ0IC0gZWxlbWVudC5jbGllbnRXaWR0aCkgPD0gdGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKGlzQXRUaGVFbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFNjcm9sbFBvc2l0aW9uKCdlbmQnKTtcbiAgICAgICAgICAgIHNldFNjcm9sbFBvc2l0aW9uKCdiZXR3ZWVuJyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHNjcm9sbEVsZW1lbnQpO1xuICAgICAgICBzY3JvbGxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbc2Nyb2xsRWxlbWVudCwgdGhyZXNob2xkXSk7XG4gICAgcmV0dXJuIHNjcm9sbFBvc2l0aW9uO1xufTtcblxuY29uc3QgdXNlVG9nZ2xlQ2FsbFJlY29yZGluZyA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzID0gdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcygpO1xuICAgIGNvbnN0IFtpc0F3YWl0aW5nUmVzcG9uc2UsIHNldElzQXdhaXRpbmdSZXNwb25zZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gVE9ETzogYWRkIHBlcm1pc3Npb25zXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gd2Ugd2FpdCB1bnRpbCBjYWxsLnJlY29yZGluZ19zdGFydGVkL3N0b3BwZWQgZXZlbnQgdG8gZmxpcHMgdGhlXG4gICAgICAgIC8vIGBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzYCBzdGF0ZSB2YXJpYWJsZS5cbiAgICAgICAgLy8gT25jZSB0aGUgZmxpcCBoYXBwZW5zLCB3ZSByZW1vdmUgdGhlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgIHNldElzQXdhaXRpbmdSZXNwb25zZSgoaXNBd2FpdGluZykgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQXdhaXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGlzQXdhaXRpbmc7XG4gICAgICAgIH0pO1xuICAgIH0sIFtpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXSk7XG4gICAgY29uc3QgdG9nZ2xlQ2FsbFJlY29yZGluZyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldElzQXdhaXRpbmdSZXNwb25zZSh0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbD8uc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbD8uc3RhcnRSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHN0YXJ0IHJlY29yZGluZ2AsIGUpO1xuICAgICAgICB9XG4gICAgfSwgW2NhbGwsIGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3NdKTtcbiAgICByZXR1cm4geyB0b2dnbGVDYWxsUmVjb3JkaW5nLCBpc0F3YWl0aW5nUmVzcG9uc2UsIGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MgfTtcbn07XG5cbmNvbnN0IHVzZVJlcXVlc3RQZXJtaXNzaW9uID0gKHBlcm1pc3Npb24pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlSGFzUGVybWlzc2lvbnMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IHVzZUhhc1Blcm1pc3Npb25zKHBlcm1pc3Npb24pO1xuICAgIGNvbnN0IFtpc0F3YWl0aW5nUGVybWlzc2lvbiwgc2V0SXNBd2FpdGluZ1Blcm1pc3Npb25dID0gdXNlU3RhdGUoZmFsc2UpOyAvLyBUT0RPOiBsb2FkIHdpdGggcG9zc2libHkgcGVuZGluZyBzdGF0ZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4gc2V0SXNBd2FpdGluZ1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICBpZiAoaGFzUGVybWlzc2lvbilcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgfSwgW2hhc1Blcm1pc3Npb25dKTtcbiAgICBjb25zdCByZXF1ZXN0UGVybWlzc2lvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGhhc1Blcm1pc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgY2FuUmVxdWVzdFBlcm1pc3Npb24gPSAhIWNhbGw/LnBlcm1pc3Npb25zQ29udGV4dC5jYW5SZXF1ZXN0KHBlcm1pc3Npb24pO1xuICAgICAgICBpZiAoaXNBd2FpdGluZ1Blcm1pc3Npb24gfHwgIWNhblJlcXVlc3RQZXJtaXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzZXRJc0F3YWl0aW5nUGVybWlzc2lvbih0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGw/LnJlcXVlc3RQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IFtwZXJtaXNzaW9uXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgc2V0SXNBd2FpdGluZ1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXF1ZXN0UGVybWlzc2lvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFtjYWxsLCBoYXNQZXJtaXNzaW9uLCBpc0F3YWl0aW5nUGVybWlzc2lvbiwgcGVybWlzc2lvbl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uLFxuICAgICAgICBoYXNQZXJtaXNzaW9uLFxuICAgICAgICBjYW5SZXF1ZXN0UGVybWlzc2lvbjogISFjYWxsPy5wZXJtaXNzaW9uc0NvbnRleHQuY2FuUmVxdWVzdChwZXJtaXNzaW9uKSxcbiAgICAgICAgaXNBd2FpdGluZ1Blcm1pc3Npb24sXG4gICAgfTtcbn07XG5cbnZhciBNZW51VmlzdWFsVHlwZTtcbihmdW5jdGlvbiAoTWVudVZpc3VhbFR5cGUpIHtcbiAgICBNZW51VmlzdWFsVHlwZVtcIlBPUlRBTFwiXSA9IFwicG9ydGFsXCI7XG4gICAgTWVudVZpc3VhbFR5cGVbXCJNRU5VXCJdID0gXCJtZW51XCI7XG59KShNZW51VmlzdWFsVHlwZSB8fCAoTWVudVZpc3VhbFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBVc2VkIHRvIHByb3ZpZGUgdXRpbGl0eSBBUElzIHRvIHRoZSBjb21wb25lbnRzIHJlbmRlcmVkIGluc2lkZSB0aGUgcG9ydGFsLlxuICovXG5jb25zdCBNZW51Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuLyoqXG4gKiBBY2Nlc3MgdG8gdGhlIGNsb3NlcyBNZW51Q29udGV4dC5cbiAqL1xuY29uc3QgdXNlTWVudUNvbnRleHQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoTWVudUNvbnRleHQpO1xufTtcbmNvbnN0IE1lbnVQb3J0YWwgPSAoeyBjaGlsZHJlbiwgcmVmcywgfSkgPT4ge1xuICAgIGNvbnN0IHBvcnRhbElkID0gdXNlTWVtbygoKSA9PiBgc3RyLXZpZGVvLXBvcnRhbC0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gLCBbXSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgaWQ6IHBvcnRhbElkLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wb3J0YWxcIiB9KSwganN4KEZsb2F0aW5nT3ZlcmxheSwgeyBjaGlsZHJlbjoganN4KEZsb2F0aW5nUG9ydGFsLCB7IGlkOiBwb3J0YWxJZCwgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BvcnRhbC1jb250ZW50XCIsIHJlZjogcmVmcy5zZXRGbG9hdGluZywgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pIH0pXSB9KSk7XG59O1xuY29uc3QgTWVudVRvZ2dsZSA9ICh7IFRvZ2dsZUJ1dHRvbiwgcGxhY2VtZW50ID0gJ3RvcC1zdGFydCcsIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJywgb2Zmc2V0LCB2aXN1YWxUeXBlID0gTWVudVZpc3VhbFR5cGUuTUVOVSwgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBjb25zdCBbbWVudVNob3duLCBzZXRNZW51U2hvd25dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgcmVmcywgeCwgeSB9ID0gdXNlRmxvYXRpbmdVSVByZXNldCh7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgIG9mZnNldCxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmbG9hdGluZyAmJiBkb21SZWZlcmVuY2U/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBzZXRNZW51U2hvd24odHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmbG9hdGluZyAmJiAhZmxvYXRpbmc/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBzZXRNZW51U2hvd24oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdlc2NhcGUnICYmXG4gICAgICAgICAgICAgICAgIWV2ZW50LmFsdEtleSAmJlxuICAgICAgICAgICAgICAgICFldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgc2V0TWVudVNob3duKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgICB9O1xuICAgIH0sIFtmbG9hdGluZywgZG9tUmVmZXJlbmNlXSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbbWVudVNob3duICYmIChqc3goTWVudUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgY2xvc2U6ICgpID0+IHNldE1lbnVTaG93bihmYWxzZSkgfSwgY2hpbGRyZW46IHZpc3VhbFR5cGUgPT09IE1lbnVWaXN1YWxUeXBlLlBPUlRBTCA/IChqc3goTWVudVBvcnRhbCwgeyByZWZzOiByZWZzLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpIDogdmlzdWFsVHlwZSA9PT0gTWVudVZpc3VhbFR5cGUuTUVOVSA/IChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19tZW51LWNvbnRhaW5lclwiLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHkgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpIDogbnVsbCB9KSksIGpzeChUb2dnbGVCdXR0b24sIHsgbWVudVNob3duOiBtZW51U2hvd24sIHJlZjogcmVmcy5zZXRSZWZlcmVuY2UgfSldIH0pKTtcbn07XG5cbmNvbnN0IEdlbmVyaWNNZW51ID0gKHsgY2hpbGRyZW4sIG9uSXRlbUNsaWNrLCB9KSA9PiB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHJldHVybiAoanN4KFwidWxcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19nZW5lcmljLW1lbnVcIiwgcmVmOiByZWYsIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAob25JdGVtQ2xpY2sgJiZcbiAgICAgICAgICAgICAgICBlLnRhcmdldCAhPT0gcmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudD8uY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgb25JdGVtQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuY29uc3QgR2VuZXJpY01lbnVCdXR0b25JdGVtID0gKHsgY2hpbGRyZW4sIC4uLnJlc3QgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwibGlcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19nZW5lcmljLW1lbnUtLWl0ZW1cIiwgY2hpbGRyZW46IGpzeChcImJ1dHRvblwiLCB7IC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59O1xuXG5jb25zdCBJY29uID0gKHsgY2xhc3NOYW1lLCBpY29uIH0pID0+IChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2ljb24nLCBpY29uICYmIGBzdHItdmlkZW9fX2ljb24tLSR7aWNvbn1gLCBjbGFzc05hbWUpIH0pKTtcblxuY29uc3QgSWNvbkJ1dHRvbiA9IGZvcndhcmRSZWYoZnVuY3Rpb24gSWNvbkJ1dHRvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBpY29uLCBlbmFibGVkLCB2YXJpYW50LCBvbkNsaWNrLCBjbGFzc05hbWUsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2NhbGwtY29udHJvbHNfX2J1dHRvbicsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgW2BzdHItdmlkZW9fX2NhbGwtY29udHJvbHNfX2J1dHRvbi0tdmFyaWFudC0ke3ZhcmlhbnR9YF06IHZhcmlhbnQsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jYWxsLWNvbnRyb2xzX19idXR0b24tLWVuYWJsZWQnOiBlbmFibGVkLFxuICAgICAgICB9KSwgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uQ2xpY2s/LihlKTtcbiAgICAgICAgfSwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBqc3goSWNvbiwgeyBpY29uOiBpY29uIH0pIH0pKTtcbn0pO1xuXG5jb25zdCBpc0NvbXBvbmVudFR5cGUgPSAoZWxlbWVudE9yQ29tcG9uZW50KSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnRPckNvbXBvbmVudCA9PT0gbnVsbFxuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogIWlzVmFsaWRFbGVtZW50KGVsZW1lbnRPckNvbXBvbmVudCk7XG59O1xuXG5jb25zdCBjaHVuayA9IChhcnJheSwgc2l6ZSkgPT4ge1xuICAgIGNvbnN0IGNodW5rQ291bnQgPSBNYXRoLmNlaWwoYXJyYXkubGVuZ3RoIC8gc2l6ZSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNodW5rQ291bnQgfSwgKF8sIGluZGV4KSA9PiBhcnJheS5zbGljZShzaXplICogaW5kZXgsIHNpemUgKiBpbmRleCArIHNpemUpKTtcbn07XG5cbmNvbnN0IGFwcGx5RWxlbWVudFRvUmVmID0gKHJlZiwgZWxlbWVudCkgPT4ge1xuICAgIGlmICghcmVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiByZWYoZWxlbWVudCk7XG4gICAgcmVmLmN1cnJlbnQgPSBlbGVtZW50O1xufTtcblxuY29uc3QgQ29tcG9zaXRlQnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGVCdXR0b24oeyBjYXB0aW9uLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBhY3RpdmUsIE1lbnUsIG1lbnVQbGFjZW1lbnQsIG1lbnVPZmZzZXQsIHRpdGxlLCBUb2dnbGVNZW51QnV0dG9uID0gRGVmYXVsdFRvZ2dsZU1lbnVCdXR0b24sIHZhcmlhbnQsIG9uQ2xpY2ssIC4uLnJlc3RCdXR0b25Qcm9wcyB9LCByZWYpIHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbicsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbi0tY2FwdGlvbic6IGNhcHRpb24sXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uLS1tZW51JzogTWVudSxcbiAgICAgICAgfSksIHRpdGxlOiB0aXRsZSwgcmVmOiByZWYsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uX19idXR0b24tZ3JvdXAnLCB7XG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b25fX2J1dHRvbi1ncm91cC0tYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICAnc3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uX19idXR0b24tZ3JvdXAtLWFjdGl2ZS1wcmltYXJ5JzogYWN0aXZlICYmIHZhcmlhbnQgPT09ICdwcmltYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbl9fYnV0dG9uLWdyb3VwLS1hY3RpdmUtc2Vjb25kYXJ5JzogYWN0aXZlICYmIHZhcmlhbnQgPT09ICdzZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgIH0pLCBjaGlsZHJlbjogW2pzeChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b25fX2J1dHRvblwiLCBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPy4oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN0QnV0dG9uUHJvcHMsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSwgTWVudSAmJiAoanN4KE1lbnVUb2dnbGUsIHsgb2Zmc2V0OiBtZW51T2Zmc2V0LCBwbGFjZW1lbnQ6IG1lbnVQbGFjZW1lbnQsIFRvZ2dsZUJ1dHRvbjogVG9nZ2xlTWVudUJ1dHRvbiwgY2hpbGRyZW46IGlzQ29tcG9uZW50VHlwZShNZW51KSA/IGpzeChNZW51LCB7fSkgOiBNZW51IH0pKV0gfSksIGNhcHRpb24gJiYgKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b25fX2NhcHRpb25cIiwgY2hpbGRyZW46IGNhcHRpb24gfSkpXSB9KSk7XG59KTtcbmNvbnN0IERlZmF1bHRUb2dnbGVNZW51QnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBEZWZhdWx0VG9nZ2xlTWVudUJ1dHRvbih7IG1lbnVTaG93biB9LCByZWYpIHtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19tZW51LXRvZ2dsZS1idXR0b24nLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19tZW51LXRvZ2dsZS1idXR0b24tLWFjdGl2ZSc6IG1lbnVTaG93bixcbiAgICAgICAgfSksIGljb246IG1lbnVTaG93biA/ICdjYXJldC1kb3duJyA6ICdjYXJldC11cCcsIHJlZjogcmVmIH0pKTtcbn0pO1xuXG5jb25zdCBUZXh0QnV0dG9uID0gKHsgY2hpbGRyZW4sIC4uLnJlc3QgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwiYnV0dG9uXCIsIHsgLi4ucmVzdCwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fdGV4dC1idXR0b25cIiwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IEFjY2VwdENhbGxCdXR0b24gPSAoeyBkaXNhYmxlZCwgb25BY2NlcHQsIG9uQ2xpY2ssIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbCkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbC5qb2luKCk7XG4gICAgICAgICAgICBvbkFjY2VwdD8uKCk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGljaywgb25BY2NlcHQsIGNhbGxdKTtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGRpc2FibGVkOiBkaXNhYmxlZCwgaWNvbjogXCJjYWxsLWFjY2VwdFwiLCB2YXJpYW50OiBcInN1Y2Nlc3NcIiwgXCJkYXRhLXRlc3RpZFwiOiBcImFjY2VwdC1jYWxsLWJ1dHRvblwiLCBvbkNsaWNrOiBoYW5kbGVDbGljayB9KSk7XG59O1xuXG5jb25zdCBOb3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGlzVmlzaWJsZSwgbWVzc2FnZSwgY2hpbGRyZW4sIHZpc2liaWxpdHlUaW1lb3V0LCByZXNldElzVmlzaWJsZSwgcGxhY2VtZW50ID0gJ3RvcCcsIGljb25DbGFzc05hbWUgPSAnc3RyLXZpZGVvX19ub3RpZmljYXRpb25fX2ljb24nLCBjbG9zZSwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgcmVmcywgeCwgeSwgc3RyYXRlZ3kgfSA9IHVzZUZsb2F0aW5nVUlQcmVzZXQoe1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICF2aXNpYmlsaXR5VGltZW91dCB8fCAhcmVzZXRJc1Zpc2libGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc2V0SXNWaXNpYmxlKCk7XG4gICAgICAgIH0sIHZpc2liaWxpdHlUaW1lb3V0KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9LCBbaXNWaXNpYmxlLCByZXNldElzVmlzaWJsZSwgdmlzaWJpbGl0eVRpbWVvdXRdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyByZWY6IHJlZnMuc2V0UmVmZXJlbmNlLCBjaGlsZHJlbjogW2lzVmlzaWJsZSAmJiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX25vdGlmaWNhdGlvblwiLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB5ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtpY29uQ2xhc3NOYW1lICYmIGpzeChcImlcIiwgeyBjbGFzc05hbWU6IGljb25DbGFzc05hbWUgfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19ub3RpZmljYXRpb25fX21lc3NhZ2VcIiwgY2hpbGRyZW46IG1lc3NhZ2UgfSksIGNsb3NlID8gKGpzeChcImlcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19pY29uIHN0ci12aWRlb19faWNvbi0tY2xvc2Ugc3RyLXZpZGVvX19ub3RpZmljYXRpb25fX2Nsb3NlXCIsIG9uQ2xpY2s6IGNsb3NlIH0pKSA6IG51bGxdIH0pKSwgY2hpbGRyZW5dIH0pKTtcbn07XG5cbmNvbnN0IFBlcm1pc3Npb25Ob3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHBlcm1pc3Npb24sIGlzQXdhaXRpbmdBcHByb3ZhbCwgbWVzc2FnZUFwcHJvdmVkLCBtZXNzYWdlQXdhaXRpbmdBcHByb3ZhbCwgbWVzc2FnZVJldm9rZWQsIHZpc2liaWxpdHlUaW1lb3V0ID0gMzUwMCwgY2hpbGRyZW4sIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHVzZUhhc1Blcm1pc3Npb25zIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSB1c2VIYXNQZXJtaXNzaW9ucyhwZXJtaXNzaW9uKTtcbiAgICBjb25zdCBwcmV2SGFzUGVybWlzc2lvbiA9IHVzZVJlZihoYXNQZXJtaXNzaW9uKTtcbiAgICBjb25zdCBbc2hvd05vdGlmaWNhdGlvbiwgc2V0U2hvd05vdGlmaWNhdGlvbl0gPSB1c2VTdGF0ZSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChoYXNQZXJtaXNzaW9uICYmICFwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRTaG93Tm90aWZpY2F0aW9uKCdncmFudGVkJyk7XG4gICAgICAgICAgICBwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaGFzUGVybWlzc2lvbiAmJiBwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRTaG93Tm90aWZpY2F0aW9uKCdyZXZva2VkJyk7XG4gICAgICAgICAgICBwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCBbaGFzUGVybWlzc2lvbl0pO1xuICAgIGNvbnN0IHJlc2V0SXNWaXNpYmxlID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0U2hvd05vdGlmaWNhdGlvbih1bmRlZmluZWQpLCBbXSk7XG4gICAgaWYgKGlzQXdhaXRpbmdBcHByb3ZhbCkge1xuICAgICAgICByZXR1cm4gKGpzeChOb3RpZmljYXRpb24sIHsgaXNWaXNpYmxlOiBpc0F3YWl0aW5nQXBwcm92YWwgJiYgIWhhc1Blcm1pc3Npb24sIG1lc3NhZ2U6IG1lc3NhZ2VBd2FpdGluZ0FwcHJvdmFsLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOb3RpZmljYXRpb24sIHsgaXNWaXNpYmxlOiAhIXNob3dOb3RpZmljYXRpb24sIHZpc2liaWxpdHlUaW1lb3V0OiB2aXNpYmlsaXR5VGltZW91dCwgcmVzZXRJc1Zpc2libGU6IHJlc2V0SXNWaXNpYmxlLCBtZXNzYWdlOiBzaG93Tm90aWZpY2F0aW9uID09PSAnZ3JhbnRlZCcgPyBtZXNzYWdlQXBwcm92ZWQgOiBtZXNzYWdlUmV2b2tlZCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IFNwZWFraW5nV2hpbGVNdXRlZE5vdGlmaWNhdGlvbiA9ICh7IGNoaWxkcmVuLCB0ZXh0LCBwbGFjZW1lbnQsIH0pID0+IHtcbiAgICBjb25zdCB7IHVzZU1pY3JvcGhvbmVTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGlzU3BlYWtpbmdXaGlsZU11dGVkIH0gPSB1c2VNaWNyb3Bob25lU3RhdGUoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdGV4dCA/PyB0KCdZb3UgYXJlIG11dGVkLiBVbm11dGUgdG8gc3BlYWsuJyk7XG4gICAgcmV0dXJuIChqc3goTm90aWZpY2F0aW9uLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGlzVmlzaWJsZTogaXNTcGVha2luZ1doaWxlTXV0ZWQsIHBsYWNlbWVudDogcGxhY2VtZW50IHx8ICd0b3Atc3RhcnQnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcblxuY29uc3QgUmVjb3JkaW5nSW5Qcm9ncmVzc05vdGlmaWNhdGlvbiA9ICh7IGNoaWxkcmVuLCB0ZXh0LCB9KSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzIH0gPSB1c2VUb2dnbGVDYWxsUmVjb3JkaW5nKCk7XG4gICAgY29uc3QgW2lzVmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRleHQgPz8gdCgnUmVjb3JkaW5nIGluIHByb2dyZXNzLi4uJyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXSk7XG4gICAgcmV0dXJuIChqc3goTm90aWZpY2F0aW9uLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGljb25DbGFzc05hbWU6IFwic3RyLXZpZGVvX19pY29uIHN0ci12aWRlb19faWNvbi0tcmVjb3JkaW5nLW9uXCIsIGlzVmlzaWJsZTogaXNWaXNpYmxlLCBwbGFjZW1lbnQ6IFwidG9wLXN0YXJ0XCIsIGNsb3NlOiAoKSA9PiBzZXRWaXNpYmxlKGZhbHNlKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSAoeyBjbGFzc05hbWUsIHR5cGUgPSAnc3Bpbm5lcicsIHRleHQsIHRvb2x0aXAsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fbG9hZGluZy1pbmRpY2F0b3InLCBjbGFzc05hbWUpLCB0aXRsZTogdG9vbHRpcCwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fbG9hZGluZy1pbmRpY2F0b3JfX2ljb24nLCB0eXBlKSB9KSwgdGV4dCAmJiBqc3goXCJwXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbG9hZGluZy1pbmRpY2F0b3ItdGV4dFwiLCBjaGlsZHJlbjogdGV4dCB9KV0gfSkpO1xufTtcblxuY29uc3QgUmVjb3JkRW5kQ29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdG9nZ2xlQ2FsbFJlY29yZGluZywgaXNBd2FpdGluZ1Jlc3BvbnNlIH0gPSB1c2VUb2dnbGVDYWxsUmVjb3JkaW5nKCk7XG4gICAgY29uc3QgeyBjbG9zZSB9ID0gdXNlTWVudUNvbnRleHQoKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19lbmQtcmVjb3JkaW5nX19jb25maXJtYXRpb25cIiwgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLXJlY29yZGluZ19faGVhZGVyXCIsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJyZWNvcmRpbmctb25cIiB9KSwganN4KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19lbmQtcmVjb3JkaW5nX19oZWFkaW5nXCIsIGNoaWxkcmVuOiB0KCdFbmQgcmVjb3JkaW5nJykgfSldIH0pLCBqc3goXCJwXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLXJlY29yZGluZ19fZGVzY3JpcHRpb25cIiwgY2hpbGRyZW46IHQoJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCBlbmQgdGhlIHJlY29yZGluZz8nKSB9KSwganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2VuZC1yZWNvcmRpbmdfX2FjdGlvbnNcIiwgY2hpbGRyZW46IFtqc3goQ29tcG9zaXRlQnV0dG9uLCB7IHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIG9uQ2xpY2s6IGNsb3NlLCBjaGlsZHJlbjogdCgnQ2FuY2VsJykgfSksIGpzeChDb21wb3NpdGVCdXR0b24sIHsgdmFyaWFudDogXCJwcmltYXJ5XCIsIG9uQ2xpY2s6IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGNoaWxkcmVuOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyBqc3goTG9hZGluZ0luZGljYXRvciwge30pIDogdCgnRW5kIHJlY29yZGluZycpIH0pXSB9KV0gfSkpO1xufTtcbmNvbnN0IFRvZ2dsZUVuZFJlY29yZGluZ01lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZUVuZFJlY29yZGluZ01lbnVCdXR0b24ocHJvcHMsIHJlZikge1xuICAgIHJldHVybiAoanN4KENvbXBvc2l0ZUJ1dHRvbiwgeyByZWY6IHJlZiwgYWN0aXZlOiB0cnVlLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCBcImRhdGEtdGVzdGlkXCI6IFwicmVjb3JkaW5nLXN0b3AtYnV0dG9uXCIsIGNoaWxkcmVuOiBqc3goSWNvbiwgeyBpY29uOiBcInJlY29yZGluZy1vZmZcIiB9KSB9KSk7XG59KTtcbmNvbnN0IFJlY29yZENhbGxDb25maXJtYXRpb25CdXR0b24gPSAoeyBjYXB0aW9uLCB9KSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyB0b2dnbGVDYWxsUmVjb3JkaW5nLCBpc0F3YWl0aW5nUmVzcG9uc2UsIGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MgfSA9IHVzZVRvZ2dsZUNhbGxSZWNvcmRpbmcoKTtcbiAgICBpZiAoaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbXG4gICAgICAgICAgICAgICAgT3duQ2FwYWJpbGl0eS5TVEFSVF9SRUNPUkRfQ0FMTCxcbiAgICAgICAgICAgICAgICBPd25DYXBhYmlsaXR5LlNUT1BfUkVDT1JEX0NBTEwsXG4gICAgICAgICAgICBdLCBjaGlsZHJlbjoganN4KE1lbnVUb2dnbGUsIHsgVG9nZ2xlQnV0dG9uOiBUb2dnbGVFbmRSZWNvcmRpbmdNZW51QnV0dG9uLCB2aXN1YWxUeXBlOiBNZW51VmlzdWFsVHlwZS5QT1JUQUwsIGNoaWxkcmVuOiBqc3goUmVjb3JkRW5kQ29uZmlybWF0aW9uLCB7fSkgfSkgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbXG4gICAgICAgICAgICBPd25DYXBhYmlsaXR5LlNUQVJUX1JFQ09SRF9DQUxMLFxuICAgICAgICAgICAgT3duQ2FwYWJpbGl0eS5TVE9QX1JFQ09SRF9DQUxMLFxuICAgICAgICBdLCBjaGlsZHJlbjoganN4KENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MsIGNhcHRpb246IGNhcHRpb24sIHRpdGxlOiBjYXB0aW9uIHx8IHQoJ1JlY29yZCBjYWxsJyksIHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIFwiZGF0YS10ZXN0aWRcIjogXCJyZWNvcmRpbmctc3RhcnQtYnV0dG9uXCIsIG9uQ2xpY2s6IGlzQXdhaXRpbmdSZXNwb25zZSA/IHVuZGVmaW5lZCA6IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGNoaWxkcmVuOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyAoanN4KExvYWRpbmdJbmRpY2F0b3IsIHsgdG9vbHRpcDogdCgnV2FpdGluZyBmb3IgcmVjb3JkaW5nIHRvIHN0YXJ0Li4uJykgfSkpIDogKGpzeChJY29uLCB7IGljb246IFwicmVjb3JkaW5nLW9mZlwiIH0pKSB9KSB9KSk7XG59O1xuY29uc3QgUmVjb3JkQ2FsbEJ1dHRvbiA9ICh7IGNhcHRpb24gfSkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdG9nZ2xlQ2FsbFJlY29yZGluZywgaXNBd2FpdGluZ1Jlc3BvbnNlLCBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzIH0gPSB1c2VUb2dnbGVDYWxsUmVjb3JkaW5nKCk7XG4gICAgbGV0IHRpdGxlID0gY2FwdGlvbiB8fCB0KCdSZWNvcmQgY2FsbCcpO1xuICAgIGlmIChpc0F3YWl0aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgdGl0bGUgPSBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXG4gICAgICAgICAgICA/IHQoJ1dhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdG9wLi4uJylcbiAgICAgICAgICAgIDogdCgnV2FpdGluZyBmb3IgcmVjb3JkaW5nIHRvIHN0YXJ0Li4uJyk7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtcbiAgICAgICAgICAgIE93bkNhcGFiaWxpdHkuU1RBUlRfUkVDT1JEX0NBTEwsXG4gICAgICAgICAgICBPd25DYXBhYmlsaXR5LlNUT1BfUkVDT1JEX0NBTEwsXG4gICAgICAgIF0sIGNoaWxkcmVuOiBqc3goQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcywgY2FwdGlvbjogY2FwdGlvbiwgdmFyaWFudDogXCJzZWNvbmRhcnlcIiwgXCJkYXRhLXRlc3RpZFwiOiBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgPyAncmVjb3JkaW5nLXN0b3AtYnV0dG9uJ1xuICAgICAgICAgICAgICAgIDogJ3JlY29yZGluZy1zdGFydC1idXR0b24nLCB0aXRsZTogdGl0bGUsIG9uQ2xpY2s6IGlzQXdhaXRpbmdSZXNwb25zZSA/IHVuZGVmaW5lZCA6IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGNoaWxkcmVuOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyAoanN4KExvYWRpbmdJbmRpY2F0b3IsIHt9KSkgOiAoanN4KEljb24sIHsgaWNvbjogaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyA/ICdyZWNvcmRpbmctb24nIDogJ3JlY29yZGluZy1vZmYnIH0pKSB9KSB9KSk7XG59O1xuXG5jb25zdCBkZWZhdWx0RW1vamlSZWFjdGlvbk1hcCA9IHtcbiAgICAnOmxpa2U6JzogJ/CfkY0nLFxuICAgICc6cmFpc2UtaGFuZDonOiAn4pyLJyxcbiAgICAnOmZpcmV3b3JrczonOiAn8J+OiScsXG4gICAgJzpkaXNsaWtlOic6ICfwn5GOJyxcbiAgICAnOmhlYXJ0Oic6ICfinaTvuI8nLFxuICAgICc6c21pbGU6JzogJ/CfmIAnLFxufTtcbmNvbnN0IFJlYWN0aW9uID0gKHsgcGFydGljaXBhbnQ6IHsgcmVhY3Rpb24sIHNlc3Npb25JZCB9LCBoaWRlQWZ0ZXJUaW1lb3V0SW5NcyA9IDU1MDAsIGVtb2ppUmVhY3Rpb25NYXAgPSBkZWZhdWx0RW1vamlSZWFjdGlvbk1hcCwgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsIHx8ICFyZWFjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjYWxsLnJlc2V0UmVhY3Rpb24oc2Vzc2lvbklkKTtcbiAgICAgICAgfSwgaGlkZUFmdGVyVGltZW91dEluTXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbGwsIGhpZGVBZnRlclRpbWVvdXRJbk1zLCByZWFjdGlvbiwgc2Vzc2lvbklkXSk7XG4gICAgaWYgKCFyZWFjdGlvbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyBlbW9qaV9jb2RlOiBlbW9qaUNvZGUgfSA9IHJlYWN0aW9uO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcmVhY3Rpb25cIiwgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19yZWFjdGlvbl9fZW1vamlcIiwgY2hpbGRyZW46IGVtb2ppQ29kZSAmJiBlbW9qaVJlYWN0aW9uTWFwW2Vtb2ppQ29kZV0gfSkgfSkpO1xufTtcblxuY29uc3QgZGVmYXVsdFJlYWN0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6bGlrZTonLFxuICAgIH0sXG4gICAge1xuICAgICAgICAvLyBUT0RPIE9MOiB1c2UgYHByb21wdGAgdHlwZT9cbiAgICAgICAgdHlwZTogJ3JhaXNlZC1oYW5kJyxcbiAgICAgICAgZW1vamlfY29kZTogJzpyYWlzZS1oYW5kOicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6ZmlyZXdvcmtzOicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6ZGlzbGlrZTonLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAncmVhY3Rpb24nLFxuICAgICAgICBlbW9qaV9jb2RlOiAnOmhlYXJ0OicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6c21pbGU6JyxcbiAgICB9LFxuXTtcbmNvbnN0IFJlYWN0aW9uc0J1dHRvbiA9ICh7IHJlYWN0aW9ucyA9IGRlZmF1bHRSZWFjdGlvbnMsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5DUkVBVEVfUkVBQ1RJT05dLCBjaGlsZHJlbjoganN4KE1lbnVUb2dnbGUsIHsgcGxhY2VtZW50OiBcInRvcFwiLCBUb2dnbGVCdXR0b246IFRvZ2dsZVJlYWN0aW9uc01lbnVCdXR0b24sIHZpc3VhbFR5cGU6IE1lbnVWaXN1YWxUeXBlLk1FTlUsIGNoaWxkcmVuOiBqc3goRGVmYXVsdFJlYWN0aW9uc01lbnUsIHsgcmVhY3Rpb25zOiByZWFjdGlvbnMgfSkgfSkgfSkpO1xufTtcbmNvbnN0IFRvZ2dsZVJlYWN0aW9uc01lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZVJlYWN0aW9uc01lbnVCdXR0b24oeyBtZW51U2hvd24gfSwgcmVmKSB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goQ29tcG9zaXRlQnV0dG9uLCB7IHJlZjogcmVmLCBhY3RpdmU6IG1lbnVTaG93biwgdmFyaWFudDogXCJwcmltYXJ5XCIsIHRpdGxlOiB0KCdSZWFjdGlvbnMnKSwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwicmVhY3Rpb25zXCIgfSkgfSkpO1xufSk7XG5jb25zdCBEZWZhdWx0UmVhY3Rpb25zTWVudSA9ICh7IHJlYWN0aW9ucywgbGF5b3V0ID0gJ2hvcml6b250YWwnLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19yZWFjdGlvbnMtbWVudScsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX3JlYWN0aW9ucy1tZW51LS1ob3Jpem9udGFsJzogbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19yZWFjdGlvbnMtbWVudS0tdmVydGljYWwnOiBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcsXG4gICAgICAgIH0pLCBjaGlsZHJlbjogcmVhY3Rpb25zLm1hcCgocmVhY3Rpb24pID0+IChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19yZWFjdGlvbnMtbWVudV9fYnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsPy5zZW5kUmVhY3Rpb24ocmVhY3Rpb24pO1xuICAgICAgICAgICAgfSwgY2hpbGRyZW46IHJlYWN0aW9uLmVtb2ppX2NvZGUgJiYgZGVmYXVsdEVtb2ppUmVhY3Rpb25NYXBbcmVhY3Rpb24uZW1vamlfY29kZV0gfSwgcmVhY3Rpb24uZW1vamlfY29kZSkpKSB9KSk7XG59O1xuXG5jb25zdCBTY3JlZW5TaGFyZUJ1dHRvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgY2FwdGlvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB1c2VIYXNPbmdvaW5nU2NyZWVuU2hhcmUsIHVzZVNjcmVlblNoYXJlU3RhdGUsIHVzZUNhbGxTZXR0aW5ncyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBpc1NvbWVvbmVTY3JlZW5TaGFyaW5nID0gdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlKCk7XG4gICAgY29uc3QgeyBoYXNQZXJtaXNzaW9uLCByZXF1ZXN0UGVybWlzc2lvbiwgaXNBd2FpdGluZ1Blcm1pc3Npb24gfSA9IHVzZVJlcXVlc3RQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkUpO1xuICAgIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHVzZUNhbGxTZXR0aW5ncygpO1xuICAgIGNvbnN0IGlzU2NyZWVuU2hhcmluZ0FsbG93ZWQgPSBjYWxsU2V0dGluZ3M/LnNjcmVlbnNoYXJpbmcuZW5hYmxlZDtcbiAgICBjb25zdCB7IHNjcmVlblNoYXJlLCBpc011dGU6IGFtSVNjcmVlblNoYXJpbmcgfSA9IHVzZVNjcmVlblNoYXJlU3RhdGUoKTtcbiAgICBjb25zdCBkaXNhYmxlU2NyZWVuU2hhcmVCdXR0b24gPSBhbUlTY3JlZW5TaGFyaW5nXG4gICAgICAgID8gaXNTb21lb25lU2NyZWVuU2hhcmluZyB8fCBpc1NjcmVlblNoYXJpbmdBbGxvd2VkID09PSBmYWxzZVxuICAgICAgICA6IGZhbHNlO1xuICAgIHJldHVybiAoanN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFXSwgY2hpbGRyZW46IGpzeChQZXJtaXNzaW9uTm90aWZpY2F0aW9uLCB7IHBlcm1pc3Npb246IE93bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkUsIGlzQXdhaXRpbmdBcHByb3ZhbDogaXNBd2FpdGluZ1Blcm1pc3Npb24sIG1lc3NhZ2VBcHByb3ZlZDogdCgnWW91IGNhbiBub3cgc2hhcmUgeW91ciBzY3JlZW4uJyksIG1lc3NhZ2VBd2FpdGluZ0FwcHJvdmFsOiB0KCdBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc2hhcmUgc2NyZWVuLicpLCBtZXNzYWdlUmV2b2tlZDogdCgnWW91IGNhbiBubyBsb25nZXIgc2hhcmUgeW91ciBzY3JlZW4uJyksIGNoaWxkcmVuOiBqc3goQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNTb21lb25lU2NyZWVuU2hhcmluZywgY2FwdGlvbjogY2FwdGlvbiwgdGl0bGU6IGNhcHRpb24gfHwgdCgnU2hhcmUgc2NyZWVuJyksIHZhcmlhbnQ6IFwicHJpbWFyeVwiLCBcImRhdGEtdGVzdGlkXCI6IGlzU29tZW9uZVNjcmVlblNoYXJpbmdcbiAgICAgICAgICAgICAgICAgICAgPyAnc2NyZWVuLXNoYXJlLXN0b3AtYnV0dG9uJ1xuICAgICAgICAgICAgICAgICAgICA6ICdzY3JlZW4tc2hhcmUtc3RhcnQtYnV0dG9uJywgZGlzYWJsZWQ6IGRpc2FibGVTY3JlZW5TaGFyZUJ1dHRvbiwgb25DbGljazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzY3JlZW5TaGFyZS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBqc3goSWNvbiwgeyBpY29uOiBpc1NvbWVvbmVTY3JlZW5TaGFyaW5nID8gJ3NjcmVlbi1zaGFyZS1vbicgOiAnc2NyZWVuLXNoYXJlLW9mZicgfSkgfSkgfSkgfSkpO1xufTtcblxuY29uc3QgU2VsZWN0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuY29uc3QgU2VsZWN0ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaWNvbiwgZGVmYXVsdFNlbGVjdGVkTGFiZWwsIGRlZmF1bHRTZWxlY3RlZEluZGV4LCBoYW5kbGVTZWxlY3Q6IGhhbmRsZVNlbGVjdFByb3AsIH0gPSBwcm9wcztcbiAgICBjb25zdCBbaXNPcGVuLCBzZXRJc09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFthY3RpdmVJbmRleCwgc2V0QWN0aXZlSW5kZXhdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGUoZGVmYXVsdFNlbGVjdGVkSW5kZXgpO1xuICAgIGNvbnN0IFtzZWxlY3RlZExhYmVsLCBzZXRTZWxlY3RlZExhYmVsXSA9IHVzZVN0YXRlKGRlZmF1bHRTZWxlY3RlZExhYmVsKTtcbiAgICBjb25zdCB7IHJlZnMsIGNvbnRleHQgfSA9IHVzZUZsb2F0aW5nKHtcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgb3BlbjogaXNPcGVuLFxuICAgICAgICBvbk9wZW5DaGFuZ2U6IHNldElzT3BlbixcbiAgICAgICAgd2hpbGVFbGVtZW50c01vdW50ZWQ6IGF1dG9VcGRhdGUsXG4gICAgICAgIG1pZGRsZXdhcmU6IFtmbGlwKCldLFxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRzUmVmID0gdXNlUmVmKFtdKTtcbiAgICBjb25zdCBsYWJlbHNSZWYgPSB1c2VSZWYoW10pO1xuICAgIGNvbnN0IGhhbmRsZVNlbGVjdCA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3RlZEluZGV4KGluZGV4KTtcbiAgICAgICAgaGFuZGxlU2VsZWN0UHJvcChpbmRleCB8fCAwKTtcbiAgICAgICAgc2V0SXNPcGVuKGZhbHNlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZExhYmVsKGxhYmVsc1JlZi5jdXJyZW50W2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9LCBbaGFuZGxlU2VsZWN0UHJvcF0pO1xuICAgIGNvbnN0IGhhbmRsZVR5cGVhaGVhZE1hdGNoID0gKGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZUluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVNlbGVjdChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpc3ROYXYgPSB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCB7XG4gICAgICAgIGxpc3RSZWY6IGVsZW1lbnRzUmVmLFxuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgb25OYXZpZ2F0ZTogc2V0QWN0aXZlSW5kZXgsXG4gICAgfSk7XG4gICAgY29uc3QgdHlwZWFoZWFkID0gdXNlVHlwZWFoZWFkKGNvbnRleHQsIHtcbiAgICAgICAgbGlzdFJlZjogbGFiZWxzUmVmLFxuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgb25NYXRjaDogaGFuZGxlVHlwZWFoZWFkTWF0Y2gsXG4gICAgfSk7XG4gICAgY29uc3QgY2xpY2sgPSB1c2VDbGljayhjb250ZXh0KTtcbiAgICBjb25zdCBkaXNtaXNzID0gdXNlRGlzbWlzcyhjb250ZXh0KTtcbiAgICBjb25zdCByb2xlID0gdXNlUm9sZShjb250ZXh0LCB7IHJvbGU6ICdsaXN0Ym94JyB9KTtcbiAgICBjb25zdCB7IGdldFJlZmVyZW5jZVByb3BzLCBnZXRGbG9hdGluZ1Byb3BzLCBnZXRJdGVtUHJvcHMgfSA9IHVzZUludGVyYWN0aW9ucyhbbGlzdE5hdiwgdHlwZWFoZWFkLCBjbGljaywgZGlzbWlzcywgcm9sZV0pO1xuICAgIGNvbnN0IHNlbGVjdENvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICBzZWxlY3RlZEluZGV4LFxuICAgICAgICBnZXRJdGVtUHJvcHMsXG4gICAgICAgIGhhbmRsZVNlbGVjdCxcbiAgICB9KSwgW2FjdGl2ZUluZGV4LCBzZWxlY3RlZEluZGV4LCBnZXRJdGVtUHJvcHMsIGhhbmRsZVNlbGVjdF0pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duXCIsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLXNlbGVjdGVkXCIsIHJlZjogcmVmcy5zZXRSZWZlcmVuY2UsIHRhYkluZGV4OiAwLCAuLi5nZXRSZWZlcmVuY2VQcm9wcygpLCBjaGlsZHJlbjogW2pzeHMoXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLXNlbGVjdGVkX19sYWJlbFwiLCBjaGlsZHJlbjogW2ljb24gJiYgKGpzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLXNlbGVjdGVkX19pY29uXCIsIGljb246IGljb24gfSkpLCBzZWxlY3RlZExhYmVsXSB9KSwganN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZHJvcGRvd24tc2VsZWN0ZWRfX2NoZXZyb25cIiwgaWNvbjogaXNPcGVuID8gJ2NoZXZyb24tdXAnIDogJ2NoZXZyb24tZG93bicgfSldIH0pLCBqc3goU2VsZWN0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogc2VsZWN0Q29udGV4dCwgY2hpbGRyZW46IGlzT3BlbiAmJiAoanN4KEZsb2F0aW5nRm9jdXNNYW5hZ2VyLCB7IGNvbnRleHQ6IGNvbnRleHQsIG1vZGFsOiBmYWxzZSwgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLWxpc3RcIiwgcmVmOiByZWZzLnNldEZsb2F0aW5nLCAuLi5nZXRGbG9hdGluZ1Byb3BzKCksIGNoaWxkcmVuOiBqc3goRmxvYXRpbmdMaXN0LCB7IGVsZW1lbnRzUmVmOiBlbGVtZW50c1JlZiwgbGFiZWxzUmVmOiBsYWJlbHNSZWYsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSB9KSkgfSldIH0pKTtcbn07XG5jb25zdCBEcm9wRG93blNlbGVjdE9wdGlvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0ZWQsIGxhYmVsLCBpY29uIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGdldEl0ZW1Qcm9wcywgaGFuZGxlU2VsZWN0IH0gPSB1c2VDb250ZXh0KFNlbGVjdENvbnRleHQpO1xuICAgIGNvbnN0IHsgcmVmLCBpbmRleCB9ID0gdXNlTGlzdEl0ZW0oKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fZHJvcGRvd24tb3B0aW9uJywge1xuICAgICAgICAgICAgJ3N0ci12aWRlb19fZHJvcGRvd24tb3B0aW9uLS1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICB9KSwgcmVmOiByZWYsIC4uLmdldEl0ZW1Qcm9wcyh7XG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBoYW5kbGVTZWxlY3QoaW5kZXgpLFxuICAgICAgICB9KSwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1pY29uXCIsIGljb246IGljb24gfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1sYWJlbFwiLCBjaGlsZHJlbjogbGFiZWwgfSldIH0pKTtcbn07XG5jb25zdCBEcm9wRG93blNlbGVjdCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGljb24sIGhhbmRsZVNlbGVjdCwgZGVmYXVsdFNlbGVjdGVkTGFiZWwsIGRlZmF1bHRTZWxlY3RlZEluZGV4LCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChqc3goU2VsZWN0LCB7IGljb246IGljb24sIGhhbmRsZVNlbGVjdDogaGFuZGxlU2VsZWN0LCBkZWZhdWx0U2VsZWN0ZWRJbmRleDogZGVmYXVsdFNlbGVjdGVkSW5kZXgsIGRlZmF1bHRTZWxlY3RlZExhYmVsOiBkZWZhdWx0U2VsZWN0ZWRMYWJlbCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IERldmljZVNlbGVjdG9yT3B0aW9uID0gKHsgZGlzYWJsZWQsIGlkLCBsYWJlbCwgb25DaGFuZ2UsIG5hbWUsIHNlbGVjdGVkLCBkZWZhdWx0Q2hlY2tlZCwgdmFsdWUsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX29wdGlvbicsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fb3B0aW9uLS1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICAgICAgJ3N0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19vcHRpb24tLWRpc2FibGVkJzogZGlzYWJsZWQsXG4gICAgICAgIH0pLCBodG1sRm9yOiBpZCwgY2hpbGRyZW46IFtqc3goXCJpbnB1dFwiLCB7IHR5cGU6IFwicmFkaW9cIiwgbmFtZTogbmFtZSwgb25DaGFuZ2U6IG9uQ2hhbmdlLCB2YWx1ZTogdmFsdWUsIGlkOiBpZCwgY2hlY2tlZDogc2VsZWN0ZWQsIGRlZmF1bHRDaGVja2VkOiBkZWZhdWx0Q2hlY2tlZCwgZGlzYWJsZWQ6IGRpc2FibGVkIH0pLCBsYWJlbF0gfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yTGlzdCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgZGV2aWNlcyA9IFtdLCBzZWxlY3RlZERldmljZUlkOiBzZWxlY3RlZERldmljZUZyb21Qcm9wcywgdGl0bGUsIHR5cGUsIG9uQ2hhbmdlLCB9ID0gcHJvcHM7XG4gICAgLy8gc29tZXRpbWVzIHRoZSBicm93c2VyIChDaHJvbWUpIHdpbGwgcmVwb3J0IHRoZSBzeXN0ZW0tZGVmYXVsdCBkZXZpY2VcbiAgICAvLyB3aXRoIGFuIGlkIG9mICdkZWZhdWx0Jy4gSW4gY2FzZSB3aGVuIGl0IGRvZXNuJ3QsIHdlJ2xsIHNlbGVjdCB0aGUgZmlyc3RcbiAgICAvLyBhdmFpbGFibGUgZGV2aWNlLlxuICAgIGxldCBzZWxlY3RlZERldmljZUlkID0gc2VsZWN0ZWREZXZpY2VGcm9tUHJvcHM7XG4gICAgaWYgKGRldmljZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhZGV2aWNlcy5maW5kKChkKSA9PiBkLmRldmljZUlkID09PSBzZWxlY3RlZERldmljZUlkKSkge1xuICAgICAgICBzZWxlY3RlZERldmljZUlkID0gZGV2aWNlc1swXS5kZXZpY2VJZDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19kZXZpY2Uta2luZFwiLCBjaGlsZHJlbjogW3RpdGxlICYmIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2RldmljZS1zZWxlY3Rvci10aXRsZVwiLCBjaGlsZHJlbjogdGl0bGUgfSkpLCAhZGV2aWNlcy5sZW5ndGggPyAoanN4KERldmljZVNlbGVjdG9yT3B0aW9uLCB7IGlkOiBgJHt0eXBlfS0tZGVmYXVsdGAsIGxhYmVsOiBcIkRlZmF1bHRcIiwgbmFtZTogdHlwZSwgZGVmYXVsdENoZWNrZWQ6IHRydWUsIHZhbHVlOiBcImRlZmF1bHRcIiB9KSkgOiAoZGV2aWNlcy5tYXAoKGRldmljZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoanN4KERldmljZVNlbGVjdG9yT3B0aW9uLCB7IGlkOiBgJHt0eXBlfS0tJHtkZXZpY2UuZGV2aWNlSWR9YCwgdmFsdWU6IGRldmljZS5kZXZpY2VJZCwgbGFiZWw6IGRldmljZS5sYWJlbCwgb25DaGFuZ2U6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT8uKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbmFtZTogdHlwZSwgc2VsZWN0ZWQ6IGRldmljZS5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCB8fCBkZXZpY2VzLmxlbmd0aCA9PT0gMSB9LCBkZXZpY2UuZGV2aWNlSWQpKTtcbiAgICAgICAgICAgIH0pKV0gfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yRHJvcGRvd24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGRldmljZXMgPSBbXSwgc2VsZWN0ZWREZXZpY2VJZDogc2VsZWN0ZWREZXZpY2VGcm9tUHJvcHMsIHRpdGxlLCBvbkNoYW5nZSwgaWNvbiwgfSA9IHByb3BzO1xuICAgIC8vIHNvbWV0aW1lcyB0aGUgYnJvd3NlciAoQ2hyb21lKSB3aWxsIHJlcG9ydCB0aGUgc3lzdGVtLWRlZmF1bHQgZGV2aWNlXG4gICAgLy8gd2l0aCBhbiBpZCBvZiAnZGVmYXVsdCcuIEluIGNhc2Ugd2hlbiBpdCBkb2Vzbid0LCB3ZSdsbCBzZWxlY3QgdGhlIGZpcnN0XG4gICAgLy8gYXZhaWxhYmxlIGRldmljZS5cbiAgICBsZXQgc2VsZWN0ZWREZXZpY2VJZCA9IHNlbGVjdGVkRGV2aWNlRnJvbVByb3BzO1xuICAgIGlmIChkZXZpY2VzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIWRldmljZXMuZmluZCgoZCkgPT4gZC5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCkpIHtcbiAgICAgICAgc2VsZWN0ZWREZXZpY2VJZCA9IGRldmljZXNbMF0uZGV2aWNlSWQ7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBkZXZpY2VzLmZpbmRJbmRleCgoZCkgPT4gZC5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCk7XG4gICAgY29uc3QgaGFuZGxlU2VsZWN0ID0gdXNlQ2FsbGJhY2soKGluZGV4KSA9PiB7XG4gICAgICAgIG9uQ2hhbmdlPy4oZGV2aWNlc1tpbmRleF0uZGV2aWNlSWQpO1xuICAgIH0sIFtkZXZpY2VzLCBvbkNoYW5nZV0pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fZGV2aWNlLWtpbmRcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2RldmljZS1zZWxlY3Rvci10aXRsZVwiLCBjaGlsZHJlbjogdGl0bGUgfSksIGpzeChEcm9wRG93blNlbGVjdCwgeyBpY29uOiBpY29uLCBkZWZhdWx0U2VsZWN0ZWRJbmRleDogc2VsZWN0ZWRJbmRleCwgZGVmYXVsdFNlbGVjdGVkTGFiZWw6IGRldmljZXNbc2VsZWN0ZWRJbmRleF0/LmxhYmVsLCBoYW5kbGVTZWxlY3Q6IGhhbmRsZVNlbGVjdCwgY2hpbGRyZW46IGRldmljZXMubWFwKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRHJvcERvd25TZWxlY3RPcHRpb24sIHsgaWNvbjogaWNvbiwgbGFiZWw6IGRldmljZS5sYWJlbCwgc2VsZWN0ZWQ6IGRldmljZS5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCB8fCBkZXZpY2VzLmxlbmd0aCA9PT0gMSB9LCBkZXZpY2UuZGV2aWNlSWQpKTtcbiAgICAgICAgICAgICAgICB9KSB9KV0gfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB2aXN1YWxUeXBlID0gJ2xpc3QnLCBpY29uLCBwbGFjZWhvbGRlciwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgaWYgKHZpc3VhbFR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICByZXR1cm4ganN4KERldmljZVNlbGVjdG9yTGlzdCwgeyAuLi5yZXN0IH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChEZXZpY2VTZWxlY3RvckRyb3Bkb3duLCB7IC4uLnJlc3QsIGljb246IGljb24sIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciB9KSk7XG59O1xuXG5jb25zdCBEZXZpY2VTZWxlY3RvckF1ZGlvSW5wdXQgPSAoeyB0aXRsZSwgdmlzdWFsVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlTWljcm9waG9uZVN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgbWljcm9waG9uZSwgc2VsZWN0ZWREZXZpY2UsIGRldmljZXMgfSA9IHVzZU1pY3JvcGhvbmVTdGF0ZSgpO1xuICAgIHJldHVybiAoanN4KERldmljZVNlbGVjdG9yLCB7IGRldmljZXM6IGRldmljZXMgfHwgW10sIHNlbGVjdGVkRGV2aWNlSWQ6IHNlbGVjdGVkRGV2aWNlLCB0eXBlOiBcImF1ZGlvaW5wdXRcIiwgb25DaGFuZ2U6IGFzeW5jIChkZXZpY2VJZCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgbWljcm9waG9uZS5zZWxlY3QoZGV2aWNlSWQpO1xuICAgICAgICB9LCB0aXRsZTogdGl0bGUsIHZpc3VhbFR5cGU6IHZpc3VhbFR5cGUsIGljb246IFwibWljXCIgfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yQXVkaW9PdXRwdXQgPSAoeyB0aXRsZSwgdmlzdWFsVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlU3BlYWtlclN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgc3BlYWtlciwgc2VsZWN0ZWREZXZpY2UsIGRldmljZXMsIGlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkIH0gPSB1c2VTcGVha2VyU3RhdGUoKTtcbiAgICBpZiAoIWlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKGpzeChEZXZpY2VTZWxlY3RvciwgeyBkZXZpY2VzOiBkZXZpY2VzLCB0eXBlOiBcImF1ZGlvb3V0cHV0XCIsIHNlbGVjdGVkRGV2aWNlSWQ6IHNlbGVjdGVkRGV2aWNlLCBvbkNoYW5nZTogKGRldmljZUlkKSA9PiB7XG4gICAgICAgICAgICBzcGVha2VyLnNlbGVjdChkZXZpY2VJZCk7XG4gICAgICAgIH0sIHRpdGxlOiB0aXRsZSwgdmlzdWFsVHlwZTogdmlzdWFsVHlwZSwgaWNvbjogXCJzcGVha2VyXCIgfSkpO1xufTtcblxuY29uc3QgRGV2aWNlU2VsZWN0b3JWaWRlbyA9ICh7IHRpdGxlLCB2aXN1YWxUeXBlLCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VDYW1lcmFTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGNhbWVyYSwgZGV2aWNlcywgc2VsZWN0ZWREZXZpY2UgfSA9IHVzZUNhbWVyYVN0YXRlKCk7XG4gICAgcmV0dXJuIChqc3goRGV2aWNlU2VsZWN0b3IsIHsgZGV2aWNlczogZGV2aWNlcyB8fCBbXSwgdHlwZTogXCJ2aWRlb2lucHV0XCIsIHNlbGVjdGVkRGV2aWNlSWQ6IHNlbGVjdGVkRGV2aWNlLCBvbkNoYW5nZTogYXN5bmMgKGRldmljZUlkKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBjYW1lcmEuc2VsZWN0KGRldmljZUlkKTtcbiAgICAgICAgfSwgdGl0bGU6IHRpdGxlLCB2aXN1YWxUeXBlOiB2aXN1YWxUeXBlLCBpY29uOiBcImNhbWVyYVwiIH0pKTtcbn07XG5cbmNvbnN0IERldmljZVNldHRpbmdzID0gKHsgdmlzdWFsVHlwZSA9IE1lbnVWaXN1YWxUeXBlLk1FTlUsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChNZW51VG9nZ2xlLCB7IHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsIFRvZ2dsZUJ1dHRvbjogVG9nZ2xlRGV2aWNlU2V0dGluZ3NNZW51QnV0dG9uLCB2aXN1YWxUeXBlOiB2aXN1YWxUeXBlLCBjaGlsZHJlbjoganN4KE1lbnUsIHt9KSB9KSk7XG59O1xuY29uc3QgTWVudSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NcIiwgY2hpbGRyZW46IFtqc3goRGV2aWNlU2VsZWN0b3JWaWRlbywgeyB0aXRsZTogdCgnU2VsZWN0IGEgQ2FtZXJhJykgfSksIGpzeChEZXZpY2VTZWxlY3RvckF1ZGlvSW5wdXQsIHsgdGl0bGU6IHQoJ1NlbGVjdCBhIE1pYycpIH0pLCBqc3goRGV2aWNlU2VsZWN0b3JBdWRpb091dHB1dCwgeyB0aXRsZTogdCgnU2VsZWN0IFNwZWFrZXJzJykgfSldIH0pKTtcbn07XG5jb25zdCBUb2dnbGVEZXZpY2VTZXR0aW5nc01lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZURldmljZVNldHRpbmdzTWVudUJ1dHRvbih7IG1lbnVTaG93biB9LCByZWYpIHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2J1dHRvbicsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fYnV0dG9uLS1hY3RpdmUnOiBtZW51U2hvd24sXG4gICAgICAgIH0pLCB0aXRsZTogdCgnVG9nZ2xlIGRldmljZSBtZW51JyksIGljb246IFwiZGV2aWNlLXNldHRpbmdzXCIsIHJlZjogcmVmIH0pKTtcbn0pO1xuXG5jb25zdCBUb2dnbGVBdWRpb1ByZXZpZXdCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNhcHRpb24sIE1lbnUsIG1lbnVQbGFjZW1lbnQsIC4uLnJlc3RDb21wb3NpdGVCdXR0b25Qcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyB1c2VNaWNyb3Bob25lU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgeyBtaWNyb3Bob25lLCBpc011dGUsIGhhc0Jyb3dzZXJQZXJtaXNzaW9uIH0gPSB1c2VNaWNyb3Bob25lU3RhdGUoKTtcbiAgICByZXR1cm4gKGpzeHMoQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNNdXRlLCBjYXB0aW9uOiBjYXB0aW9uLCBjbGFzc05hbWU6IGNsc3goIWhhc0Jyb3dzZXJQZXJtaXNzaW9uICYmICdzdHItdmlkZW9fX2RldmljZS11bmF2YWlsYWJsZScpLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCB0aXRsZTogIWhhc0Jyb3dzZXJQZXJtaXNzaW9uXG4gICAgICAgICAgICA/IHQoJ0NoZWNrIHlvdXIgYnJvd3NlciBhdWRpbyBwZXJtaXNzaW9ucycpXG4gICAgICAgICAgICA6IGNhcHRpb24gfHwgdCgnTWljJyksIGRpc2FibGVkOiAhaGFzQnJvd3NlclBlcm1pc3Npb24sIFwiZGF0YS10ZXN0aWRcIjogaXNNdXRlID8gJ3ByZXZpZXctYXVkaW8tdW5tdXRlLWJ1dHRvbicgOiAncHJldmlldy1hdWRpby1tdXRlLWJ1dHRvbicsIG9uQ2xpY2s6ICgpID0+IG1pY3JvcGhvbmUudG9nZ2xlKCksIE1lbnU6IE1lbnUsIG1lbnVQbGFjZW1lbnQ6IG1lbnVQbGFjZW1lbnQsIC4uLnJlc3RDb21wb3NpdGVCdXR0b25Qcm9wcywgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiAhaXNNdXRlID8gJ21pYycgOiAnbWljLW9mZicgfSksICFoYXNCcm93c2VyUGVybWlzc2lvbiAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX25vLW1lZGlhLXBlcm1pc3Npb25cIiwgdGl0bGU6IHQoJ0NoZWNrIHlvdXIgYnJvd3NlciBhdWRpbyBwZXJtaXNzaW9ucycpLCBjaGlsZHJlbjogXCIhXCIgfSkpXSB9KSk7XG59O1xuY29uc3QgVG9nZ2xlQXVkaW9QdWJsaXNoaW5nQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyBjYXB0aW9uLCBNZW51ID0ganN4KERldmljZVNlbGVjdG9yQXVkaW9JbnB1dCwgeyB2aXN1YWxUeXBlOiBcImxpc3RcIiB9KSwgbWVudVBsYWNlbWVudCA9ICd0b3AnLCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgaGFzUGVybWlzc2lvbiwgcmVxdWVzdFBlcm1pc3Npb24sIGlzQXdhaXRpbmdQZXJtaXNzaW9uIH0gPSB1c2VSZXF1ZXN0UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNFTkRfQVVESU8pO1xuICAgIGNvbnN0IHsgdXNlTWljcm9waG9uZVN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgbWljcm9waG9uZSwgaXNNdXRlLCBoYXNCcm93c2VyUGVybWlzc2lvbiB9ID0gdXNlTWljcm9waG9uZVN0YXRlKCk7XG4gICAgcmV0dXJuIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuU0VORF9BVURJT10sIGNoaWxkcmVuOiBqc3goUGVybWlzc2lvbk5vdGlmaWNhdGlvbiwgeyBwZXJtaXNzaW9uOiBPd25DYXBhYmlsaXR5LlNFTkRfQVVESU8sIGlzQXdhaXRpbmdBcHByb3ZhbDogaXNBd2FpdGluZ1Blcm1pc3Npb24sIG1lc3NhZ2VBcHByb3ZlZDogdCgnWW91IGNhbiBub3cgc3BlYWsuJyksIG1lc3NhZ2VBd2FpdGluZ0FwcHJvdmFsOiB0KCdBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc3BlYWsuJyksIG1lc3NhZ2VSZXZva2VkOiB0KCdZb3UgY2FuIG5vIGxvbmdlciBzcGVhay4nKSwgY2hpbGRyZW46IGpzeHMoQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNNdXRlLCBjYXB0aW9uOiBjYXB0aW9uLCB0aXRsZTogIWhhc1Blcm1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgPyB0KCdZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgYXVkaW8nKVxuICAgICAgICAgICAgICAgICAgICA6ICFoYXNCcm93c2VyUGVybWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0KCdDaGVjayB5b3VyIGJyb3dzZXIgbWljIHBlcm1pc3Npb25zJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2FwdGlvbiB8fCB0KCdNaWMnKSwgdmFyaWFudDogXCJzZWNvbmRhcnlcIiwgZGlzYWJsZWQ6ICFoYXNCcm93c2VyUGVybWlzc2lvbiB8fCAhaGFzUGVybWlzc2lvbiwgXCJkYXRhLXRlc3RpZFwiOiBpc011dGUgPyAnYXVkaW8tdW5tdXRlLWJ1dHRvbicgOiAnYXVkaW8tbXV0ZS1idXR0b24nLCBvbkNsaWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzUGVybWlzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVxdWVzdFBlcm1pc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG1pY3JvcGhvbmUudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBNZW51OiBNZW51LCBtZW51UGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCBtZW51T2Zmc2V0OiAxNiwgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IGlzTXV0ZSA/ICdtaWMtb2ZmJyA6ICdtaWMnIH0pLCAoIWhhc0Jyb3dzZXJQZXJtaXNzaW9uIHx8ICFoYXNQZXJtaXNzaW9uKSAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX25vLW1lZGlhLXBlcm1pc3Npb25cIiwgY2hpbGRyZW46IFwiIVwiIH0pKV0gfSkgfSkgfSkpO1xufTtcblxuY29uc3QgVG9nZ2xlVmlkZW9QcmV2aWV3QnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjYXB0aW9uLCBNZW51ID0gRGV2aWNlU2VsZWN0b3JWaWRlbywgbWVudVBsYWNlbWVudCA9ICd0b3AnLCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdXNlQ2FtZXJhU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgeyBjYW1lcmEsIGlzTXV0ZSwgaGFzQnJvd3NlclBlcm1pc3Npb24gfSA9IHVzZUNhbWVyYVN0YXRlKCk7XG4gICAgcmV0dXJuIChqc3hzKENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzTXV0ZSwgY2FwdGlvbjogY2FwdGlvbiwgY2xhc3NOYW1lOiBjbHN4KCFoYXNCcm93c2VyUGVybWlzc2lvbiAmJiAnc3RyLXZpZGVvX19kZXZpY2UtdW5hdmFpbGFibGUnKSwgdGl0bGU6ICFoYXNCcm93c2VyUGVybWlzc2lvblxuICAgICAgICAgICAgPyB0KCdDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnMnKVxuICAgICAgICAgICAgOiBjYXB0aW9uIHx8IHQoJ1ZpZGVvJyksIHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIFwiZGF0YS10ZXN0aWRcIjogaXNNdXRlID8gJ3ByZXZpZXctdmlkZW8tdW5tdXRlLWJ1dHRvbicgOiAncHJldmlldy12aWRlby1tdXRlLWJ1dHRvbicsIG9uQ2xpY2s6ICgpID0+IGNhbWVyYS50b2dnbGUoKSwgZGlzYWJsZWQ6ICFoYXNCcm93c2VyUGVybWlzc2lvbiwgTWVudTogTWVudSwgbWVudVBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246ICFpc011dGUgPyAnY2FtZXJhJyA6ICdjYW1lcmEtb2ZmJyB9KSwgIWhhc0Jyb3dzZXJQZXJtaXNzaW9uICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbm8tbWVkaWEtcGVybWlzc2lvblwiLCB0aXRsZTogdCgnQ2hlY2sgeW91ciBicm93c2VyIHZpZGVvIHBlcm1pc3Npb25zJyksIGNoaWxkcmVuOiBcIiFcIiB9KSldIH0pKTtcbn07XG5jb25zdCBUb2dnbGVWaWRlb1B1Ymxpc2hpbmdCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IGNhcHRpb24sIE1lbnUgPSBqc3goRGV2aWNlU2VsZWN0b3JWaWRlbywgeyB2aXN1YWxUeXBlOiBcImxpc3RcIiB9KSwgbWVudVBsYWNlbWVudCA9ICd0b3AnLCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgaGFzUGVybWlzc2lvbiwgcmVxdWVzdFBlcm1pc3Npb24sIGlzQXdhaXRpbmdQZXJtaXNzaW9uIH0gPSB1c2VSZXF1ZXN0UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNFTkRfVklERU8pO1xuICAgIGNvbnN0IHsgdXNlQ2FtZXJhU3RhdGUsIHVzZUNhbGxTZXR0aW5ncyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGNhbWVyYSwgaXNNdXRlLCBoYXNCcm93c2VyUGVybWlzc2lvbiB9ID0gdXNlQ2FtZXJhU3RhdGUoKTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSB1c2VDYWxsU2V0dGluZ3MoKTtcbiAgICBjb25zdCBpc1B1Ymxpc2hpbmdWaWRlb0FsbG93ZWQgPSBjYWxsU2V0dGluZ3M/LnZpZGVvLmVuYWJsZWQ7XG4gICAgcmV0dXJuIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuU0VORF9WSURFT10sIGNoaWxkcmVuOiBqc3goUGVybWlzc2lvbk5vdGlmaWNhdGlvbiwgeyBwZXJtaXNzaW9uOiBPd25DYXBhYmlsaXR5LlNFTkRfVklERU8sIGlzQXdhaXRpbmdBcHByb3ZhbDogaXNBd2FpdGluZ1Blcm1pc3Npb24sIG1lc3NhZ2VBcHByb3ZlZDogdCgnWW91IGNhbiBub3cgc2hhcmUgeW91ciB2aWRlby4nKSwgbWVzc2FnZUF3YWl0aW5nQXBwcm92YWw6IHQoJ0F3YWl0aW5nIGZvciBhbiBhcHByb3ZhbCB0byBzaGFyZSB5b3VyIHZpZGVvLicpLCBtZXNzYWdlUmV2b2tlZDogdCgnWW91IGNhbiBubyBsb25nZXIgc2hhcmUgeW91ciB2aWRlby4nKSwgY2hpbGRyZW46IGpzeHMoQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNNdXRlLCBjYXB0aW9uOiBjYXB0aW9uLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCB0aXRsZTogIWhhc1Blcm1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgPyB0KCdZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgdmlkZW8nKVxuICAgICAgICAgICAgICAgICAgICA6ICFoYXNCcm93c2VyUGVybWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0KCdDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAhaXNQdWJsaXNoaW5nVmlkZW9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0KCdWaWRlbyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkIGJ5IHRoZSBzeXN0ZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FwdGlvbiB8fCB0KCdWaWRlbycpLCBkaXNhYmxlZDogIWhhc0Jyb3dzZXJQZXJtaXNzaW9uIHx8ICFoYXNQZXJtaXNzaW9uIHx8ICFpc1B1Ymxpc2hpbmdWaWRlb0FsbG93ZWQsIFwiZGF0YS10ZXN0aWRcIjogaXNNdXRlID8gJ3ZpZGVvLXVubXV0ZS1idXR0b24nIDogJ3ZpZGVvLW11dGUtYnV0dG9uJywgb25DbGljazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYW1lcmEudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBNZW51OiBNZW51LCBtZW51UGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCBtZW51T2Zmc2V0OiAxNiwgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IGlzTXV0ZSA/ICdjYW1lcmEtb2ZmJyA6ICdjYW1lcmEnIH0pLCAoIWhhc0Jyb3dzZXJQZXJtaXNzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhaGFzUGVybWlzc2lvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzUHVibGlzaGluZ1ZpZGVvQWxsb3dlZCkgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19uby1tZWRpYS1wZXJtaXNzaW9uXCIsIGNoaWxkcmVuOiBcIiFcIiB9KSldIH0pIH0pIH0pKTtcbn07XG5cbmNvbnN0IEVuZENhbGxNZW51ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBvbkxlYXZlLCBvbkVuZCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLWNhbGxfX2NvbmZpcm1hdGlvblwiLCBjaGlsZHJlbjogW2pzeHMoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19idXR0b24gc3RyLXZpZGVvX19lbmQtY2FsbF9fbGVhdmVcIiwgdHlwZTogXCJidXR0b25cIiwgXCJkYXRhLXRlc3RpZFwiOiBcImxlYXZlLWNhbGwtYnV0dG9uXCIsIG9uQ2xpY2s6IG9uTGVhdmUsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fYnV0dG9uX19pY29uIHN0ci12aWRlb19fZW5kLWNhbGxfX2xlYXZlLWljb25cIiwgaWNvbjogXCJsb2dvdXRcIiB9KSwgdCgnTGVhdmUgY2FsbCcpXSB9KSwganN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LkVORF9DQUxMXSwgY2hpbGRyZW46IGpzeHMoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19idXR0b24gc3RyLXZpZGVvX19lbmQtY2FsbF9fZW5kXCIsIHR5cGU6IFwiYnV0dG9uXCIsIFwiZGF0YS10ZXN0aWRcIjogXCJlbmQtY2FsbC1mb3ItYWxsLWJ1dHRvblwiLCBvbkNsaWNrOiBvbkVuZCwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19idXR0b25fX2ljb24gc3RyLXZpZGVvX19lbmQtY2FsbF9fZW5kLWljb25cIiwgaWNvbjogXCJjYWxsLWVuZFwiIH0pLCB0KCdFbmQgY2FsbCBmb3IgYWxsJyldIH0pIH0pXSB9KSk7XG59O1xuY29uc3QgQ2FuY2VsQ2FsbFRvZ2dsZU1lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIENhbmNlbENhbGxUb2dnbGVNZW51QnV0dG9uKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGljb246IFwiY2FsbC1lbmRcIiwgdmFyaWFudDogXCJkYW5nZXJcIiwgdGl0bGU6IHQoJ0xlYXZlIGNhbGwnKSwgXCJkYXRhLXRlc3RpZFwiOiBcImxlYXZlLWNhbGwtYnV0dG9uXCIsIHJlZjogcmVmIH0pKTtcbn0pO1xuY29uc3QgQ2FuY2VsQ2FsbENvbmZpcm1CdXR0b24gPSAoeyBvbkNsaWNrLCBvbkxlYXZlLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBoYW5kbGVMZWF2ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGwpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGwubGVhdmUoKTtcbiAgICAgICAgICAgIG9uTGVhdmU/LigpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2ssIG9uTGVhdmUsIGNhbGxdKTtcbiAgICBjb25zdCBoYW5kbGVFbmRDYWxsID0gdXNlQ2FsbGJhY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbCkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbC5lbmRDYWxsKCk7XG4gICAgICAgICAgICBvbkxlYXZlPy4oKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrLCBvbkxlYXZlLCBjYWxsXSk7XG4gICAgcmV0dXJuIChqc3goTWVudVRvZ2dsZSwgeyBwbGFjZW1lbnQ6IFwidG9wLXN0YXJ0XCIsIFRvZ2dsZUJ1dHRvbjogQ2FuY2VsQ2FsbFRvZ2dsZU1lbnVCdXR0b24sIGNoaWxkcmVuOiBqc3goRW5kQ2FsbE1lbnUsIHsgb25FbmQ6IGhhbmRsZUVuZENhbGwsIG9uTGVhdmU6IGhhbmRsZUxlYXZlIH0pIH0pKTtcbn07XG5jb25zdCBDYW5jZWxDYWxsQnV0dG9uID0gKHsgZGlzYWJsZWQsIG9uQ2xpY2ssIG9uTGVhdmUsIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbCkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbC5sZWF2ZSgpO1xuICAgICAgICAgICAgb25MZWF2ZT8uKCk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGljaywgb25MZWF2ZSwgY2FsbF0pO1xuICAgIHJldHVybiAoanN4KEljb25CdXR0b24sIHsgZGlzYWJsZWQ6IGRpc2FibGVkLCBpY29uOiBcImNhbGwtZW5kXCIsIHZhcmlhbnQ6IFwiZGFuZ2VyXCIsIHRpdGxlOiB0KCdMZWF2ZSBjYWxsJyksIFwiZGF0YS10ZXN0aWRcIjogXCJjYW5jZWwtY2FsbC1idXR0b25cIiwgb25DbGljazogaGFuZGxlQ2xpY2sgfSkpO1xufTtcblxuY29uc3QgQ2FsbENvbnRyb2xzID0gKHsgb25MZWF2ZSB9KSA9PiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtY29udHJvbHNcIiwgY2hpbGRyZW46IFtqc3goUmVjb3JkQ2FsbEJ1dHRvbiwge30pLCBqc3goUmVhY3Rpb25zQnV0dG9uLCB7fSksIGpzeChTY3JlZW5TaGFyZUJ1dHRvbiwge30pLCBqc3goU3BlYWtpbmdXaGlsZU11dGVkTm90aWZpY2F0aW9uLCB7IGNoaWxkcmVuOiBqc3goVG9nZ2xlQXVkaW9QdWJsaXNoaW5nQnV0dG9uLCB7fSkgfSksIGpzeChUb2dnbGVWaWRlb1B1Ymxpc2hpbmdCdXR0b24sIHt9KSwganN4KENhbmNlbENhbGxCdXR0b24sIHsgb25MZWF2ZTogb25MZWF2ZSB9KV0gfSkpO1xuXG5DaGFydC5yZWdpc3RlcihDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCk7XG5jb25zdCBDYWxsU3RhdHNMYXRlbmN5Q2hhcnQgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHZhbHVlcyB9ID0gcHJvcHM7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgbGFiZWxzOiB2YWx1ZXMubWFwKChwb2ludCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHBvaW50LnggKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtkYXRlLmdldEhvdXJzKCl9OiR7ZGF0ZS5nZXRNaW51dGVzKCl9YDtcbiAgICAgICAgfSksXG4gICAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzLm1hcCgocG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB5IH0gPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzAwZTJhMScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzAwZTJhMScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH07XG4gICAgY29uc3Qgb3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgIG1heDogTWF0aC5tYXgoMTgwLCBNYXRoLmNlaWwoKG1heCArIDEwKSAvIDEwKSAqIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzk3OWNhMCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwU2l6ZTogMzAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW21heF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0cy1saW5lLWNoYXJ0LWNvbnRhaW5lclwiLCBjaGlsZHJlbjoganN4KExpbmUsIHsgb3B0aW9uczogb3B0aW9ucywgZGF0YTogZGF0YSwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fbGF0ZW5jeWNoYXJ0XCIgfSkgfSkpO1xufTtcblxudmFyIFN0YXR1c2VzO1xuKGZ1bmN0aW9uIChTdGF0dXNlcykge1xuICAgIFN0YXR1c2VzW1wiR09PRFwiXSA9IFwiR29vZFwiO1xuICAgIFN0YXR1c2VzW1wiT0tcIl0gPSBcIk9rXCI7XG4gICAgU3RhdHVzZXNbXCJCQURcIl0gPSBcIkJhZFwiO1xufSkoU3RhdHVzZXMgfHwgKFN0YXR1c2VzID0ge30pKTtcbmNvbnN0IHN0YXRzU3RhdHVzID0gKHsgdmFsdWUsIGxvd0JvdW5kLCBoaWdoQm91bmQsIH0pID0+IHtcbiAgICBpZiAodmFsdWUgPD0gbG93Qm91bmQpIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c2VzLkdPT0Q7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSBsb3dCb3VuZCAmJiB2YWx1ZSA8PSBoaWdoQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c2VzLk9LO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gaGlnaEJvdW5kKSB7XG4gICAgICAgIHJldHVybiBTdGF0dXNlcy5CQUQ7XG4gICAgfVxuICAgIHJldHVybiBTdGF0dXNlcy5HT09EO1xufTtcbmNvbnN0IENhbGxTdGF0cyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbGF0ZW5jeUxvd0JvdW5kID0gNzUsIGxhdGVuY3lIaWdoQm91bmQgPSA0MDAgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtsYXRlbmN5QnVmZmVyLCBzZXRMYXRlbmN5QnVmZmVyXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IDIwIH0sIChfLCBpKSA9PiAoeyB4OiBub3cgKyBpLCB5OiAwIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBbcHVibGlzaEJpdHJhdGUsIHNldFB1Ymxpc2hCaXRyYXRlXSA9IHVzZVN0YXRlKCctJyk7XG4gICAgY29uc3QgW3N1YnNjcmliZUJpdHJhdGUsIHNldFN1YnNjcmliZUJpdHJhdGVdID0gdXNlU3RhdGUoJy0nKTtcbiAgICBjb25zdCBwcmV2aW91c1N0YXRzID0gdXNlUmVmKCk7XG4gICAgY29uc3QgeyB1c2VDYWxsU3RhdHNSZXBvcnQgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgY2FsbFN0YXRzUmVwb3J0ID0gdXNlQ2FsbFN0YXRzUmVwb3J0KCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsU3RhdHNSZXBvcnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcHJldmlvdXNTdGF0cy5jdXJyZW50KSB7XG4gICAgICAgICAgICBwcmV2aW91c1N0YXRzLmN1cnJlbnQgPSBjYWxsU3RhdHNSZXBvcnQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNDYWxsU3RhdHNSZXBvcnQgPSBwcmV2aW91c1N0YXRzLmN1cnJlbnQ7XG4gICAgICAgIHNldFB1Ymxpc2hCaXRyYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVQdWJsaXNoQml0cmF0ZShwcmV2aW91c0NhbGxTdGF0c1JlcG9ydCwgY2FsbFN0YXRzUmVwb3J0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFN1YnNjcmliZUJpdHJhdGUoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZVN1YnNjcmliZUJpdHJhdGUocHJldmlvdXNDYWxsU3RhdHNSZXBvcnQsIGNhbGxTdGF0c1JlcG9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRMYXRlbmN5QnVmZmVyKChsYXRlbmN5QnVmKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdMYXRlbmN5QnVmZmVyID0gbGF0ZW5jeUJ1Zi5zbGljZSgtMTkpO1xuICAgICAgICAgICAgbmV3TGF0ZW5jeUJ1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBjYWxsU3RhdHNSZXBvcnQudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIHk6IGNhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdMYXRlbmN5QnVmZmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXNTdGF0cy5jdXJyZW50ID0gY2FsbFN0YXRzUmVwb3J0O1xuICAgIH0sIFtjYWxsU3RhdHNSZXBvcnRdKTtcbiAgICBjb25zdCBsYXRlbmN5Q29tcGFyaXNvbiA9IHtcbiAgICAgICAgbG93Qm91bmQ6IGxhdGVuY3lMb3dCb3VuZCxcbiAgICAgICAgaGlnaEJvdW5kOiBsYXRlbmN5SGlnaEJvdW5kLFxuICAgICAgICB2YWx1ZTogY2FsbFN0YXRzUmVwb3J0Py5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgfHwgMCxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c1wiLCBjaGlsZHJlbjogY2FsbFN0YXRzUmVwb3J0ICYmIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2hlYWRlclwiLCBjaGlsZHJlbjogW2pzeHMoXCJoM1wiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2hlYWRpbmdcIiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19pY29uXCIsIGljb246IFwiY2FsbC1sYXRlbmN5XCIgfSksIHQoJ0NhbGwgTGF0ZW5jeScpXSB9KSwganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2Rlc2NyaXB0aW9uXCIsIGNoaWxkcmVuOiB0KCdWZXJ5IGhpZ2ggbGF0ZW5jeSB2YWx1ZXMgbWF5IHJlZHVjZSBjYWxsIHF1YWxpdHksIGNhdXNlIGxhZywgYW5kIG1ha2UgdGhlIGNhbGwgbGVzcyBlbmpveWFibGUuJykgfSldIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19sYXRlbmN5Y2hhcnRcIiwgY2hpbGRyZW46IGpzeChDYWxsU3RhdHNMYXRlbmN5Q2hhcnQsIHsgdmFsdWVzOiBsYXRlbmN5QnVmZmVyIH0pIH0pLCBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19faGVhZGVyXCIsIGNoaWxkcmVuOiBbanN4cyhcImgzXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19faGVhZGluZ1wiLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2ljb25cIiwgaWNvbjogXCJuZXR3b3JrLXF1YWxpdHlcIiB9KSwgdCgnQ2FsbCBwZXJmb3JtYW5jZScpXSB9KSwganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2Rlc2NyaXB0aW9uXCIsIGNoaWxkcmVuOiB0KCdSZXZpZXcgdGhlIGtleSBkYXRhIHBvaW50cyBiZWxvdyB0byBhc3Nlc3MgY2FsbCBwZXJmb3JtYW5jZScpIH0pXSB9KSwganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmQtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBbanN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIlJlZ2lvblwiLCB2YWx1ZTogY2FsbFN0YXRzUmVwb3J0LmRhdGFjZW50ZXIgfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJMYXRlbmN5XCIsIHZhbHVlOiBgJHtjYWxsU3RhdHNSZXBvcnQucHVibGlzaGVyU3RhdHMuYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zfSBtcy5gLCBjb21wYXJpc29uOiBsYXRlbmN5Q29tcGFyaXNvbiB9KSwganN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIlJlY2VpdmUgaml0dGVyXCIsIHZhbHVlOiBgJHtjYWxsU3RhdHNSZXBvcnQuc3Vic2NyaWJlclN0YXRzLmF2ZXJhZ2VKaXR0ZXJJbk1zfSBtcy5gLCBjb21wYXJpc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmxhdGVuY3lDb21wYXJpc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2FsbFN0YXRzUmVwb3J0LnN1YnNjcmliZXJTdGF0cy5hdmVyYWdlSml0dGVySW5NcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUHVibGlzaCBqaXR0ZXJcIiwgdmFsdWU6IGAke2NhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlSml0dGVySW5Nc30gbXMuYCwgY29tcGFyaXNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5sYXRlbmN5Q29tcGFyaXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlSml0dGVySW5NcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUHVibGlzaCByZXNvbHV0aW9uXCIsIHZhbHVlOiB0b0ZyYW1lU2l6ZShjYWxsU3RhdHNSZXBvcnQucHVibGlzaGVyU3RhdHMpIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUHVibGlzaCBxdWFsaXR5IGRyb3AgcmVhc29uXCIsIHZhbHVlOiBjYWxsU3RhdHNSZXBvcnQucHVibGlzaGVyU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb25zIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUmVjZWl2aW5nIHJlc29sdXRpb25cIiwgdmFsdWU6IHRvRnJhbWVTaXplKGNhbGxTdGF0c1JlcG9ydC5zdWJzY3JpYmVyU3RhdHMpIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUmVjZWl2ZSBxdWFsaXR5IGRyb3AgcmVhc29uXCIsIHZhbHVlOiBjYWxsU3RhdHNSZXBvcnQuc3Vic2NyaWJlclN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucyB9KSwganN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIlB1Ymxpc2ggYml0cmF0ZVwiLCB2YWx1ZTogcHVibGlzaEJpdHJhdGUgfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJSZWNlaXZpbmcgYml0cmF0ZVwiLCB2YWx1ZTogc3Vic2NyaWJlQml0cmF0ZSB9KV0gfSldIH0pKSB9KSk7XG59O1xuY29uc3QgU3RhdENhcmRFeHBsYW5hdGlvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgZGVzY3JpcHRpb24gfSA9IHByb3BzO1xuICAgIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgeyByZWZzLCBmbG9hdGluZ1N0eWxlcywgY29udGV4dCB9ID0gdXNlRmxvYXRpbmcoe1xuICAgICAgICBvcGVuOiBpc09wZW4sXG4gICAgICAgIG9uT3BlbkNoYW5nZTogc2V0SXNPcGVuLFxuICAgIH0pO1xuICAgIGNvbnN0IGhvdmVyID0gdXNlSG92ZXIoY29udGV4dCk7XG4gICAgY29uc3QgeyBnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcyB9ID0gdXNlSW50ZXJhY3Rpb25zKFtob3Zlcl0pO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtZXhwbGFuYXRpb25cIiwgcmVmOiByZWZzLnNldFJlZmVyZW5jZSwgLi4uZ2V0UmVmZXJlbmNlUHJvcHMoKSwgY2hpbGRyZW46IGpzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtZXhwbGFuYXRpb25fX2ljb25cIiwgaWNvbjogXCJpbmZvXCIgfSkgfSksIGlzT3BlbiAmJiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1leHBsYW5hdGlvbl9fZGVzY3JpcHRpb25cIiwgcmVmOiByZWZzLnNldEZsb2F0aW5nLCBzdHlsZTogZmxvYXRpbmdTdHlsZXMsIC4uLmdldEZsb2F0aW5nUHJvcHMoKSwgY2hpbGRyZW46IGRlc2NyaXB0aW9uIH0pKV0gfSkpO1xufTtcbmNvbnN0IFN0YXRzVGFnID0gKHsgY2hpbGRyZW4sIHN0YXR1cyA9IFN0YXR1c2VzLkdPT0QsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jYWxsLXN0YXRzX190YWcnLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jYWxsLXN0YXRzX190YWctLWdvb2QnOiBzdGF0dXMgPT09IFN0YXR1c2VzLkdPT0QsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jYWxsLXN0YXRzX190YWctLW9rJzogc3RhdHVzID09PSBTdGF0dXNlcy5PSyxcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2NhbGwtc3RhdHNfX3RhZy0tYmFkJzogc3RhdHVzID09PSBTdGF0dXNlcy5CQUQsXG4gICAgICAgIH0pLCBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fdGFnX190ZXh0XCIsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59O1xuY29uc3QgU3RhdENhcmQgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGxhYmVsLCB2YWx1ZSwgZGVzY3JpcHRpb24sIGNvbXBhcmlzb24gfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHN0YXR1cyA9IGNvbXBhcmlzb24gPyBzdGF0c1N0YXR1cyhjb21wYXJpc29uKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19jYXJkXCIsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmQtY29udGVudFwiLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19jYXJkLWxhYmVsXCIsIGNoaWxkcmVuOiBbbGFiZWwsIGRlc2NyaXB0aW9uICYmIGpzeChTdGF0Q2FyZEV4cGxhbmF0aW9uLCB7IGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9KV0gfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmQtdmFsdWVcIiwgY2hpbGRyZW46IHZhbHVlIH0pXSB9KSwgY29tcGFyaXNvbiAmJiBzdGF0dXMgJiYganN4KFN0YXRzVGFnLCB7IHN0YXR1czogc3RhdHVzLCBjaGlsZHJlbjogdChzdGF0dXMpIH0pXSB9KSk7XG59O1xuY29uc3QgdG9GcmFtZVNpemUgPSAoc3RhdHMpID0+IHtcbiAgICBjb25zdCB7IGhpZ2hlc3RGcmFtZVdpZHRoOiB3LCBoaWdoZXN0RnJhbWVIZWlnaHQ6IGgsIGhpZ2hlc3RGcmFtZXNQZXJTZWNvbmQ6IGZwcywgfSA9IHN0YXRzO1xuICAgIGxldCBzaXplID0gYC1gO1xuICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgc2l6ZSA9IGAke3d9eCR7aH1gO1xuICAgICAgICBpZiAoZnBzKSB7XG4gICAgICAgICAgICBzaXplICs9IGBAJHtmcHN9ZnBzLmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59O1xuY29uc3QgY2FsY3VsYXRlUHVibGlzaEJpdHJhdGUgPSAocHJldmlvdXNDYWxsU3RhdHNSZXBvcnQsIGNhbGxTdGF0c1JlcG9ydCkgPT4ge1xuICAgIGNvbnN0IHsgcHVibGlzaGVyU3RhdHM6IHsgdG90YWxCeXRlc1NlbnQ6IHByZXZpb3VzVG90YWxCeXRlc1NlbnQsIHRpbWVzdGFtcDogcHJldmlvdXNUaW1lc3RhbXAsIH0sIH0gPSBwcmV2aW91c0NhbGxTdGF0c1JlcG9ydDtcbiAgICBjb25zdCB7IHB1Ymxpc2hlclN0YXRzOiB7IHRvdGFsQnl0ZXNTZW50LCB0aW1lc3RhbXAgfSwgfSA9IGNhbGxTdGF0c1JlcG9ydDtcbiAgICBjb25zdCBieXRlc1NlbnQgPSB0b3RhbEJ5dGVzU2VudCAtIHByZXZpb3VzVG90YWxCeXRlc1NlbnQ7XG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSB0aW1lc3RhbXAgLSBwcmV2aW91c1RpbWVzdGFtcDtcbiAgICByZXR1cm4gYCR7KChieXRlc1NlbnQgKiA4KSAvIHRpbWVFbGFwc2VkKS50b0ZpeGVkKDIpfSBrYnBzYDtcbn07XG5jb25zdCBjYWxjdWxhdGVTdWJzY3JpYmVCaXRyYXRlID0gKHByZXZpb3VzQ2FsbFN0YXRzUmVwb3J0LCBjYWxsU3RhdHNSZXBvcnQpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmliZXJTdGF0czogeyB0b3RhbEJ5dGVzUmVjZWl2ZWQ6IHByZXZpb3VzVG90YWxCeXRlc1JlY2VpdmVkLCB0aW1lc3RhbXA6IHByZXZpb3VzVGltZXN0YW1wLCB9LCB9ID0gcHJldmlvdXNDYWxsU3RhdHNSZXBvcnQ7XG4gICAgY29uc3QgeyBzdWJzY3JpYmVyU3RhdHM6IHsgdG90YWxCeXRlc1JlY2VpdmVkLCB0aW1lc3RhbXAgfSwgfSA9IGNhbGxTdGF0c1JlcG9ydDtcbiAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gdG90YWxCeXRlc1JlY2VpdmVkIC0gcHJldmlvdXNUb3RhbEJ5dGVzUmVjZWl2ZWQ7XG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSB0aW1lc3RhbXAgLSBwcmV2aW91c1RpbWVzdGFtcDtcbiAgICByZXR1cm4gYCR7KChieXRlc1JlY2VpdmVkICogOCkgLyB0aW1lRWxhcHNlZCkudG9GaXhlZCgyKX0ga2Jwc2A7XG59O1xuXG5jb25zdCBDYWxsU3RhdHNCdXR0b24gPSAoKSA9PiAoanN4KE1lbnVUb2dnbGUsIHsgcGxhY2VtZW50OiBcInRvcC1lbmRcIiwgVG9nZ2xlQnV0dG9uOiBUb2dnbGVNZW51QnV0dG9uLCBjaGlsZHJlbjoganN4KENhbGxTdGF0cywge30pIH0pKTtcbmNvbnN0IFRvZ2dsZU1lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZU1lbnVCdXR0b24ocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgY2FwdGlvbiwgbWVudVNob3duIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChDb21wb3NpdGVCdXR0b24sIHsgcmVmOiByZWYsIGFjdGl2ZTogbWVudVNob3duLCBjYXB0aW9uOiBjYXB0aW9uLCB0aXRsZTogY2FwdGlvbiB8fCB0KCdTdGF0aXN0aWNzJyksIFwiZGF0YS10ZXN0aWRcIjogXCJzdGF0cy1idXR0b25cIiwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwic3RhdHNcIiB9KSB9KSk7XG59KTtcblxuY29uc3QgVG9nZ2xlQXVkaW9PdXRwdXRCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IGNhcHRpb24sIE1lbnUgPSBEZXZpY2VTZWxlY3RvckF1ZGlvT3V0cHV0LCBtZW51UGxhY2VtZW50ID0gJ3RvcCcsIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChDb21wb3NpdGVCdXR0b24sIHsgTWVudTogTWVudSwgbWVudVBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgY2FwdGlvbjogY2FwdGlvbiwgdGl0bGU6IGNhcHRpb24gfHwgdCgnU3BlYWtlcnMnKSwgXCJkYXRhLXRlc3RpZFwiOiBcImF1ZGlvLW91dHB1dC1idXR0b25cIiwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwic3BlYWtlclwiIH0pIH0pKTtcbn07XG5cbmNvbnN0IEJsb2NrZWRVc2VyTGlzdGluZyA9ICh7IGRhdGEgfSkgPT4ge1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nXCIsIGNoaWxkcmVuOiBkYXRhLm1hcCgodXNlcklkKSA9PiAoanN4KEJsb2NrZWRVc2VyTGlzdGluZ0l0ZW0sIHsgdXNlcklkOiB1c2VySWQgfSwgdXNlcklkKSkpIH0pIH0pKTtcbn07XG5jb25zdCBCbG9ja2VkVXNlckxpc3RpbmdJdGVtID0gKHsgdXNlcklkIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHVuYmxvY2tVc2VyQ2xpY2tIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAodXNlcklkKVxuICAgICAgICAgICAgY2FsbD8udW5ibG9ja1VzZXIodXNlcklkKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbVwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9fZGlzcGxheS1uYW1lXCIsIGNoaWxkcmVuOiB1c2VySWQgfSksIGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5CTE9DS19VU0VSU10sIGNoaWxkcmVuOiBqc3goVGV4dEJ1dHRvbiwgeyBvbkNsaWNrOiB1bmJsb2NrVXNlckNsaWNrSGFuZGxlciwgY2hpbGRyZW46IFwiVW5ibG9ja1wiIH0pIH0pXSB9KSk7XG59O1xuXG5jb25zdCBDYWxsUGFydGljaXBhbnRMaXN0SGVhZGVyID0gKHsgb25DbG9zZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRzLCB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50IH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHVzZVBhcnRpY2lwYW50cygpO1xuICAgIGNvbnN0IGFub255bW91c1BhcnRpY2lwYW50Q291bnQgPSB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50KCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdC1oZWFkZXJcIiwgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdC1oZWFkZXJfX3RpdGxlXCIsIGNoaWxkcmVuOiBbdCgnUGFydGljaXBhbnRzJyksICcgJywganN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0LWhlYWRlcl9fdGl0bGUtY291bnRcIiwgY2hpbGRyZW46IFtcIltcIiwgcGFydGljaXBhbnRzLmxlbmd0aCwgXCJdXCJdIH0pLCBhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50ID4gMCAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3QtaGVhZGVyX190aXRsZS1hbm9ueW1vdXNcIiwgY2hpbGRyZW46IHQoJ0Fub255bW91cycsIHsgY291bnQ6IGFub255bW91c1BhcnRpY2lwYW50Q291bnQgfSkgfSkpXSB9KSwganN4KEljb25CdXR0b24sIHsgb25DbGljazogb25DbG9zZSwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdC1oZWFkZXJfX2Nsb3NlLWJ1dHRvblwiLCBpY29uOiBcImNsb3NlXCIgfSldIH0pKTtcbn07XG5cbmNvbnN0IFRvb2x0aXAgPSAoeyBjaGlsZHJlbiwgcmVmZXJlbmNlRWxlbWVudCwgdG9vbHRpcENsYXNzTmFtZSwgdG9vbHRpcFBsYWNlbWVudCA9ICd0b3AnLCB2aXNpYmxlID0gZmFsc2UsIH0pID0+IHtcbiAgICBjb25zdCB7IHJlZnMsIHgsIHksIHN0cmF0ZWd5IH0gPSB1c2VGbG9hdGluZ1VJUHJlc2V0KHtcbiAgICAgICAgcGxhY2VtZW50OiB0b29sdGlwUGxhY2VtZW50LFxuICAgICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZWZzLnNldFJlZmVyZW5jZShyZWZlcmVuY2VFbGVtZW50KTtcbiAgICB9LCBbcmVmZXJlbmNlRWxlbWVudCwgcmVmc10pO1xuICAgIGlmICghdmlzaWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fdG9vbHRpcCcsIHRvb2x0aXBDbGFzc05hbWUpLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIHN0eWxlOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICAgICAgICB0b3A6IHkgPz8gMCxcbiAgICAgICAgICAgIGxlZnQ6IHggPz8gMCxcbiAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcblxuY29uc3QgdXNlRW50ZXJMZWF2ZUhhbmRsZXJzID0gKHsgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IFt0b29sdGlwVmlzaWJsZSwgc2V0VG9vbHRpcFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGhhbmRsZU1vdXNlRW50ZXIgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBzZXRUb29sdGlwVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgb25Nb3VzZUVudGVyPy4oZSk7XG4gICAgfSwgW29uTW91c2VFbnRlcl0pO1xuICAgIGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBzZXRUb29sdGlwVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIG9uTW91c2VMZWF2ZT8uKGUpO1xuICAgIH0sIFtvbk1vdXNlTGVhdmVdKTtcbiAgICByZXR1cm4geyBoYW5kbGVNb3VzZUVudGVyLCBoYW5kbGVNb3VzZUxlYXZlLCB0b29sdGlwVmlzaWJsZSB9O1xufTtcblxuLy8gdG9kbzogZHVwbGljYXRlIG9mIENhbGxQYXJ0aWNpcGFudExpc3QudHN4I01lZGlhSW5kaWNhdG9yIC0gcmVmYWN0b3IgdG8gYSBzaW5nbGUgY29tcG9uZW50XG5jb25zdCBXaXRoVG9vbHRpcCA9ICh7IHRpdGxlLCB0b29sdGlwQ2xhc3NOYW1lLCB0b29sdGlwUGxhY2VtZW50LCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyBoYW5kbGVNb3VzZUVudGVyLCBoYW5kbGVNb3VzZUxlYXZlLCB0b29sdGlwVmlzaWJsZSB9ID0gdXNlRW50ZXJMZWF2ZUhhbmRsZXJzKCk7XG4gICAgY29uc3QgW3Rvb2x0aXBBbmNob3IsIHNldFRvb2x0aXBBbmNob3JdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFRvb2x0aXAsIHsgcmVmZXJlbmNlRWxlbWVudDogdG9vbHRpcEFuY2hvciwgdmlzaWJsZTogdG9vbHRpcFZpc2libGUsIHRvb2x0aXBDbGFzc05hbWU6IHRvb2x0aXBDbGFzc05hbWUsIHRvb2x0aXBQbGFjZW1lbnQ6IHRvb2x0aXBQbGFjZW1lbnQsIGNoaWxkcmVuOiB0aXRsZSB8fCAnJyB9KSwganN4KFwiZGl2XCIsIHsgcmVmOiBzZXRUb29sdGlwQW5jaG9yLCBvbk1vdXNlRW50ZXI6IGhhbmRsZU1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZTogaGFuZGxlTW91c2VMZWF2ZSwgLi4ucHJvcHMgfSldIH0pKTtcbn07XG5cbmNvbnN0IENhbGxQYXJ0aWNpcGFudExpc3RpbmdJdGVtID0gKHsgcGFydGljaXBhbnQsIERpc3BsYXlOYW1lID0gRGVmYXVsdERpc3BsYXlOYW1lLCB9KSA9PiB7XG4gICAgY29uc3QgaXNBdWRpb09uID0gcGFydGljaXBhbnQucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuQVVESU8pO1xuICAgIGNvbnN0IGlzVmlkZW9PbiA9IHBhcnRpY2lwYW50LnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKTtcbiAgICBjb25zdCBpc1Bpbm5lZCA9ICEhcGFydGljaXBhbnQucGluO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbVwiLCBjaGlsZHJlbjogW2pzeChBdmF0YXIsIHsgbmFtZTogcGFydGljaXBhbnQubmFtZSwgaW1hZ2VTcmM6IHBhcnRpY2lwYW50LmltYWdlIH0pLCBqc3goRGlzcGxheU5hbWUsIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50IH0pLCBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtX19tZWRpYS1pbmRpY2F0b3ItZ3JvdXBcIiwgY2hpbGRyZW46IFtqc3goTWVkaWFJbmRpY2F0b3IsIHsgdGl0bGU6IGlzQXVkaW9PbiA/IHQoJ01pY3JvcGhvbmUgb24nKSA6IHQoJ01pY3JvcGhvbmUgb2ZmJyksIGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nLWl0ZW1fX2ljb24nLCBgc3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nLWl0ZW1fX2ljb24tJHtpc0F1ZGlvT24gPyAnbWljJyA6ICdtaWMtb2ZmJ31gKSB9KSwganN4KE1lZGlhSW5kaWNhdG9yLCB7IHRpdGxlOiBpc1ZpZGVvT24gPyB0KCdDYW1lcmEgb24nKSA6IHQoJ0NhbWVyYSBvZmYnKSwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbicsIGBzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbi0ke2lzVmlkZW9PbiA/ICdjYW1lcmEnIDogJ2NhbWVyYS1vZmYnfWApIH0pLCBpc1Bpbm5lZCAmJiAoanN4KE1lZGlhSW5kaWNhdG9yLCB7IHRpdGxlOiB0KCdQaW5uZWQnKSwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbicsICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbi1waW5uZWQnKSB9KSksIGpzeChNZW51VG9nZ2xlLCB7IHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsIFRvZ2dsZUJ1dHRvbjogVG9nZ2xlQnV0dG9uJDIsIGNoaWxkcmVuOiBqc3goUGFydGljaXBhbnRWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBwYXJ0aWNpcGFudCwgdHJhY2tUeXBlOiAnbm9uZScgfSwgY2hpbGRyZW46IGpzeChQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSwge30pIH0pIH0pXSB9KV0gfSkpO1xufTtcbmNvbnN0IE1lZGlhSW5kaWNhdG9yID0gKHByb3BzKSA9PiAoanN4KFdpdGhUb29sdGlwLCB7IC4uLnByb3BzIH0pKTtcbmNvbnN0IERlZmF1bHREaXNwbGF5TmFtZSA9ICh7IHBhcnRpY2lwYW50IH0pID0+IHtcbiAgICBjb25zdCBjb25uZWN0ZWRVc2VyID0gdXNlQ29ubmVjdGVkVXNlcigpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IG1lRmxhZyA9IHBhcnRpY2lwYW50LnVzZXJJZCA9PT0gY29ubmVjdGVkVXNlcj8uaWQgPyB0KCdNZScpIDogJyc7XG4gICAgY29uc3QgbmFtZU9ySWQgPSBwYXJ0aWNpcGFudC5uYW1lIHx8IHBhcnRpY2lwYW50LnVzZXJJZCB8fCB0KCdVbmtub3duJyk7XG4gICAgbGV0IGRpc3BsYXlOYW1lO1xuICAgIGlmICghcGFydGljaXBhbnQubmFtZSkge1xuICAgICAgICBkaXNwbGF5TmFtZSA9IG1lRmxhZyB8fCBuYW1lT3JJZCB8fCB0KCdVbmtub3duJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1lRmxhZykge1xuICAgICAgICBkaXNwbGF5TmFtZSA9IGAke25hbWVPcklkfSAoJHttZUZsYWd9KWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkaXNwbGF5TmFtZSA9IG5hbWVPcklkO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChXaXRoVG9vbHRpcCwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nLWl0ZW1fX2Rpc3BsYXktbmFtZVwiLCB0aXRsZTogZGlzcGxheU5hbWUsIGNoaWxkcmVuOiBkaXNwbGF5TmFtZSB9KSk7XG59O1xuY29uc3QgVG9nZ2xlQnV0dG9uJDIgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZUJ1dHRvbihwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIGpzeChJY29uQnV0dG9uLCB7IGVuYWJsZWQ6IHByb3BzLm1lbnVTaG93biwgaWNvbjogXCJlbGxpcHNpc1wiLCByZWY6IHJlZiB9KTtcbn0pO1xuXG5jb25zdCBDYWxsUGFydGljaXBhbnRMaXN0aW5nID0gKHsgZGF0YSwgfSkgPT4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmdcIiwgY2hpbGRyZW46IGRhdGEubWFwKChwYXJ0aWNpcGFudCkgPT4gKGpzeChDYWxsUGFydGljaXBhbnRMaXN0aW5nSXRlbSwgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQgfSwgcGFydGljaXBhbnQuc2Vzc2lvbklkKSkpIH0pKTtcblxuY29uc3QgRW1wdHlQYXJ0aWNpcGFudFNlYXJjaExpc3QgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0LS1lbXB0eVwiLCBjaGlsZHJlbjogdCgnTm8gcGFydGljaXBhbnRzIGZvdW5kJykgfSkpO1xufTtcblxuY29uc3QgU2VhcmNoSW5wdXQgPSAoeyBleGl0U2VhcmNoLCBpc0FjdGl2ZSwgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3QgW2lucHV0RWxlbWVudCwgc2V0SW5wdXRFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleS50b0xvd2VyQ2FzZSgpID09PSAnZXNjYXBlJylcbiAgICAgICAgICAgICAgICBleGl0U2VhcmNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgICB9O1xuICAgIH0sIFtleGl0U2VhcmNoLCBpbnB1dEVsZW1lbnRdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fc2VhcmNoLWlucHV0X19jb250YWluZXInLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19zZWFyY2gtaW5wdXRfX2NvbnRhaW5lci0tYWN0aXZlJzogaXNBY3RpdmUsXG4gICAgICAgIH0pLCBjaGlsZHJlbjogW2pzeChcImlucHV0XCIsIHsgcGxhY2Vob2xkZXI6IFwiU2VhcmNoXCIsIC4uLnJlc3QsIHJlZjogc2V0SW5wdXRFbGVtZW50IH0pLCBpc0FjdGl2ZSA/IChqc3goXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zZWFyY2gtaW5wdXRfX2NsZWFyLWJ0blwiLCBvbkNsaWNrOiBleGl0U2VhcmNoLCBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NlYXJjaC1pbnB1dF9faWNvbi0tYWN0aXZlXCIgfSkgfSkpIDogKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zZWFyY2gtaW5wdXRfX2ljb25cIiB9KSldIH0pKTtcbn07XG5cbmNvbnN0IFNlYXJjaFJlc3VsdHMgPSAoeyBFbXB0eVNlYXJjaFJlc3VsdENvbXBvbmVudCwgTG9hZGluZ0luZGljYXRvcjogTG9hZGluZ0luZGljYXRvciQxID0gTG9hZGluZ0luZGljYXRvciwgc2VhcmNoUXVlcnlJblByb2dyZXNzLCBzZWFyY2hSZXN1bHRzLCBTZWFyY2hSZXN1bHRMaXN0LCB9KSA9PiB7XG4gICAgaWYgKHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NlYXJjaC1yZXN1bHRzLS1sb2FkaW5nXCIsIGNoaWxkcmVuOiBqc3goTG9hZGluZ0luZGljYXRvciQxLCB7fSkgfSkpO1xuICAgIH1cbiAgICBpZiAoIXNlYXJjaFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBqc3goRW1wdHlTZWFyY2hSZXN1bHRDb21wb25lbnQsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeChTZWFyY2hSZXN1bHRMaXN0LCB7IGRhdGE6IHNlYXJjaFJlc3VsdHMgfSk7XG59O1xuXG5jb25zdCB1c2VTZWFyY2ggPSAoeyBkZWJvdW5jZUludGVydmFsLCBzZWFyY2hGbiwgc2VhcmNoUXVlcnkgPSAnJywgfSkgPT4ge1xuICAgIGNvbnN0IFtzZWFyY2hSZXN1bHRzLCBzZXRTZWFyY2hSZXN1bHRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBbc2VhcmNoUXVlcnlJblByb2dyZXNzLCBzZXRTZWFyY2hRdWVyeUluUHJvZ3Jlc3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc2VhcmNoUXVlcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXRTZWFyY2hRdWVyeUluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgICAgICAgICAgc2V0U2VhcmNoUmVzdWx0cyhbXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VhcmNoUXVlcnlJblByb2dyZXNzKHRydWUpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzZWFyY2hGbihzZWFyY2hRdWVyeSk7XG4gICAgICAgICAgICAgICAgc2V0U2VhcmNoUmVzdWx0cyhyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0U2VhcmNoUXVlcnlJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZGVib3VuY2VJbnRlcnZhbCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgfSwgW2RlYm91bmNlSW50ZXJ2YWwsIHNlYXJjaEZuLCBzZWFyY2hRdWVyeV0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcyxcbiAgICAgICAgc2VhcmNoUmVzdWx0cyxcbiAgICB9O1xufTtcblxuY29uc3QgVXNlckxpc3RUeXBlcyA9IHtcbiAgICBhY3RpdmU6ICdBY3RpdmUgdXNlcnMnLFxuICAgIGJsb2NrZWQ6ICdCbG9ja2VkIHVzZXJzJyxcbn07XG5jb25zdCBERUZBVUxUX0RFQk9VTkNFX1NFQVJDSF9JTlRFUlZBTCA9IDIwMDtcbmNvbnN0IENhbGxQYXJ0aWNpcGFudHNMaXN0ID0gKHsgb25DbG9zZSwgYWN0aXZlVXNlcnNTZWFyY2hGbiwgYmxvY2tlZFVzZXJzU2VhcmNoRm4sIGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwsIH0pID0+IHtcbiAgICBjb25zdCBbc2VhcmNoUXVlcnksIHNldFNlYXJjaFF1ZXJ5XSA9IHVzZVN0YXRlKCcnKTtcbiAgICBjb25zdCBbdXNlckxpc3RUeXBlLCBzZXRVc2VyTGlzdFR5cGVdID0gdXNlU3RhdGUoJ2FjdGl2ZScpO1xuICAgIGNvbnN0IGV4aXRTZWFyY2ggPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRTZWFyY2hRdWVyeSgnJyksIFtdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0XCIsIGNoaWxkcmVuOiBbanN4KENhbGxQYXJ0aWNpcGFudExpc3RIZWFkZXIsIHsgb25DbG9zZTogb25DbG9zZSB9KSwganN4KFNlYXJjaElucHV0LCB7IHZhbHVlOiBzZWFyY2hRdWVyeSwgb25DaGFuZ2U6ICh7IGN1cnJlbnRUYXJnZXQgfSkgPT4gc2V0U2VhcmNoUXVlcnkoY3VycmVudFRhcmdldC52YWx1ZSksIGV4aXRTZWFyY2g6IGV4aXRTZWFyY2gsIGlzQWN0aXZlOiAhIXNlYXJjaFF1ZXJ5IH0pLCBqc3goQ2FsbFBhcnRpY2lwYW50TGlzdENvbnRlbnRIZWFkZXIsIHsgdXNlckxpc3RUeXBlOiB1c2VyTGlzdFR5cGUsIHNldFVzZXJMaXN0VHlwZTogc2V0VXNlckxpc3RUeXBlIH0pLCBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdF9fY29udGVudFwiLCBjaGlsZHJlbjogW3VzZXJMaXN0VHlwZSA9PT0gJ2FjdGl2ZScgJiYgKGpzeChBY3RpdmVVc2Vyc1NlYXJjaFJlc3VsdHMsIHsgc2VhcmNoUXVlcnk6IHNlYXJjaFF1ZXJ5LCBhY3RpdmVVc2Vyc1NlYXJjaEZuOiBhY3RpdmVVc2Vyc1NlYXJjaEZuLCBkZWJvdW5jZVNlYXJjaEludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsIH0pKSwgdXNlckxpc3RUeXBlID09PSAnYmxvY2tlZCcgJiYgKGpzeChCbG9ja2VkVXNlcnNTZWFyY2hSZXN1bHRzLCB7IHNlYXJjaFF1ZXJ5OiBzZWFyY2hRdWVyeSwgYmxvY2tlZFVzZXJzU2VhcmNoRm46IGJsb2NrZWRVc2Vyc1NlYXJjaEZuLCBkZWJvdW5jZVNlYXJjaEludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsIH0pKV0gfSldIH0pKTtcbn07XG5jb25zdCBDYWxsUGFydGljaXBhbnRMaXN0Q29udGVudEhlYWRlciA9ICh7IHVzZXJMaXN0VHlwZSwgc2V0VXNlckxpc3RUeXBlLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBtdXRlQWxsID0gKCkgPT4ge1xuICAgICAgICBjYWxsPy5tdXRlQWxsVXNlcnMoJ2F1ZGlvJyk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0X19jb250ZW50LWhlYWRlclwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RfX2NvbnRlbnQtaGVhZGVyLXRpdGxlXCIsIGNoaWxkcmVuOiB1c2VyTGlzdFR5cGUgPT09ICdhY3RpdmUnICYmIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuTVVURV9VU0VSU10sIGhhc1Blcm1pc3Npb25zT25seTogdHJ1ZSwgY2hpbGRyZW46IGpzeChUZXh0QnV0dG9uLCB7IG9uQ2xpY2s6IG11dGVBbGwsIGNoaWxkcmVuOiBcIk11dGUgYWxsXCIgfSkgfSkpIH0pLCBqc3goTWVudVRvZ2dsZSwgeyBwbGFjZW1lbnQ6IFwiYm90dG9tLWVuZFwiLCBUb2dnbGVCdXR0b246IFRvZ2dsZUJ1dHRvbiQxLCBjaGlsZHJlbjoganN4KEdlbmVyaWNNZW51LCB7IGNoaWxkcmVuOiBPYmplY3Qua2V5cyhVc2VyTGlzdFR5cGVzKS5tYXAoKGx0KSA9PiAoanN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBcImFyaWEtc2VsZWN0ZWRcIjogbHQgPT09IHVzZXJMaXN0VHlwZSwgb25DbGljazogKCkgPT4gc2V0VXNlckxpc3RUeXBlKGx0KSwgY2hpbGRyZW46IFVzZXJMaXN0VHlwZXNbbHRdIH0sIGx0KSkpIH0pIH0pXSB9KSk7XG59O1xuY29uc3QgQWN0aXZlVXNlcnNTZWFyY2hSZXN1bHRzID0gKHsgc2VhcmNoUXVlcnksIGFjdGl2ZVVzZXJzU2VhcmNoRm46IGFjdGl2ZVVzZXJzU2VhcmNoRm5Gcm9tUHJvcHMsIGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwgPSBERUZBVUxUX0RFQk9VTkNFX1NFQVJDSF9JTlRFUlZBTCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHVzZVBhcnRpY2lwYW50cyh7IHNvcnRCeTogbmFtZSB9KTtcbiAgICBjb25zdCBhY3RpdmVVc2Vyc1NlYXJjaEZuID0gdXNlQ2FsbGJhY2soKHF1ZXJ5U3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChxdWVyeVN0cmluZywgJ2knKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXJ0aWNpcGFudHMuZmlsdGVyKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50Lm5hbWUubWF0Y2gocXVlcnlSZWdFeHApO1xuICAgICAgICB9KSk7XG4gICAgfSwgW3BhcnRpY2lwYW50c10pO1xuICAgIGNvbnN0IHsgc2VhcmNoUXVlcnlJblByb2dyZXNzLCBzZWFyY2hSZXN1bHRzIH0gPSB1c2VTZWFyY2goe1xuICAgICAgICBzZWFyY2hGbjogYWN0aXZlVXNlcnNTZWFyY2hGbkZyb21Qcm9wcyA/PyBhY3RpdmVVc2Vyc1NlYXJjaEZuLFxuICAgICAgICBkZWJvdW5jZUludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsLFxuICAgICAgICBzZWFyY2hRdWVyeSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGpzeChTZWFyY2hSZXN1bHRzLCB7IEVtcHR5U2VhcmNoUmVzdWx0Q29tcG9uZW50OiBFbXB0eVBhcnRpY2lwYW50U2VhcmNoTGlzdCwgTG9hZGluZ0luZGljYXRvcjogTG9hZGluZ0luZGljYXRvciwgc2VhcmNoUXVlcnlJblByb2dyZXNzOiBzZWFyY2hRdWVyeUluUHJvZ3Jlc3MsIHNlYXJjaFJlc3VsdHM6IHNlYXJjaFF1ZXJ5ID8gc2VhcmNoUmVzdWx0cyA6IHBhcnRpY2lwYW50cywgU2VhcmNoUmVzdWx0TGlzdDogQ2FsbFBhcnRpY2lwYW50TGlzdGluZyB9KSk7XG59O1xuY29uc3QgQmxvY2tlZFVzZXJzU2VhcmNoUmVzdWx0cyA9ICh7IGJsb2NrZWRVc2Vyc1NlYXJjaEZuOiBibG9ja2VkVXNlcnNTZWFyY2hGbkZyb21Qcm9wcywgZGVib3VuY2VTZWFyY2hJbnRlcnZhbCA9IERFRkFVTFRfREVCT1VOQ0VfU0VBUkNIX0lOVEVSVkFMLCBzZWFyY2hRdWVyeSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlQ2FsbEJsb2NrZWRVc2VySWRzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGJsb2NrZWRVc2VycyA9IHVzZUNhbGxCbG9ja2VkVXNlcklkcygpO1xuICAgIGNvbnN0IGJsb2NrZWRVc2Vyc1NlYXJjaEZuID0gdXNlQ2FsbGJhY2soKHF1ZXJ5U3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChxdWVyeVN0cmluZywgJ2knKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShibG9ja2VkVXNlcnMuZmlsdGVyKChibG9ja2VkVXNlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrZWRVc2VyLm1hdGNoKHF1ZXJ5UmVnRXhwKTtcbiAgICAgICAgfSkpO1xuICAgIH0sIFtibG9ja2VkVXNlcnNdKTtcbiAgICBjb25zdCB7IHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcywgc2VhcmNoUmVzdWx0cyB9ID0gdXNlU2VhcmNoKHtcbiAgICAgICAgc2VhcmNoRm46IGJsb2NrZWRVc2Vyc1NlYXJjaEZuRnJvbVByb3BzID8/IGJsb2NrZWRVc2Vyc1NlYXJjaEZuLFxuICAgICAgICBkZWJvdW5jZUludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsLFxuICAgICAgICBzZWFyY2hRdWVyeSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGpzeChTZWFyY2hSZXN1bHRzLCB7IEVtcHR5U2VhcmNoUmVzdWx0Q29tcG9uZW50OiBFbXB0eVBhcnRpY2lwYW50U2VhcmNoTGlzdCwgTG9hZGluZ0luZGljYXRvcjogTG9hZGluZ0luZGljYXRvciwgc2VhcmNoUXVlcnlJblByb2dyZXNzOiBzZWFyY2hRdWVyeUluUHJvZ3Jlc3MsIHNlYXJjaFJlc3VsdHM6IHNlYXJjaFF1ZXJ5ID8gc2VhcmNoUmVzdWx0cyA6IGJsb2NrZWRVc2VycywgU2VhcmNoUmVzdWx0TGlzdDogQmxvY2tlZFVzZXJMaXN0aW5nIH0pKTtcbn07XG5jb25zdCBUb2dnbGVCdXR0b24kMSA9IGZvcndhcmRSZWYoZnVuY3Rpb24gVG9nZ2xlQnV0dG9uKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4ganN4KEljb25CdXR0b24sIHsgZW5hYmxlZDogcHJvcHMubWVudVNob3duLCBpY29uOiBcImZpbHRlclwiLCByZWY6IHJlZiB9KTtcbn0pO1xuXG5jb25zdCBDYWxsUHJldmlldyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxUaHVtYm5haWwgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgdGh1bWJuYWlsID0gdXNlQ2FsbFRodW1ibmFpbCgpO1xuICAgIGNvbnN0IFtpbWFnZVJlZiwgc2V0SW1hZ2VSZWZdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpbWFnZVJlZiB8fCAhY2FsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNhbGwuYmluZENhbGxUaHVtYm5haWxFbGVtZW50KGltYWdlUmVmKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFudXAoKTtcbiAgICB9LCBbaW1hZ2VSZWYsIGNhbGxdKTtcbiAgICBpZiAoIXRodW1ibmFpbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3goXCJpbWdcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fY2FsbC1wcmV2aWV3JywgY2xhc3NOYW1lKSwgc3R5bGU6IHN0eWxlLCBhbHQ6IFwiQ2FsbCBQcmV2aWV3IFRodW1ibmFpbFwiLCByZWY6IHNldEltYWdlUmVmIH0pKTtcbn07XG5cbmNvbnN0IENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyID0gKHsgY2FsbFJlY29yZGluZ3MsIG9uUmVmcmVzaCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2hlYWRlclwiLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190aXRsZVwiLCBjaGlsZHJlbjogW2pzeChcInNwYW5cIiwgeyBjaGlsZHJlbjogdCgnQ2FsbCBSZWNvcmRpbmdzJykgfSksIGNhbGxSZWNvcmRpbmdzLmxlbmd0aCA/IGpzeHMoXCJzcGFuXCIsIHsgY2hpbGRyZW46IFtcIihcIiwgY2FsbFJlY29yZGluZ3MubGVuZ3RoLCBcIilcIl0gfSkgOiBudWxsXSB9KSwgb25SZWZyZXNoICYmIChqc3goSWNvbkJ1dHRvbiwgeyBpY29uOiBcInJlZnJlc2hcIiwgdGl0bGU6IHQoJ1JlZnJlc2gnKSwgb25DbGljazogb25SZWZyZXNoIH0pKV0gfSkpO1xufTtcblxuY29uc3QgZGF0ZUZvcm1hdCA9IChkYXRlKSA9PiB7XG4gICAgY29uc3QgZm9ybWF0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgcmV0dXJuIGZvcm1hdC50b1RpbWVTdHJpbmcoKS5zcGxpdCgnICcpWzBdO1xufTtcbmNvbnN0IENhbGxSZWNvcmRpbmdMaXN0SXRlbSA9ICh7IHJlY29yZGluZywgfSkgPT4ge1xuICAgIHJldHVybiAoanN4cyhcImxpXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9faXRlbVwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RhYmxlLWNlbGwgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19maWxlbmFtZVwiLCBjaGlsZHJlbjogcmVjb3JkaW5nLmZpbGVuYW1lIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190YWJsZS1jZWxsIHN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGltZVwiLCBjaGlsZHJlbjogZGF0ZUZvcm1hdChyZWNvcmRpbmcuc3RhcnRfdGltZSkgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RhYmxlLWNlbGwgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190aW1lXCIsIGNoaWxkcmVuOiBkYXRlRm9ybWF0KHJlY29yZGluZy5lbmRfdGltZSkgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RhYmxlLWNlbGwgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19kb3dubG9hZFwiLCBjaGlsZHJlbjoganN4KFwiYVwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0LWl0ZW1fX2FjdGlvbi1idXR0b24nLCAnc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0LWl0ZW1fX2FjdGlvbi1idXR0b24tLWRvd25sb2FkJyksIHJvbGU6IFwiYnV0dG9uXCIsIGhyZWY6IHJlY29yZGluZy51cmwsIGRvd25sb2FkOiByZWNvcmRpbmcuZmlsZW5hbWUsIHRpdGxlOiBcIkRvd25sb2FkIHRoZSByZWNvcmRpbmdcIiwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwiZG93bmxvYWRcIiB9KSB9KSB9KV0gfSkpO1xufTtcblxuY29uc3QgRW1wdHlDYWxsUmVjb3JkaW5nTGlzdGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nIHN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdGluZy0tZW1wdHlcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nLS1pY29uLWVtcHR5XCIgfSksIGpzeChcInBcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nLS10ZXh0LWVtcHR5XCIsIGNoaWxkcmVuOiBcIk5vIHJlY29yZGluZ3MgYXZhaWxhYmxlXCIgfSldIH0pKTtcbn07XG5cbmNvbnN0IExvYWRpbmdDYWxsUmVjb3JkaW5nTGlzdGluZyA9ICh7IGNhbGxSZWNvcmRpbmdzLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbY2FsbFJlY29yZGluZ3MubWFwKChyZWNvcmRpbmcpID0+IChqc3goQ2FsbFJlY29yZGluZ0xpc3RJdGVtLCB7IHJlY29yZGluZzogcmVjb3JkaW5nIH0sIHJlY29yZGluZy5maWxlbmFtZSkpKSwganN4KExvYWRpbmdJbmRpY2F0b3IsIHsgdGV4dDogXCJSZWNvcmRpbmcgZ2V0dGluZyByZWFkeVwiIH0pXSB9KSk7XG59O1xuXG5jb25zdCBDYWxsUmVjb3JkaW5nTGlzdCA9ICh7IGNhbGxSZWNvcmRpbmdzLCBDYWxsUmVjb3JkaW5nTGlzdEhlYWRlcjogQ2FsbFJlY29yZGluZ0xpc3RIZWFkZXIkMSA9IENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyLCBDYWxsUmVjb3JkaW5nTGlzdEl0ZW06IENhbGxSZWNvcmRpbmdMaXN0SXRlbSQxID0gQ2FsbFJlY29yZGluZ0xpc3RJdGVtLCBFbXB0eUNhbGxSZWNvcmRpbmdMaXN0ID0gRW1wdHlDYWxsUmVjb3JkaW5nTGlzdGluZywgbG9hZGluZywgTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0ID0gTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0aW5nLCBvblJlZnJlc2gsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0XCIsIGNoaWxkcmVuOiBbanN4KENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyJDEsIHsgY2FsbFJlY29yZGluZ3M6IGNhbGxSZWNvcmRpbmdzLCBvblJlZnJlc2g6IG9uUmVmcmVzaCB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdGluZ1wiLCBjaGlsZHJlbjogbG9hZGluZyA/IChqc3goTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0LCB7IGNhbGxSZWNvcmRpbmdzOiBjYWxsUmVjb3JkaW5ncyB9KSkgOiBjYWxsUmVjb3JkaW5ncy5sZW5ndGggPyAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcInVsXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdFwiLCBjaGlsZHJlbjoganN4cyhcImxpXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9faXRlbVwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2ZpbGVuYW1lXCIsIGNoaWxkcmVuOiBcIk5hbWVcIiB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGltZVwiLCBjaGlsZHJlbjogXCJTdGFydCB0aW1lXCIgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RpbWVcIiwgY2hpbGRyZW46IFwiRW5kIHRpbWVcIiB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fZG93bmxvYWRcIiB9KV0gfSkgfSksIGpzeChcInVsXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdFwiLCBjaGlsZHJlbjogY2FsbFJlY29yZGluZ3MubWFwKChyZWNvcmRpbmcpID0+IChqc3goQ2FsbFJlY29yZGluZ0xpc3RJdGVtJDEsIHsgcmVjb3JkaW5nOiByZWNvcmRpbmcgfSwgcmVjb3JkaW5nLmZpbGVuYW1lKSkpIH0pXSB9KSkgOiAoanN4KEVtcHR5Q2FsbFJlY29yZGluZ0xpc3QsIHt9KSkgfSldIH0pKTtcbn07XG5cbmNvbnN0IFJpbmdpbmdDYWxsQ29udHJvbHMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxDYWxsaW5nU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgY2FsbENhbGxpbmdTdGF0ZSA9IHVzZUNhbGxDYWxsaW5nU3RhdGUoKTtcbiAgICBpZiAoIWNhbGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJ1dHRvbnNEaXNhYmxlZCA9IGNhbGxDYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVuZGluZy1jYWxsLWNvbnRyb2xzXCIsIGNoaWxkcmVuOiBjYWxsLmlzQ3JlYXRlZEJ5TWUgPyAoanN4KENhbmNlbENhbGxCdXR0b24sIHsgZGlzYWJsZWQ6IGJ1dHRvbnNEaXNhYmxlZCB9KSkgOiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChBY2NlcHRDYWxsQnV0dG9uLCB7IGRpc2FibGVkOiBidXR0b25zRGlzYWJsZWQgfSksIGpzeChDYW5jZWxDYWxsQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IGNhbGwubGVhdmUoeyByZWplY3Q6IHRydWUgfSksIGRpc2FibGVkOiBidXR0b25zRGlzYWJsZWQgfSldIH0pKSB9KSk7XG59O1xuXG5jb25zdCBDQUxMSU5HX1NUQVRFX1RPX0xBQkVMID0ge1xuICAgIFtDYWxsaW5nU3RhdGUuSk9JTklOR106ICdKb2luaW5nJyxcbiAgICBbQ2FsbGluZ1N0YXRlLlJJTkdJTkddOiAnUmluZ2luZycsXG4gICAgW0NhbGxpbmdTdGF0ZS5NSUdSQVRJTkddOiAnTWlncmF0aW5nJyxcbiAgICBbQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR106ICdSZS1jb25uZWN0aW5nJyxcbiAgICBbQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRURdOiAnRmFpbGVkJyxcbiAgICBbQ2FsbGluZ1N0YXRlLk9GRkxJTkVdOiAnTm8gaW50ZXJuZXQgY29ubmVjdGlvbicsXG4gICAgW0NhbGxpbmdTdGF0ZS5JRExFXTogJycsXG4gICAgW0NhbGxpbmdTdGF0ZS5VTktOT1dOXTogJycsXG4gICAgW0NhbGxpbmdTdGF0ZS5KT0lORURdOiAnSm9pbmVkJyxcbiAgICBbQ2FsbGluZ1N0YXRlLkxFRlRdOiAnTGVmdCBjYWxsJyxcbn07XG5jb25zdCBSaW5naW5nQ2FsbCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgaW5jbHVkZVNlbGYgPSBmYWxzZSwgdG90YWxNZW1iZXJzVG9TaG93ID0gMyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IHVzZUNhbGxDYWxsaW5nU3RhdGUsIHVzZUNhbGxNZW1iZXJzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGNhbGxpbmdTdGF0ZSA9IHVzZUNhbGxDYWxsaW5nU3RhdGUoKTtcbiAgICBjb25zdCBtZW1iZXJzID0gdXNlQ2FsbE1lbWJlcnMoKTtcbiAgICBjb25zdCBjb25uZWN0ZWRVc2VyID0gdXNlQ29ubmVjdGVkVXNlcigpO1xuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gdGFrZSB0aGUgZmlyc3QgTiBtZW1iZXJzIHRvIHNob3cgdGhlaXIgYXZhdGFyc1xuICAgIGNvbnN0IG1lbWJlcnNUb1Nob3cgPSAobWVtYmVycyB8fCBbXSlcbiAgICAgICAgLnNsaWNlKDAsIHRvdGFsTWVtYmVyc1RvU2hvdylcbiAgICAgICAgLm1hcCgoeyB1c2VyIH0pID0+IHVzZXIpXG4gICAgICAgIC5maWx0ZXIoKHVzZXIpID0+IHVzZXIuaWQgIT09IGNvbm5lY3RlZFVzZXI/LmlkIHx8IGluY2x1ZGVTZWxmKTtcbiAgICBpZiAoaW5jbHVkZVNlbGYgJiZcbiAgICAgICAgIW1lbWJlcnNUb1Nob3cuZmluZCgodXNlcikgPT4gdXNlci5pZCA9PT0gY29ubmVjdGVkVXNlcj8uaWQpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHVzZXIgaXMgbm90IGluIHRoZSBpbml0aWFsIGJhdGNoIG9mIG1lbWJlcnMsXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIGZpcnN0IGl0ZW0gaW4gbWVtYmVyc1RvU2hvdyBhcnJheSB3aXRoIHRoZSBjdXJyZW50IHVzZXJcbiAgICAgICAgY29uc3Qgc2VsZiA9IG1lbWJlcnMuZmluZCgoeyB1c2VyIH0pID0+IHVzZXIuaWQgPT09IGNvbm5lY3RlZFVzZXI/LmlkKTtcbiAgICAgICAgaWYgKHNlbGYpIHtcbiAgICAgICAgICAgIG1lbWJlcnNUb1Nob3cuc3BsaWNlKDAsIDEsIHNlbGYudXNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsbGluZ1N0YXRlTGFiZWwgPSBDQUxMSU5HX1NUQVRFX1RPX0xBQkVMW2NhbGxpbmdTdGF0ZV07XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1wYW5lbCBzdHItdmlkZW9fX2NhbGwtcGFuZWwtLXJpbmdpbmdcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXBhbmVsX19tZW1iZXJzLWxpc3RcIiwgY2hpbGRyZW46IG1lbWJlcnNUb1Nob3cubWFwKCh1c2VyKSA9PiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcGFuZWxfX21lbWJlci1ib3hcIiwgY2hpbGRyZW46IFtqc3goQXZhdGFyLCB7IG5hbWU6IHVzZXIubmFtZSwgaW1hZ2VTcmM6IHVzZXIuaW1hZ2UgfSksIHVzZXIubmFtZSAmJiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbWVtYmVyX2RldGFpbHNcIiwgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19tZW1iZXJfbmFtZVwiLCBjaGlsZHJlbjogdXNlci5uYW1lIH0pIH0pKV0gfSwgdXNlci5pZCkpKSB9KSwgY2FsbGluZ1N0YXRlTGFiZWwgJiYgKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcGFuZWxfX2NhbGxpbmctc3RhdGUtbGFiZWxcIiwgY2hpbGRyZW46IHQoY2FsbGluZ1N0YXRlTGFiZWwpIH0pKSwgW0NhbGxpbmdTdGF0ZS5SSU5HSU5HLCBDYWxsaW5nU3RhdGUuSk9JTklOR10uaW5jbHVkZXMoY2FsbGluZ1N0YXRlKSAmJiAoanN4KFJpbmdpbmdDYWxsQ29udHJvbHMsIHt9KSldIH0pKTtcbn07XG5cbmNvbnN0IGJ5TmFtZU9ySWQgPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLm5hbWUgJiYgYi5uYW1lICYmIGEubmFtZSA8IGIubmFtZSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChhLm5hbWUgJiYgYi5uYW1lICYmIGEubmFtZSA+IGIubmFtZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGEuaWQgPCBiLmlkKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGEuaWQgPiBiLmlkKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBQZXJtaXNzaW9uUmVxdWVzdHMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUxvY2FsUGFydGljaXBhbnQsIHVzZUhhc1Blcm1pc3Npb25zIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGxvY2FsUGFydGljaXBhbnQgPSB1c2VMb2NhbFBhcnRpY2lwYW50KCk7XG4gICAgY29uc3QgW2V4cGFuZGVkLCBzZXRFeHBhbmRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Blcm1pc3Npb25SZXF1ZXN0cywgc2V0UGVybWlzc2lvblJlcXVlc3RzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBjYW5VcGRhdGVDYWxsUGVybWlzc2lvbnMgPSB1c2VIYXNQZXJtaXNzaW9ucyhPd25DYXBhYmlsaXR5LlVQREFURV9DQUxMX1BFUk1JU1NJT05TKTtcbiAgICBjb25zdCBsb2NhbFVzZXJJZCA9IGxvY2FsUGFydGljaXBhbnQ/LnVzZXJJZDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwgfHwgIWNhblVwZGF0ZUNhbGxQZXJtaXNzaW9ucylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGNhbGwub24oJ2NhbGwucGVybWlzc2lvbl9yZXF1ZXN0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudXNlci5pZCAhPT0gbG9jYWxVc2VySWQpIHtcbiAgICAgICAgICAgICAgICBzZXRQZXJtaXNzaW9uUmVxdWVzdHMoKHJlcXVlc3RzKSA9PiBbLi4ucmVxdWVzdHMsIGV2ZW50XS5zb3J0KChhLCBiKSA9PiBieU5hbWVPcklkKGEudXNlciwgYi51c2VyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbY2FsbCwgY2FuVXBkYXRlQ2FsbFBlcm1pc3Npb25zLCBsb2NhbFVzZXJJZF0pO1xuICAgIGNvbnN0IGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24gPSAocmVxdWVzdCwgdHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VyLCBwZXJtaXNzaW9ucyB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dyYW50JzpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FsbD8uZ3JhbnRQZXJtaXNzaW9ucyh1c2VyLmlkLCBwZXJtaXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Jldm9rZSc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGw/LnJldm9rZVBlcm1pc3Npb25zKHVzZXIuaWQsIHBlcm1pc3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRQZXJtaXNzaW9uUmVxdWVzdHMoKHJlcXVlc3RzKSA9PiByZXF1ZXN0cy5maWx0ZXIoKHIpID0+IHIgIT09IHJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHsgcmVmcywgeCwgeSwgc3RyYXRlZ3kgfSA9IHVzZUZsb2F0aW5nVUlQcmVzZXQoe1xuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICB9KTtcbiAgICAvLyBkb24ndCByZW5kZXIgYW55dGhpbmcgaWYgdGhlcmUgYXJlIG5vIHBlcm1pc3Npb24gcmVxdWVzdHNcbiAgICBpZiAocGVybWlzc2lvblJlcXVlc3RzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0c1wiLCByZWY6IHJlZnMuc2V0UmVmZXJlbmNlLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RzX19ub3RpZmljYXRpb25cIiwgY2hpbGRyZW46IFtqc3hzKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3Blcm1pc3Npb24tcmVxdWVzdHNfX25vdGlmaWNhdGlvbl9fbWVzc2FnZVwiLCBjaGlsZHJlbjogW3Blcm1pc3Npb25SZXF1ZXN0cy5sZW5ndGgsIFwiIHBlbmRpbmcgcGVybWlzc2lvbiByZXF1ZXN0c1wiXSB9KSwganN4KEJ1dHRvbiwgeyB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXhwYW5kZWQoKGUpID0+ICFlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBleHBhbmRlZCA/ICdIaWRlIHJlcXVlc3RzJyA6ICdTaG93IHJlcXVlc3RzJyB9KV0gfSksIGV4cGFuZGVkICYmIChqc3goUGVybWlzc2lvblJlcXVlc3RMaXN0LCB7IHJlZjogcmVmcy5zZXRGbG9hdGluZywgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHkgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogeCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICB9LCBwZXJtaXNzaW9uUmVxdWVzdHM6IHBlcm1pc3Npb25SZXF1ZXN0cywgaGFuZGxlVXBkYXRlUGVybWlzc2lvbjogaGFuZGxlVXBkYXRlUGVybWlzc2lvbiB9KSldIH0pKTtcbn07XG5jb25zdCBQZXJtaXNzaW9uUmVxdWVzdExpc3QgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFBlcm1pc3Npb25SZXF1ZXN0TGlzdChwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9uUmVxdWVzdHMsIGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24sIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0cy1saXN0XCIsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogcGVybWlzc2lvblJlcXVlc3RzLm1hcCgocmVxdWVzdCwgcmVxSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlciwgcGVybWlzc2lvbnMgfSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICByZXR1cm4gKGpzeChGcmFnbWVudCQxLCB7IGNoaWxkcmVuOiBwZXJtaXNzaW9ucy5tYXAoKHBlcm1pc3Npb24pID0+IChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0XCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0X19tZXNzYWdlXCIsIGNoaWxkcmVuOiBtZXNzYWdlRm9yUGVybWlzc2lvbih1c2VyLm5hbWUgfHwgdXNlci5pZCwgcGVybWlzc2lvbiwgdCkgfSksIGpzeChCdXR0b24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0X19idXR0b24tLWFsbG93XCIsIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24ocmVxdWVzdCwgJ2dyYW50JyksIGNoaWxkcmVuOiB0KCdBbGxvdycpIH0pLCBqc3goQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3Blcm1pc3Npb24tcmVxdWVzdF9fYnV0dG9uLS1yZWplY3RcIiwgdHlwZTogXCJidXR0b25cIiwgb25DbGljazogaGFuZGxlVXBkYXRlUGVybWlzc2lvbihyZXF1ZXN0LCAncmV2b2tlJyksIGNoaWxkcmVuOiB0KCdSZXZva2UnKSB9KSwganN4KEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RfX2J1dHRvbi0tcmVqZWN0XCIsIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24ocmVxdWVzdCwgJ2Rpc21pc3MnKSwgY2hpbGRyZW46IHQoJ0Rpc21pc3MnKSB9KV0gfSwgcGVybWlzc2lvbikpKSB9LCBgJHt1c2VyLmlkfS8ke3JlcUluZGV4fWApKTtcbiAgICAgICAgfSkgfSkpO1xufSk7XG5jb25zdCBCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0X19idXR0b24nLCBjbGFzc05hbWUpLCAuLi5yZXN0IH0pKTtcbn07XG5jb25zdCBtZXNzYWdlRm9yUGVybWlzc2lvbiA9ICh1c2VyTmFtZSwgcGVybWlzc2lvbiwgdCkgPT4ge1xuICAgIHN3aXRjaCAocGVybWlzc2lvbikge1xuICAgICAgICBjYXNlIE93bkNhcGFiaWxpdHkuU0VORF9BVURJTzpcbiAgICAgICAgICAgIHJldHVybiB0KCd7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHNwZWFrJywgeyB1c2VyTmFtZSB9KTtcbiAgICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNFTkRfVklERU86XG4gICAgICAgICAgICByZXR1cm4gdCgne3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBzaGFyZSB0aGVpciBjYW1lcmEnLCB7XG4gICAgICAgICAgICAgICAgdXNlck5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFOlxuICAgICAgICAgICAgcmV0dXJuIHQoJ3t7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgdG8gcHJlc2VudCB0aGVpciBzY3JlZW4nLCB7XG4gICAgICAgICAgICAgICAgdXNlck5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0KCd7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHBlcm1pc3Npb246IHt7IHBlcm1pc3Npb24gfX0nLCB7XG4gICAgICAgICAgICAgICAgdXNlck5hbWUsXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IFN0cmVhbVRoZW1lID0gKHsgYXM6IENvbXBvbmVudCA9ICdkaXYnLCBjbGFzc05hbWUsIGNoaWxkcmVuLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goQ29tcG9uZW50LCB7IC4uLnByb3BzLCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlbycsIGNsYXNzTmFtZSksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCBEZWZhdWx0VmlkZW9QbGFjZWhvbGRlciA9IGZvcndhcmRSZWYoZnVuY3Rpb24gRGVmYXVsdFZpZGVvUGxhY2Vob2xkZXIoeyBwYXJ0aWNpcGFudCwgc3R5bGUgfSwgcmVmKSB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRpY2lwYW50Lm5hbWUgfHwgcGFydGljaXBhbnQudXNlcklkO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3ZpZGVvLXBsYWNlaG9sZGVyXCIsIHN0eWxlOiBzdHlsZSwgcmVmOiByZWYsIGNoaWxkcmVuOiBbKCFwYXJ0aWNpcGFudC5pbWFnZSB8fCBlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA/IChqc3goSW5pdGlhbHNGYWxsYmFjaywgeyBuYW1lOiBuYW1lIH0pKSA6IChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX192aWRlby1wbGFjZWhvbGRlcl9fbm8tdmlkZW8tbGFiZWxcIiwgY2hpbGRyZW46IHQoJ1ZpZGVvIGlzIGRpc2FibGVkJykgfSkpKSwgcGFydGljaXBhbnQuaW1hZ2UgJiYgIWVycm9yICYmIChqc3goXCJpbWdcIiwgeyBvbkVycm9yOiAoKSA9PiBzZXRFcnJvcih0cnVlKSwgYWx0OiBcInZpZGVvLXBsYWNlaG9sZGVyXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3ZpZGVvLXBsYWNlaG9sZGVyX19hdmF0YXJcIiwgc3JjOiBwYXJ0aWNpcGFudC5pbWFnZSB9KSldIH0pKTtcbn0pO1xuY29uc3QgSW5pdGlhbHNGYWxsYmFjayA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbmFtZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaW5pdGlhbHMgPSBuYW1lXG4gICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgIC5zbGljZSgwLCAyKVxuICAgICAgICAubWFwKChuKSA9PiBuWzBdKVxuICAgICAgICAuam9pbignJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX192aWRlby1wbGFjZWhvbGRlcl9faW5pdGlhbHMtZmFsbGJhY2tcIiwgY2hpbGRyZW46IGluaXRpYWxzIH0pKTtcbn07XG5cbmNvbnN0IFZpZGVvJDEgPSAoeyB0cmFja1R5cGUsIHBhcnRpY2lwYW50LCBjbGFzc05hbWUsIFZpZGVvUGxhY2Vob2xkZXIgPSBEZWZhdWx0VmlkZW9QbGFjZWhvbGRlciwgcmVmcywgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZXNzaW9uSWQsIHZpZGVvU3RyZWFtLCBzY3JlZW5TaGFyZVN0cmVhbSwgcHVibGlzaGVkVHJhY2tzLCB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSwgaXNMb2NhbFBhcnRpY2lwYW50LCB1c2VySWQsIH0gPSBwYXJ0aWNpcGFudDtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IFt2aWRlb0VsZW1lbnQsIHNldFZpZGVvRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICAvLyBzdGFydCB3aXRoIHRydWUsIHdpbGwgZmxpcCBvbmNlIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZ1xuICAgIGNvbnN0IFtpc1ZpZGVvUGF1c2VkLCBzZXRJc1ZpZGVvUGF1c2VkXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtpc1dpZGVNb2RlLCBzZXRJc1dpZGVNb2RlXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IHN0cmVhbSA9IHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snXG4gICAgICAgID8gdmlkZW9TdHJlYW1cbiAgICAgICAgOiB0cmFja1R5cGUgPT09ICdzY3JlZW5TaGFyZVRyYWNrJ1xuICAgICAgICAgICAgPyBzY3JlZW5TaGFyZVN0cmVhbVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsIHx8ICF2aWRlb0VsZW1lbnQgfHwgdHJhY2tUeXBlID09PSAnbm9uZScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBjYWxsLmJpbmRWaWRlb0VsZW1lbnQodmlkZW9FbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwPy4oKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY2FsbCwgdHJhY2tUeXBlLCBzZXNzaW9uSWQsIHZpZGVvRWxlbWVudF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc3RyZWFtIHx8ICF2aWRlb0VsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IFt0cmFja10gPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKCF0cmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlUGxheVBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNWaWRlb1BhdXNlZCh2aWRlb0VsZW1lbnQucGF1c2VkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggPSAwLCBoZWlnaHQgPSAwIH0gPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgc2V0SXNXaWRlTW9kZSh3aWR0aCA+PSBoZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBwbGF5YmFjayBtYXkgaGF2ZSBzdGFydGVkIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG9cbiAgICAgICAgLy8gYXR0YWNoIHRoZSAncGxheS9wYXVzZScgZXZlbnQgbGlzdGVuZXIsIHNvIHdlIHNldCB0aGUgc3RhdGVcbiAgICAgICAgLy8gaGVyZSB0byBtYWtlIHN1cmUgaXQncyBpbiBzeW5jXG4gICAgICAgIHNldElzVmlkZW9QYXVzZWQodmlkZW9FbGVtZW50LnBhdXNlZCk7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5JywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXVzZScsIGhhbmRsZVBsYXlQYXVzZSk7XG4gICAgICAgICAgICB0cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCBoYW5kbGVQbGF5UGF1c2UpO1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhlICdwYXVzZScgc3RhdGUgb25jZSB3ZSB1bm1vdW50IHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICAgICAgICBzZXRJc1ZpZGVvUGF1c2VkKHRydWUpO1xuICAgICAgICB9O1xuICAgIH0sIFtzdHJlYW0sIHZpZGVvRWxlbWVudF0pO1xuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaXNQdWJsaXNoaW5nVHJhY2sgPSB0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJ1xuICAgICAgICA/IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKVxuICAgICAgICA6IHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlVHJhY2snXG4gICAgICAgICAgICA/IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgaXNJbnZpc2libGUgPSB0cmFja1R5cGUgPT09ICdub25lJyB8fFxuICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8uW3RyYWNrVHlwZV0gPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEU7XG4gICAgY29uc3QgaGFzTm9WaWRlb09ySW52aXNpYmxlID0gIWlzUHVibGlzaGluZ1RyYWNrIHx8IGlzSW52aXNpYmxlO1xuICAgIGNvbnN0IG1pcnJvclZpZGVvID0gaXNMb2NhbFBhcnRpY2lwYW50ICYmIHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snO1xuICAgIGNvbnN0IGlzU2NyZWVuU2hhcmVUcmFjayA9IHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlVHJhY2snO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogWyFoYXNOb1ZpZGVvT3JJbnZpc2libGUgJiYgKGpzeChcInZpZGVvXCIsIHsgLi4ucmVzdCwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3ZpZGVvJywgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLS1ub3QtcGxheWluZyc6IGlzVmlkZW9QYXVzZWQsXG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLS10YWxsJzogIWlzV2lkZU1vZGUsXG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLS1taXJyb3InOiBtaXJyb3JWaWRlbyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fdmlkZW8tLXNjcmVlbi1zaGFyZSc6IGlzU2NyZWVuU2hhcmVUcmFjayxcbiAgICAgICAgICAgICAgICB9KSwgXCJkYXRhLXVzZXItaWRcIjogdXNlcklkLCBcImRhdGEtc2Vzc2lvbi1pZFwiOiBzZXNzaW9uSWQsIHJlZjogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmlkZW9FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZWZzPy5zZXRWaWRlb0VsZW1lbnQ/LihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IH0pKSwgKGhhc05vVmlkZW9PckludmlzaWJsZSB8fCBpc1ZpZGVvUGF1c2VkKSAmJiBWaWRlb1BsYWNlaG9sZGVyICYmIChqc3goVmlkZW9QbGFjZWhvbGRlciwgeyBzdHlsZTogeyBwb3NpdGlvbjogJ2Fic29sdXRlJyB9LCBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQsIHJlZjogcmVmcz8uc2V0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQgfSkpXSB9KSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBFeHRlbmRzIHZpZGVvIGVsZW1lbnQgd2l0aCBgc3RyZWFtYCBwcm9wZXJ0eVxuICogKGBzcmNPYmplY3RgKSB0byByZWFjdGl2ZWx5IGhhbmRsZSBzdHJlYW0gY2hhbmdlc1xuICovXG5jb25zdCBCYXNlVmlkZW8gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIEJhc2VWaWRlbyh7IHN0cmVhbSwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCBbdmlkZW9FbGVtZW50LCBzZXRWaWRlb0VsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF2aWRlb0VsZW1lbnQgfHwgIXN0cmVhbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHN0cmVhbSA9PT0gdmlkZW9FbGVtZW50LnNyY09iamVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgaWYgKEJyb3dzZXJzLmlzU2FmYXJpKCkgfHwgQnJvd3NlcnMuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggYW5kIFNhZmFyaSBoYXZlIHNvbWUgdGltaW5nIGlzc3VlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5wbGF5KCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBsYXkgc3RyZWFtYCwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBhdXNlKCk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LCBbc3RyZWFtLCB2aWRlb0VsZW1lbnRdKTtcbiAgICByZXR1cm4gKGpzeChcInZpZGVvXCIsIHsgYXV0b1BsYXk6IHRydWUsIHBsYXlzSW5saW5lOiB0cnVlLCAuLi5yZXN0LCByZWY6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBhcHBseUVsZW1lbnRUb1JlZihyZWYsIGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VmlkZW9FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9IH0pKTtcbn0pO1xuXG5jb25zdCBEZWZhdWx0RGlzYWJsZWRWaWRlb1ByZXZpZXcgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyX3ZpZGVvX192aWRlby1wcmV2aWV3X19kaXNhYmxlZC12aWRlby1wcmV2aWV3XCIsIGNoaWxkcmVuOiB0KCdWaWRlbyBpcyBkaXNhYmxlZCcpIH0pKTtcbn07XG5jb25zdCBEZWZhdWx0Tm9DYW1lcmFQcmV2aWV3ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0cl92aWRlb19fdmlkZW8tcHJldmlld19fbm8tY2FtZXJhLXByZXZpZXdcIiwgY2hpbGRyZW46IHQoJ05vIGNhbWVyYSBmb3VuZCcpIH0pKTtcbn07XG5jb25zdCBWaWRlb1ByZXZpZXcgPSAoeyBjbGFzc05hbWUsIG1pcnJvciA9IHRydWUsIERpc2FibGVkVmlkZW9QcmV2aWV3ID0gRGVmYXVsdERpc2FibGVkVmlkZW9QcmV2aWV3LCBOb0NhbWVyYVByZXZpZXcgPSBEZWZhdWx0Tm9DYW1lcmFQcmV2aWV3LCBTdGFydGluZ0NhbWVyYVByZXZpZXcgPSBMb2FkaW5nSW5kaWNhdG9yLCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VDYW1lcmFTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGRldmljZXMsIHN0YXR1cywgaXNNdXRlLCBtZWRpYVN0cmVhbSB9ID0gdXNlQ2FtZXJhU3RhdGUoKTtcbiAgICBsZXQgY29udGVudHM7XG4gICAgaWYgKGlzTXV0ZSAmJiBkZXZpY2VzPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGVudHMgPSBqc3goTm9DYW1lcmFQcmV2aWV3LCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgIGNvbnN0IGxvYWRpbmcgPSAhbWVkaWFTdHJlYW07XG4gICAgICAgIGNvbnRlbnRzID0gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFttZWRpYVN0cmVhbSAmJiAoanN4KEJhc2VWaWRlbywgeyBzdHJlYW06IG1lZGlhU3RyZWFtLCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fdmlkZW8tcHJldmlldycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLXByZXZpZXctLW1pcnJvcic6IG1pcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLXByZXZpZXctLWxvYWRpbmcnOiBsb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgICB9KSB9KSksIGxvYWRpbmcgJiYganN4KFN0YXJ0aW5nQ2FtZXJhUHJldmlldywge30pXSB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250ZW50cyA9IGpzeChEaXNhYmxlZFZpZGVvUHJldmlldywge30pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX192aWRlby1wcmV2aWV3LWNvbnRhaW5lcicsIGNsYXNzTmFtZSksIGNoaWxkcmVuOiBjb250ZW50cyB9KSk7XG59O1xuXG5jb25zdCBQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50LCBwYXJ0aWNpcGFudFZpZXdFbGVtZW50LCB2aWRlb0VsZW1lbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCBbZnVsbHNjcmVlbk1vZGVPbiwgc2V0RnVsbHNjcmVlbk1vZGVPbl0gPSB1c2VTdGF0ZSghIWRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50KTtcbiAgICBjb25zdCBbcGljdHVyZUluUGljdHVyZUVsZW1lbnQsIHNldFBpY3R1cmVJblBpY3R1cmVFbGVtZW50XSA9IHVzZVN0YXRlKGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50KTtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgcGluLCBwdWJsaXNoZWRUcmFja3MsIHNlc3Npb25JZCwgdXNlcklkIH0gPSBwYXJ0aWNpcGFudDtcbiAgICBjb25zdCBoYXNBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLkFVRElPKTtcbiAgICBjb25zdCBoYXNWaWRlbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKTtcbiAgICBjb25zdCBoYXNTY3JlZW5TaGFyZSA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSk7XG4gICAgY29uc3QgaGFzU2NyZWVuU2hhcmVBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTyk7XG4gICAgY29uc3QgYmxvY2tVc2VyID0gKCkgPT4gY2FsbD8uYmxvY2tVc2VyKHVzZXJJZCk7XG4gICAgY29uc3QgbXV0ZUF1ZGlvID0gKCkgPT4gY2FsbD8ubXV0ZVVzZXIodXNlcklkLCAnYXVkaW8nKTtcbiAgICBjb25zdCBtdXRlVmlkZW8gPSAoKSA9PiBjYWxsPy5tdXRlVXNlcih1c2VySWQsICd2aWRlbycpO1xuICAgIGNvbnN0IG11dGVTY3JlZW5TaGFyZSA9ICgpID0+IGNhbGw/Lm11dGVVc2VyKHVzZXJJZCwgJ3NjcmVlbnNoYXJlJyk7XG4gICAgY29uc3QgbXV0ZVNjcmVlblNoYXJlQXVkaW8gPSAoKSA9PiBjYWxsPy5tdXRlVXNlcih1c2VySWQsICdzY3JlZW5zaGFyZV9hdWRpbycpO1xuICAgIGNvbnN0IGdyYW50UGVybWlzc2lvbiA9IChwZXJtaXNzaW9uKSA9PiAoKSA9PiB7XG4gICAgICAgIGNhbGw/LnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICBncmFudF9wZXJtaXNzaW9uczogW3Blcm1pc3Npb25dLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJldm9rZVBlcm1pc3Npb24gPSAocGVybWlzc2lvbikgPT4gKCkgPT4ge1xuICAgICAgICBjYWxsPy51cGRhdGVVc2VyUGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgcmV2b2tlX3Blcm1pc3Npb25zOiBbcGVybWlzc2lvbl0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlUGFydGljaXBhbnRQaW4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgICAgIGNhbGw/LnVucGluKHNlc3Npb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsPy5waW4oc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGluRm9yRXZlcnlvbmUgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxcbiAgICAgICAgICAgID8ucGluRm9yRXZlcnlvbmUoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwaW4gcGFydGljaXBhbnQgJHt1c2VySWR9YCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB1bnBpbkZvckV2ZXJ5b25lID0gKCkgPT4ge1xuICAgICAgICBjYWxsXG4gICAgICAgICAgICA/LnVucGluRm9yRXZlcnlvbmUoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1bnBpbiBwYXJ0aWNpcGFudCAke3VzZXJJZH1gLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRvZ2dsZUZ1bGxzY3JlZW5Nb2RlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWZ1bGxzY3JlZW5Nb2RlT24pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWNpcGFudFZpZXdFbGVtZW50Py5yZXF1ZXN0RnVsbHNjcmVlbigpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH07XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gaGFuZGxlcyB0aGUgY2FzZSB3aGVuIGZ1bGxzY3JlZW4gbW9kZSBpcyB0b2dnbGVkIGV4dGVybmFsbHksXG4gICAgICAgIC8vIGUuZy4sIGJ5IHByZXNzaW5nIEVTQyBrZXkgb3Igc29tZSBvdGhlciBrZXlib2FyZCBzaG9ydGN1dFxuICAgICAgICBjb25zdCBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0RnVsbHNjcmVlbk1vZGVPbighIWRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXZpZGVvRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlUGlQID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0UGljdHVyZUluUGljdHVyZUVsZW1lbnQoZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgaGFuZGxlUGlQKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIGhhbmRsZVBpUCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgaGFuZGxlUGlQKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCBoYW5kbGVQaVApO1xuICAgICAgICB9O1xuICAgIH0sIFt2aWRlb0VsZW1lbnRdKTtcbiAgICBjb25zdCB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlkZW9FbGVtZW50ICYmIHBpY3R1cmVJblBpY3R1cmVFbGVtZW50ICE9PSB2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlb0VsZW1lbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdFBpY3R1cmVJblBpY3R1cmUoKVxuICAgICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZXhpdFBpY3R1cmVJblBpY3R1cmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICB9O1xuICAgIGNvbnN0IHsgY2xvc2UgfSA9IHVzZU1lbnVDb250ZXh0KCkgfHwge307XG4gICAgcmV0dXJuIChqc3hzKEdlbmVyaWNNZW51LCB7IG9uSXRlbUNsaWNrOiBjbG9zZSwgY2hpbGRyZW46IFtqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiB0b2dnbGVQYXJ0aWNpcGFudFBpbiwgZGlzYWJsZWQ6IHBpbiAmJiAhcGluLmlzTG9jYWxQaW4sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJwaW5cIiB9KSwgcGluID8gdCgnVW5waW4nKSA6IHQoJ1BpbicpXSB9KSwganN4cyhSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5QSU5fRk9SX0VWRVJZT05FXSwgY2hpbGRyZW46IFtqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBwaW5Gb3JFdmVyeW9uZSwgZGlzYWJsZWQ6IHBpbiAmJiAhcGluLmlzTG9jYWxQaW4sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJwaW5cIiB9KSwgdCgnUGluIGZvciBldmVyeW9uZScpXSB9KSwganN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogdW5waW5Gb3JFdmVyeW9uZSwgZGlzYWJsZWQ6ICFwaW4gfHwgcGluLmlzTG9jYWxQaW4sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJwaW5cIiB9KSwgdCgnVW5waW4gZm9yIGV2ZXJ5b25lJyldIH0pXSB9KSwganN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LkJMT0NLX1VTRVJTXSwgY2hpbGRyZW46IGpzeHMoR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IGJsb2NrVXNlciwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcIm5vdC1hbGxvd2VkXCIgfSksIHQoJ0Jsb2NrJyldIH0pIH0pLCBqc3hzKFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5Lk1VVEVfVVNFUlNdLCBjaGlsZHJlbjogW2hhc1ZpZGVvICYmIChqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBtdXRlVmlkZW8sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJjYW1lcmEtb2ZmLW91dGxpbmVcIiB9KSwgdCgnVHVybiBvZmYgdmlkZW8nKV0gfSkpLCBoYXNTY3JlZW5TaGFyZSAmJiAoanN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogbXV0ZVNjcmVlblNoYXJlLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwic2NyZWVuLXNoYXJlLW9mZlwiIH0pLCB0KCdUdXJuIG9mZiBzY3JlZW4gc2hhcmUnKV0gfSkpLCBoYXNBdWRpbyAmJiAoanN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogbXV0ZUF1ZGlvLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwibm8tYXVkaW9cIiB9KSwgdCgnTXV0ZSBhdWRpbycpXSB9KSksIGhhc1NjcmVlblNoYXJlQXVkaW8gJiYgKGpzeHMoR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IG11dGVTY3JlZW5TaGFyZUF1ZGlvLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwibm8tYXVkaW9cIiB9KSwgdCgnTXV0ZSBzY3JlZW4gc2hhcmUgYXVkaW8nKV0gfSkpXSB9KSwgcGFydGljaXBhbnRWaWV3RWxlbWVudCAmJiAoanN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiB0b2dnbGVGdWxsc2NyZWVuTW9kZSwgY2hpbGRyZW46IHQoJ3t7IGRpcmVjdGlvbiB9fSBmdWxsc2NyZWVuJywge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGZ1bGxzY3JlZW5Nb2RlT24gPyB0KCdMZWF2ZScpIDogdCgnRW50ZXInKSxcbiAgICAgICAgICAgICAgICB9KSB9KSksIHZpZGVvRWxlbWVudCAmJiBkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRW5hYmxlZCAmJiAoanN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlLCBjaGlsZHJlbjogdCgne3sgZGlyZWN0aW9uIH19IHBpY3R1cmUtaW4tcGljdHVyZScsIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBwaWN0dXJlSW5QaWN0dXJlRWxlbWVudCA9PT0gdmlkZW9FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHQoJ0xlYXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdCgnRW50ZXInKSxcbiAgICAgICAgICAgICAgICB9KSB9KSksIGpzeHMoUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuVVBEQVRFX0NBTExfUEVSTUlTU0lPTlNdLCBjaGlsZHJlbjogW2pzeChHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogZ3JhbnRQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0VORF9BVURJTyksIGNoaWxkcmVuOiB0KCdBbGxvdyBhdWRpbycpIH0pLCBqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IGdyYW50UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNFTkRfVklERU8pLCBjaGlsZHJlbjogdCgnQWxsb3cgdmlkZW8nKSB9KSwganN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBncmFudFBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TQ1JFRU5TSEFSRSksIGNoaWxkcmVuOiB0KCdBbGxvdyBzY3JlZW4gc2hhcmluZycpIH0pLCBqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IHJldm9rZVBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPKSwgY2hpbGRyZW46IHQoJ0Rpc2FibGUgYXVkaW8nKSB9KSwganN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiByZXZva2VQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0VORF9WSURFTyksIGNoaWxkcmVuOiB0KCdEaXNhYmxlIHZpZGVvJykgfSksIGpzeChHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogcmV2b2tlUGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFKSwgY2hpbGRyZW46IHQoJ0Rpc2FibGUgc2NyZWVuIHNoYXJpbmcnKSB9KV0gfSldIH0pKTtcbn07XG5cbmNvbnN0IHVzZVRyYWNrRWxlbWVudFZpc2liaWxpdHkgPSAoeyB0cmFja2VkRWxlbWVudCwgZHluYXNjYWxlTWFuYWdlcjogcHJvcHNEeW5hc2NhbGVNYW5hZ2VyLCBzZXNzaW9uSWQsIHRyYWNrVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgbWFuYWdlciA9IHByb3BzRHluYXNjYWxlTWFuYWdlciA/PyBjYWxsPy5keW5hc2NhbGVNYW5hZ2VyO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdHJhY2tlZEVsZW1lbnQgfHwgIW1hbmFnZXIgfHwgIWNhbGwgfHwgdHJhY2tUeXBlID09PSAnbm9uZScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG1hbmFnZXIudHJhY2tFbGVtZW50VmlzaWJpbGl0eSh0cmFja2VkRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5vYnNlcnZlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW3RyYWNrZWRFbGVtZW50LCBtYW5hZ2VyLCBjYWxsLCBzZXNzaW9uSWQsIHRyYWNrVHlwZV0pO1xufTtcblxuY29uc3QgVG9nZ2xlQnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBUb2dnbGVCdXR0b24ocHJvcHMsIHJlZikge1xuICAgIHJldHVybiBqc3goSWNvbkJ1dHRvbiwgeyBlbmFibGVkOiBwcm9wcy5tZW51U2hvd24sIGljb246IFwiZWxsaXBzaXNcIiwgcmVmOiByZWYgfSk7XG59KTtcbmNvbnN0IERlZmF1bHRTY3JlZW5TaGFyZU92ZXJsYXkgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBzdG9wU2NyZWVuU2hhcmUgPSAoKSA9PiB7XG4gICAgICAgIGNhbGw/LnNjcmVlblNoYXJlLmRpc2FibGUoKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NjcmVlbi1zaGFyZS1vdmVybGF5XCIsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJzY3JlZW4tc2hhcmUtb2ZmXCIgfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zY3JlZW4tc2hhcmUtb3ZlcmxheV9fdGl0bGVcIiwgY2hpbGRyZW46IHQoJ1lvdSBhcmUgcHJlc2VudGluZyB5b3VyIHNjcmVlbicpIH0pLCBqc3hzKFwiYnV0dG9uXCIsIHsgb25DbGljazogc3RvcFNjcmVlblNoYXJlLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zY3JlZW4tc2hhcmUtb3ZlcmxheV9fYnV0dG9uXCIsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJjbG9zZVwiIH0pLCBcIiBcIiwgdCgnU3RvcCBTY3JlZW4gU2hhcmluZycpXSB9KV0gfSkpO1xufTtcbmNvbnN0IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSA9ICh7IGluZGljYXRvcnNWaXNpYmxlID0gdHJ1ZSwgbWVudVBsYWNlbWVudCA9ICdib3R0b20tc3RhcnQnLCBzaG93TWVudUJ1dHRvbiA9IHRydWUsIFBhcnRpY2lwYW50QWN0aW9uc0NvbnRleHRNZW51OiBQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSQxID0gUGFydGljaXBhbnRBY3Rpb25zQ29udGV4dE1lbnUsIH0pID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50LCB0cmFja1R5cGUgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCB7IHB1Ymxpc2hlZFRyYWNrcyB9ID0gcGFydGljaXBhbnQ7XG4gICAgY29uc3QgaGFzU2NyZWVuU2hhcmUgPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpO1xuICAgIGlmIChwYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnQgJiZcbiAgICAgICAgaGFzU2NyZWVuU2hhcmUgJiZcbiAgICAgICAgdHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVUcmFjaycpIHtcbiAgICAgICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KERlZmF1bHRTY3JlZW5TaGFyZU92ZXJsYXksIHt9KSwganN4KFBhcnRpY2lwYW50RGV0YWlscywgeyBpbmRpY2F0b3JzVmlzaWJsZTogaW5kaWNhdG9yc1Zpc2libGUgfSldIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbc2hvd01lbnVCdXR0b24gJiYgKGpzeChNZW51VG9nZ2xlLCB7IHN0cmF0ZWd5OiBcImZpeGVkXCIsIHBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgVG9nZ2xlQnV0dG9uOiBUb2dnbGVCdXR0b24sIGNoaWxkcmVuOiBqc3goUGFydGljaXBhbnRBY3Rpb25zQ29udGV4dE1lbnUkMSwge30pIH0pKSwganN4KFJlYWN0aW9uLCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCB9KSwganN4KFBhcnRpY2lwYW50RGV0YWlscywgeyBpbmRpY2F0b3JzVmlzaWJsZTogaW5kaWNhdG9yc1Zpc2libGUgfSldIH0pKTtcbn07XG5jb25zdCBQYXJ0aWNpcGFudERldGFpbHMgPSAoeyBpbmRpY2F0b3JzVmlzaWJsZSA9IHRydWUsIH0pID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50IH0gPSB1c2VQYXJ0aWNpcGFudFZpZXdDb250ZXh0KCk7XG4gICAgY29uc3QgeyBpc0xvY2FsUGFydGljaXBhbnQsIGNvbm5lY3Rpb25RdWFsaXR5LCBwdWJsaXNoZWRUcmFja3MsIHBpbiwgc2Vzc2lvbklkLCBuYW1lLCB1c2VySWQsIH0gPSBwYXJ0aWNpcGFudDtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25RdWFsaXR5QXNTdHJpbmcgPSAhIWNvbm5lY3Rpb25RdWFsaXR5ICYmXG4gICAgICAgIFNmdU1vZGVscy5Db25uZWN0aW9uUXVhbGl0eVtjb25uZWN0aW9uUXVhbGl0eV0udG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBoYXNBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLkFVRElPKTtcbiAgICBjb25zdCBoYXNWaWRlbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKTtcbiAgICBjb25zdCBjYW5VbnBpbiA9ICEhcGluICYmIHBpbi5pc0xvY2FsUGluO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWRldGFpbHNcIiwgY2hpbGRyZW46IGpzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fbmFtZVwiLCBjaGlsZHJlbjogW25hbWUgfHwgdXNlcklkLCBpbmRpY2F0b3JzVmlzaWJsZSAmJiAhaGFzQXVkaW8gJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1kZXRhaWxzX19uYW1lLS1hdWRpby1tdXRlZFwiIH0pKSwgaW5kaWNhdG9yc1Zpc2libGUgJiYgIWhhc1ZpZGVvICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fbmFtZS0tdmlkZW8tbXV0ZWRcIiB9KSksIGluZGljYXRvcnNWaXNpYmxlICYmIGNhblVucGluICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG1vbnN0cm9zaXR5IG9uY2Ugd2UgaGF2ZSBhIHByb3BlciBkZXNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIGpzeChcInNwYW5cIiwgeyB0aXRsZTogdCgnVW5waW4nKSwgb25DbGljazogKCkgPT4gY2FsbD8udW5waW4oc2Vzc2lvbklkKSwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fbmFtZS0tcGlubmVkXCIgfSkpLCBpbmRpY2F0b3JzVmlzaWJsZSAmJiBqc3goU3BlZWNoSW5kaWNhdG9yLCB7fSldIH0pIH0pLCBpbmRpY2F0b3JzVmlzaWJsZSAmJiAoanN4KE5vdGlmaWNhdGlvbiwgeyBpc1Zpc2libGU6IGlzTG9jYWxQYXJ0aWNpcGFudCAmJlxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uUXVhbGl0eSA9PT0gU2Z1TW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5LlBPT1IsIG1lc3NhZ2U6IHQoJ1Bvb3IgY29ubmVjdGlvbiBxdWFsaXR5JyksIGNoaWxkcmVuOiBjb25uZWN0aW9uUXVhbGl0eUFzU3RyaW5nICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWRldGFpbHNfX2Nvbm5lY3Rpb24tcXVhbGl0eScsIGBzdHItdmlkZW9fX3BhcnRpY2lwYW50LWRldGFpbHNfX2Nvbm5lY3Rpb24tcXVhbGl0eS0tJHtjb25uZWN0aW9uUXVhbGl0eUFzU3RyaW5nfWApLCB0aXRsZTogY29ubmVjdGlvblF1YWxpdHlBc1N0cmluZyB9KSkgfSkpXSB9KSk7XG59O1xuY29uc3QgU3BlZWNoSW5kaWNhdG9yID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCB7IGlzU3BlYWtpbmcsIGlzRG9taW5hbnRTcGVha2VyIH0gPSBwYXJ0aWNpcGFudDtcbiAgICByZXR1cm4gKGpzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3NwZWVjaC1pbmRpY2F0b3InLCBpc1NwZWFraW5nICYmICdzdHItdmlkZW9fX3NwZWVjaC1pbmRpY2F0b3ItLXNwZWFraW5nJywgaXNEb21pbmFudFNwZWFrZXIgJiYgJ3N0ci12aWRlb19fc3BlZWNoLWluZGljYXRvci0tZG9taW5hbnQnKSwgY2hpbGRyZW46IFtqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlZWNoLWluZGljYXRvcl9fYmFyXCIgfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVlY2gtaW5kaWNhdG9yX19iYXJcIiB9KSwganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWVjaC1pbmRpY2F0b3JfX2JhclwiIH0pXSB9KSk7XG59O1xuXG5jb25zdCBQYXJ0aWNpcGFudFZpZXcgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFBhcnRpY2lwYW50Vmlldyh7IHBhcnRpY2lwYW50LCB0cmFja1R5cGUgPSAndmlkZW9UcmFjaycsIG11dGVBdWRpbywgcmVmczogeyBzZXRWaWRlb0VsZW1lbnQsIHNldFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50IH0gPSB7fSwgY2xhc3NOYW1lLCBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSSA9IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSwgfSwgcmVmKSB7XG4gICAgY29uc3QgeyBpc0xvY2FsUGFydGljaXBhbnQsIGlzU3BlYWtpbmcsIGlzRG9taW5hbnRTcGVha2VyLCBwdWJsaXNoZWRUcmFja3MsIHNlc3Npb25JZCwgfSA9IHBhcnRpY2lwYW50O1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuQVVESU8pO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuVklERU8pO1xuICAgIGNvbnN0IGhhc1NjcmVlblNoYXJlQXVkaW8gPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pO1xuICAgIGNvbnN0IFt0cmFja2VkRWxlbWVudCwgc2V0VHJhY2tlZEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2NvbnRleHRWaWRlb0VsZW1lbnQsIHNldENvbnRleHRWaWRlb0VsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2NvbnRleHRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudCwgc2V0Q29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIC8vIFRPRE86IGFsbG93IHRvIHBhc3MgY3VzdG9tIFZpZXdwb3J0VHJhY2tlciBpbnN0YW5jZSBmcm9tIHByb3BzXG4gICAgdXNlVHJhY2tFbGVtZW50VmlzaWJpbGl0eSh7XG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgdHJhY2tlZEVsZW1lbnQsXG4gICAgICAgIHRyYWNrVHlwZSxcbiAgICB9KTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudFZpZXdDb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgICBwYXJ0aWNpcGFudFZpZXdFbGVtZW50OiB0cmFja2VkRWxlbWVudCxcbiAgICAgICAgdmlkZW9FbGVtZW50OiBjb250ZXh0VmlkZW9FbGVtZW50LFxuICAgICAgICB2aWRlb1BsYWNlaG9sZGVyRWxlbWVudDogY29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50LFxuICAgICAgICB0cmFja1R5cGUsXG4gICAgfSksIFtcbiAgICAgICAgY29udGV4dFZpZGVvRWxlbWVudCxcbiAgICAgICAgY29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50LFxuICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgdHJhY2tlZEVsZW1lbnQsXG4gICAgICAgIHRyYWNrVHlwZSxcbiAgICBdKTtcbiAgICBjb25zdCB2aWRlb1JlZnMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHNldFZpZGVvRWxlbWVudDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHNldFZpZGVvRWxlbWVudD8uKGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0Q29udGV4dFZpZGVvRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQ6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBzZXRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudD8uKGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0Q29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgIH0pLCBbc2V0VmlkZW9FbGVtZW50LCBzZXRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInBhcnRpY2lwYW50LXZpZXdcIiwgcmVmOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgYXBwbHlFbGVtZW50VG9SZWYocmVmLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHNldFRyYWNrZWRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9LCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcGFydGljaXBhbnQtdmlldycsIGlzRG9taW5hbnRTcGVha2VyICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLWRvbWluYW50LXNwZWFrZXInLCBpc1NwZWFraW5nICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLXNwZWFraW5nJywgIWhhc1ZpZGVvICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLW5vLXZpZGVvJywgIWhhc0F1ZGlvICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLW5vLWF1ZGlvJywgY2xhc3NOYW1lKSwgY2hpbGRyZW46IGpzeHMoUGFydGljaXBhbnRWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcGFydGljaXBhbnRWaWV3Q29udGV4dFZhbHVlLCBjaGlsZHJlbjogWyFpc0xvY2FsUGFydGljaXBhbnQgJiYgIW11dGVBdWRpbyAmJiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2hhc0F1ZGlvICYmIChqc3goQXVkaW8sIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50LCB0cmFja1R5cGU6IFwiYXVkaW9UcmFja1wiIH0pKSwgaGFzU2NyZWVuU2hhcmVBdWRpbyAmJiAoanN4KEF1ZGlvLCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCwgdHJhY2tUeXBlOiBcInNjcmVlblNoYXJlQXVkaW9UcmFja1wiIH0pKV0gfSkpLCBqc3goVmlkZW8kMSwgeyBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQsIHRyYWNrVHlwZTogdHJhY2tUeXBlLCByZWZzOiB2aWRlb1JlZnMsIGF1dG9QbGF5OiB0cnVlIH0pLCBpc0NvbXBvbmVudFR5cGUoUGFydGljaXBhbnRWaWV3VUkpID8gKGpzeChQYXJ0aWNpcGFudFZpZXdVSSwge30pKSA6IChQYXJ0aWNpcGFudFZpZXdVSSldIH0pIH0pKTtcbn0pO1xuXG4vLyByZS1leHBvcnRpbmcgdGhlIFN0cmVhbUNhbGxQcm92aWRlciBhcyBTdHJlYW1DYWxsXG5jb25zdCBTdHJlYW1DYWxsID0gU3RyZWFtQ2FsbFByb3ZpZGVyO1xuXG52YXIgSm9pbmluZyA9IFwiSm9pbmluZ1wiO1xudmFyIE1pYyA9IFwiTWljXCI7XG52YXIgUmluZ2luZyA9IFwiUmluZ2luZ1wiO1xudmFyIFNwZWFrZXJzID0gXCJTcGVha2Vyc1wiO1xudmFyIFZpZGVvID0gXCJWaWRlb1wiO1xudmFyIExpdmUgPSBcIkxpdmVcIjtcbnZhciBSZWFjdGlvbnMgPSBcIlJlYWN0aW9uc1wiO1xudmFyIFN0YXRpc3RpY3MgPSBcIlN0YXRpc3RpY3NcIjtcbnZhciBJbnZpdGUgPSBcIkludml0ZVwiO1xudmFyIEpvaW4gPSBcIkpvaW5cIjtcbnZhciBZb3UgPSBcIllvdVwiO1xudmFyIE1lID0gXCJNZVwiO1xudmFyIFVua25vd24gPSBcIlVua25vd25cIjtcbnZhciBSZWZyZXNoID0gXCJSZWZyZXNoXCI7XG52YXIgQWxsb3cgPSBcIkFsbG93XCI7XG52YXIgUmV2b2tlID0gXCJSZXZva2VcIjtcbnZhciBEaXNtaXNzID0gXCJEaXNtaXNzXCI7XG52YXIgUGlubmVkID0gXCJQaW5uZWRcIjtcbnZhciBVbnBpbiA9IFwiVW5waW5cIjtcbnZhciBQaW4gPSBcIlBpblwiO1xudmFyIEJsb2NrID0gXCJCbG9ja1wiO1xudmFyIEVudGVyID0gXCJFbnRlclwiO1xudmFyIExlYXZlID0gXCJMZWF2ZVwiO1xudmFyIFBhcnRpY2lwYW50cyA9IFwiUGFydGljaXBhbnRzXCI7XG52YXIgQW5vbnltb3VzID0gXCIsIGFuZCAoe3sgY291bnQgfX0pIGFub255bW91c1wiO1xudmFyIGVuID0ge1xuXHRKb2luaW5nOiBKb2luaW5nLFxuXHRNaWM6IE1pYyxcblx0XCJObyBpbnRlcm5ldCBjb25uZWN0aW9uXCI6IFwiTm8gaW50ZXJuZXQgY29ubmVjdGlvblwiLFxuXHRcIlJlLWNvbm5lY3RpbmdcIjogXCJSZS1jb25uZWN0aW5nXCIsXG5cdFJpbmdpbmc6IFJpbmdpbmcsXG5cdFwiU2NyZWVuIFNoYXJlXCI6IFwiU2NyZWVuIFNoYXJlXCIsXG5cdFwiU2VsZWN0IGEgQ2FtZXJhXCI6IFwiU2VsZWN0IGEgQ2FtZXJhXCIsXG5cdFwiU2VsZWN0IGEgTWljXCI6IFwiU2VsZWN0IGEgTWljXCIsXG5cdFwiU2VsZWN0IFNwZWFrZXJzXCI6IFwiU2VsZWN0IFNwZWFrZXJzXCIsXG5cdFNwZWFrZXJzOiBTcGVha2Vycyxcblx0VmlkZW86IFZpZGVvLFxuXHRcIllvdSBhcmUgbXV0ZWQuIFVubXV0ZSB0byBzcGVhay5cIjogXCJZb3UgYXJlIG11dGVkLiBVbm11dGUgdG8gc3BlYWsuXCIsXG5cdExpdmU6IExpdmUsXG5cdFwiWW91IGNhbiBub3cgc3BlYWsuXCI6IFwiWW91IGNhbiBub3cgc3BlYWsuXCIsXG5cdFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNwZWFrLlwiOiBcIkF3YWl0aW5nIGZvciBhbiBhcHByb3ZhbCB0byBzcGVhay5cIixcblx0XCJZb3UgY2FuIG5vIGxvbmdlciBzcGVhay5cIjogXCJZb3UgY2FuIG5vIGxvbmdlciBzcGVhay5cIixcblx0XCJZb3UgY2FuIG5vdyBzaGFyZSB5b3VyIHZpZGVvLlwiOiBcIllvdSBjYW4gbm93IHNoYXJlIHlvdXIgdmlkZW8uXCIsXG5cdFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHlvdXIgdmlkZW8uXCI6IFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHlvdXIgdmlkZW8uXCIsXG5cdFwiWW91IGNhbiBubyBsb25nZXIgc2hhcmUgeW91ciB2aWRlby5cIjogXCJZb3UgY2FuIG5vIGxvbmdlciBzaGFyZSB5b3VyIHZpZGVvLlwiLFxuXHRcIldhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdG9wLi4uXCI6IFwiV2FpdGluZyBmb3IgcmVjb3JkaW5nIHRvIHN0b3AuLi5cIixcblx0XCJXYWl0aW5nIGZvciByZWNvcmRpbmcgdG8gc3RhcnQuLi5cIjogXCJXYWl0aW5nIGZvciByZWNvcmRpbmcgdG8gc3RhcnQuLi5cIixcblx0XCJSZWNvcmQgY2FsbFwiOiBcIlJlY29yZCBjYWxsXCIsXG5cdFJlYWN0aW9uczogUmVhY3Rpb25zLFxuXHRTdGF0aXN0aWNzOiBTdGF0aXN0aWNzLFxuXHRcIllvdSBjYW4gbm93IHNoYXJlIHlvdXIgc2NyZWVuLlwiOiBcIllvdSBjYW4gbm93IHNoYXJlIHlvdXIgc2NyZWVuLlwiLFxuXHRcIkF3YWl0aW5nIGZvciBhbiBhcHByb3ZhbCB0byBzaGFyZSBzY3JlZW4uXCI6IFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHNjcmVlbi5cIixcblx0XCJZb3UgY2FuIG5vIGxvbmdlciBzaGFyZSB5b3VyIHNjcmVlbi5cIjogXCJZb3UgY2FuIG5vIGxvbmdlciBzaGFyZSB5b3VyIHNjcmVlbi5cIixcblx0XCJTaGFyZSBzY3JlZW5cIjogXCJTaGFyZSBzY3JlZW5cIixcblx0XCJJbmNvbWluZyBDYWxsLi4uXCI6IFwiSW5jb21pbmcgQ2FsbC4uLlwiLFxuXHRcIkNhbGxpbmcuLi5cIjogXCJDYWxsaW5nLi4uXCIsXG5cdFwiTXV0ZSBBbGxcIjogXCJNdXRlIEFsbFwiLFxuXHRJbnZpdGU6IEludml0ZSxcblx0Sm9pbjogSm9pbixcblx0WW91OiBZb3UsXG5cdE1lOiBNZSxcblx0VW5rbm93bjogVW5rbm93bixcblx0XCJUb2dnbGUgZGV2aWNlIG1lbnVcIjogXCJUb2dnbGUgZGV2aWNlIG1lbnVcIixcblx0XCJDYWxsIFJlY29yZGluZ3NcIjogXCJDYWxsIFJlY29yZGluZ3NcIixcblx0UmVmcmVzaDogUmVmcmVzaCxcblx0XCJDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnNcIjogXCJDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnNcIixcblx0XCJWaWRlbyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkIGJ5IHRoZSBzeXN0ZW1cIjogXCJWaWRlbyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkIGJ5IHRoZSBzeXN0ZW1cIixcblx0XCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgdmlkZW9cIjogXCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgdmlkZW9cIixcblx0XCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgYXVkaW9cIjogXCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgYXVkaW9cIixcblx0XCJZb3UgYXJlIHByZXNlbnRpbmcgeW91ciBzY3JlZW5cIjogXCJZb3UgYXJlIHByZXNlbnRpbmcgeW91ciBzY3JlZW5cIixcblx0XCJTdG9wIFNjcmVlbiBTaGFyaW5nXCI6IFwiU3RvcCBTY3JlZW4gU2hhcmluZ1wiLFxuXHRBbGxvdzogQWxsb3csXG5cdFJldm9rZTogUmV2b2tlLFxuXHREaXNtaXNzOiBEaXNtaXNzLFxuXHRcIk1pY3JvcGhvbmUgb25cIjogXCJNaWNyb3Bob25lIG9uXCIsXG5cdFwiTWljcm9waG9uZSBvZmZcIjogXCJNaWNyb3Bob25lIG9mZlwiLFxuXHRcIkNhbWVyYSBvblwiOiBcIkNhbWVyYSBvblwiLFxuXHRcIkNhbWVyYSBvZmZcIjogXCJDYW1lcmEgb2ZmXCIsXG5cdFwiTm8gY2FtZXJhIGZvdW5kXCI6IFwiTm8gY2FtZXJhIGZvdW5kXCIsXG5cdFwiVmlkZW8gaXMgZGlzYWJsZWRcIjogXCJWaWRlbyBpcyBkaXNhYmxlZFwiLFxuXHRQaW5uZWQ6IFBpbm5lZCxcblx0VW5waW46IFVucGluLFxuXHRQaW46IFBpbixcblx0XCJQaW4gZm9yIGV2ZXJ5b25lXCI6IFwiUGluIGZvciBldmVyeW9uZVwiLFxuXHRcIlVucGluIGZvciBldmVyeW9uZVwiOiBcIlVucGluIGZvciBldmVyeW9uZVwiLFxuXHRCbG9jazogQmxvY2ssXG5cdFwiVHVybiBvZmYgdmlkZW9cIjogXCJUdXJuIG9mZiB2aWRlb1wiLFxuXHRcIlR1cm4gb2ZmIHNjcmVlbiBzaGFyZVwiOiBcIlR1cm4gb2ZmIHNjcmVlbiBzaGFyZVwiLFxuXHRcIk11dGUgYXVkaW9cIjogXCJNdXRlIGF1ZGlvXCIsXG5cdFwiTXV0ZSBzY3JlZW4gc2hhcmUgYXVkaW9cIjogXCJNdXRlIHNjcmVlbiBzaGFyZSBhdWRpb1wiLFxuXHRcIkFsbG93IGF1ZGlvXCI6IFwiQWxsb3cgYXVkaW9cIixcblx0XCJBbGxvdyB2aWRlb1wiOiBcIkFsbG93IHZpZGVvXCIsXG5cdFwiQWxsb3cgc2NyZWVuIHNoYXJpbmdcIjogXCJBbGxvdyBzY3JlZW4gc2hhcmluZ1wiLFxuXHRcIkRpc2FibGUgYXVkaW9cIjogXCJEaXNhYmxlIGF1ZGlvXCIsXG5cdFwiRGlzYWJsZSB2aWRlb1wiOiBcIkRpc2FibGUgdmlkZW9cIixcblx0XCJEaXNhYmxlIHNjcmVlbiBzaGFyaW5nXCI6IFwiRGlzYWJsZSBzY3JlZW4gc2hhcmluZ1wiLFxuXHRFbnRlcjogRW50ZXIsXG5cdExlYXZlOiBMZWF2ZSxcblx0XCJMZWF2ZSBjYWxsXCI6IFwiTGVhdmUgY2FsbFwiLFxuXHRcIkVuZCBjYWxsIGZvciBhbGxcIjogXCJFbmQgY2FsbCBmb3IgYWxsXCIsXG5cdFwie3sgZGlyZWN0aW9uIH19IGZ1bGxzY3JlZW5cIjogXCJ7eyBkaXJlY3Rpb24gfX0gZnVsbHNjcmVlblwiLFxuXHRcInt7IGRpcmVjdGlvbiB9fSBwaWN0dXJlLWluLXBpY3R1cmVcIjogXCJ7eyBkaXJlY3Rpb24gfX0gcGljdHVyZS1pbi1waWN0dXJlXCIsXG5cdFwiRG9taW5hbnQgU3BlYWtlclwiOiBcIkRvbWluYW50IFNwZWFrZXJcIixcblx0XCJQb29yIGNvbm5lY3Rpb24gcXVhbGl0eVwiOiBcIlBvb3IgY29ubmVjdGlvbiBxdWFsaXR5LiBQbGVhc2UgY2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uLlwiLFxuXHRQYXJ0aWNpcGFudHM6IFBhcnRpY2lwYW50cyxcblx0QW5vbnltb3VzOiBBbm9ueW1vdXMsXG5cdFwiTm8gcGFydGljaXBhbnRzIGZvdW5kXCI6IFwiTm8gcGFydGljaXBhbnRzIGZvdW5kXCIsXG5cdFwiUGFydGljaXBhbnRzICh7eyBudW1iZXJPZlBhcnRpY2lwYW50cyB9fSlcIjogXCJQYXJ0aWNpcGFudHMgKHt7IG51bWJlck9mUGFydGljaXBhbnRzIH19KVwiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHNoYXJpbmcgdGhlaXIgc2NyZWVuXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgc2hhcmluZyB0aGVpciBzY3JlZW5cIixcblx0XCJ7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHNwZWFrXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBzcGVha1wiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgdG8gc2hhcmUgdGhlaXIgY2FtZXJhXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBzaGFyZSB0aGVpciBjYW1lcmFcIixcblx0XCJ7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHByZXNlbnQgdGhlaXIgc2NyZWVuXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBwcmVzZW50IHRoZWlyIHNjcmVlblwiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgcGVybWlzc2lvbjoge3sgcGVybWlzc2lvbiB9fVwiOiBcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgcGVybWlzc2lvbjoge3sgcGVybWlzc2lvbiB9fVwiXG59O1xuXG5jb25zdCB0cmFuc2xhdGlvbnMgPSB7IGVuIH07XG5cbmNvbnN0IFN0cmVhbVZpZGVvID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIChqc3goU3RyZWFtVmlkZW9Qcm92aWRlciwgeyB0cmFuc2xhdGlvbnNPdmVycmlkZXM6IHRyYW5zbGF0aW9ucywgLi4ucHJvcHMgfSkpO1xufTtcblxuY29uc3QgdXNlUGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCA9IChjYWxsKSA9PiB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsLnNldFNvcnRQYXJ0aWNpcGFudHNCeShwYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2V0U29ydFByZXNldChjYWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY2FsbF0pO1xufTtcbmNvbnN0IHVzZVNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0ID0gKGNhbGwsIGlzT25lT25PbmVDYWxsKSA9PiB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBhbHdheXMgc2hvdyB0aGUgcmVtb3RlIHBhcnRpY2lwYW50IGluIHRoZSBzcG90bGlnaHRcbiAgICAgICAgaWYgKGlzT25lT25PbmVDYWxsKSB7XG4gICAgICAgICAgICBjYWxsLnNldFNvcnRQYXJ0aWNpcGFudHNCeShjb21iaW5lQ29tcGFyYXRvcnMoc2NyZWVuU2hhcmluZywgbG9nZ2VkSW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGwuc2V0U29ydFBhcnRpY2lwYW50c0J5KHNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzZXRTb3J0UHJlc2V0KGNhbGwpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxsLCBpc09uZU9uT25lQ2FsbF0pO1xufTtcbmNvbnN0IHJlc2V0U29ydFByZXNldCA9IChjYWxsKSA9PiB7XG4gICAgLy8gcmVzZXQgdGhlIHNvcnRpbmcgdG8gdGhlIGRlZmF1bHQgZm9yIHRoZSBjYWxsIHR5cGVcbiAgICBjb25zdCBjYWxsQ29uZmlnID0gQ2FsbFR5cGVzLmdldChjYWxsLnR5cGUpO1xuICAgIGNhbGwuc2V0U29ydFBhcnRpY2lwYW50c0J5KGNhbGxDb25maWcub3B0aW9ucy5zb3J0UGFydGljaXBhbnRzQnkgfHwgZGVmYXVsdFNvcnRQcmVzZXQpO1xufTtcbmNvbnN0IGxvZ2dlZEluID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5pc0xvY2FsUGFydGljaXBhbnQpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChiLmlzTG9jYWxQYXJ0aWNpcGFudClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufTtcblxuY29uc3QgTGl2ZXN0cmVhbUxheW91dCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRzLCB1c2VSZW1vdGVQYXJ0aWNpcGFudHMsIHVzZUhhc09uZ29pbmdTY3JlZW5TaGFyZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IFtjdXJyZW50U3BlYWtlciwgLi4ub3RoZXJQYXJ0aWNpcGFudHNdID0gdXNlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnRzID0gdXNlUmVtb3RlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgaGFzT25nb2luZ1NjcmVlblNoYXJlID0gdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlKCk7XG4gICAgY29uc3QgcHJlc2VudGVyID0gaGFzT25nb2luZ1NjcmVlblNoYXJlXG4gICAgICAgID8gaGFzU2NyZWVuU2hhcmUkMShjdXJyZW50U3BlYWtlcikgJiYgY3VycmVudFNwZWFrZXJcbiAgICAgICAgOiBvdGhlclBhcnRpY2lwYW50cy5maW5kKGhhc1NjcmVlblNoYXJlJDEpO1xuICAgIHVzZVBhZ2luYXRlZExheW91dFNvcnRQcmVzZXQoY2FsbCk7XG4gICAgY29uc3QgT3ZlcmxheSA9IChqc3goUGFydGljaXBhbnRPdmVybGF5LCB7IHNob3dQYXJ0aWNpcGFudENvdW50OiBwcm9wcy5zaG93UGFydGljaXBhbnRDb3VudCwgc2hvd0R1cmF0aW9uOiBwcm9wcy5zaG93RHVyYXRpb24sIHNob3dMaXZlQmFkZ2U6IHByb3BzLnNob3dMaXZlQmFkZ2UsIHNob3dTcGVha2VyTmFtZTogcHJvcHMuc2hvd1NwZWFrZXJOYW1lIH0pKTtcbiAgICBjb25zdCB7IGZsb2F0aW5nUGFydGljaXBhbnRQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgRmxvYXRpbmdQYXJ0aWNpcGFudE92ZXJsYXkgPSBoYXNPbmdvaW5nU2NyZWVuU2hhcmUgJiYgKGpzeChQYXJ0aWNpcGFudE92ZXJsYXlcbiAgICAvLyB0aGVzZSBlbGVtZW50cyBhcmVuJ3QgbmVlZGVkIGZvciB0aGUgdmlkZW8gZmVlZFxuICAgICwgeyBcbiAgICAgICAgLy8gdGhlc2UgZWxlbWVudHMgYXJlbid0IG5lZWRlZCBmb3IgdGhlIHZpZGVvIGZlZWRcbiAgICAgICAgc2hvd1BhcnRpY2lwYW50Q291bnQ6IGZsb2F0aW5nUGFydGljaXBhbnRQcm9wcz8uc2hvd1BhcnRpY2lwYW50Q291bnQgPz8gZmFsc2UsIHNob3dEdXJhdGlvbjogZmxvYXRpbmdQYXJ0aWNpcGFudFByb3BzPy5zaG93RHVyYXRpb24gPz8gZmFsc2UsIHNob3dMaXZlQmFkZ2U6IGZsb2F0aW5nUGFydGljaXBhbnRQcm9wcz8uc2hvd0xpdmVCYWRnZSA/PyBmYWxzZSwgc2hvd1NwZWFrZXJOYW1lOiBmbG9hdGluZ1BhcnRpY2lwYW50UHJvcHM/LnNob3dTcGVha2VyTmFtZSA/PyB0cnVlIH0pKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fd3JhcHBlclwiLCBjaGlsZHJlbjogW2pzeChQYXJ0aWNpcGFudHNBdWRpbywgeyBwYXJ0aWNpcGFudHM6IHJlbW90ZVBhcnRpY2lwYW50cyB9KSwgaGFzT25nb2luZ1NjcmVlblNoYXJlICYmIHByZXNlbnRlciAmJiAoanN4KFBhcnRpY2lwYW50VmlldywgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fc2NyZWVuLXNoYXJlXCIsIHBhcnRpY2lwYW50OiBwcmVzZW50ZXIsIFBhcnRpY2lwYW50Vmlld1VJOiBPdmVybGF5LCB0cmFja1R5cGU6IFwic2NyZWVuU2hhcmVUcmFja1wiLCBtdXRlQXVkaW8gLy8gYXVkaW8gaXMgcmVuZGVyZWQgYnkgUGFydGljaXBhbnRzQXVkaW9cbiAgICAgICAgICAgICAgICA6IHRydWUgfSkpLCBjdXJyZW50U3BlYWtlciAmJiAoanN4KFBhcnRpY2lwYW50VmlldywgeyBjbGFzc05hbWU6IGNsc3goaGFzT25nb2luZ1NjcmVlblNoYXJlICYmXG4gICAgICAgICAgICAgICAgICAgIGNsc3goJ3N0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2Zsb2F0aW5nLXBhcnRpY2lwYW50JywgYHN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2Zsb2F0aW5nLXBhcnRpY2lwYW50LS0ke2Zsb2F0aW5nUGFydGljaXBhbnRQcm9wcz8ucG9zaXRpb24gPz8gJ3RvcC1yaWdodCd9YCkpLCBwYXJ0aWNpcGFudDogY3VycmVudFNwZWFrZXIsIFBhcnRpY2lwYW50Vmlld1VJOiBGbG9hdGluZ1BhcnRpY2lwYW50T3ZlcmxheSB8fCBPdmVybGF5LCBtdXRlQXVkaW8gLy8gYXVkaW8gaXMgcmVuZGVyZWQgYnkgUGFydGljaXBhbnRzQXVkaW9cbiAgICAgICAgICAgICAgICA6IHRydWUgfSkpXSB9KSk7XG59O1xuY29uc3QgaGFzU2NyZWVuU2hhcmUkMSA9IChwKSA9PiAhIXA/LnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSk7XG5jb25zdCBQYXJ0aWNpcGFudE92ZXJsYXkgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGVuYWJsZUZ1bGxTY3JlZW4gPSB0cnVlLCBzaG93UGFydGljaXBhbnRDb3VudCA9IHRydWUsIHNob3dEdXJhdGlvbiA9IHRydWUsIHNob3dMaXZlQmFkZ2UgPSB0cnVlLCBzaG93U3BlYWtlck5hbWUgPSBmYWxzZSwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCB7IHVzZVBhcnRpY2lwYW50Q291bnQgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRDb3VudCA9IHVzZVBhcnRpY2lwYW50Q291bnQoKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHVzZVVwZGF0ZUNhbGxEdXJhdGlvbigpO1xuICAgIGNvbnN0IHRvZ2dsZUZ1bGxTY3JlZW4gPSB1c2VUb2dnbGVGdWxsU2NyZWVuKCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fb3ZlcmxheVwiLCBjaGlsZHJlbjoganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2xpdmVzdHJlYW0tbGF5b3V0X19vdmVybGF5X19iYXJcIiwgY2hpbGRyZW46IFtzaG93TGl2ZUJhZGdlICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2xpdmUtYmFkZ2VcIiwgY2hpbGRyZW46IHQoJ0xpdmUnKSB9KSksIHNob3dQYXJ0aWNpcGFudENvdW50ICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX3ZpZXdlcnMtY291bnRcIiwgY2hpbGRyZW46IHBhcnRpY2lwYW50Q291bnQgfSkpLCBzaG93U3BlYWtlck5hbWUgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fc3BlYWtlci1uYW1lXCIsIHRpdGxlOiBwYXJ0aWNpcGFudC5uYW1lIHx8IHBhcnRpY2lwYW50LnVzZXJJZCB8fCAnJywgY2hpbGRyZW46IHBhcnRpY2lwYW50Lm5hbWUgfHwgcGFydGljaXBhbnQudXNlcklkIHx8ICcnIH0pKSwgc2hvd0R1cmF0aW9uICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2R1cmF0aW9uXCIsIGNoaWxkcmVuOiBmb3JtYXREdXJhdGlvbihkdXJhdGlvbikgfSkpLCBlbmFibGVGdWxsU2NyZWVuICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2dvLWZ1bGxzY3JlZW5cIiwgb25DbGljazogdG9nZ2xlRnVsbFNjcmVlbiB9KSldIH0pIH0pKTtcbn07XG5jb25zdCB1c2VVcGRhdGVDYWxsRHVyYXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyB1c2VJc0NhbGxMaXZlLCB1c2VDYWxsU2Vzc2lvbiB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBpc0NhbGxMaXZlID0gdXNlSXNDYWxsTGl2ZSgpO1xuICAgIGNvbnN0IHNlc3Npb24gPSB1c2VDYWxsU2Vzc2lvbigpO1xuICAgIGNvbnN0IFtkdXJhdGlvbiwgc2V0RHVyYXRpb25dID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ubGl2ZV9zdGFydGVkX2F0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IGxpdmVTdGFydFRpbWUgPSBuZXcgRGF0ZShzZXNzaW9uLmxpdmVfc3RhcnRlZF9hdCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChub3cuZ2V0VGltZSgpIC0gbGl2ZVN0YXJ0VGltZS5nZXRUaW1lKCkpIC8gMTAwMCk7XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0NhbGxMaXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHNldER1cmF0aW9uKChkKSA9PiBkICsgMSk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH07XG4gICAgfSwgW2lzQ2FsbExpdmVdKTtcbiAgICByZXR1cm4gZHVyYXRpb247XG59O1xuY29uc3QgdXNlVG9nZ2xlRnVsbFNjcmVlbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50Vmlld0VsZW1lbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCBbaXNGdWxsc2NyZWVuLCBzZXRJc0Z1bGxzY3JlZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChpc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0SXNGdWxsc2NyZWVuKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFydGljaXBhbnRWaWV3RWxlbWVudD8ucmVxdWVzdEZ1bGxzY3JlZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRJc0Z1bGxzY3JlZW4odHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0Z1bGxzY3JlZW4sIHBhcnRpY2lwYW50Vmlld0VsZW1lbnRdKTtcbn07XG5jb25zdCBmb3JtYXREdXJhdGlvbiA9IChkdXJhdGlvbkluTXMpID0+IHtcbiAgICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihkdXJhdGlvbkluTXMgLyA4NjQwMCk7XG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKGR1cmF0aW9uSW5NcyAvIDM2MDApO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChkdXJhdGlvbkluTXMgJSAzNjAwKSAvIDYwKTtcbiAgICBjb25zdCBzZWNvbmRzID0gZHVyYXRpb25Jbk1zICUgNjA7XG4gICAgcmV0dXJuIGAke2RheXMgPyBkYXlzICsgJyAnIDogJyd9JHtob3VycyA/IGhvdXJzICsgJzonIDogJyd9JHttaW51dGVzIDwgMTAgPyAnMCcgOiAnJ30ke21pbnV0ZXN9OiR7c2Vjb25kcyA8IDEwID8gJzAnIDogJyd9JHtzZWNvbmRzfWA7XG59O1xuXG5jb25zdCBHUk9VUF9TSVpFID0gMTY7XG5jb25zdCBQYWdpbmF0ZWRHcmlkTGF5b3V0R3JvdXAgPSAoeyBncm91cCwgVmlkZW9QbGFjZWhvbGRlciwgUGFydGljaXBhbnRWaWV3VUksIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXRfX2dyb3VwJywge1xuICAgICAgICAgICAgJ3N0ci12aWRlb19fcGFnaW5hdGVkLWdyaWQtbGF5b3V0LS1vbmUnOiBncm91cC5sZW5ndGggPT09IDEsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXQtLXR3by1mb3VyJzogZ3JvdXAubGVuZ3RoID49IDIgJiYgZ3JvdXAubGVuZ3RoIDw9IDQsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXQtLWZpdmUtbmluZSc6IGdyb3VwLmxlbmd0aCA+PSA1ICYmIGdyb3VwLmxlbmd0aCA8PSA5LFxuICAgICAgICB9KSwgY2hpbGRyZW46IGdyb3VwLm1hcCgocGFydGljaXBhbnQpID0+IChqc3goUGFydGljaXBhbnRWaWV3LCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCwgbXV0ZUF1ZGlvOiB0cnVlLCBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUkgfSwgcGFydGljaXBhbnQuc2Vzc2lvbklkKSkpIH0pKTtcbn07XG5jb25zdCBQYWdpbmF0ZWRHcmlkTGF5b3V0ID0gKHsgZ3JvdXBTaXplID0gR1JPVVBfU0laRSwgZXhjbHVkZUxvY2FsUGFydGljaXBhbnQgPSBmYWxzZSwgcGFnZUFycm93c1Zpc2libGUgPSB0cnVlLCBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSSA9IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYWdlLCBzZXRQYWdlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtwYWdpbmF0ZWRHcmlkTGF5b3V0V3JhcHBlckVsZW1lbnQsIHNldFBhZ2luYXRlZEdyaWRMYXlvdXRXcmFwcGVyRWxlbWVudCxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZVBhcnRpY2lwYW50cywgdXNlUmVtb3RlUGFydGljaXBhbnRzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHVzZVBhcnRpY2lwYW50cygpO1xuICAgIC8vIHVzZWQgdG8gcmVuZGVyIGF1ZGlvIGVsZW1lbnRzXG4gICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnRzID0gdXNlUmVtb3RlUGFydGljaXBhbnRzKCk7XG4gICAgdXNlUGFnaW5hdGVkTGF5b3V0U29ydFByZXNldChjYWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXBhZ2luYXRlZEdyaWRMYXlvdXRXcmFwcGVyRWxlbWVudCB8fCAhY2FsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNhbGwuc2V0Vmlld3BvcnQocGFnaW5hdGVkR3JpZExheW91dFdyYXBwZXJFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFudXAoKTtcbiAgICB9LCBbcGFnaW5hdGVkR3JpZExheW91dFdyYXBwZXJFbGVtZW50LCBjYWxsXSk7XG4gICAgLy8gb25seSB1c2VkIHRvIHJlbmRlciB2aWRlbyBlbGVtZW50c1xuICAgIGNvbnN0IHBhcnRpY2lwYW50R3JvdXBzID0gdXNlTWVtbygoKSA9PiBjaHVuayhleGNsdWRlTG9jYWxQYXJ0aWNpcGFudCA/IHJlbW90ZVBhcnRpY2lwYW50cyA6IHBhcnRpY2lwYW50cywgZ3JvdXBTaXplKSwgW2V4Y2x1ZGVMb2NhbFBhcnRpY2lwYW50LCByZW1vdGVQYXJ0aWNpcGFudHMsIHBhcnRpY2lwYW50cywgZ3JvdXBTaXplXSk7XG4gICAgY29uc3QgcGFnZUNvdW50ID0gcGFydGljaXBhbnRHcm91cHMubGVuZ3RoO1xuICAgIC8vIHVwZGF0ZSBwYWdlIHdoZW4gcGFnZSBjb3VudCBpcyByZWR1Y2VkIGFuZCBzZWxlY3RlZCBwYWdlIG5vIGxvbmdlciBleGlzdHNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocGFnZSA+IHBhZ2VDb3VudCAtIDEpIHtcbiAgICAgICAgICAgIHNldFBhZ2UoTWF0aC5tYXgoMCwgcGFnZUNvdW50IC0gMSkpO1xuICAgICAgICB9XG4gICAgfSwgW3BhZ2UsIHBhZ2VDb3VudF0pO1xuICAgIGNvbnN0IHNlbGVjdGVkR3JvdXAgPSBwYXJ0aWNpcGFudEdyb3Vwc1twYWdlXTtcbiAgICBpZiAoIWNhbGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhZ2luYXRlZC1ncmlkLWxheW91dF9fd3JhcHBlclwiLCByZWY6IHNldFBhZ2luYXRlZEdyaWRMYXlvdXRXcmFwcGVyRWxlbWVudCwgY2hpbGRyZW46IFtqc3goUGFydGljaXBhbnRzQXVkaW8sIHsgcGFydGljaXBhbnRzOiByZW1vdGVQYXJ0aWNpcGFudHMgfSksIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXRcIiwgY2hpbGRyZW46IFtwYWdlQXJyb3dzVmlzaWJsZSAmJiBwYWdlQ291bnQgPiAxICYmIChqc3goSWNvbkJ1dHRvbiwgeyBpY29uOiBcImNhcmV0LWxlZnRcIiwgZGlzYWJsZWQ6IHBhZ2UgPT09IDAsIG9uQ2xpY2s6ICgpID0+IHNldFBhZ2UoKGN1cnJlbnRQYWdlKSA9PiBNYXRoLm1heCgwLCBjdXJyZW50UGFnZSAtIDEpKSB9KSksIHNlbGVjdGVkR3JvdXAgJiYgKGpzeChQYWdpbmF0ZWRHcmlkTGF5b3V0R3JvdXAsIHsgZ3JvdXA6IHBhcnRpY2lwYW50R3JvdXBzW3BhZ2VdLCBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUkgfSkpLCBwYWdlQXJyb3dzVmlzaWJsZSAmJiBwYWdlQ291bnQgPiAxICYmIChqc3goSWNvbkJ1dHRvbiwgeyBkaXNhYmxlZDogcGFnZSA9PT0gcGFnZUNvdW50IC0gMSwgaWNvbjogXCJjYXJldC1yaWdodFwiLCBvbkNsaWNrOiAoKSA9PiBzZXRQYWdlKChjdXJyZW50UGFnZSkgPT4gTWF0aC5taW4ocGFnZUNvdW50IC0gMSwgY3VycmVudFBhZ2UgKyAxKSkgfSkpXSB9KV0gfSkpO1xufTtcblxuY29uc3QgdXNlQ2FsY3VsYXRlSGFyZExpbWl0ID0gKFxuLyoqXG4gKiBFbGVtZW50IHRoYXQgc3RyZXRjaGVzIHRvIDEwMCUgb2YgdGhlIHdob2xlIGxheW91dCBjb21wb25lbnRcbiAqL1xud3JhcHBlckVsZW1lbnQsIFxuLyoqXG4gKiBFbGVtZW50IHRoYXQgZGlyZWN0bHkgaG9zdHMgaW5kaXZpZHVhbCBgUGFydGljaXBhbnRWaWV3YCAob3Igd3JhcHBlcikgZWxlbWVudHNcbiAqL1xuaG9zdEVsZW1lbnQsIGxpbWl0KSA9PiB7XG4gICAgY29uc3QgW2NhbGN1bGF0ZWRMaW1pdCwgc2V0Q2FsY3VsYXRlZExpbWl0XSA9IHVzZVN0YXRlKHtcbiAgICAgICAgdmVydGljYWw6IHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBsaW1pdCA6IG51bGwsXG4gICAgICAgIGhvcml6b250YWw6IHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBsaW1pdCA6IG51bGwsXG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFob3N0RWxlbWVudCB8fFxuICAgICAgICAgICAgIXdyYXBwZXJFbGVtZW50IHx8XG4gICAgICAgICAgICB0eXBlb2YgbGltaXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY2hpbGRXaWR0aCA9IG51bGw7XG4gICAgICAgIGxldCBjaGlsZEhlaWdodCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgLy8gdGhpcyBwYXJ0IHNob3VsZCBpZGVhbGx5IHJ1biBhcyBsaXR0bGUgdGltZXMgYXMgcG9zc2libGVcbiAgICAgICAgICAgIC8vIGdldCBjaGlsZCBtZWFzdXJlbWVudHMgYW5kIGRpc2Nvbm5lY3RcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IGNvbnNpZGVyIGR5bmFtaWNhbGx5IHNpemVkIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB0aGlzIGhvb2sgaXMgZm9yIFNwZWFrZXJMYXlvdXQgdXNlIG9ubHksIHdoZXJlIGNoaWxkcmVuIGluIHRoZSBiYXIgYXJlIGZpeGVkIHNpemVcbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGhvc3RFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSGVpZ2h0ID0gY2hpbGQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFdpZHRoID0gY2hpbGQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCB0aGUgc3RhdGUgYXQgeyB2ZXJ0aWNhbDogMSwgaG9yaXpvbnRhbDogMSB9XG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSBnZXQgdGhlIHByb3BlciBjaGlsZCBtZWFzdXJlbWVudHNcbiAgICAgICAgICAgIGlmIChjaGlsZEhlaWdodCA9PT0gbnVsbCB8fCBjaGlsZFdpZHRoID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsID0gTWF0aC5mbG9vcih3cmFwcGVyRWxlbWVudC5jbGllbnRIZWlnaHQgLyBjaGlsZEhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBob3Jpem9udGFsID0gTWF0aC5mbG9vcih3cmFwcGVyRWxlbWVudC5jbGllbnRXaWR0aCAvIGNoaWxkV2lkdGgpO1xuICAgICAgICAgICAgc2V0Q2FsY3VsYXRlZExpbWl0KChwdikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwdi52ZXJ0aWNhbCAhPT0gdmVydGljYWwgfHwgcHYuaG9yaXpvbnRhbCAhPT0gaG9yaXpvbnRhbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmVydGljYWwsIGhvcml6b250YWwgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUod3JhcHBlckVsZW1lbnQpO1xuICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGhvc3RFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaG9zdEVsZW1lbnQsIGxpbWl0LCB3cmFwcGVyRWxlbWVudF0pO1xuICAgIHJldHVybiBjYWxjdWxhdGVkTGltaXQ7XG59O1xuXG5jb25zdCBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUlCYXIgPSAoKSA9PiAoanN4KERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSwgeyBtZW51UGxhY2VtZW50OiBcInRvcC1lbmRcIiB9KSk7XG5jb25zdCBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUlTcG90bGlnaHQgPSAoKSA9PiBqc3goRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJLCB7fSk7XG5jb25zdCBTcGVha2VyTGF5b3V0ID0gKHsgUGFydGljaXBhbnRWaWV3VUlCYXIgPSBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUlCYXIsIFBhcnRpY2lwYW50Vmlld1VJU3BvdGxpZ2h0ID0gRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJU3BvdGxpZ2h0LCBWaWRlb1BsYWNlaG9sZGVyLCBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9ICdib3R0b20nLCBwYXJ0aWNpcGFudHNCYXJMaW1pdCwgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyB1c2VQYXJ0aWNpcGFudHMsIHVzZVJlbW90ZVBhcnRpY2lwYW50cyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBbcGFydGljaXBhbnRJblNwb3RsaWdodCwgLi4ub3RoZXJQYXJ0aWNpcGFudHNdID0gdXNlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnRzID0gdXNlUmVtb3RlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgW3BhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50LCBzZXRQYXJ0aWNpcGFudHNCYXJXcmFwcGVyRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbcGFydGljaXBhbnRzQmFyRWxlbWVudCwgc2V0UGFydGljaXBhbnRzQmFyRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbYnV0dG9uc1dyYXBwZXJFbGVtZW50LCBzZXRCdXR0b25zV3JhcHBlckVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgaXNTcGVha2VyU2NyZWVuU2hhcmluZyA9IGhhc1NjcmVlblNoYXJlKHBhcnRpY2lwYW50SW5TcG90bGlnaHQpO1xuICAgIGNvbnN0IGhhcmRMaW1pdCA9IHVzZUNhbGN1bGF0ZUhhcmRMaW1pdChidXR0b25zV3JhcHBlckVsZW1lbnQsIHBhcnRpY2lwYW50c0JhckVsZW1lbnQsIHBhcnRpY2lwYW50c0JhckxpbWl0KTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gcGFydGljaXBhbnRzQmFyUG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcGFydGljaXBhbnRzQmFyUG9zaXRpb24gPT09ICdib3R0b20nO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQgfHwgIWNhbGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBjYWxsLnNldFZpZXdwb3J0KHBhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFudXAoKTtcbiAgICB9LCBbcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQsIGNhbGxdKTtcbiAgICBjb25zdCBpc09uZU9uT25lQ2FsbCA9IG90aGVyUGFydGljaXBhbnRzLmxlbmd0aCA9PT0gMTtcbiAgICB1c2VTcGVha2VyTGF5b3V0U29ydFByZXNldChjYWxsLCBpc09uZU9uT25lQ2FsbCk7XG4gICAgbGV0IHBhcnRpY2lwYW50c1dpdGhBcHBsaWVkTGltaXQgPSBvdGhlclBhcnRpY2lwYW50cztcbiAgICBjb25zdCBoYXJkTGltaXRUb0FwcGx5ID0gaXNWZXJ0aWNhbFxuICAgICAgICA/IGhhcmRMaW1pdC52ZXJ0aWNhbFxuICAgICAgICA6IGhhcmRMaW1pdC5ob3Jpem9udGFsO1xuICAgIGlmICh0eXBlb2YgcGFydGljaXBhbnRzQmFyTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIGhhcmRMaW1pdFRvQXBwbHkgIT09IG51bGwpIHtcbiAgICAgICAgcGFydGljaXBhbnRzV2l0aEFwcGxpZWRMaW1pdCA9IG90aGVyUGFydGljaXBhbnRzLnNsaWNlKDAsIFxuICAgICAgICAvLyBzdWJ0cmFjdCAxIGlmIHNwZWFrZXIgaXMgc2hhcmluZyBzY3JlZW4gYXNcbiAgICAgICAgLy8gdGhhdCBvbmUgaXMgcmVuZGVyZWQgaW5kZXBlbmRlbnRseSBmcm9tIG90aGVyUGFydGljaXBhbnRzIGFycmF5XG4gICAgICAgIGhhcmRMaW1pdFRvQXBwbHkgLSAoaXNTcGVha2VyU2NyZWVuU2hhcmluZyA/IDEgOiAwKSk7XG4gICAgfVxuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3dyYXBwZXJcIiwgY2hpbGRyZW46IFtqc3goUGFydGljaXBhbnRzQXVkaW8sIHsgcGFydGljaXBhbnRzOiByZW1vdGVQYXJ0aWNpcGFudHMgfSksIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fc3BlYWtlci1sYXlvdXQnLCBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBgc3RyLXZpZGVvX19zcGVha2VyLWxheW91dC0tdmFyaWFudC0ke3BhcnRpY2lwYW50c0JhclBvc2l0aW9ufWApLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19zcG90bGlnaHRcIiwgY2hpbGRyZW46IHBhcnRpY2lwYW50SW5TcG90bGlnaHQgJiYgKGpzeChQYXJ0aWNpcGFudFZpZXcsIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50SW5TcG90bGlnaHQsIG11dGVBdWRpbzogdHJ1ZSwgdHJhY2tUeXBlOiBpc1NwZWFrZXJTY3JlZW5TaGFyaW5nID8gJ3NjcmVlblNoYXJlVHJhY2snIDogJ3ZpZGVvVHJhY2snLCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUlTcG90bGlnaHQsIFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIgfSkpIH0pLCBwYXJ0aWNpcGFudHNXaXRoQXBwbGllZExpbWl0Lmxlbmd0aCA+IDAgJiYgcGFydGljaXBhbnRzQmFyUG9zaXRpb24gJiYgKGpzeHMoXCJkaXZcIiwgeyByZWY6IHNldEJ1dHRvbnNXcmFwcGVyRWxlbWVudCwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItYnV0dG9ucy13cmFwcGVyXCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItd3JhcHBlclwiLCByZWY6IHNldFBhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50LCBjaGlsZHJlbjoganN4cyhcImRpdlwiLCB7IHJlZjogc2V0UGFydGljaXBhbnRzQmFyRWxlbWVudCwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXJcIiwgY2hpbGRyZW46IFtpc1NwZWFrZXJTY3JlZW5TaGFyaW5nICYmIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnQtdGlsZVwiLCBjaGlsZHJlbjoganN4KFBhcnRpY2lwYW50VmlldywgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnRJblNwb3RsaWdodCwgUGFydGljaXBhbnRWaWV3VUk6IFBhcnRpY2lwYW50Vmlld1VJQmFyLCBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBtdXRlQXVkaW86IHRydWUgfSkgfSwgcGFydGljaXBhbnRJblNwb3RsaWdodC5zZXNzaW9uSWQpKSwgcGFydGljaXBhbnRzV2l0aEFwcGxpZWRMaW1pdC5tYXAoKHBhcnRpY2lwYW50KSA9PiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50LXRpbGVcIiwgY2hpbGRyZW46IGpzeChQYXJ0aWNpcGFudFZpZXcsIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50LCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUlCYXIsIFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIsIG11dGVBdWRpbzogdHJ1ZSB9KSB9LCBwYXJ0aWNpcGFudC5zZXNzaW9uSWQpKSldIH0pIH0pLCBpc1ZlcnRpY2FsICYmIChqc3goVmVydGljYWxTY3JvbGxCdXR0b25zLCB7IHNjcm9sbFdyYXBwZXI6IHBhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50IH0pKSwgaXNIb3Jpem9udGFsICYmIChqc3goSG9yaXpvbnRhbFNjcm9sbEJ1dHRvbnMsIHsgc2Nyb2xsV3JhcHBlcjogcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQgfSkpXSB9KSldIH0pXSB9KSk7XG59O1xuY29uc3QgSG9yaXpvbnRhbFNjcm9sbEJ1dHRvbnMgPSAoeyBzY3JvbGxXcmFwcGVyLCB9KSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB1c2VIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb24oc2Nyb2xsV3JhcHBlcik7XG4gICAgY29uc3Qgc2Nyb2xsU3RhcnRDbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFdyYXBwZXI/LnNjcm9sbEJ5KHsgbGVmdDogLTE1MCwgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2Nyb2xsRW5kQ2xpY2tIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzY3JvbGxXcmFwcGVyPy5zY3JvbGxCeSh7IGxlZnQ6IDE1MCwgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbc2Nyb2xsUG9zaXRpb24gJiYgc2Nyb2xsUG9zaXRpb24gIT09ICdzdGFydCcgJiYgKGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6IHNjcm9sbFN0YXJ0Q2xpY2tIYW5kbGVyLCBpY29uOiBcImNhcmV0LWxlZnRcIiwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItLWJ1dHRvbi1sZWZ0XCIgfSkpLCBzY3JvbGxQb3NpdGlvbiAmJiBzY3JvbGxQb3NpdGlvbiAhPT0gJ2VuZCcgJiYgKGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6IHNjcm9sbEVuZENsaWNrSGFuZGxlciwgaWNvbjogXCJjYXJldC1yaWdodFwiLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnRzLWJhci0tYnV0dG9uLXJpZ2h0XCIgfSkpXSB9KSk7XG59O1xuY29uc3QgVmVydGljYWxTY3JvbGxCdXR0b25zID0gKHsgc2Nyb2xsV3JhcHBlciwgfSkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gdXNlVmVydGljYWxTY3JvbGxQb3NpdGlvbihzY3JvbGxXcmFwcGVyKTtcbiAgICBjb25zdCBzY3JvbGxUb3BDbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFdyYXBwZXI/LnNjcm9sbEJ5KHsgdG9wOiAtMTUwLCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzY3JvbGxCb3R0b21DbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFdyYXBwZXI/LnNjcm9sbEJ5KHsgdG9wOiAxNTAsIGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW3Njcm9sbFBvc2l0aW9uICYmIHNjcm9sbFBvc2l0aW9uICE9PSAndG9wJyAmJiAoanN4KEljb25CdXR0b24sIHsgb25DbGljazogc2Nyb2xsVG9wQ2xpY2tIYW5kbGVyLCBpY29uOiBcImNhcmV0LXVwXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19wYXJ0aWNpcGFudHMtYmFyLS1idXR0b24tdG9wXCIgfSkpLCBzY3JvbGxQb3NpdGlvbiAmJiBzY3JvbGxQb3NpdGlvbiAhPT0gJ2JvdHRvbScgJiYgKGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6IHNjcm9sbEJvdHRvbUNsaWNrSGFuZGxlciwgaWNvbjogXCJjYXJldC1kb3duXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19wYXJ0aWNpcGFudHMtYmFyLS1idXR0b24tYm90dG9tXCIgfSkpXSB9KSk7XG59O1xuY29uc3QgaGFzU2NyZWVuU2hhcmUgPSAocCkgPT4gISFwPy5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpO1xuXG5jb25zdCBbbWFqb3IsIG1pbm9yLCBwYXRjaF0gPSAoXCIwLjYuN1wiICkuc3BsaXQoJy4nKTtcbnNldFNka0luZm8oe1xuICAgIHR5cGU6IFNmdU1vZGVscy5TZGtUeXBlLlJFQUNULFxuICAgIG1ham9yLFxuICAgIG1pbm9yLFxuICAgIHBhdGNoLFxufSk7XG5cbmV4cG9ydCB7IEFjY2VwdENhbGxCdXR0b24sIEF1ZGlvLCBBdmF0YXIsIEF2YXRhckZhbGxiYWNrLCBCYWNrZ3JvdW5kRmlsdGVyc1Byb3ZpZGVyLCBCYXNlVmlkZW8sIENhbGxDb250cm9scywgQ2FsbFBhcnRpY2lwYW50TGlzdGluZywgQ2FsbFBhcnRpY2lwYW50TGlzdGluZ0l0ZW0sIENhbGxQYXJ0aWNpcGFudHNMaXN0LCBDYWxsUHJldmlldywgQ2FsbFJlY29yZGluZ0xpc3QsIENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyLCBDYWxsUmVjb3JkaW5nTGlzdEl0ZW0sIENhbGxTdGF0cywgQ2FsbFN0YXRzQnV0dG9uLCBDYWxsU3RhdHNMYXRlbmN5Q2hhcnQsIENhbmNlbENhbGxCdXR0b24sIENhbmNlbENhbGxDb25maXJtQnV0dG9uLCBDb21wb3NpdGVCdXR0b24sIERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSwgRGVmYXVsdFJlYWN0aW9uc01lbnUsIERlZmF1bHRTY3JlZW5TaGFyZU92ZXJsYXksIERlZmF1bHRWaWRlb1BsYWNlaG9sZGVyLCBEZXZpY2VTZWxlY3RvciwgRGV2aWNlU2VsZWN0b3JBdWRpb0lucHV0LCBEZXZpY2VTZWxlY3RvckF1ZGlvT3V0cHV0LCBEZXZpY2VTZWxlY3RvclZpZGVvLCBEZXZpY2VTZXR0aW5ncywgRHJvcERvd25TZWxlY3QsIERyb3BEb3duU2VsZWN0T3B0aW9uLCBFbXB0eUNhbGxSZWNvcmRpbmdMaXN0aW5nLCBHZW5lcmljTWVudSwgR2VuZXJpY01lbnVCdXR0b25JdGVtLCBJY29uLCBJY29uQnV0dG9uLCBMaXZlc3RyZWFtTGF5b3V0LCBMb2FkaW5nQ2FsbFJlY29yZGluZ0xpc3RpbmcsIExvYWRpbmdJbmRpY2F0b3IsIE1lbnVUb2dnbGUsIE1lbnVWaXN1YWxUeXBlLCBOb3RpZmljYXRpb24sIFBhZ2luYXRlZEdyaWRMYXlvdXQsIFBhcnRpY2lwYW50QWN0aW9uc0NvbnRleHRNZW51LCBQYXJ0aWNpcGFudERldGFpbHMsIFBhcnRpY2lwYW50VmlldywgUGFydGljaXBhbnRWaWV3Q29udGV4dCwgUGFydGljaXBhbnRzQXVkaW8sIFBlcm1pc3Npb25Ob3RpZmljYXRpb24sIFBlcm1pc3Npb25SZXF1ZXN0TGlzdCwgUGVybWlzc2lvblJlcXVlc3RzLCBSZWFjdGlvbnNCdXR0b24sIFJlY29yZENhbGxCdXR0b24sIFJlY29yZENhbGxDb25maXJtYXRpb25CdXR0b24sIFJlY29yZGluZ0luUHJvZ3Jlc3NOb3RpZmljYXRpb24sIFJpbmdpbmdDYWxsLCBSaW5naW5nQ2FsbENvbnRyb2xzLCBTY3JlZW5TaGFyZUJ1dHRvbiwgU2VhcmNoSW5wdXQsIFNlYXJjaFJlc3VsdHMsIFNwZWFrZXJMYXlvdXQsIFNwZWFraW5nV2hpbGVNdXRlZE5vdGlmaWNhdGlvbiwgU3BlZWNoSW5kaWNhdG9yLCBTdGF0Q2FyZCwgU3RhdENhcmRFeHBsYW5hdGlvbiwgU3RhdHNUYWcsIFN0YXR1c2VzLCBTdHJlYW1DYWxsLCBTdHJlYW1UaGVtZSwgU3RyZWFtVmlkZW8sIFRleHRCdXR0b24sIFRvZ2dsZUF1ZGlvT3V0cHV0QnV0dG9uLCBUb2dnbGVBdWRpb1ByZXZpZXdCdXR0b24sIFRvZ2dsZUF1ZGlvUHVibGlzaGluZ0J1dHRvbiwgVG9nZ2xlVmlkZW9QcmV2aWV3QnV0dG9uLCBUb2dnbGVWaWRlb1B1Ymxpc2hpbmdCdXR0b24sIFRvb2x0aXAsIFZpZGVvJDEgYXMgVmlkZW8sIFZpZGVvUHJldmlldywgV2l0aFRvb2x0aXAsIGRlZmF1bHRSZWFjdGlvbnMsIHRyYW5zbGF0aW9ucywgdXNlQmFja2dyb3VuZEZpbHRlcnMsIHVzZUhvcml6b250YWxTY3JvbGxQb3NpdGlvbiwgdXNlTWVudUNvbnRleHQsIHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQsIHVzZVBlcnNpc3RlZERldmljZVByZWZlcmVuY2VzLCB1c2VSZXF1ZXN0UGVybWlzc2lvbiwgdXNlVHJhY2tFbGVtZW50VmlzaWJpbGl0eSwgdXNlVmVydGljYWxTY3JvbGxQb3NpdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-react-sdk/dist/index.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@stream-io/video-react-sdk/dist/css/styles.css":
/*!*********************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-sdk/dist/css/styles.css ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"7965c045aba3\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9jc3Mvc3R5bGVzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYW1zcGFjZS8uL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL3ZpZGVvLXJlYWN0LXNkay9kaXN0L2Nzcy9zdHlsZXMuY3NzPzNlMTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI3OTY1YzA0NWFiYTNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@stream-io/video-react-sdk/dist/css/styles.css\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@stream-io/node-sdk/dist/index.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stream-io/node-sdk/dist/index.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APNConfigRequestAuthTypeEnum: () => (/* binding */ APNConfigRequestAuthTypeEnum),\n/* harmony export */   AppSearchBackendEnum: () => (/* binding */ AppSearchBackendEnum),\n/* harmony export */   AsyncModerationCallbackConfigRequestModeEnum: () => (/* binding */ AsyncModerationCallbackConfigRequestModeEnum),\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   BlockListOptionsBehaviorEnum: () => (/* binding */ BlockListOptionsBehaviorEnum),\n/* harmony export */   BlockListOptionsRequestBehaviorEnum: () => (/* binding */ BlockListOptionsRequestBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodBehaviorEnum: () => (/* binding */ ChannelConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodEnum: () => (/* binding */ ChannelConfigAutomodEnum),\n/* harmony export */   ChannelConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodEnum: () => (/* binding */ ChannelConfigWithInfoAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelMemberRequestRoleEnum: () => (/* binding */ ChannelMemberRequestRoleEnum),\n/* harmony export */   ChannelMemberRoleEnum: () => (/* binding */ ChannelMemberRoleEnum),\n/* harmony export */   ChannelTypeConfigAutomodBehaviorEnum: () => (/* binding */ ChannelTypeConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelTypeConfigAutomodEnum: () => (/* binding */ ChannelTypeConfigAutomodEnum),\n/* harmony export */   ChannelTypeConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelTypeConfigBlocklistBehaviorEnum),\n/* harmony export */   CheckPushRequestPushProviderTypeEnum: () => (/* binding */ CheckPushRequestPushProviderTypeEnum),\n/* harmony export */   CheckSNSResponseStatusEnum: () => (/* binding */ CheckSNSResponseStatusEnum),\n/* harmony export */   CheckSQSResponseStatusEnum: () => (/* binding */ CheckSQSResponseStatusEnum),\n/* harmony export */   ConfigDefaultRoleEnum: () => (/* binding */ ConfigDefaultRoleEnum),\n/* harmony export */   ConfigRequestDefaultRoleEnum: () => (/* binding */ ConfigRequestDefaultRoleEnum),\n/* harmony export */   CreateCallRequestTypeEnum: () => (/* binding */ CreateCallRequestTypeEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodEnum: () => (/* binding */ CreateChannelTypeRequestAutomodEnum),\n/* harmony export */   CreateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodEnum: () => (/* binding */ CreateChannelTypeResponseAutomodEnum),\n/* harmony export */   CreateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   CreateImportRequestModeEnum: () => (/* binding */ CreateImportRequestModeEnum),\n/* harmony export */   DeleteUsersRequestConversationsEnum: () => (/* binding */ DeleteUsersRequestConversationsEnum),\n/* harmony export */   DeleteUsersRequestMessagesEnum: () => (/* binding */ DeleteUsersRequestMessagesEnum),\n/* harmony export */   DeleteUsersRequestUserEnum: () => (/* binding */ DeleteUsersRequestUserEnum),\n/* harmony export */   DeviceFieldsPushProviderEnum: () => (/* binding */ DeviceFieldsPushProviderEnum),\n/* harmony export */   DevicePushProviderEnum: () => (/* binding */ DevicePushProviderEnum),\n/* harmony export */   DeviceRequestPushProviderEnum: () => (/* binding */ DeviceRequestPushProviderEnum),\n/* harmony export */   ImageSizeCropEnum: () => (/* binding */ ImageSizeCropEnum),\n/* harmony export */   ImageSizeResizeEnum: () => (/* binding */ ImageSizeResizeEnum),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* binding */ LayoutSettingsNameEnum),\n/* harmony export */   MessageRequest1TypeEnum: () => (/* binding */ MessageRequest1TypeEnum),\n/* harmony export */   MessageRequestTypeEnum: () => (/* binding */ MessageRequestTypeEnum),\n/* harmony export */   MessageTypeEnum: () => (/* binding */ MessageTypeEnum),\n/* harmony export */   PermissionLevelEnum: () => (/* binding */ PermissionLevelEnum),\n/* harmony export */   PolicyRequest1ActionEnum: () => (/* binding */ PolicyRequest1ActionEnum),\n/* harmony export */   PolicyRequestActionEnum: () => (/* binding */ PolicyRequestActionEnum),\n/* harmony export */   PushConfigRequestVersionEnum: () => (/* binding */ PushConfigRequestVersionEnum),\n/* harmony export */   StreamCall: () => (/* binding */ StreamCall),\n/* harmony export */   StreamChannel: () => (/* binding */ StreamChannel),\n/* harmony export */   StreamChatClient: () => (/* binding */ StreamChatClient),\n/* harmony export */   StreamClient: () => (/* binding */ StreamClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranslateMessageRequestLanguageEnum: () => (/* binding */ TranslateMessageRequestLanguageEnum),\n/* harmony export */   UpdateAppRequestEnforceUniqueUsernamesEnum: () => (/* binding */ UpdateAppRequestEnforceUniqueUsernamesEnum),\n/* harmony export */   UpdateAppRequestPermissionVersionEnum: () => (/* binding */ UpdateAppRequestPermissionVersionEnum),\n/* harmony export */   UpdateAppRequestVideoProviderEnum: () => (/* binding */ UpdateAppRequestVideoProviderEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodEnum),\n/* harmony export */   UpdateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodEnum),\n/* harmony export */   UpdateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   VideoAudioSettingsDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsDefaultDeviceEnum),\n/* harmony export */   VideoAudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   VideoCreateDeviceRequestPushProviderEnum: () => (/* binding */ VideoCreateDeviceRequestPushProviderEnum),\n/* harmony export */   VideoLayoutSettingsNameEnum: () => (/* binding */ VideoLayoutSettingsNameEnum),\n/* harmony export */   VideoLayoutSettingsRequestNameEnum: () => (/* binding */ VideoLayoutSettingsRequestNameEnum),\n/* harmony export */   VideoOwnCapability: () => (/* binding */ VideoOwnCapability),\n/* harmony export */   VideoRecordSettingsRequestModeEnum: () => (/* binding */ VideoRecordSettingsRequestModeEnum),\n/* harmony export */   VideoRecordSettingsRequestQualityEnum: () => (/* binding */ VideoRecordSettingsRequestQualityEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoTranscriptionSettingsModeEnum: () => (/* binding */ VideoTranscriptionSettingsModeEnum),\n/* harmony export */   VideoTranscriptionSettingsRequestModeEnum: () => (/* binding */ VideoTranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoVideoSettingsCameraFacingEnum: () => (/* binding */ VideoVideoSettingsCameraFacingEnum),\n/* harmony export */   VideoVideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoVideoSettingsRequestCameraFacingEnum)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonwebtoken */ \"(action-browser)/./node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n/**\n * @export\n */\nconst APNConfigRequestAuthTypeEnum = {\n    CERTIFICATE: 'certificate',\n    TOKEN: 'token'\n};\n/**\n * @export\n */\nconst AppSearchBackendEnum = {\n    ELASTICSEARCH: 'elasticsearch',\n    POSTGRES: 'postgres',\n    DISABLED: 'disabled'\n};\n/**\n * @export\n */\nconst AsyncModerationCallbackConfigRequestModeEnum = {\n    NONE: 'CALLBACK_MODE_NONE',\n    REST: 'CALLBACK_MODE_REST',\n    TWIRP: 'CALLBACK_MODE_TWIRP'\n};\n/**\n * @export\n */\nconst AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst BlockListOptionsBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst BlockListOptionsRequestBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelMemberRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelMemberRequestRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CheckPushRequestPushProviderTypeEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CheckSNSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst CheckSQSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst ConfigDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst ConfigRequestDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst CreateCallRequestTypeEnum = {\n    AUDIO: 'audio',\n    VIDEO: 'video'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CreateImportRequestModeEnum = {\n    INSERT: 'insert',\n    UPSERT: 'upsert'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestConversationsEnum = {\n    SOFT: 'soft',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestMessagesEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestUserEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DevicePushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceFieldsPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst ImageSizeCropEnum = {\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    RIGHT: 'right',\n    CENTER: 'center'\n};\n/**\n * @export\n */\nconst ImageSizeResizeEnum = {\n    CLIP: 'clip',\n    CROP: 'crop',\n    SCALE: 'scale',\n    FILL: 'fill'\n};\n/**\n * @export\n */\nconst LayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst MessageTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequestTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequest1TypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst PermissionLevelEnum = {\n    APP: 'app',\n    CHANNEL: 'channel'\n};\n/**\n * @export\n */\nconst PolicyRequestActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PolicyRequest1ActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PushConfigRequestVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst TranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst TranslateMessageRequestLanguageEnum = {\n    AF: 'af',\n    SQ: 'sq',\n    AM: 'am',\n    AR: 'ar',\n    AZ: 'az',\n    BN: 'bn',\n    BS: 'bs',\n    BG: 'bg',\n    ZH: 'zh',\n    ZH_TW: 'zh-TW',\n    HR: 'hr',\n    CS: 'cs',\n    DA: 'da',\n    FA_AF: 'fa-AF',\n    NL: 'nl',\n    EN: 'en',\n    ET: 'et',\n    FI: 'fi',\n    FR: 'fr',\n    FR_CA: 'fr-CA',\n    KA: 'ka',\n    DE: 'de',\n    EL: 'el',\n    HA: 'ha',\n    HE: 'he',\n    HI: 'hi',\n    HU: 'hu',\n    ID: 'id',\n    IT: 'it',\n    JA: 'ja',\n    KO: 'ko',\n    LV: 'lv',\n    MS: 'ms',\n    NO: 'no',\n    FA: 'fa',\n    PS: 'ps',\n    PL: 'pl',\n    PT: 'pt',\n    RO: 'ro',\n    RU: 'ru',\n    SR: 'sr',\n    SK: 'sk',\n    SL: 'sl',\n    SO: 'so',\n    ES: 'es',\n    ES_MX: 'es-MX',\n    SW: 'sw',\n    SV: 'sv',\n    TL: 'tl',\n    TA: 'ta',\n    TH: 'th',\n    TR: 'tr',\n    UK: 'uk',\n    UR: 'ur',\n    VI: 'vi'\n};\n/**\n * @export\n */\nconst UpdateAppRequestEnforceUniqueUsernamesEnum = {\n    NO: 'no',\n    APP: 'app',\n    TEAM: 'team'\n};\n/**\n * @export\n */\nconst UpdateAppRequestPermissionVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst UpdateAppRequestVideoProviderEnum = {\n    AGORA: 'agora',\n    HMS: 'hms'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst VideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/**\n * @export\n */\nconst VideoAudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoAudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoCreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsRequestNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * All possibility of string to use\n * @export\n */\nconst VideoOwnCapability = {\n    BLOCK_USERS: 'block-users',\n    CREATE_CALL: 'create-call',\n    CREATE_REACTION: 'create-reaction',\n    END_CALL: 'end-call',\n    JOIN_BACKSTAGE: 'join-backstage',\n    JOIN_CALL: 'join-call',\n    JOIN_ENDED_CALL: 'join-ended-call',\n    MUTE_USERS: 'mute-users',\n    PIN_FOR_EVERYONE: 'pin-for-everyone',\n    READ_CALL: 'read-call',\n    REMOVE_CALL_MEMBER: 'remove-call-member',\n    SCREENSHARE: 'screenshare',\n    SEND_AUDIO: 'send-audio',\n    SEND_VIDEO: 'send-video',\n    START_BROADCAST_CALL: 'start-broadcast-call',\n    START_RECORD_CALL: 'start-record-call',\n    START_TRANSCRIPTION_CALL: 'start-transcription-call',\n    STOP_BROADCAST_CALL: 'stop-broadcast-call',\n    STOP_RECORD_CALL: 'stop-record-call',\n    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',\n    UPDATE_CALL: 'update-call',\n    UPDATE_CALL_MEMBER: 'update-call-member',\n    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',\n    UPDATE_CALL_SETTINGS: 'update-call-settings'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestQualityEnum = {\n    _360P: '360p',\n    _480P: '480p',\n    _720P: '720p',\n    _1080P: '1080p',\n    _1440P: '1440p'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsRequestCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH$1 = \"https://chat.stream-io-api.com\".replace(/\\/+$/, \"\");\nlet Configuration$1 = class Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring$1;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n};\nconst DefaultConfig$1 = new Configuration$1();\n/**\n * This is the base class for all generated API classes.\n */\nlet BaseAPI$1 = class BaseAPI {\n    constructor(configuration = DefaultConfig$1) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError$1(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError$1(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData$1(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob$1(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n};\nBaseAPI$1.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob$1(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData$1(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nlet ResponseError$1 = class ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n};\nlet FetchError$1 = class FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n};\nlet RequiredError$1 = class RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n};\nconst COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\nfunction querystring$1(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey$1(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey$1(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey$1(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring$1(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nfunction canConsumeForm(consumes) {\n    for (const consume of consumes) {\n        if ('multipart/form-data' === consume.contentType) {\n            return true;\n        }\n    }\n    return false;\n}\nlet JSONApiResponse$1 = class JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n};\nlet VoidApiResponse$1 = class VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelTypesApi extends BaseAPI$1 {\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelsApi extends BaseAPI$1 {\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteChannel.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {\n                throw new RequiredError$1('deleteChannelsRequest', 'Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {\n                throw new RequiredError$1('exportChannelsRequest', 'Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatusRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatus(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getExportChannelsStatusRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {\n                throw new RequiredError$1('channelGetOrCreateRequest', 'Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/query`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.channelGetOrCreateRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {\n                throw new RequiredError$1('hideChannelRequest', 'Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/hide`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.hideChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.hideChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {\n                throw new RequiredError$1('muteChannelRequest', 'Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {\n                throw new RequiredError$1('queryChannelsRequest', 'Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.queryChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/members`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {\n                throw new RequiredError$1('showChannelRequest', 'Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/show`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.showChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.showChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {\n                throw new RequiredError$1('truncateChannelRequest', 'Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/truncate`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.truncateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.truncateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {\n                throw new RequiredError$1('unmuteChannelRequest', 'Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCountsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/unread`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCounts(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unreadCountsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {\n                throw new RequiredError$1('updateChannelRequest', 'Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {\n                throw new RequiredError$1('updateChannelPartialRequest', 'Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass CustomCommandsApi extends BaseAPI$1 {\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createCommandRequest === null || requestParameters.createCommandRequest === undefined) {\n                throw new RequiredError$1('createCommandRequest', 'Required parameter requestParameters.createCommandRequest was null or undefined when calling createCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommandsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommands(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCommandsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateCommand.');\n            }\n            if (requestParameters.updateCommandRequest === null || requestParameters.updateCommandRequest === undefined) {\n                throw new RequiredError$1('updateCommandRequest', 'Required parameter requestParameters.updateCommandRequest was null or undefined when calling updateCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DevicesApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass EventsApi extends BaseAPI$1 {\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {\n                throw new RequiredError$1('sendEventRequest', 'Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling sendUserCustomEvent.');\n            }\n            if (requestParameters.sendUserCustomEventRequest === null || requestParameters.sendUserCustomEventRequest === undefined) {\n                throw new RequiredError$1('sendUserCustomEventRequest', 'Required parameter requestParameters.sendUserCustomEventRequest was null or undefined when calling sendUserCustomEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/event`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendUserCustomEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendUserCustomEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass MessagesApi extends BaseAPI$1 {\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteFile.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteImage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteMessage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hard !== undefined) {\n                queryParameters['hard'] = requestParameters.hard;\n            }\n            if (requestParameters.deletedBy !== undefined) {\n                queryParameters['deleted_by'] = requestParameters.deletedBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteReaction.');\n            }\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteReaction.');\n            }\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction/{type}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessagesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getManyMessages.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getManyMessages.');\n            }\n            const queryParameters = {};\n            if (requestParameters.ids) {\n                queryParameters['ids'] = requestParameters.ids.join(',');\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/messages`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessages(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getManyMessagesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOGRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/og`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOG(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOGRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getReactions.');\n            }\n            const queryParameters = {};\n            if (requestParameters.limit !== undefined) {\n                queryParameters['limit'] = requestParameters.limit;\n            }\n            if (requestParameters.offset !== undefined) {\n                queryParameters['offset'] = requestParameters.offset;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reactions`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getReactionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getRepliesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.parentId === null || requestParameters.parentId === undefined) {\n                throw new RequiredError$1('parentId', 'Required parameter requestParameters.parentId was null or undefined when calling getReplies.');\n            }\n            const queryParameters = {};\n            if (requestParameters.idGte !== undefined) {\n                queryParameters['id_gte'] = requestParameters.idGte;\n            }\n            if (requestParameters.idGt !== undefined) {\n                queryParameters['id_gt'] = requestParameters.idGt;\n            }\n            if (requestParameters.idLte !== undefined) {\n                queryParameters['id_lte'] = requestParameters.idLte;\n            }\n            if (requestParameters.idLt !== undefined) {\n                queryParameters['id_lt'] = requestParameters.idLt;\n            }\n            if (requestParameters.createdAtAfterOrEqual !== undefined) {\n                queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;\n            }\n            if (requestParameters.createdAtAfter !== undefined) {\n                queryParameters['created_at_after'] = requestParameters.createdAtAfter;\n            }\n            if (requestParameters.createdAtBeforeOrEqual !== undefined) {\n                queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;\n            }\n            if (requestParameters.createdAtBefore !== undefined) {\n                queryParameters['created_at_before'] = requestParameters.createdAtBefore;\n            }\n            if (requestParameters.idAround !== undefined) {\n                queryParameters['id_around'] = requestParameters.idAround;\n            }\n            if (requestParameters.createdAtAround !== undefined) {\n                queryParameters['created_at_around'] = requestParameters.createdAtAround;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{parent_id}/replies`.replace(`{${\"parent_id\"}}`, encodeURIComponent(String(requestParameters.parentId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getReplies(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRepliesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlagsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flags/message`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlags(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMessageFlagsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageActionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling runMessageAction.');\n            }\n            if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {\n                throw new RequiredError$1('messageActionRequest', 'Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/action`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.messageActionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageAction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.runMessageActionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {\n                throw new RequiredError$1('sendMessageRequest', 'Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/message`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendReaction.');\n            }\n            if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {\n                throw new RequiredError$1('sendReactionRequest', 'Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendReactionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling translateMessage.');\n            }\n            if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {\n                throw new RequiredError$1('translateMessageRequest', 'Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/translate`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.translateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.translateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessage.');\n            }\n            if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {\n                throw new RequiredError$1('updateMessageRequest', 'Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');\n            }\n            if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {\n                throw new RequiredError$1('updateMessagePartialRequest', 'Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessagePartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessagePartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadFile.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadImage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.uploadSizes) {\n                formParams.append('upload_sizes', requestParameters.uploadSizes.join(COLLECTION_FORMATS[\"csv\"]));\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PermissionsV2Api extends BaseAPI$1 {\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {\n                throw new RequiredError$1('createRoleRequest', 'Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createRoleRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermissionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getPermission.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermission(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getPermissionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissionsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissions(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPermissionsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRolesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRoles(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRolesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PushApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet ServerSideApi$1 = class ServerSideApi extends BaseAPI$1 {\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {\n                throw new RequiredError$1('upsertPushProviderRequest', 'Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.upsertPushProviderRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.upsertPushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet SettingsApi$1 = class SettingsApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {\n                throw new RequiredError$1('createBlockListRequest', 'Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getAppRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getApp(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getAppRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimitsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.serverSide !== undefined) {\n                queryParameters['server_side'] = requestParameters.serverSide;\n            }\n            if (requestParameters.android !== undefined) {\n                queryParameters['android'] = requestParameters.android;\n            }\n            if (requestParameters.ios !== undefined) {\n                queryParameters['ios'] = requestParameters.ios;\n            }\n            if (requestParameters.web !== undefined) {\n                queryParameters['web'] = requestParameters.web;\n            }\n            if (requestParameters.endpoints !== undefined) {\n                queryParameters['endpoints'] = requestParameters.endpoints;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/rate_limits`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimits(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRateLimitsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockListsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockLists(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listBlockListsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateAppRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {\n                throw new RequiredError$1('updateAppRequest', 'Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateAppRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateApp(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateAppRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateBlockList.');\n            }\n            if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {\n                throw new RequiredError$1('updateBlockListRequest', 'Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TasksApi extends BaseAPI$1 {\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTaskRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getTask.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/tasks/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTask(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getTaskRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TestingApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass UsersApi extends BaseAPI$1 {\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    banRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {\n                throw new RequiredError$1('banRequest', 'Required parameter requestParameters.banRequest was null or undefined when calling ban.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.banRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    ban(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.banRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connect(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.connectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.guestRequest === null || requestParameters.guestRequest === undefined) {\n                throw new RequiredError$1('guestRequest', 'Required parameter requestParameters.guestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.guestRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');\n            }\n            if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {\n                throw new RequiredError$1('deactivateUserRequest', 'Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/deactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {\n                throw new RequiredError$1('deactivateUsersRequest', 'Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/deactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deleteUser.');\n            }\n            const queryParameters = {};\n            if (requestParameters.markMessagesDeleted !== undefined) {\n                queryParameters['mark_messages_deleted'] = requestParameters.markMessagesDeleted;\n            }\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            if (requestParameters.deleteConversationChannels !== undefined) {\n                queryParameters['delete_conversation_channels'] = requestParameters.deleteConversationChannels;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {\n                throw new RequiredError$1('deleteUsersRequest', 'Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling exportUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/export`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {\n                throw new RequiredError$1('exportUsersRequest', 'Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPollRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/longpoll`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPoll(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.longPollRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {\n                throw new RequiredError$1('muteUserRequest', 'Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/query_banned_users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryBannedUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');\n            }\n            if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {\n                throw new RequiredError$1('reactivateUserRequest', 'Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/reactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {\n                throw new RequiredError$1('reactivateUsersRequest', 'Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/reactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {\n                throw new RequiredError$1('restoreUsersRequest', 'Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/restore`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.restoreUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.restoreUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unbanRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.targetUserId !== undefined) {\n                queryParameters['target_user_id'] = requestParameters.targetUserId;\n            }\n            if (requestParameters.type !== undefined) {\n                queryParameters['type'] = requestParameters.type;\n            }\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.createdBy !== undefined) {\n                queryParameters['created_by'] = requestParameters.createdBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unban(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unbanRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {\n                throw new RequiredError$1('unmuteUserRequest', 'Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {\n                throw new RequiredError$1('updateUsersRequest', 'Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUserPartialRequest === null || requestParameters.updateUserPartialRequest === undefined) {\n                throw new RequiredError$1('updateUserPartialRequest', 'Required parameter requestParameters.updateUserPartialRequest was null or undefined when calling updateUsersPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUserPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamChannel {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.delete = (request) => {\n            return this.channelsApi.deleteChannel(Object.assign(Object.assign({}, this.baseRequest), (request !== null && request !== void 0 ? request : {})));\n        };\n        this.update = (updateChannelRequest) => {\n            return this.channelsApi.updateChannel(Object.assign(Object.assign({}, this.baseRequest), { updateChannelRequest }));\n        };\n        this.updatePartial = (updateChannelPartialRequest) => {\n            return this.channelsApi.updateChannelPartial(Object.assign(Object.assign({}, this.baseRequest), { updateChannelPartialRequest }));\n        };\n        this.getOrCreate = (channelGetOrCreateRequest) => __awaiter(this, void 0, void 0, function* () {\n            if (this.id) {\n                return yield this.channelsApi.getOrCreateChannel(Object.assign(Object.assign({}, this.baseRequest), { channelGetOrCreateRequest: channelGetOrCreateRequest !== null && channelGetOrCreateRequest !== void 0 ? channelGetOrCreateRequest : {} }));\n            }\n            else {\n                throw new Error(`This operation isn't yet implemented`);\n                // if (!channelGetOrCreateRequest?.data?.members) {\n                //   throw new Error('You need to provide members to create a channel without ID');\n                // }\n                // const response = await this.channelsApi.getOrCreateChannelType1({type: this.type, channelGetOrCreateRequest});\n                // this.id = response.channel?.id;\n                // return response;\n            }\n        });\n        this.markRead = (markReadRequest) => {\n            return this.channelsApi.markRead(Object.assign(Object.assign({}, this.baseRequest), { markReadRequest }));\n        };\n        this.markUnread = (markUnreadRequest) => {\n            return this.channelsApi.markUnread(Object.assign(Object.assign({}, this.baseRequest), { markUnreadRequest }));\n        };\n        this.show = (showChannelRequest) => {\n            return this.channelsApi.showChannel(Object.assign(Object.assign({}, this.baseRequest), { showChannelRequest }));\n        };\n        this.hide = (hideChannelRequest) => {\n            return this.channelsApi.hideChannel(Object.assign(Object.assign({}, this.baseRequest), { hideChannelRequest }));\n        };\n        this.truncate = (truncateChannelRequest) => {\n            return this.channelsApi.truncateChannel(Object.assign(Object.assign({}, this.baseRequest), { truncateChannelRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.channelsApi.queryMembers({\n                payload: Object.assign(Object.assign({}, this.baseRequest), request),\n            });\n        };\n        this.mute = (muteChannelRequest) => {\n            return this.channelsApi.muteChannel({\n                muteChannelRequest: Object.assign(Object.assign({}, muteChannelRequest), { channel_cids: [this.cid] }),\n            });\n        };\n        this.unmute = (unmuteChannelRequest) => {\n            return this.channelsApi.unmuteChannel({\n                unmuteChannelRequest: Object.assign(Object.assign({}, unmuteChannelRequest), { channel_cid: this.cid, channel_cids: [] }),\n            });\n        };\n        // TODO: there is probably an issue with the generated code here\n        // uploadFile = (options: Omit<OmitTypeId<UploadFileRequest>, 'file'>, file: Buffer) => {\n        //   return this.messagesApi.uploadFile({...options, ...this.baseRequest, file: file as any as string});\n        // }\n        // deleteFile = (request: OmitTypeId<DeleteFileRequest>) => {\n        //   return this.messagesApi.deleteFile({...request, ...this.baseRequest});\n        // }\n        // uploadImage = (request: OmitTypeId<UploadImageRequest>) => {\n        //   return this.messagesApi.uploadImage({...request, ...this.baseRequest});\n        // }\n        // deleteImage = (request: OmitTypeId<DeleteImageRequest>) => {\n        //   return this.messagesApi.deleteImage({...request, ...this.baseRequest});\n        // }\n        this.sendMessage = (sendMessageRequest) => {\n            return this.messagesApi.sendMessage(Object.assign(Object.assign({}, this.baseRequest), { sendMessageRequest }));\n        };\n        this.deleteMessage = (request) => {\n            return this.messagesApi.deleteMessage(request);\n        };\n        this.updateMessage = (id, updateMessageRequest) => {\n            return this.messagesApi.updateMessage({ id, updateMessageRequest });\n        };\n        this.updateMessagePartial = (id, updateMessagePartialRequest) => {\n            return this.messagesApi.updateMessagePartial({\n                id,\n                updateMessagePartialRequest,\n            });\n        };\n        this.getMessage = (request) => {\n            return this.messagesApi.getMessage(request);\n        };\n        this.getManyMessages = (request) => {\n            return this.messagesApi.getManyMessages(Object.assign(Object.assign({}, request), this.baseRequest));\n        };\n        this.translateMessage = (id, translateMessageRequest) => {\n            return this.messagesApi.translateMessage({ id, translateMessageRequest });\n        };\n        this.getMessagesAround = (request) => {\n            return this.messagesApi.getReplies(request);\n        };\n        this.getOpenGraphData = (request) => {\n            return this.messagesApi.getOG(request);\n        };\n        this.sendMessageReaction = (messageId, sendReactionRequest) => {\n            return this.messagesApi.sendReaction({\n                id: messageId,\n                sendReactionRequest,\n            });\n        };\n        this.deleteMessageReaction = (messageId, request) => {\n            return this.messagesApi.deleteReaction(Object.assign(Object.assign({}, request), { id: messageId }));\n        };\n        this.getMessageReactions = (messageId, request) => {\n            return this.messagesApi.getReactions(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), { id: messageId }));\n        };\n        this.sendCustomEvent = (event) => {\n            return this.eventsApi.sendEvent(Object.assign(Object.assign({}, this.baseRequest), { sendEventRequest: { event } }));\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.messagesApi = new MessagesApi(configuration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(configuration);\n    }\n    get cid() {\n        return `${this.baseRequest.type}:${this.baseRequest.id}`;\n    }\n    get baseRequest() {\n        if (!this.id) {\n            throw new Error('You need to initialize the channel with `getOrCreate`');\n        }\n        return {\n            id: this.id,\n            type: this.type,\n        };\n    }\n}\n\nclass StreamChatClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.channel = (type, id) => {\n            return new StreamChannel(this.streamClient, type, id);\n        };\n        this.createBlockList = (createBlockListRequest) => {\n            return this.settingsApi.createBlockList({ createBlockListRequest });\n        };\n        this.listBlockLists = () => {\n            return this.settingsApi.listBlockLists();\n        };\n        this.getBlockList = (request) => {\n            return this.settingsApi.getBlockList(request);\n        };\n        this.updateBlockList = (name, updateBlockListRequest) => {\n            return this.settingsApi.updateBlockList({ name, updateBlockListRequest });\n        };\n        this.deleteBlockList = (request) => {\n            return this.settingsApi.deleteBlockList(request);\n        };\n        this.createChannelType = (createChannelTypeRequest) => {\n            return this.channelTypesApi.createChannelType({ createChannelTypeRequest });\n        };\n        this.deleteChannelType = (request) => {\n            return this.channelTypesApi.deleteChannelType(request);\n        };\n        this.getChannelType = (request) => {\n            return this.channelTypesApi.getChannelType(request);\n        };\n        this.listChannelTypes = () => {\n            return this.channelTypesApi.listChannelTypes();\n        };\n        this.updateChannelType = (name, updateChannelTypeRequest) => {\n            return this.channelTypesApi.updateChannelType({\n                name,\n                updateChannelTypeRequest,\n            });\n        };\n        this.queryChannels = (queryChannelsRequest) => {\n            return this.channelsApi.queryChannels({\n                queryChannelsRequest: queryChannelsRequest !== null && queryChannelsRequest !== void 0 ? queryChannelsRequest : null,\n            });\n        };\n        this.searchMessages = (payload) => {\n            return this.channelsApi.search({ payload });\n        };\n        this.exportChannels = (exportChannelsRequest) => {\n            return this.channelsApi.exportChannels({\n                exportChannelsRequest: exportChannelsRequest !== null && exportChannelsRequest !== void 0 ? exportChannelsRequest : null,\n            });\n        };\n        this.getExportStatus = (request) => {\n            return this.channelsApi.getExportChannelsStatus(request);\n        };\n        this.listCommands = () => {\n            return this.commandsApi.listCommands();\n        };\n        this.createCommand = (createCommandRequest) => {\n            return this.commandsApi.createCommand({ createCommandRequest });\n        };\n        this.getCommand = (getCommandRequest) => {\n            return this.commandsApi.getCommand(getCommandRequest);\n        };\n        this.updateCommand = (name, updateCommandRequest) => {\n            return this.commandsApi.updateCommand({ name, updateCommandRequest });\n        };\n        this.deleteCommand = (request) => {\n            return this.commandsApi.deleteCommand(request);\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(configuration);\n        /** @ts-expect-error */\n        this.channelTypesApi = new ChannelTypesApi(configuration);\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.commandsApi = new CustomCommandsApi(configuration);\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH = \"https://stream-io-api.com\".replace(/\\/+$/, \"\");\nclass Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n}\nconst DefaultConfig = new Configuration();\n/**\n * This is the base class for all generated API classes.\n */\nclass BaseAPI {\n    constructor(configuration = DefaultConfig) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n}\nBaseAPI.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nclass ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n}\nclass FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n}\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nfunction querystring(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nclass JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n}\nclass VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DefaultApi extends BaseAPI {\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.videoBlockUserRequest === null || requestParameters.videoBlockUserRequest === undefined) {\n                throw new RequiredError('videoBlockUserRequest', 'Required parameter requestParameters.videoBlockUserRequest was null or undefined when calling blockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/block`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoBlockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.blockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateDeviceRequest === null || requestParameters.videoCreateDeviceRequest === undefined) {\n                throw new RequiredError('videoCreateDeviceRequest', 'Required parameter requestParameters.videoCreateDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateDeviceRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateGuestRequest === null || requestParameters.videoCreateGuestRequest === undefined) {\n                throw new RequiredError('videoCreateGuestRequest', 'Required parameter requestParameters.videoCreateGuestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateGuestRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling endCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling endCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mark_ended`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.endCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            if (requestParameters.membersLimit !== undefined) {\n                queryParameters['members_limit'] = requestParameters.membersLimit;\n            }\n            if (requestParameters.ring !== undefined) {\n                queryParameters['ring'] = requestParameters.ring;\n            }\n            if (requestParameters.notify !== undefined) {\n                queryParameters['notify'] = requestParameters.notify;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdgesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/edges`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdges(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getEdgesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.videoGetOrCreateCallRequest === null || requestParameters.videoGetOrCreateCallRequest === undefined) {\n                throw new RequiredError('videoGetOrCreateCallRequest', 'Required parameter requestParameters.videoGetOrCreateCallRequest was null or undefined when calling getOrCreateCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGetOrCreateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling goLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling goLive.');\n            }\n            if (requestParameters.videoGoLiveRequest === null || requestParameters.videoGoLiveRequest === undefined) {\n                throw new RequiredError('videoGoLiveRequest', 'Required parameter requestParameters.videoGoLiveRequest was null or undefined when calling goLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/go_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGoLiveRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.goLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordingsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listRecordings.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listRecordings.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/recordings`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordings(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRecordingsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listTranscriptions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listTranscriptions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/transcriptions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listTranscriptionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.videoMuteUsersRequest === null || requestParameters.videoMuteUsersRequest === undefined) {\n                throw new RequiredError('videoMuteUsersRequest', 'Required parameter requestParameters.videoMuteUsersRequest was null or undefined when calling muteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mute_users`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoMuteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCallsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryCallsRequest === null || requestParameters.videoQueryCallsRequest === undefined) {\n                throw new RequiredError('videoQueryCallsRequest', 'Required parameter requestParameters.videoQueryCallsRequest was null or undefined when calling queryCalls.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calls`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryCallsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCalls(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryCallsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryMembersRequest === null || requestParameters.videoQueryMembersRequest === undefined) {\n                throw new RequiredError('videoQueryMembersRequest', 'Required parameter requestParameters.videoQueryMembersRequest was null or undefined when calling queryMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/members`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.videoSendEventRequest === null || requestParameters.videoSendEventRequest === undefined) {\n                throw new RequiredError('videoSendEventRequest', 'Required parameter requestParameters.videoSendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoSendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.videoStartRecordingRequest === null || requestParameters.videoStartRecordingRequest === undefined) {\n                throw new RequiredError('videoStartRecordingRequest', 'Required parameter requestParameters.videoStartRecordingRequest was null or undefined when calling startRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartRecordingRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.videoStartTranscriptionRequest === null || requestParameters.videoStartTranscriptionRequest === undefined) {\n                throw new RequiredError('videoStartTranscriptionRequest', 'Required parameter requestParameters.videoStartTranscriptionRequest was null or undefined when calling startTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartTranscriptionRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.videoUnblockUserRequest === null || requestParameters.videoUnblockUserRequest === undefined) {\n                throw new RequiredError('videoUnblockUserRequest', 'Required parameter requestParameters.videoUnblockUserRequest was null or undefined when calling unblockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unblock`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnblockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unblockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.videoUpdateCallRequest === null || requestParameters.videoUpdateCallRequest === undefined) {\n                throw new RequiredError('videoUpdateCallRequest', 'Required parameter requestParameters.videoUpdateCallRequest was null or undefined when calling updateCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.videoUpdateCallMembersRequest === null || requestParameters.videoUpdateCallMembersRequest === undefined) {\n                throw new RequiredError('videoUpdateCallMembersRequest', 'Required parameter requestParameters.videoUpdateCallMembersRequest was null or undefined when calling updateCallMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/members`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.videoUpdateUserPermissionsRequest === null || requestParameters.videoUpdateUserPermissionsRequest === undefined) {\n                throw new RequiredError('videoUpdateUserPermissionsRequest', 'Required parameter requestParameters.videoUpdateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/user_permissions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateUserPermissionsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUserPermissionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoWSAuthMessageRequest === null || requestParameters.videoWSAuthMessageRequest === undefined) {\n                throw new RequiredError('videoWSAuthMessageRequest', 'Required parameter requestParameters.videoWSAuthMessageRequest was null or undefined when calling videoConnect.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoWSAuthMessageRequest,\n            }, initOverrides);\n            return new VoidApiResponse(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnect(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.videoConnectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.videoPinRequest === null || requestParameters.videoPinRequest === undefined) {\n                throw new RequiredError('videoPinRequest', 'Required parameter requestParameters.videoPinRequest was null or undefined when calling videoPin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/pin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoPinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoPinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.videoUnpinRequest === null || requestParameters.videoUnpinRequest === undefined) {\n                throw new RequiredError('videoUnpinRequest', 'Required parameter requestParameters.videoUnpinRequest was null or undefined when calling videoUnpin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unpin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnpinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoUnpinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ServerSideApi extends BaseAPI {\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}/check`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateCallTypeRequest === null || requestParameters.videoCreateCallTypeRequest === undefined) {\n                throw new RequiredError('videoCreateCallTypeRequest', 'Required parameter requestParameters.videoCreateCallTypeRequest was null or undefined when calling createCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCallTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateCallType.');\n            }\n            if (requestParameters.videoUpdateCallTypeRequest === null || requestParameters.videoUpdateCallTypeRequest === undefined) {\n                throw new RequiredError('videoUpdateCallTypeRequest', 'Required parameter requestParameters.videoUpdateCallTypeRequest was null or undefined when calling updateCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');\n            }\n            if (requestParameters.videoUpdateExternalStorageRequest === null || requestParameters.videoUpdateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoUpdateExternalStorageRequest', 'Required parameter requestParameters.videoUpdateExternalStorageRequest was null or undefined when calling updateExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass SettingsApi extends BaseAPI {\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateExternalStorageRequest === null || requestParameters.videoCreateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoCreateExternalStorageRequest', 'Required parameter requestParameters.videoCreateExternalStorageRequest was null or undefined when calling createExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorageRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorage(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listExternalStorageRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamCall {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.blockUser = (videoBlockUserRequest) => {\n            return this.apiClient.blockUser(Object.assign(Object.assign({}, this.baseRequest), { videoBlockUserRequest }));\n        };\n        this.endCall = () => {\n            return this.apiClient.endCall(Object.assign({}, this.baseRequest));\n        };\n        this.get = (request) => {\n            return this.apiClient.getCall(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest));\n        };\n        this.getOrCreate = (videoGetOrCreateCallRequest) => {\n            return this.apiClient.getOrCreateCall(Object.assign(Object.assign({}, this.baseRequest), { videoGetOrCreateCallRequest: videoGetOrCreateCallRequest !== null && videoGetOrCreateCallRequest !== void 0 ? videoGetOrCreateCallRequest : {} }));\n        };\n        this.create = (getOrCreateCallRequest) => {\n            return this.getOrCreate(getOrCreateCallRequest);\n        };\n        this.goLive = (videoGoLiveRequest) => {\n            return this.apiClient.goLive(Object.assign(Object.assign({}, this.baseRequest), { videoGoLiveRequest: videoGoLiveRequest !== null && videoGoLiveRequest !== void 0 ? videoGoLiveRequest : {} }));\n        };\n        this.listRecordings = () => {\n            return this.apiClient.listRecordings(Object.assign({}, this.baseRequest));\n        };\n        this.listTranscriptions = () => {\n            return this.apiClient.listTranscriptions(Object.assign({}, this.baseRequest));\n        };\n        this.muteUsers = (videoMuteUsersRequest) => {\n            return this.apiClient.muteUsers(Object.assign(Object.assign({}, this.baseRequest), { videoMuteUsersRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.apiClient.queryMembers({\n                videoQueryMembersRequest: Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest),\n            });\n        };\n        this.sendCustomEvent = (event) => {\n            return this.apiClient.sendEvent(Object.assign({ videoSendEventRequest: { custom: event } }, this.baseRequest));\n        };\n        this.startHLSBroadcasting = () => {\n            return this.apiClient.startHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.startRecording = (request) => {\n            return this.apiClient.startRecording(Object.assign(Object.assign({}, this.baseRequest), { videoStartRecordingRequest: request !== null && request !== void 0 ? request : {} }));\n        };\n        this.startTranscription = (videoStartTranscriptionRequest = {}) => {\n            return this.apiClient.startTranscription(Object.assign(Object.assign({}, this.baseRequest), { videoStartTranscriptionRequest }));\n        };\n        this.stopHLSBroadcasting = () => {\n            return this.apiClient.stopHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.stopLive = () => {\n            return this.apiClient.stopLive(Object.assign({}, this.baseRequest));\n        };\n        this.stopRecording = () => {\n            return this.apiClient.stopRecording(Object.assign({}, this.baseRequest));\n        };\n        this.stopTranscription = () => {\n            return this.apiClient.stopTranscription(Object.assign({}, this.baseRequest));\n        };\n        this.unblockUser = (videoUnblockUserRequest) => {\n            return this.apiClient.unblockUser(Object.assign({ videoUnblockUserRequest }, this.baseRequest));\n        };\n        this.update = (videoUpdateCallRequest) => {\n            return this.apiClient.updateCall(Object.assign({ videoUpdateCallRequest }, this.baseRequest));\n        };\n        this.updateCallMembers = (videoUpdateCallMembersRequest) => {\n            return this.apiClient.updateCallMembers(Object.assign({ videoUpdateCallMembersRequest }, this.baseRequest));\n        };\n        this.updateUserPermissions = (videoUpdateUserPermissionsRequest) => {\n            return this.apiClient.updateUserPermissions(Object.assign({ videoUpdateUserPermissionsRequest }, this.baseRequest));\n        };\n        this.pinVideo = (videoPinRequest) => {\n            return this.apiClient.videoPin(Object.assign({ videoPinRequest }, this.baseRequest));\n        };\n        this.unpinVideo = (videoUnpinRequest) => {\n            return this.apiClient.videoUnpin(Object.assign({ videoUnpinRequest }, this.baseRequest));\n        };\n        this.baseRequest = { id: this.id, type: this.type };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n    }\n}\n\nclass StreamVideoClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.call = (type, id) => {\n            return new StreamCall(this.streamClient, type, id);\n        };\n        this.queryCalls = (request) => {\n            return this.apiClient.queryCalls({\n                videoQueryCallsRequest: request !== null && request !== void 0 ? request : {},\n            });\n        };\n        this.createCallType = (videoCreateCallTypeRequest) => {\n            return this.videoServerSideApiClient.createCallType({\n                videoCreateCallTypeRequest,\n            });\n        };\n        this.deleteCallType = (request) => {\n            return this.videoServerSideApiClient.deleteCallType(request);\n        };\n        this.getCallType = (request) => {\n            return this.videoServerSideApiClient.getCallType(request);\n        };\n        this.listCallTypes = () => {\n            return this.videoServerSideApiClient.listCallTypes();\n        };\n        this.updateCallType = (name, videoUpdateCallTypeRequest) => {\n            return this.videoServerSideApiClient.updateCallType({\n                name,\n                videoUpdateCallTypeRequest,\n            });\n        };\n        this.listExternalStorages = () => {\n            return this.settingsApi.listExternalStorage();\n        };\n        this.createExternalStorage = (videoCreateExternalStorageRequest) => {\n            return this.settingsApi.createExternalStorage({\n                videoCreateExternalStorageRequest,\n            });\n        };\n        this.deleteExternalStorage = (request) => {\n            return this.settingsApi.deleteExternalStorage(request);\n        };\n        this.updateExternalStorage = (name, videoUpdateExternalStorageRequest) => {\n            return this.videoServerSideApiClient.updateExternalStorage({\n                name,\n                videoUpdateExternalStorageRequest,\n            });\n        };\n        this.checkExternalStorage = (request) => {\n            return this.videoServerSideApiClient.checkExternalStorage(request);\n        };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n        this.settingsApi = new SettingsApi(configuration);\n        this.videoServerSideApiClient = new ServerSideApi(configuration);\n    }\n}\n\nfunction JWTUserToken(apiSecret, userId, extraData = {}, jwtOptions = {}) {\n    if (typeof userId !== 'string') {\n        throw new TypeError('userId should be a string');\n    }\n    const payload = Object.assign({ user_id: userId }, extraData);\n    // make sure we return a clear error when jwt is shimmed (ie. browser build)\n    if ((jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default()) == null || (jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign) == null) {\n        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);\n    }\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    if (payload.iat) {\n        opts.noTimestamp = false;\n    }\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\nfunction JWTServerToken(apiSecret, jwtOptions = {}) {\n    const payload = {\n        server: true,\n    };\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\n\nclass StreamClient {\n    /**\n     *\n     * @param apiKey\n     * @param secret\n     * @param config can be a string, which will be interpreted as base path (deprecated), or a config object\n     */\n    constructor(apiKey, secret, config) {\n        var _a;\n        this.apiKey = apiKey;\n        this.secret = secret;\n        this.config = config;\n        this.options = {};\n        this.createDevice = (createDeviceRequest) => {\n            return this.devicesApi.createDevice({ createDeviceRequest });\n        };\n        this.deleteDevice = (requestParameters) => {\n            return this.devicesApi.deleteDevice(requestParameters);\n        };\n        this.listDevices = (requestParameters) => {\n            return this.devicesApi.listDevices(requestParameters);\n        };\n        this.listPushProviders = () => {\n            return this.pushApi.listPushProviders();\n        };\n        this.deletePushProvider = (request) => {\n            return this.pushApi.deletePushProvider(request);\n        };\n        this.upsertPushProvider = (request) => {\n            return this.serversideApi.upsertPushProvider({\n                upsertPushProviderRequest: { push_provider: request },\n            });\n        };\n        this.checkPush = (checkPushRequest) => {\n            return this.testingApi.checkPush({ checkPushRequest });\n        };\n        this.createGuest = (guestRequest) => __awaiter(this, void 0, void 0, function* () {\n            guestRequest.user = this.mapCustomDataBeforeSend(guestRequest.user);\n            const response = yield this.usersApi.createGuest({ guestRequest });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.banUser = (banRequest) => {\n            banRequest.user = this.mapCustomDataBeforeSend(banRequest.user);\n            banRequest.banned_by = this.mapCustomDataBeforeSend(banRequest.banned_by);\n            return this.usersApi.ban({ banRequest });\n        };\n        this.deactivateUser = (deactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deactivateUser({\n                deactivateUserRequest,\n                userId: deactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deactivateUsers = (deactivateUsersRequest) => {\n            return this.usersApi.deactivateUsers({ deactivateUsersRequest });\n        };\n        /**\n         * @deprecated use `deleteUsers` instead\n         * @param deleteUsersRequest\n         * @returns\n         */\n        this.deleteUser = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deleteUser(request);\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deleteUsers = (deleteUsersRequest) => {\n            return this.usersApi.deleteUsers({ deleteUsersRequest });\n        };\n        this.exportUser = (request) => {\n            return this.usersApi.exportUser(request);\n        };\n        this.exportUsers = (exportUsersRequest) => {\n            return this.usersApi.exportUsers({ exportUsersRequest });\n        };\n        this.flag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _b, _c;\n            flagRequest.user = this.mapCustomDataBeforeSend(flagRequest.user);\n            const response = yield this.usersApi.flag({ flagRequest });\n            if ((_b = response.flag) === null || _b === void 0 ? void 0 : _b.user) {\n                response.flag.user = this.mapCustomDataAfterReceive((_c = response.flag) === null || _c === void 0 ? void 0 : _c.user);\n            }\n            return response;\n        });\n        this.queryBannedUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryBannedUsers({ payload });\n            response.bans.forEach((b) => {\n                b.banned_by = this.mapCustomDataAfterReceive(b.banned_by);\n                b.user = this.mapCustomDataAfterReceive(b.user);\n            });\n            return response;\n        });\n        this.queryUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryUsers({ payload });\n            /** @ts-expect-error */\n            response.users = response.users.map((u) => this.mapCustomDataAfterReceive(u));\n            return response;\n        });\n        this.reactivateUser = (reactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.reactivateUser({\n                reactivateUserRequest,\n                userId: reactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n        });\n        this.reactivateUsers = (reactivateUsersRequest) => {\n            return this.usersApi.reactivateUsers({ reactivateUsersRequest });\n        };\n        this.restoreUsers = (restoreUsersRequest) => {\n            return this.usersApi.restoreUsers({ restoreUsersRequest });\n        };\n        this.unbanUser = (request) => {\n            return this.usersApi.unban(request);\n        };\n        this.unflag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _d;\n            const response = yield this.usersApi.unflag({ flagRequest });\n            if ((_d = response.flag) === null || _d === void 0 ? void 0 : _d.user) {\n                response.flag.user = this.mapCustomDataAfterReceive(response.flag.user);\n            }\n            return response;\n        });\n        this.upsertUsers = (updateUsersRequest) => __awaiter(this, void 0, void 0, function* () {\n            Object.keys(updateUsersRequest.users).forEach((key) => {\n                updateUsersRequest.users[key] = this.mapCustomDataBeforeSend(updateUsersRequest.users[key]);\n            });\n            const response = yield this.usersApi.updateUsers({ updateUsersRequest });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.updateUsersPartial = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.updateUsersPartial({\n                /** @ts-expect-error */\n                updateUserPartialRequest: request,\n            });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.muteUser = (muteUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _e, _f;\n            muteUserRequest.user = this.mapCustomDataBeforeSend(muteUserRequest.user);\n            const response = yield this.usersApi.muteUser({ muteUserRequest });\n            if ((_e = response.mute) === null || _e === void 0 ? void 0 : _e.user) {\n                response.mute.user = this.mapCustomDataAfterReceive((_f = response.mute) === null || _f === void 0 ? void 0 : _f.user);\n            }\n            if (response.mutes) {\n                response.mutes = response.mutes.map((m) => {\n                    return Object.assign(Object.assign({}, m), { user: this.mapCustomDataAfterReceive(m.user) });\n                });\n            }\n            return response;\n        });\n        this.unmuteUser = (unmuteUserRequest) => {\n            unmuteUserRequest.user = this.mapCustomDataBeforeSend(unmuteUserRequest.user);\n            return this.usersApi.unmuteUser({ unmuteUserRequest });\n        };\n        this.sendCustomEventToUser = (userId, event) => {\n            return this.eventsApi.sendUserCustomEvent({\n                userId,\n                sendUserCustomEventRequest: { event },\n            });\n        };\n        this.createRole = (createRoleRequest) => {\n            return this.permissionsApi.createRole({ createRoleRequest });\n        };\n        this.deleteRole = (request) => {\n            return this.permissionsApi.deleteRole(request);\n        };\n        this.getPermission = (request) => {\n            return this.permissionsApi.getPermission(request);\n        };\n        this.listPermissions = () => {\n            return this.permissionsApi.listPermissions();\n        };\n        this.listRoles = () => {\n            return this.permissionsApi.listRoles();\n        };\n        this.getAppSettings = () => {\n            return this.settingsApi.getApp();\n        };\n        this.updateAppSettings = (updateAppRequest) => {\n            return this.settingsApi.updateApp({ updateAppRequest });\n        };\n        this.getRateLimits = () => {\n            return this.settingsApi.getRateLimits();\n        };\n        this.getTaskStatus = (request) => {\n            return this.tasksApi.getTask(request);\n        };\n        this.verifyWebhook = (requestBody, xSignature) => {\n            const key = Buffer.from(this.secret, 'utf8');\n            const hash = crypto__WEBPACK_IMPORTED_MODULE_1___default().createHmac('sha256', key)\n                .update(requestBody)\n                .digest('hex');\n            try {\n                return crypto__WEBPACK_IMPORTED_MODULE_1___default().timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));\n            }\n            catch (err) {\n                return false;\n            }\n        };\n        this.getConfiguration = (product = 'chat') => {\n            var _a;\n            return new Configuration({\n                apiKey: (name) => {\n                    const mapping = {\n                        'Stream-Auth-Type': 'jwt',\n                        api_key: this.apiKey,\n                        Authorization: this.token,\n                    };\n                    return mapping[name];\n                },\n                basePath: (_a = this.options.basePath) !== null && _a !== void 0 ? _a : (product === 'chat'\n                    ? 'https://chat.stream-io-api.com'\n                    : 'https://video.stream-io-api.com'),\n                headers: {\n                    'X-Stream-Client': 'stream-node-' + \"0.1.13\",\n                },\n                middleware: [\n                    {\n                        pre: (context) => {\n                            context.init.headers = Object.assign(Object.assign({}, context.init.headers), { 'x-client-request-id': (0,uuid__WEBPACK_IMPORTED_MODULE_2__.v4)(), 'Accept-Encoding': 'gzip' });\n                            return Promise.resolve(context);\n                        },\n                    },\n                    {\n                        // This should be the last post middleware because that will throw an error\n                        // The Fetch API won't throw an error for HTTP error responses, which means the \"onError\" middleware won't be called so we need to throw error from \"post\" middleware\n                        post: (context) => __awaiter(this, void 0, void 0, function* () {\n                            if ((context.response && context.response.status < 200) ||\n                                context.response.status >= 300) {\n                                const response = new JSONApiResponse(context.response);\n                                const value = (yield response.value());\n                                throw new Error(`Stream error code ${value.code}: ${value.message}`);\n                            }\n                        }),\n                    },\n                    {\n                        pre: (context) => {\n                            context.init.signal = AbortSignal.timeout(this.options.timeout);\n                            return Promise.resolve(context);\n                        },\n                        onError: (context) => {\n                            const error = context.error;\n                            if (error.name === 'AbortError' || error.name === 'TimeoutError') {\n                                throw new FetchError(error, `The request was aborted due to to the ${this.options.timeout}ms timeout, you can set the timeout in the StreamClient constructor`);\n                            }\n                            return Promise.resolve(context.response);\n                        },\n                    },\n                ],\n                // https://github.com/OpenAPITools/openapi-generator/issues/13222\n                queryParamsStringify: (params) => {\n                    const newParams = [];\n                    for (const k in params) {\n                        if (Array.isArray(params[k]) || typeof params[k] === 'object') {\n                            newParams.push(`${k}=${encodeURIComponent(JSON.stringify(params[k]))}`);\n                        }\n                        else {\n                            const value = params[k];\n                            if (typeof value === 'string' ||\n                                typeof value === 'number' ||\n                                typeof value === 'boolean') {\n                                newParams.push(`${k}=${encodeURIComponent(value)}`);\n                            }\n                        }\n                    }\n                    return newParams.join('&');\n                },\n            });\n        };\n        this.reservedKeywords = [\n            'ban_expires',\n            'banned',\n            'id',\n            'invisible',\n            'language',\n            'push_notifications',\n            'revoke_tokens_issued_before',\n            'role',\n            'teams',\n            'created_at',\n            'deactivated_at',\n            'deleted_at',\n            'last_active',\n            'online',\n            'updated_at',\n            'shadow_banned',\n            'name',\n            'image',\n        ];\n        this.mapCustomDataBeforeSend = (user) => {\n            if (!user) {\n                return undefined;\n            }\n            const copy = Object.assign({}, user);\n            delete copy.custom;\n            return Object.assign(Object.assign({}, copy), user.custom);\n        };\n        this.token = JWTServerToken(this.secret);\n        if (typeof config === 'string') {\n            this.options.basePath = config;\n            this.options.timeout = StreamClient.DEFAULT_TIMEOUT;\n        }\n        else {\n            if (config) {\n                this.options = config;\n            }\n            this.options.timeout = (_a = config === null || config === void 0 ? void 0 : config.timeout) !== null && _a !== void 0 ? _a : StreamClient.DEFAULT_TIMEOUT;\n        }\n        this.video = new StreamVideoClient(this);\n        this.chat = new StreamChatClient(this);\n        const chatConfiguration = this.getConfiguration();\n        /** @ts-expect-error */\n        this.usersApi = new UsersApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.devicesApi = new DevicesApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.pushApi = new PushApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.serversideApi = new ServerSideApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.testingApi = new TestingApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.permissionsApi = new PermissionsV2Api(chatConfiguration);\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.tasksApi = new TasksApi(chatConfiguration);\n    }\n    /**\n     *\n     * @param userID\n     * @param exp\n     * @param iat deprecated, the default date will be set internally\n     * @param call_cids this parameter is deprecated use `createCallToken` for call tokens\n     * @returns\n     */\n    createToken(userID, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000), call_cids) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        if (call_cids) {\n            console.warn(`Use createCallToken method for creating call tokens, the \"call_cids\" param will be removed from the createToken method with version 0.2.0`);\n            extra.call_cids = call_cids;\n        }\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    /**\n     *\n     * @param userID\n     * @param call_cids\n     * @param exp\n     * @param iat this is deprecated, the current date will be set internally\n     * @returns\n     */\n    createCallToken(userID, call_cids, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000)) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        extra.call_cids = call_cids;\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    mapCustomDataAfterReceive(user) {\n        if (!user) {\n            return undefined;\n        }\n        /** @ts-expect-error */\n        const result = {};\n        Object.keys(user).forEach((key) => {\n            if (!this.reservedKeywords.includes(key)) {\n                if (!result.custom) {\n                    result.custom = {};\n                }\n                result.custom[key] = user[key];\n            }\n            else {\n                result[key] = user[key];\n            }\n        });\n        return result;\n    }\n}\nStreamClient.DEFAULT_TIMEOUT = 3000;\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL25vZGUtc2RrL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNLO0FBQ0g7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxZQUFZLEVBQUUsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztB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LE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUV3bkY7QUFDeG5GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhbXNwYWNlLy4vbm9kZV9tb2R1bGVzL0BzdHJlYW0taW8vbm9kZS1zZGsvZGlzdC9pbmRleC5lcy5qcz82ZWYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBUE5Db25maWdSZXF1ZXN0QXV0aFR5cGVFbnVtID0ge1xuICAgIENFUlRJRklDQVRFOiAnY2VydGlmaWNhdGUnLFxuICAgIFRPS0VOOiAndG9rZW4nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFwcFNlYXJjaEJhY2tlbmRFbnVtID0ge1xuICAgIEVMQVNUSUNTRUFSQ0g6ICdlbGFzdGljc2VhcmNoJyxcbiAgICBQT1NUR1JFUzogJ3Bvc3RncmVzJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3luY01vZGVyYXRpb25DYWxsYmFja0NvbmZpZ1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBOT05FOiAnQ0FMTEJBQ0tfTU9ERV9OT05FJyxcbiAgICBSRVNUOiAnQ0FMTEJBQ0tfTU9ERV9SRVNUJyxcbiAgICBUV0lSUDogJ0NBTExCQUNLX01PREVfVFdJUlAnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEF1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tMaXN0T3B0aW9uc0JlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tMaXN0T3B0aW9uc1JlcXVlc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9BdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9CbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9SZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsTWVtYmVyUm9sZUVudW0gPSB7XG4gICAgTUVNQkVSOiAnbWVtYmVyJyxcbiAgICBNT0RFUkFUT1I6ICdtb2RlcmF0b3InLFxuICAgIEFETUlOOiAnYWRtaW4nLFxuICAgIE9XTkVSOiAnb3duZXInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxNZW1iZXJSZXF1ZXN0Um9sZUVudW0gPSB7XG4gICAgTUVNQkVSOiAnbWVtYmVyJyxcbiAgICBNT0RFUkFUT1I6ICdtb2RlcmF0b3InLFxuICAgIEFETUlOOiAnYWRtaW4nLFxuICAgIE9XTkVSOiAnb3duZXInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxUeXBlQ29uZmlnQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsVHlwZUNvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxUeXBlQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGVja1B1c2hSZXF1ZXN0UHVzaFByb3ZpZGVyVHlwZUVudW0gPSB7XG4gICAgRklSRUJBU0U6ICdmaXJlYmFzZScsXG4gICAgQVBOOiAnYXBuJyxcbiAgICBIVUFXRUk6ICdodWF3ZWknLFxuICAgIFhJQU9NSTogJ3hpYW9taSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hlY2tTTlNSZXNwb25zZVN0YXR1c0VudW0gPSB7XG4gICAgT0s6ICdvaycsXG4gICAgRVJST1I6ICdlcnJvcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hlY2tTUVNSZXNwb25zZVN0YXR1c0VudW0gPSB7XG4gICAgT0s6ICdvaycsXG4gICAgRVJST1I6ICdlcnJvcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29uZmlnRGVmYXVsdFJvbGVFbnVtID0ge1xuICAgIEFUVEVOREVFOiAnYXR0ZW5kZWUnLFxuICAgIFBVQkxJU0hFUjogJ3B1Ymxpc2hlcicsXG4gICAgU1VCU0NSSUJFUjogJ3N1YnNjcmliZXInLFxuICAgIEFETUlOOiAnYWRtaW4nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbmZpZ1JlcXVlc3REZWZhdWx0Um9sZUVudW0gPSB7XG4gICAgQVRURU5ERUU6ICdhdHRlbmRlZScsXG4gICAgUFVCTElTSEVSOiAncHVibGlzaGVyJyxcbiAgICBTVUJTQ1JJQkVSOiAnc3Vic2NyaWJlcicsXG4gICAgQURNSU46ICdhZG1pbidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2FsbFJlcXVlc3RUeXBlRW51bSA9IHtcbiAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICBWSURFTzogJ3ZpZGVvJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDcmVhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEF1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VCbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUltcG9ydFJlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBJTlNFUlQ6ICdpbnNlcnQnLFxuICAgIFVQU0VSVDogJ3Vwc2VydCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGVsZXRlVXNlcnNSZXF1ZXN0Q29udmVyc2F0aW9uc0VudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIEhBUkQ6ICdoYXJkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZWxldGVVc2Vyc1JlcXVlc3RNZXNzYWdlc0VudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIFBSVU5JTkc6ICdwcnVuaW5nJyxcbiAgICBIQVJEOiAnaGFyZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGVsZXRlVXNlcnNSZXF1ZXN0VXNlckVudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIFBSVU5JTkc6ICdwcnVuaW5nJyxcbiAgICBIQVJEOiAnaGFyZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGV2aWNlUHVzaFByb3ZpZGVyRW51bSA9IHtcbiAgICBGSVJFQkFTRTogJ2ZpcmViYXNlJyxcbiAgICBBUE46ICdhcG4nLFxuICAgIEhVQVdFSTogJ2h1YXdlaScsXG4gICAgWElBT01JOiAneGlhb21pJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZXZpY2VGaWVsZHNQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IERldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEltYWdlU2l6ZUNyb3BFbnVtID0ge1xuICAgIFRPUDogJ3RvcCcsXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgUklHSFQ6ICdyaWdodCcsXG4gICAgQ0VOVEVSOiAnY2VudGVyJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBJbWFnZVNpemVSZXNpemVFbnVtID0ge1xuICAgIENMSVA6ICdjbGlwJyxcbiAgICBDUk9QOiAnY3JvcCcsXG4gICAgU0NBTEU6ICdzY2FsZScsXG4gICAgRklMTDogJ2ZpbGwnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IExheW91dFNldHRpbmdzTmFtZUVudW0gPSB7XG4gICAgU1BPVExJR0hUOiAnc3BvdGxpZ2h0JyxcbiAgICBHUklEOiAnZ3JpZCcsXG4gICAgU0lOR0xFX1BBUlRJQ0lQQU5UOiAnc2luZ2xlLXBhcnRpY2lwYW50JyxcbiAgICBNT0JJTEU6ICdtb2JpbGUnLFxuICAgIENVU1RPTTogJ2N1c3RvbSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZVR5cGVFbnVtID0ge1xuICAgIFJFR1VMQVI6ICdyZWd1bGFyJyxcbiAgICBFUEhFTUVSQUw6ICdlcGhlbWVyYWwnLFxuICAgIEVSUk9SOiAnZXJyb3InLFxuICAgIFJFUExZOiAncmVwbHknLFxuICAgIFNZU1RFTTogJ3N5c3RlbScsXG4gICAgREVMRVRFRDogJ2RlbGV0ZWQnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE1lc3NhZ2VSZXF1ZXN0VHlwZUVudW0gPSB7XG4gICAgUkVHVUxBUjogJ3JlZ3VsYXInLFxuICAgIEVQSEVNRVJBTDogJ2VwaGVtZXJhbCcsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgUkVQTFk6ICdyZXBseScsXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgICBERUxFVEVEOiAnZGVsZXRlZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZVJlcXVlc3QxVHlwZUVudW0gPSB7XG4gICAgUkVHVUxBUjogJ3JlZ3VsYXInLFxuICAgIEVQSEVNRVJBTDogJ2VwaGVtZXJhbCcsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgUkVQTFk6ICdyZXBseScsXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgICBERUxFVEVEOiAnZGVsZXRlZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUGVybWlzc2lvbkxldmVsRW51bSA9IHtcbiAgICBBUFA6ICdhcHAnLFxuICAgIENIQU5ORUw6ICdjaGFubmVsJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQb2xpY3lSZXF1ZXN0QWN0aW9uRW51bSA9IHtcbiAgICBERU5ZOiAnRGVueScsXG4gICAgQUxMT1c6ICdBbGxvdydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUG9saWN5UmVxdWVzdDFBY3Rpb25FbnVtID0ge1xuICAgIERFTlk6ICdEZW55JyxcbiAgICBBTExPVzogJ0FsbG93J1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQdXNoQ29uZmlnUmVxdWVzdFZlcnNpb25FbnVtID0ge1xuICAgIFYxOiAndjEnLFxuICAgIFYyOiAndjInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0TGFuZ3VhZ2VFbnVtID0ge1xuICAgIEFGOiAnYWYnLFxuICAgIFNROiAnc3EnLFxuICAgIEFNOiAnYW0nLFxuICAgIEFSOiAnYXInLFxuICAgIEFaOiAnYXonLFxuICAgIEJOOiAnYm4nLFxuICAgIEJTOiAnYnMnLFxuICAgIEJHOiAnYmcnLFxuICAgIFpIOiAnemgnLFxuICAgIFpIX1RXOiAnemgtVFcnLFxuICAgIEhSOiAnaHInLFxuICAgIENTOiAnY3MnLFxuICAgIERBOiAnZGEnLFxuICAgIEZBX0FGOiAnZmEtQUYnLFxuICAgIE5MOiAnbmwnLFxuICAgIEVOOiAnZW4nLFxuICAgIEVUOiAnZXQnLFxuICAgIEZJOiAnZmknLFxuICAgIEZSOiAnZnInLFxuICAgIEZSX0NBOiAnZnItQ0EnLFxuICAgIEtBOiAna2EnLFxuICAgIERFOiAnZGUnLFxuICAgIEVMOiAnZWwnLFxuICAgIEhBOiAnaGEnLFxuICAgIEhFOiAnaGUnLFxuICAgIEhJOiAnaGknLFxuICAgIEhVOiAnaHUnLFxuICAgIElEOiAnaWQnLFxuICAgIElUOiAnaXQnLFxuICAgIEpBOiAnamEnLFxuICAgIEtPOiAna28nLFxuICAgIExWOiAnbHYnLFxuICAgIE1TOiAnbXMnLFxuICAgIE5POiAnbm8nLFxuICAgIEZBOiAnZmEnLFxuICAgIFBTOiAncHMnLFxuICAgIFBMOiAncGwnLFxuICAgIFBUOiAncHQnLFxuICAgIFJPOiAncm8nLFxuICAgIFJVOiAncnUnLFxuICAgIFNSOiAnc3InLFxuICAgIFNLOiAnc2snLFxuICAgIFNMOiAnc2wnLFxuICAgIFNPOiAnc28nLFxuICAgIEVTOiAnZXMnLFxuICAgIEVTX01YOiAnZXMtTVgnLFxuICAgIFNXOiAnc3cnLFxuICAgIFNWOiAnc3YnLFxuICAgIFRMOiAndGwnLFxuICAgIFRBOiAndGEnLFxuICAgIFRIOiAndGgnLFxuICAgIFRSOiAndHInLFxuICAgIFVLOiAndWsnLFxuICAgIFVSOiAndXInLFxuICAgIFZJOiAndmknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUFwcFJlcXVlc3RFbmZvcmNlVW5pcXVlVXNlcm5hbWVzRW51bSA9IHtcbiAgICBOTzogJ25vJyxcbiAgICBBUFA6ICdhcHAnLFxuICAgIFRFQU06ICd0ZWFtJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVBcHBSZXF1ZXN0UGVybWlzc2lvblZlcnNpb25FbnVtID0ge1xuICAgIFYxOiAndjEnLFxuICAgIFYyOiAndjInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUFwcFJlcXVlc3RWaWRlb1Byb3ZpZGVyRW51bSA9IHtcbiAgICBBR09SQTogJ2Fnb3JhJyxcbiAgICBITVM6ICdobXMnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdEF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0gPSB7XG4gICAgRlJPTlQ6ICdmcm9udCcsXG4gICAgQkFDSzogJ2JhY2snLFxuICAgIEVYVEVSTkFMOiAnZXh0ZXJuYWwnXG59O1xuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9BdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0gPSB7XG4gICAgU1BFQUtFUjogJ3NwZWFrZXInLFxuICAgIEVBUlBJRUNFOiAnZWFycGllY2UnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSA9IHtcbiAgICBGSVJFQkFTRTogJ2ZpcmViYXNlJyxcbiAgICBBUE46ICdhcG4nLFxuICAgIEhVQVdFSTogJ2h1YXdlaScsXG4gICAgWElBT01JOiAneGlhb21pJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb0xheW91dFNldHRpbmdzTmFtZUVudW0gPSB7XG4gICAgU1BPVExJR0hUOiAnc3BvdGxpZ2h0JyxcbiAgICBHUklEOiAnZ3JpZCcsXG4gICAgU0lOR0xFX1BBUlRJQ0lQQU5UOiAnc2luZ2xlLXBhcnRpY2lwYW50JyxcbiAgICBNT0JJTEU6ICdtb2JpbGUnLFxuICAgIENVU1RPTTogJ2N1c3RvbSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9MYXlvdXRTZXR0aW5nc1JlcXVlc3ROYW1lRW51bSA9IHtcbiAgICBTUE9UTElHSFQ6ICdzcG90bGlnaHQnLFxuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBTSU5HTEVfUEFSVElDSVBBTlQ6ICdzaW5nbGUtcGFydGljaXBhbnQnLFxuICAgIE1PQklMRTogJ21vYmlsZScsXG4gICAgQ1VTVE9NOiAnY3VzdG9tJ1xufTtcbi8qKlxuICogQWxsIHBvc3NpYmlsaXR5IG9mIHN0cmluZyB0byB1c2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9Pd25DYXBhYmlsaXR5ID0ge1xuICAgIEJMT0NLX1VTRVJTOiAnYmxvY2stdXNlcnMnLFxuICAgIENSRUFURV9DQUxMOiAnY3JlYXRlLWNhbGwnLFxuICAgIENSRUFURV9SRUFDVElPTjogJ2NyZWF0ZS1yZWFjdGlvbicsXG4gICAgRU5EX0NBTEw6ICdlbmQtY2FsbCcsXG4gICAgSk9JTl9CQUNLU1RBR0U6ICdqb2luLWJhY2tzdGFnZScsXG4gICAgSk9JTl9DQUxMOiAnam9pbi1jYWxsJyxcbiAgICBKT0lOX0VOREVEX0NBTEw6ICdqb2luLWVuZGVkLWNhbGwnLFxuICAgIE1VVEVfVVNFUlM6ICdtdXRlLXVzZXJzJyxcbiAgICBQSU5fRk9SX0VWRVJZT05FOiAncGluLWZvci1ldmVyeW9uZScsXG4gICAgUkVBRF9DQUxMOiAncmVhZC1jYWxsJyxcbiAgICBSRU1PVkVfQ0FMTF9NRU1CRVI6ICdyZW1vdmUtY2FsbC1tZW1iZXInLFxuICAgIFNDUkVFTlNIQVJFOiAnc2NyZWVuc2hhcmUnLFxuICAgIFNFTkRfQVVESU86ICdzZW5kLWF1ZGlvJyxcbiAgICBTRU5EX1ZJREVPOiAnc2VuZC12aWRlbycsXG4gICAgU1RBUlRfQlJPQURDQVNUX0NBTEw6ICdzdGFydC1icm9hZGNhc3QtY2FsbCcsXG4gICAgU1RBUlRfUkVDT1JEX0NBTEw6ICdzdGFydC1yZWNvcmQtY2FsbCcsXG4gICAgU1RBUlRfVFJBTlNDUklQVElPTl9DQUxMOiAnc3RhcnQtdHJhbnNjcmlwdGlvbi1jYWxsJyxcbiAgICBTVE9QX0JST0FEQ0FTVF9DQUxMOiAnc3RvcC1icm9hZGNhc3QtY2FsbCcsXG4gICAgU1RPUF9SRUNPUkRfQ0FMTDogJ3N0b3AtcmVjb3JkLWNhbGwnLFxuICAgIFNUT1BfVFJBTlNDUklQVElPTl9DQUxMOiAnc3RvcC10cmFuc2NyaXB0aW9uLWNhbGwnLFxuICAgIFVQREFURV9DQUxMOiAndXBkYXRlLWNhbGwnLFxuICAgIFVQREFURV9DQUxMX01FTUJFUjogJ3VwZGF0ZS1jYWxsLW1lbWJlcicsXG4gICAgVVBEQVRFX0NBTExfUEVSTUlTU0lPTlM6ICd1cGRhdGUtY2FsbC1wZXJtaXNzaW9ucycsXG4gICAgVVBEQVRFX0NBTExfU0VUVElOR1M6ICd1cGRhdGUtY2FsbC1zZXR0aW5ncydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9SZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1JlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtID0ge1xuICAgIF8zNjBQOiAnMzYwcCcsXG4gICAgXzQ4MFA6ICc0ODBwJyxcbiAgICBfNzIwUDogJzcyMHAnLFxuICAgIF8xMDgwUDogJzEwODBwJyxcbiAgICBfMTQ0MFA6ICcxNDQwcCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9UcmFuc2NyaXB0aW9uU2V0dGluZ3NNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1ZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1ZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSA9IHtcbiAgICBGUk9OVDogJ2Zyb250JyxcbiAgICBCQUNLOiAnYmFjaycsXG4gICAgRVhURVJOQUw6ICdleHRlcm5hbCdcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuY29uc3QgQkFTRV9QQVRIJDEgPSBcImh0dHBzOi8vY2hhdC5zdHJlYW0taW8tYXBpLmNvbVwiLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG5sZXQgQ29uZmlndXJhdGlvbiQxID0gY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIHNldCBjb25maWcoY29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggIT0gbnVsbCA/IHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCA6IEJBU0VfUEFUSCQxO1xuICAgIH1cbiAgICBnZXQgZmV0Y2hBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGk7XG4gICAgfVxuICAgIGdldCBtaWRkbGV3YXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm1pZGRsZXdhcmUgfHwgW107XG4gICAgfVxuICAgIGdldCBxdWVyeVBhcmFtc1N0cmluZ2lmeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeSB8fCBxdWVyeXN0cmluZyQxO1xuICAgIH1cbiAgICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udXNlcm5hbWU7XG4gICAgfVxuICAgIGdldCBwYXNzd29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5wYXNzd29yZDtcbiAgICB9XG4gICAgZ2V0IGFwaUtleSgpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcGlLZXkgPT09ICdmdW5jdGlvbicgPyBhcGlLZXkgOiAoKSA9PiBhcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMuY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbjtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nID8gYWNjZXNzVG9rZW4gOiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBhY2Nlc3NUb2tlbjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmNyZWRlbnRpYWxzO1xuICAgIH1cbn07XG5jb25zdCBEZWZhdWx0Q29uZmlnJDEgPSBuZXcgQ29uZmlndXJhdGlvbiQxKCk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWQgQVBJIGNsYXNzZXMuXG4gKi9cbmxldCBCYXNlQVBJJDEgPSBjbGFzcyBCYXNlQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uID0gRGVmYXVsdENvbmZpZyQxKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuZmV0Y2hBcGkgPSAodXJsLCBpbml0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hQYXJhbXMgPSB7IHVybCwgaW5pdCB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcyA9ICh5aWVsZCBtaWRkbGV3YXJlLnByZShPYmplY3QuYXNzaWduKHsgZmV0Y2g6IHRoaXMuZmV0Y2hBcGkgfSwgZmV0Y2hQYXJhbXMpKSkgfHwgZmV0Y2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkICh0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGkgfHwgZmV0Y2gpKGZldGNoUGFyYW1zLnVybCwgZmV0Y2hQYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoUGFyYW1zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSA/IHJlc3BvbnNlLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IkMShlLCAnVGhlIHJlcXVlc3QgZmFpbGVkIGFuZCB0aGUgaW50ZXJjZXB0b3JzIGRpZCBub3QgcmV0dXJuIGFuIGFsdGVybmF0aXZlIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5wb3N0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoQXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBmZXRjaFBhcmFtcy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIH0pKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmUgPSBjb25maWd1cmF0aW9uLm1pZGRsZXdhcmU7XG4gICAgfVxuICAgIHdpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG5leHQubWlkZGxld2FyZSA9IG5leHQubWlkZGxld2FyZS5jb25jYXQoLi4ubWlkZGxld2FyZXMpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgd2l0aFByZU1pZGRsZXdhcmUoLi4ucHJlTWlkZGxld2FyZXMpIHtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSBwcmVNaWRkbGV3YXJlcy5tYXAoKHByZSkgPT4gKHsgcHJlIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpO1xuICAgIH1cbiAgICB3aXRoUG9zdE1pZGRsZXdhcmUoLi4ucG9zdE1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gcG9zdE1pZGRsZXdhcmVzLm1hcCgocG9zdCkgPT4gKHsgcG9zdCB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIE1JTUUgaXMgYSBKU09OIE1JTUUuXG4gICAgICogSlNPTiBNSU1FIGV4YW1wbGVzOlxuICAgICAqICAgYXBwbGljYXRpb24vanNvblxuICAgICAqICAgYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEY4XG4gICAgICogICBBUFBMSUNBVElPTi9KU09OXG4gICAgICogICBhcHBsaWNhdGlvbi92bmQuY29tcGFueStqc29uXG4gICAgICogQHBhcmFtIG1pbWUgLSBNSU1FIChNdWx0aXB1cnBvc2UgSW50ZXJuZXQgTWFpbCBFeHRlbnNpb25zKVxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBKU09OLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNKc29uTWltZShtaW1lKSB7XG4gICAgICAgIGlmICghbWltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXNlQVBJLmpzb25SZWdleC50ZXN0KG1pbWUpO1xuICAgIH1cbiAgICByZXF1ZXN0KGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBpbml0IH0gPSB5aWVsZCB0aGlzLmNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoQXBpKHVybCwgaW5pdCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yJDEocmVzcG9uc2UsICdSZXNwb25zZSByZXR1cm5lZCBhbiBlcnJvciBjb2RlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVGZXRjaFBhcmFtcyhjb250ZXh0LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gdGhpcy5jb25maWd1cmF0aW9uLmJhc2VQYXRoICsgY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQucXVlcnkgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyhjb250ZXh0LnF1ZXJ5KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGUgcXVlcnlzdHJpbmcgdG8gdGhlIFVSTCBpZiB0aGVyZSBhcmUgcXVlcnkgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGRvbmUgdG8gYXZvaWQgdXJscyBlbmRpbmcgd2l0aCBhIFwiP1wiIGNoYXJhY3RlciB3aGljaCBidWdneSB3ZWJzZXJ2ZXJzXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGhhbmRsZSBjb3JyZWN0bHkgc29tZXRpbWVzLlxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLmNvbmZpZ3VyYXRpb24ucXVlcnlQYXJhbXNTdHJpbmdpZnkoY29udGV4dC5xdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWd1cmF0aW9uLmhlYWRlcnMsIGNvbnRleHQuaGVhZGVycyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGtleSA9PiBoZWFkZXJzW2tleV0gPT09IHVuZGVmaW5lZCA/IGRlbGV0ZSBoZWFkZXJzW2tleV0gOiB7fSk7XG4gICAgICAgICAgICBjb25zdCBpbml0T3ZlcnJpZGVGbiA9IHR5cGVvZiBpbml0T3ZlcnJpZGVzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IGluaXRPdmVycmlkZXNcbiAgICAgICAgICAgICAgICA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIGluaXRPdmVycmlkZXM7IH0pO1xuICAgICAgICAgICAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogY29udGV4dC5ib2R5LFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmNvbmZpZ3VyYXRpb24uY3JlZGVudGlhbHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGRlbkluaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRQYXJhbXMpLCAoeWllbGQgaW5pdE92ZXJyaWRlRm4oe1xuICAgICAgICAgICAgICAgIGluaXQ6IGluaXRQYXJhbXMsXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBjb25zdCBpbml0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZGVuSW5pdCksIHsgYm9keTogaXNGb3JtRGF0YSQxKG92ZXJyaWRkZW5Jbml0LmJvZHkpIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRkZW5Jbml0LmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9iJDEob3ZlcnJpZGRlbkluaXQuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgPyBvdmVycmlkZGVuSW5pdC5ib2R5XG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkob3ZlcnJpZGRlbkluaXQuYm9keSkgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB1cmwsIGluaXQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY2xvbmUgb2YgYHRoaXNgIGJ5IGNvbnN0cnVjdGluZyBhIG5ldyBpbnN0YW5jZVxuICAgICAqIGFuZCB0aGVuIHNoYWxsb3cgY2xvbmluZyBkYXRhIG1lbWJlcnMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ldyBjb25zdHJ1Y3Rvcih0aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBuZXh0Lm1pZGRsZXdhcmUgPSB0aGlzLm1pZGRsZXdhcmUuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxufTtcbkJhc2VBUEkkMS5qc29uUmVnZXggPSBuZXcgUmVnRXhwKCdeKDo/YXBwbGljYXRpb25cXC9qc29ufFteOy8gXFx0XStcXC9bXjsvIFxcdF0rWytdanNvbilbIFxcdF0qKDo/Oy4qKT8kJywgJ2knKTtcbmZ1bmN0aW9uIGlzQmxvYiQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2I7XG59XG5mdW5jdGlvbiBpc0Zvcm1EYXRhJDEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5sZXQgUmVzcG9uc2VFcnJvciQxID0gY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSZXNwb25zZUVycm9yXCI7XG4gICAgfVxufTtcbmxldCBGZXRjaEVycm9yJDEgPSBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdXNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIjtcbiAgICB9XG59O1xubGV0IFJlcXVpcmVkRXJyb3IkMSA9IGNsYXNzIFJlcXVpcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVxdWlyZWRFcnJvclwiO1xuICAgIH1cbn07XG5jb25zdCBDT0xMRUNUSU9OX0ZPUk1BVFMgPSB7XG4gICAgY3N2OiBcIixcIixcbiAgICBzc3Y6IFwiIFwiLFxuICAgIHRzdjogXCJcXHRcIixcbiAgICBwaXBlczogXCJ8XCIsXG59O1xuZnVuY3Rpb24gcXVlcnlzdHJpbmckMShwYXJhbXMsIHByZWZpeCA9ICcnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLm1hcChrZXkgPT4gcXVlcnlzdHJpbmdTaW5nbGVLZXkkMShrZXksIHBhcmFtc1trZXldLCBwcmVmaXgpKVxuICAgICAgICAuZmlsdGVyKHBhcnQgPT4gcGFydC5sZW5ndGggPiAwKVxuICAgICAgICAuam9pbignJicpO1xufVxuZnVuY3Rpb24gcXVlcnlzdHJpbmdTaW5nbGVLZXkkMShrZXksIHZhbHVlLCBrZXlQcmVmaXggPSAnJykge1xuICAgIGNvbnN0IGZ1bGxLZXkgPSBrZXlQcmVmaXggKyAoa2V5UHJlZml4Lmxlbmd0aCA/IGBbJHtrZXl9XWAgOiBrZXkpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IG11bHRpVmFsdWUgPSB2YWx1ZS5tYXAoc2luZ2xlVmFsdWUgPT4gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzaW5nbGVWYWx1ZSkpKVxuICAgICAgICAgICAgLmpvaW4oYCYke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09YCk7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7bXVsdGlWYWx1ZX1gO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBc0FycmF5ID0gQXJyYXkuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBxdWVyeXN0cmluZ1NpbmdsZUtleSQxKGtleSwgdmFsdWVBc0FycmF5LCBrZXlQcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvSVNPU3RyaW5nKCkpfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcXVlcnlzdHJpbmckMSh2YWx1ZSwgZnVsbEtleSk7XG4gICAgfVxuICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh2YWx1ZSkpfWA7XG59XG5mdW5jdGlvbiBjYW5Db25zdW1lRm9ybShjb25zdW1lcykge1xuICAgIGZvciAoY29uc3QgY29uc3VtZSBvZiBjb25zdW1lcykge1xuICAgICAgICBpZiAoJ211bHRpcGFydC9mb3JtLWRhdGEnID09PSBjb25zdW1lLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5sZXQgSlNPTkFwaVJlc3BvbnNlJDEgPSBjbGFzcyBKU09OQXBpUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJhdywgdHJhbnNmb3JtZXIgPSAoanNvblZhbHVlKSA9PiBqc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcih5aWVsZCB0aGlzLnJhdy5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xubGV0IFZvaWRBcGlSZXNwb25zZSQxID0gY2xhc3MgVm9pZEFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBDaGFubmVsVHlwZXNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWx0eXBlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjaGFubmVsIHR5cGVcbiAgICAgKiBDcmVhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgY3JlYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBjaGFubmVsIHR5cGVzXG4gICAgICogTGlzdCBjaGFubmVsIHR5cGVzXG4gICAgICovXG4gICAgbGlzdENoYW5uZWxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgY2hhbm5lbCB0eXBlc1xuICAgICAqIExpc3QgY2hhbm5lbCB0eXBlc1xuICAgICAqL1xuICAgIGxpc3RDaGFubmVsVHlwZXMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RDaGFubmVsVHlwZXNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogVXBkYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIENoYW5uZWxzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUNoYW5uZWxcbiAgICAgKiBEZWxldGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydoYXJkX2RlbGV0ZSddID0gcmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICBkZWxldGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBkZWxldGUgc2V2ZXJhbCBjaGFubmVscyBhdCBvbmNlIGFzeW5jaHJvbm91c2x5ICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlcyBjaGFubmVscyBhc3luY2hyb25vdXNseVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZUNoYW5uZWxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDaGFubmVsc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvZGVsZXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBkZWxldGUgc2V2ZXJhbCBjaGFubmVscyBhdCBvbmNlIGFzeW5jaHJvbm91c2x5ICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlcyBjaGFubmVscyBhc3luY2hyb25vdXNseVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNoYW5uZWwgZGF0YSB0byBKU09OIGZpbGVcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBleHBvcnRDaGFubmVsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydENoYW5uZWxzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRDaGFubmVsc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2V4cG9ydENoYW5uZWxzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZXhwb3J0Q2hhbm5lbHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2V4cG9ydF9jaGFubmVsc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydENoYW5uZWxzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNoYW5uZWwgZGF0YSB0byBKU09OIGZpbGVcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBleHBvcnRDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmV4cG9ydENoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHMgc3RhdHVzXG4gICAgICovXG4gICAgZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9leHBvcnRfY2hhbm5lbHMve2lkfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRXhwb3J0IGNoYW5uZWxzIHN0YXR1c1xuICAgICAqL1xuICAgIGdldEV4cG9ydENoYW5uZWxzU3RhdHVzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgY2hhbm5lbCBvciByZXR1cm5zIGFuIGV4aXN0aW5nIG9uZSB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmNyZWF0ZWQgLSBtZW1iZXIuYWRkZWQgLSBtZW1iZXIucmVtb3ZlZCAtIG1lbWJlci51cGRhdGVkIC0gdXNlci53YXRjaGluZy5zdGFydFxuICAgICAqIEdldCBvciBjcmVhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcXVlcnlgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBjaGFubmVsIG9yIHJldHVybnMgYW4gZXhpc3Rpbmcgb25lIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcyAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuY3JlYXRlZCAtIG1lbWJlci5hZGRlZCAtIG1lbWJlci5yZW1vdmVkIC0gbWVtYmVyLnVwZGF0ZWQgLSB1c2VyLndhdGNoaW5nLnN0YXJ0XG4gICAgICogR2V0IG9yIGNyZWF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0T3JDcmVhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyBoaWRkZW4gZm9yIGN1cnJlbnQgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuaGlkZGVuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEhpZGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGhpZGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgaGlkZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGhpZGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhpZGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5oaWRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2hpZGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaGlkZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgaGlkZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L2hpZGVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5oaWRlQ2hhbm5lbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyBoaWRkZW4gZm9yIGN1cnJlbnQgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuaGlkZGVuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEhpZGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGhpZGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGlkZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVscyBhcyByZWFkIHVwIHRvIHRoZSBzcGVjaWZpYyBtZXNzYWdlLiBJZiBubyBjaGFubmVscyBpcyBnaXZlbiwgbWFyayBhbGwgY2hhbm5lbCBhcyByZWFkICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5yZWFkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgY2hhbm5lbHMgYXMgcmVhZFxuICAgICAqL1xuICAgIG1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya0NoYW5uZWxzUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya0NoYW5uZWxzUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvcmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1JlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1JlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ21hcmtVbnJlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3VucmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtVbnJlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdXRlcyBjaGFubmVsIGZvciB1c2VyICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBNdXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICBtdXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tdXRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ211dGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubXV0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbXV0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vbXV0ZS9jaGFubmVsYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubXV0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGVzIGNoYW5uZWwgZm9yIHVzZXIgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlQ2hhbm5lbFxuICAgICAqIE11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIG11dGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubXV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjaGFubmVscyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBjaGFubmVsc1xuICAgICAqL1xuICAgIHF1ZXJ5Q2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncXVlcnlDaGFubmVsc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcXVlcnlDaGFubmVscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjaGFubmVscyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBjaGFubmVsc1xuICAgICAqL1xuICAgIHF1ZXJ5Q2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeUNoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgbWVtYmVycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBtZW1iZXJzXG4gICAgICovXG4gICAgcXVlcnlNZW1iZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVtYmVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgbWVtYmVycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBtZW1iZXJzXG4gICAgICovXG4gICAgcXVlcnlNZW1iZXJzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeU1lbWJlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXMgYWNyb3NzIGNoYW5uZWxzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFNlYXJjaCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHNlYXJjaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3NlYXJjaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzIGFjcm9zcyBjaGFubmVscyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXNcbiAgICAgKi9cbiAgICBzZWFyY2gocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlYXJjaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHByZXZpb3VzbHkgaGlkZGVuIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnZpc2libGVcbiAgICAgKiBTaG93IGNoYW5uZWxcbiAgICAgKi9cbiAgICBzaG93Q2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNob3dDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzaG93Q2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zaG93Q2hhbm5lbFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2hvd0NoYW5uZWxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzaG93Q2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNob3dDaGFubmVsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNob3dDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9zaG93YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2hvd0NoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHByZXZpb3VzbHkgaGlkZGVuIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnZpc2libGVcbiAgICAgKiBTaG93IGNoYW5uZWxcbiAgICAgKi9cbiAgICBzaG93Q2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNob3dDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnRydW5jYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQ2hhbm5lbCAtIFRydW5jYXRlQ2hhbm5lbFxuICAgICAqIFRydW5jYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICB0cnVuY2F0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cnVuY2F0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHRydW5jYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50cnVuY2F0ZUNoYW5uZWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnRydW5jYXRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3RydW5jYXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnRydW5jYXRlQ2hhbm5lbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cnVuY2F0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3RydW5jYXRlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudHJ1bmNhdGVDaGFubmVsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudHJ1bmNhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsIC0gVHJ1bmNhdGVDaGFubmVsXG4gICAgICogVHJ1bmNhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHRydW5jYXRlQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnRydW5jYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgY2hhbm5lbCBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudW5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBVbm11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVubXV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51bm11dGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51bm11dGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndW5tdXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5tdXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bm11dGUvY2hhbm5lbGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgY2hhbm5lbCBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudW5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBVbm11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVubXV0ZUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bm11dGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICovXG4gICAgdW5yZWFkQ291bnRzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VucmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICovXG4gICAgdW5yZWFkQ291bnRzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bnJlYWRDb3VudHNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjaGFubmVsIGRhdGEgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnVwZGF0ZWQgLSBtZW1iZXIuYWRkZWQgLSBtZW1iZXIucmVtb3ZlZCAtIG1lbWJlci51cGRhdGVkIC0gbWVzc2FnZS5uZXcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZE93bkNoYW5uZWxNZW1iZXJzaGlwIC0gUmVtb3ZlT3duQ2hhbm5lbE1lbWJlcnNoaXAgLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plbiAtIFVwZGF0ZUNoYW5uZWxNZW1iZXJzXG4gICAgICogVXBkYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY2hhbm5lbCBkYXRhICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkIC0gbWVtYmVyLmFkZGVkIC0gbWVtYmVyLnJlbW92ZWQgLSBtZW1iZXIudXBkYXRlZCAtIG1lc3NhZ2UubmV3ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRPd25DaGFubmVsTWVtYmVyc2hpcCAtIFJlbW92ZU93bkNoYW5uZWxNZW1iZXJzaGlwIC0gVXBkYXRlQ2hhbm5lbCAtIFVwZGF0ZUNoYW5uZWxDb29sZG93biAtIFVwZGF0ZUNoYW5uZWxGcm96ZW4gLSBVcGRhdGVDaGFubmVsTWVtYmVyc1xuICAgICAqIFVwZGF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plblxuICAgICAqIFBhcnRpYWxseSB1cGRhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUGFydGlhbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plblxuICAgICAqIFBhcnRpYWxseSB1cGRhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBDdXN0b21Db21tYW5kc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogQ3JlYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZUNvbW1hbmRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDb21tYW5kUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NvbW1hbmRzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogQ3JlYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY3VzdG9tIGNoYXQgY29tbWFuZFxuICAgICAqIERlbGV0ZSBjb21tYW5kXG4gICAgICovXG4gICAgZGVsZXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogRGVsZXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBkZWxldGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VzdG9tIGNvbW1hbmQgYnkgaXRzIG5hbWVcbiAgICAgKiBHZXQgY29tbWFuZFxuICAgICAqL1xuICAgIGdldENvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY29tbWFuZHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VzdG9tIGNvbW1hbmQgYnkgaXRzIG5hbWVcbiAgICAgKiBHZXQgY29tbWFuZFxuICAgICAqL1xuICAgIGdldENvbW1hbmQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3VzdG9tIGNvbW1hbmRzXG4gICAgICogTGlzdCBjb21tYW5kc1xuICAgICAqL1xuICAgIGxpc3RDb21tYW5kc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3VzdG9tIGNvbW1hbmRzXG4gICAgICogTGlzdCBjb21tYW5kc1xuICAgICAqL1xuICAgIGxpc3RDb21tYW5kcyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdENvbW1hbmRzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGN1c3RvbSBjaGF0IGNvbW1hbmRcbiAgICAgKiBVcGRhdGUgY29tbWFuZFxuICAgICAqL1xuICAgIHVwZGF0ZUNvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNvbW1hbmRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNvbW1hbmRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVDb21tYW5kUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogVXBkYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICB1cGRhdGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIERldmljZXNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlRGV2aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRldmljZSB0byBhIHVzZXIsIGlmIHRoZSBzYW1lIGRldmljZSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICogQ3JlYXRlIGRldmljZVxuICAgICAqL1xuICAgIGNyZWF0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBvbmUgZGV2aWNlXG4gICAgICogRGVsZXRlIGRldmljZVxuICAgICAqL1xuICAgIGRlbGV0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1c2VyX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBvbmUgZGV2aWNlXG4gICAgICogRGVsZXRlIGRldmljZVxuICAgICAqL1xuICAgIGRlbGV0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGRldmljZXNcbiAgICAgKiBMaXN0IGRldmljZXNcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgZGV2aWNlc1xuICAgICAqIExpc3QgZGV2aWNlc1xuICAgICAqL1xuICAgIGxpc3REZXZpY2VzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0RGV2aWNlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIEV2ZW50c0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogU2VuZHMgZXZlbnQgdG8gdGhlIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBhbnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFNlbmRDdXN0b21FdmVudFxuICAgICAqIFNlbmQgZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kRXZlbnRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRFdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRFdmVudFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRFdmVudFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L2V2ZW50YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2VuZEV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBldmVudCB0byB0aGUgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGFueSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VuZEN1c3RvbUV2ZW50XG4gICAgICogU2VuZCBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgY3VzdG9tIGV2ZW50IHRvIGEgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGN1c3RvbVxuICAgICAqIFNlbmQgdXNlciBldmVudFxuICAgICAqL1xuICAgIHNlbmRVc2VyQ3VzdG9tRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1c2VySWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRVc2VyQ3VzdG9tRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRVc2VyQ3VzdG9tRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3t1c2VyX2lkfS9ldmVudGAucmVwbGFjZShgeyR7XCJ1c2VyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGN1c3RvbSBldmVudCB0byBhIHVzZXIgIFNlbmRzIGV2ZW50czogLSBjdXN0b21cbiAgICAgKiBTZW5kIHVzZXIgZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kVXNlckN1c3RvbUV2ZW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFVzZXJDdXN0b21FdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIE1lc3NhZ2VzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgdXBsb2FkZWQgZmlsZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQXR0YWNobWVudFxuICAgICAqIERlbGV0ZSBmaWxlXG4gICAgICovXG4gICAgZGVsZXRlRmlsZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXJsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vZmlsZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IHVwbG9hZGVkIGZpbGUgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUF0dGFjaG1lbnRcbiAgICAgKiBEZWxldGUgZmlsZVxuICAgICAqL1xuICAgIGRlbGV0ZUZpbGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVGaWxlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IHVwbG9hZGVkIGltYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVBdHRhY2htZW50XG4gICAgICogRGVsZXRlIGltYWdlXG4gICAgICovXG4gICAgZGVsZXRlSW1hZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVJbWFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlSW1hZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXJsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vaW1hZ2VgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgcHJldmlvdXNseSB1cGxvYWRlZCBpbWFnZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQXR0YWNobWVudFxuICAgICAqIERlbGV0ZSBpbWFnZVxuICAgICAqL1xuICAgIGRlbGV0ZUltYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlSW1hZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZU1lc3NhZ2VcbiAgICAgKiBEZWxldGUgbWVzc2FnZVxuICAgICAqL1xuICAgIGRlbGV0ZU1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaGFyZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuaGFyZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVkQnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snZGVsZXRlZF9ieSddID0gcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlZEJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZU1lc3NhZ2VcbiAgICAgKiBEZWxldGUgbWVzc2FnZVxuICAgICAqL1xuICAgIGRlbGV0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB1c2VyIHJlYWN0aW9uIGZyb20gdGhlIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVSZWFjdGlvblxuICAgICAqIERlbGV0ZSByZWFjdGlvblxuICAgICAqL1xuICAgIGRlbGV0ZVJlYWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3JlYWN0aW9uL3t0eXBlfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB1c2VyIHJlYWN0aW9uIGZyb20gdGhlIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVSZWFjdGlvblxuICAgICAqIERlbGV0ZSByZWFjdGlvblxuICAgICAqL1xuICAgIGRlbGV0ZVJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlUmVhY3Rpb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdmbGFnUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBmbGFnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL2ZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3QgbWVzc2FnZXMgZm91bmQgYnkgSURzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCBtYW55IG1lc3NhZ2VzXG4gICAgICovXG4gICAgZ2V0TWFueU1lc3NhZ2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0TWFueU1lc3NhZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRNYW55TWVzc2FnZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkcyddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWRzLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9tZXNzYWdlc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG1lc3NhZ2VzIGZvdW5kIGJ5IElEcyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgbWFueSBtZXNzYWdlc1xuICAgICAqL1xuICAgIGdldE1hbnlNZXNzYWdlcyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldE1hbnlNZXNzYWdlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWVzc2FnZSBieSBJRCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgbWVzc2FnZVxuICAgICAqL1xuICAgIGdldE1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0TWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG1lc3NhZ2UgYnkgSUQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBnZXRNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0TWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBPcGVuR3JhcGggYXR0YWNobWVudCBmb3IgYSBsaW5rXG4gICAgICogR2V0IE9HXG4gICAgICovXG4gICAgZ2V0T0dSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1cmwnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9vZ2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIE9wZW5HcmFwaCBhdHRhY2htZW50IGZvciBhIGxpbmtcbiAgICAgKiBHZXQgT0dcbiAgICAgKi9cbiAgICBnZXRPRyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0T0dSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgcmVhY3Rpb25zIG9mIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlYWN0aW9uc1xuICAgICAqL1xuICAgIGdldFJlYWN0aW9uc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRSZWFjdGlvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydsaW1pdCddID0gcmVxdWVzdFBhcmFtZXRlcnMubGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMub2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ29mZnNldCddID0gcmVxdWVzdFBhcmFtZXRlcnMub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH0vcmVhY3Rpb25zYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG9mIHJlYWN0aW9ucyBvZiBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCByZWFjdGlvbnNcbiAgICAgKi9cbiAgICBnZXRSZWFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRSZWFjdGlvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJlcGxpZXMgKHRocmVhZCkgb2YgdGhlIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlcGxpZXNcbiAgICAgKi9cbiAgICBnZXRSZXBsaWVzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3BhcmVudElkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFJlcGxpZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEd0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9ndGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRfZ3QnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWRMdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRfbHRlJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZEx0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkX2x0J10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZEx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEFmdGVyT3JFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2FmdGVyX29yX2VxdWFsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRBZnRlck9yRXF1YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QWZ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snY3JlYXRlZF9hdF9hZnRlciddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QmVmb3JlT3JFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2JlZm9yZV9vcl9lcXVhbCddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QmVmb3JlT3JFcXVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snY3JlYXRlZF9hdF9iZWZvcmUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEJlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEFyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9hcm91bmQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkQXJvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEFyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2Fyb3VuZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QXJvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3twYXJlbnRfaWR9L3JlcGxpZXNgLnJlcGxhY2UoYHske1wicGFyZW50X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByZXBsaWVzICh0aHJlYWQpIG9mIHRoZSBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCByZXBsaWVzXG4gICAgICovXG4gICAgZ2V0UmVwbGllcyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFJlcGxpZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVscyBhcyByZWFkIHVwIHRvIHRoZSBzcGVjaWZpYyBtZXNzYWdlLiBJZiBubyBjaGFubmVscyBpcyBnaXZlbiwgbWFyayBhbGwgY2hhbm5lbCBhcyByZWFkICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5yZWFkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgY2hhbm5lbHMgYXMgcmVhZFxuICAgICAqL1xuICAgIG1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya0NoYW5uZWxzUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya0NoYW5uZWxzUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvcmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1JlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1JlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ21hcmtVbnJlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3VucmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtVbnJlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgbWVzc2FnZSBmbGFncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZE1lc3NhZ2VGbGFnc1xuICAgICAqIFF1ZXJ5IE1lc3NhZ2UgRmxhZ3NcbiAgICAgKi9cbiAgICBxdWVyeU1lc3NhZ2VGbGFnc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vZmxhZ3MvbWVzc2FnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIG1lc3NhZ2UgZmxhZ3MgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRNZXNzYWdlRmxhZ3NcbiAgICAgKiBRdWVyeSBNZXNzYWdlIEZsYWdzXG4gICAgICovXG4gICAgcXVlcnlNZXNzYWdlRmxhZ3MocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5TWVzc2FnZUZsYWdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgbWVzc2FnZSBjb21tYW5kIGFjdGlvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLm5ldyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUnVuTWVzc2FnZUFjdGlvblxuICAgICAqIFJ1biBtZXNzYWdlIGNvbW1hbmQgYWN0aW9uXG4gICAgICovXG4gICAgcnVuTWVzc2FnZUFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBydW5NZXNzYWdlQWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2VBY3Rpb25SZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2VBY3Rpb25SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtZXNzYWdlQWN0aW9uUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubWVzc2FnZUFjdGlvblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBydW5NZXNzYWdlQWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L2FjdGlvbmAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5tZXNzYWdlQWN0aW9uUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBtZXNzYWdlIGNvbW1hbmQgYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UubmV3ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSdW5NZXNzYWdlQWN0aW9uXG4gICAgICogUnVuIG1lc3NhZ2UgY29tbWFuZCBhY3Rpb25cbiAgICAgKi9cbiAgICBydW5NZXNzYWdlQWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucnVuTWVzc2FnZUFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBtZXNzYWdlcyBhY3Jvc3MgY2hhbm5lbHMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzXG4gICAgICovXG4gICAgc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvc2VhcmNoYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXMgYWNyb3NzIGNoYW5uZWxzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFNlYXJjaCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHNlYXJjaChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbmV3IG1lc3NhZ2UgdG8gdGhlIHNwZWNpZmllZCBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5uZXcgLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gQ3JlYXRlTWVzc2FnZSAtIFBpbk1lc3NhZ2UgLSBTa2lwQ2hhbm5lbENvb2xkb3duIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXNlRnJvemVuQ2hhbm5lbFxuICAgICAqIFNlbmQgbmV3IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZE1lc3NhZ2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzZW5kTWVzc2FnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9tZXNzYWdlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2VuZE1lc3NhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG5ldyBtZXNzYWdlIHRvIHRoZSBzcGVjaWZpZWQgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UubmV3IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIENyZWF0ZU1lc3NhZ2UgLSBQaW5NZXNzYWdlIC0gU2tpcENoYW5uZWxDb29sZG93biAtIFNraXBNZXNzYWdlTW9kZXJhdGlvbiAtIFVzZUZyb3plbkNoYW5uZWxcbiAgICAgKiBTZW5kIG5ldyBtZXNzYWdlXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIHJlYWN0aW9uIHRvIHNwZWNpZmllZCBtZXNzYWdlICBTZW5kcyBldmVudHM6IC0gcmVhY3Rpb24ubmV3IC0gcmVhY3Rpb24udXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQ3JlYXRlUmVhY3Rpb24gLSBVc2VGcm96ZW5DaGFubmVsXG4gICAgICogU2VuZCByZWFjdGlvblxuICAgICAqL1xuICAgIHNlbmRSZWFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kUmVhY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuc2VuZFJlYWN0aW9uUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5zZW5kUmVhY3Rpb25SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzZW5kUmVhY3Rpb25SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5zZW5kUmVhY3Rpb25SZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZFJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3JlYWN0aW9uYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRSZWFjdGlvblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgcmVhY3Rpb24gdG8gc3BlY2lmaWVkIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5uZXcgLSByZWFjdGlvbi51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVSZWFjdGlvbiAtIFVzZUZyb3plbkNoYW5uZWxcbiAgICAgKiBTZW5kIHJlYWN0aW9uXG4gICAgICovXG4gICAgc2VuZFJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFJlYWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBtZXNzYWdlIHRvIGEgZ2l2ZW4gbGFuZ3VhZ2UgdXNpbmcgYXV0b21hdGVkIHRyYW5zbGF0aW9uIHNvZnR3YXJlICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFRyYW5zbGF0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgdHJhbnNsYXRlTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cmFuc2xhdGVNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHJhbnNsYXRlTWVzc2FnZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cmFuc2xhdGVNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3RyYW5zbGF0ZWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy50cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG1lc3NhZ2UgdG8gYSBnaXZlbiBsYW5ndWFnZSB1c2luZyBhdXRvbWF0ZWQgdHJhbnNsYXRpb24gc29mdHdhcmUgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogVHJhbnNsYXRlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB0cmFuc2xhdGVNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudHJhbnNsYXRlTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2ZsYWdSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bmZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHByZXZpb3VzbHkgY3JlYXRlZCB1c2VyIG9yIG1lc3NhZ2UgZmxhZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIFVuZmxhZ1xuICAgICAqL1xuICAgIHVuZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVuZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbWVzc2FnZSB3aXRoIG5ldyBkYXRhICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIFBpbk1lc3NhZ2UgLSBTa2lwTWVzc2FnZU1vZGVyYXRpb24gLSBVcGRhdGVNZXNzYWdlXG4gICAgICogVXBkYXRlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZU1lc3NhZ2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBtZXNzYWdlIHdpdGggbmV3IGRhdGEgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gUGluTWVzc2FnZSAtIFNraXBNZXNzYWdlTW9kZXJhdGlvbiAtIFVwZGF0ZU1lc3NhZ2VcbiAgICAgKiBVcGRhdGUgbWVzc2FnZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjZXJ0YWluIGZpZWxkcyBvZiB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBQaW5NZXNzYWdlIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXBkYXRlTWVzc2FnZVxuICAgICAqIFBhcnRpYWxseSBtZXNzYWdlIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUGFydGlhbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVBhcnRpYWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlTWVzc2FnZVBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUGFydGlhbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjZXJ0YWluIGZpZWxkcyBvZiB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBQaW5NZXNzYWdlIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXBkYXRlTWVzc2FnZVxuICAgICAqIFBhcnRpYWxseSBtZXNzYWdlIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlTWVzc2FnZVBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGZpbGUgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgZmlsZVxuICAgICAqL1xuICAgIHVwbG9hZEZpbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRGaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRGaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29uc3VtZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBjb250ZW50VHlwZTogJ211bHRpcGFydC9mb3JtLWRhdGEnIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogY2FuQ29uc3VtZUZvcm0gbWF5IGJlIHVudXNlZFxuICAgICAgICAgICAgY2FuQ29uc3VtZUZvcm0oY29uc3VtZXMpO1xuICAgICAgICAgICAgbGV0IGZvcm1QYXJhbXM7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5maWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JtUGFyYW1zLmFwcGVuZCgnZmlsZScsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vZmlsZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1QYXJhbXMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBmaWxlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGxvYWRBdHRhY2htZW50XG4gICAgICogVXBsb2FkIGZpbGVcbiAgICAgKi9cbiAgICB1cGxvYWRGaWxlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBsb2FkRmlsZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgaW1hZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgaW1hZ2VcbiAgICAgKi9cbiAgICB1cGxvYWRJbWFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwbG9hZEltYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRJbWFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVzID0gW1xuICAgICAgICAgICAgICAgIHsgY29udGVudFR5cGU6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGNhbkNvbnN1bWVGb3JtIG1heSBiZSB1bnVzZWRcbiAgICAgICAgICAgIGNhbkNvbnN1bWVGb3JtKGNvbnN1bWVzKTtcbiAgICAgICAgICAgIGxldCBmb3JtUGFyYW1zO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcy5hcHBlbmQoJ2ZpbGUnLCByZXF1ZXN0UGFyYW1ldGVycy5maWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGxvYWRTaXplcykge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1cGxvYWRfc2l6ZXMnLCByZXF1ZXN0UGFyYW1ldGVycy51cGxvYWRTaXplcy5qb2luKENPTExFQ1RJT05fRk9STUFUU1tcImNzdlwiXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vaW1hZ2VgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtUGFyYW1zLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgaW1hZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgaW1hZ2VcbiAgICAgKi9cbiAgICB1cGxvYWRJbWFnZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwbG9hZEltYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgUGVybWlzc2lvbnNWMkFwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gcm9sZVxuICAgICAqIENyZWF0ZSByb2xlXG4gICAgICovXG4gICAgY3JlYXRlUm9sZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVSb2xlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlUm9sZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVSb2xlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yb2xlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY3VzdG9tIHJvbGVcbiAgICAgKiBDcmVhdGUgcm9sZVxuICAgICAqL1xuICAgIGNyZWF0ZVJvbGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVSb2xlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gcm9sZVxuICAgICAqIERlbGV0ZSByb2xlXG4gICAgICovXG4gICAgZGVsZXRlUm9sZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJvbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yb2xlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gcm9sZVxuICAgICAqIERlbGV0ZSByb2xlXG4gICAgICovXG4gICAgZGVsZXRlUm9sZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVJvbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGN1c3RvbSBwZXJtaXNzaW9uXG4gICAgICogR2V0IHBlcm1pc3Npb25cbiAgICAgKi9cbiAgICBnZXRQZXJtaXNzaW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFBlcm1pc3Npb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wZXJtaXNzaW9ucy97aWR9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXN0b20gcGVybWlzc2lvblxuICAgICAqIEdldCBwZXJtaXNzaW9uXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvbihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFBlcm1pc3Npb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIHBlcm1pc3Npb25zXG4gICAgICogTGlzdCBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIGxpc3RQZXJtaXNzaW9uc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wZXJtaXNzaW9uc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBwZXJtaXNzaW9uc1xuICAgICAqIExpc3QgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICBsaXN0UGVybWlzc2lvbnMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RQZXJtaXNzaW9uc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSByb2xlc1xuICAgICAqIExpc3Qgcm9sZXNcbiAgICAgKi9cbiAgICBsaXN0Um9sZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcm9sZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgcm9sZXNcbiAgICAgKiBMaXN0IHJvbGVzXG4gICAgICovXG4gICAgbGlzdFJvbGVzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Um9sZXNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFB1c2hBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlRGV2aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRldmljZSB0byBhIHVzZXIsIGlmIHRoZSBzYW1lIGRldmljZSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICogQ3JlYXRlIGRldmljZVxuICAgICAqL1xuICAgIGNyZWF0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlciBmcm9tIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydC4gdjEgaXNuXFwndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbmRwb2ludFxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICBkZWxldGVQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlUHVzaFByb3ZpZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcHVzaF9wcm92aWRlcnMve3R5cGV9L3tuYW1lfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXIgZnJvbSB2MiB3aXRoIG11bHRpIGJ1bmRsZS9wYWNrYWdlIHN1cHBvcnQuIHYxIGlzblxcJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW5kcG9pbnRcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyXG4gICAgICovXG4gICAgZGVsZXRlUHVzaFByb3ZpZGVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlUHVzaFByb3ZpZGVyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBkZXRhaWxzIG9mIGFsbCBwdXNoIHByb3ZpZGVycy5cbiAgICAgKiBMaXN0IHB1c2ggcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdFB1c2hQcm92aWRlcnNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcHVzaF9wcm92aWRlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgZGV0YWlscyBvZiBhbGwgcHVzaCBwcm92aWRlcnMuXG4gICAgICogTGlzdCBwdXNoIHByb3ZpZGVyc1xuICAgICAqL1xuICAgIGxpc3RQdXNoUHJvdmlkZXJzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0UHVzaFByb3ZpZGVyc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xubGV0IFNlcnZlclNpZGVBcGkkMSA9IGNsYXNzIFNlcnZlclNpZGVBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXIgZm9yIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydFxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICB1cHNlcnRQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cHNlcnRQdXNoUHJvdmlkZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwc2VydFB1c2hQcm92aWRlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3Vwc2VydFB1c2hQcm92aWRlclJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwc2VydFB1c2hQcm92aWRlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cHNlcnRQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3B1c2hfcHJvdmlkZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcHNlcnQgYSBwdXNoIHByb3ZpZGVyIGZvciB2MiB3aXRoIG11bHRpIGJ1bmRsZS9wYWNrYWdlIHN1cHBvcnRcbiAgICAgKiBVcHNlcnQgYSBwdXNoIHByb3ZpZGVyXG4gICAgICovXG4gICAgdXBzZXJ0UHVzaFByb3ZpZGVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBzZXJ0UHVzaFByb3ZpZGVyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmxldCBTZXR0aW5nc0FwaSQxID0gY2xhc3MgU2V0dGluZ3NBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdGVzdCBtZXNzYWdlIHZpYSBwdXNoLCB0aGlzIGlzIGEgdGVzdCBlbmRwb2ludCB0byB2ZXJpZnkgeW91ciBwdXNoIHNldHRpbmdzXG4gICAgICogQ2hlY2sgcHVzaFxuICAgICAqL1xuICAgIGNoZWNrUHVzaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tQdXNoUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrUHVzaC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfcHVzaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTTlNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NOUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc25zYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU05TIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBDaGVjayBTTlNcbiAgICAgKi9cbiAgICBjaGVja1NOUyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTUVMgY3JlZGVudGlhbHNcbiAgICAgKiBDaGVjayBTUVNcbiAgICAgKi9cbiAgICBjaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NoZWNrU1FTUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tTUVMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoZWNrX3Nxc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTUVNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFwcGxpY2F0aW9uIGJsb2NrbGlzdCwgb25jZSBjcmVhdGVkIHRoZSBibG9ja2xpc3QgY2FuIGJlIHVzZWQgYnkgYW55IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVCbG9ja0xpc3RSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlQmxvY2tMaXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFwcGxpY2F0aW9uIGJsb2NrbGlzdCwgb25jZSBjcmVhdGVkIHRoZSBibG9ja2xpc3QgY2FuIGJlIHVzZWQgYnkgYW55IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlQmxvY2tMaXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgY2hhbm5lbCB0eXBlXG4gICAgICogQ3JlYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IGNyZWF0ZWQgYXBwbGljYXRpb24gYmxvY2tsaXN0XG4gICAgICogRGVsZXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBkZWxldGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgY3JlYXRlZCBhcHBsaWNhdGlvbiBibG9ja2xpc3RcbiAgICAgKiBEZWxldGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGRlbGV0ZUJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyIGZyb20gdjIgd2l0aCBtdWx0aSBidW5kbGUvcGFja2FnZSBzdXBwb3J0LiB2MSBpc25cXCd0IHN1cHBvcnRlZCBpbiB0aGlzIGVuZHBvaW50XG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlclxuICAgICAqL1xuICAgIGRlbGV0ZVB1c2hQcm92aWRlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVB1c2hQcm92aWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVycy97dHlwZX0ve25hbWV9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlciBmcm9tIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydC4gdjEgaXNuXFwndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbmRwb2ludFxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICBkZWxldGVQdXNoUHJvdmlkZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIEdldCBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICBnZXRBcHBSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYXBwYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIEdldCBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICBnZXRBcHAoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldEFwcFJhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBibG9jayBsaXN0IGJ5IGdpdmVuIG5hbWVcbiAgICAgKiBHZXQgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGdldEJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldEJsb2NrTGlzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYmxvY2sgbGlzdCBieSBnaXZlbiBuYW1lXG4gICAgICogR2V0IGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBnZXRCbG9ja0xpc3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJhdGUgbGltaXRzIHVzYWdlIGFuZCBxdW90YXNcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHNcbiAgICAgKi9cbiAgICBnZXRSYXRlTGltaXRzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZXJ2ZXJTaWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3NlcnZlcl9zaWRlJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5zZXJ2ZXJTaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmFuZHJvaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snYW5kcm9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuYW5kcm9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaW9zJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMud2ViICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3dlYiddID0gcmVxdWVzdFBhcmFtZXRlcnMud2ViO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmVuZHBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydlbmRwb2ludHMnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmVuZHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yYXRlX2xpbWl0c2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJhdGUgbGltaXRzIHVzYWdlIGFuZCBxdW90YXNcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHNcbiAgICAgKi9cbiAgICBnZXRSYXRlTGltaXRzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRSYXRlTGltaXRzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGJsb2NrIGxpc3RzXG4gICAgICogTGlzdCBibG9jayBsaXN0c1xuICAgICAqL1xuICAgIGxpc3RCbG9ja0xpc3RzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBibG9jayBsaXN0c1xuICAgICAqIExpc3QgYmxvY2sgbGlzdHNcbiAgICAgKi9cbiAgICBsaXN0QmxvY2tMaXN0cyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdEJsb2NrTGlzdHNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgY2hhbm5lbCB0eXBlc1xuICAgICAqIExpc3QgY2hhbm5lbCB0eXBlc1xuICAgICAqL1xuICAgIGxpc3RDaGFubmVsVHlwZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIGNoYW5uZWwgdHlwZXNcbiAgICAgKiBMaXN0IGNoYW5uZWwgdHlwZXNcbiAgICAgKi9cbiAgICBsaXN0Q2hhbm5lbFR5cGVzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Q2hhbm5lbFR5cGVzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGRldGFpbHMgb2YgYWxsIHB1c2ggcHJvdmlkZXJzLlxuICAgICAqIExpc3QgcHVzaCBwcm92aWRlcnNcbiAgICAgKi9cbiAgICBsaXN0UHVzaFByb3ZpZGVyc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBkZXRhaWxzIG9mIGFsbCBwdXNoIHByb3ZpZGVycy5cbiAgICAgKiBMaXN0IHB1c2ggcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdFB1c2hQcm92aWRlcnMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RQdXNoUHJvdmlkZXJzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIG9uZSBvciBtb3JlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAgICogVXBkYXRlIEFwcCBTZXR0aW5nc1xuICAgICAqL1xuICAgIHVwZGF0ZUFwcFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUFwcFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQXBwUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUFwcC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYXBwYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUFwcFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXBkYXRlcyBvbmUgb3IgbW9yZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIFVwZGF0ZSBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICB1cGRhdGVBcHAocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVBcHBSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNvbnRlbnRzIG9mIHRoZSBibG9jayBsaXN0XG4gICAgICogVXBkYXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICB1cGRhdGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQmxvY2tMaXN0UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVCbG9ja0xpc3RSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQmxvY2tMaXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udGVudHMgb2YgdGhlIGJsb2NrIGxpc3RcbiAgICAgKiBVcGRhdGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIHVwZGF0ZUJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogVXBkYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBUYXNrc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogR2V0cyBzdGF0dXMgb2YgYSB0YXNrXG4gICAgICogR2V0IHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKi9cbiAgICBnZXRUYXNrUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFRhc2suJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC90YXNrcy97aWR9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBzdGF0dXMgb2YgYSB0YXNrXG4gICAgICogR2V0IHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKi9cbiAgICBnZXRUYXNrKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0VGFza1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFRlc3RpbmdBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdGVzdCBtZXNzYWdlIHZpYSBwdXNoLCB0aGlzIGlzIGEgdGVzdCBlbmRwb2ludCB0byB2ZXJpZnkgeW91ciBwdXNoIHNldHRpbmdzXG4gICAgICogQ2hlY2sgcHVzaFxuICAgICAqL1xuICAgIGNoZWNrUHVzaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tQdXNoUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrUHVzaC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfcHVzaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTTlNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NOUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc25zYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU05TIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBDaGVjayBTTlNcbiAgICAgKi9cbiAgICBjaGVja1NOUyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTUVMgY3JlZGVudGlhbHNcbiAgICAgKiBDaGVjayBTUVNcbiAgICAgKi9cbiAgICBjaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NoZWNrU1FTUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tTUVMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoZWNrX3Nxc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTUVNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBVc2Vyc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogUmVzdHJpY3RzIHVzZXIgYWN0aXZpdHkgZWl0aGVyIGluIHNwZWNpZmljIGNoYW5uZWwgb3IgZ2xvYmFsbHkgIFNlbmRzIGV2ZW50czogLSB1c2VyLmJhbm5lZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmFuQ2hhbm5lbE1lbWJlciAtIEJhblVzZXJcbiAgICAgKiBCYW4gdXNlclxuICAgICAqL1xuICAgIGJhblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmJhblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuYmFuUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnYmFuUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuYmFuUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJhbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9iYW5gLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5iYW5SZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RyaWN0cyB1c2VyIGFjdGl2aXR5IGVpdGhlciBpbiBzcGVjaWZpYyBjaGFubmVsIG9yIGdsb2JhbGx5ICBTZW5kcyBldmVudHM6IC0gdXNlci5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogQmFuIHVzZXJcbiAgICAgKi9cbiAgICBiYW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5iYW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIENvbm5lY3QgKFdlYlNvY2tldClcbiAgICAgKi9cbiAgICBjb25uZWN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2pzb24nXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY29ubmVjdGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXIgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBDb25uZWN0IChXZWJTb2NrZXQpXG4gICAgICovXG4gICAgY29ubmVjdChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBndWVzdCB1c2VyXG4gICAgICogQ3JlYXRlIGd1ZXN0XG4gICAgICovXG4gICAgY3JlYXRlR3Vlc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5ndWVzdFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZ3Vlc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdndWVzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmd1ZXN0UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUd1ZXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ndWVzdGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmd1ZXN0UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGd1ZXN0IHVzZXJcbiAgICAgKiBDcmVhdGUgZ3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUd1ZXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgdXNlciB3aXRoIHBvc3NpYmlsaXR5IHRvIGFjdGl2YXRlIGl0IGJhY2sgIFNlbmRzIGV2ZW50czogLSB1c2VyLmRlYWN0aXZhdGVkXG4gICAgICogRGVhY3RpdmF0ZSB1c2VyXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1c2VySWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlYWN0aXZhdGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2VyUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2RlYWN0aXZhdGVVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVhY3RpdmF0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3t1c2VyX2lkfS9kZWFjdGl2YXRlYC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyB1c2VyIHdpdGggcG9zc2liaWxpdHkgdG8gYWN0aXZhdGUgaXQgYmFjayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuZGVhY3RpdmF0ZWRcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlYWN0aXZhdGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZSB1c2VycyBpbiBiYXRjaGVzICBTZW5kcyBldmVudHM6IC0gdXNlci5kZWFjdGl2YXRlZFxuICAgICAqIERlYWN0aXZhdGUgdXNlcnNcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2RlYWN0aXZhdGVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWFjdGl2YXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL2RlYWN0aXZhdGVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGUgdXNlcnMgaW4gYmF0Y2hlcyAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuZGVhY3RpdmF0ZWRcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJzXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVhY3RpdmF0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB1c2VyIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzLiBUaGUgRW5kcG9pbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcXCdEZWxldGUgVXNlcnNcXCcgZW5kcG9pbnQgaW5zdGVhZCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIG1lc3NhZ2UuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICovXG4gICAgZGVsZXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtNZXNzYWdlc0RlbGV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snbWFya19tZXNzYWdlc19kZWxldGVkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5tYXJrTWVzc2FnZXNEZWxldGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmREZWxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaGFyZF9kZWxldGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmREZWxldGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ29udmVyc2F0aW9uQ2hhbm5lbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snZGVsZXRlX2NvbnZlcnNhdGlvbl9jaGFubmVscyddID0gcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ29udmVyc2F0aW9uQ2hhbm5lbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9YC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB1c2VyIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzLiBUaGUgRW5kcG9pbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcXCdEZWxldGUgVXNlcnNcXCcgZW5kcG9pbnQgaW5zdGVhZCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIG1lc3NhZ2UuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICovXG4gICAgZGVsZXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHVzZXJzIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzIGFzeW5jaHJvbm91c2x5LiAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSBVc2Vyc1xuICAgICAqL1xuICAgIGRlbGV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVsZXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvZGVsZXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdXNlcnMgYW5kIG9wdGlvbmFsbHkgYWxsIHRoZWlyIGJlbG9uZ2luZ3MgYXN5bmNocm9ub3VzbHkuICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkIC0gdXNlci5kZWxldGVkXG4gICAgICogRGVsZXRlIFVzZXJzXG4gICAgICovXG4gICAgZGVsZXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHVzZXJcXCdzIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMuIFJhaXNlcyBhbiBlcnJvciBpZiBhIHVzZXIgaGFzIG1vcmUgdGhhbiAxMGsgbWVzc2FnZXMgb3IgcmVhY3Rpb25zXG4gICAgICogRXhwb3J0IHVzZXJcbiAgICAgKi9cbiAgICBleHBvcnRVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXNlcklkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBleHBvcnRVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L2V4cG9ydGAucmVwbGFjZShgeyR7XCJ1c2VyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHVzZXJcXCdzIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMuIFJhaXNlcyBhbiBlcnJvciBpZiBhIHVzZXIgaGFzIG1vcmUgdGhhbiAxMGsgbWVzc2FnZXMgb3IgcmVhY3Rpb25zXG4gICAgICogRXhwb3J0IHVzZXJcbiAgICAgKi9cbiAgICBleHBvcnRVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZXhwb3J0VXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdXNlciBwcm9maWxlLCByZWFjdGlvbnMgYW5kIG1lc3NhZ2VzIGZvciBsaXN0IG9mIGdpdmVuIHVzZXJzXG4gICAgICogRXhwb3J0IHVzZXJzXG4gICAgICovXG4gICAgZXhwb3J0VXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0VXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdleHBvcnRVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydFVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGV4cG9ydFVzZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9leHBvcnQvdXNlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB1c2VyIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMgZm9yIGxpc3Qgb2YgZ2l2ZW4gdXNlcnNcbiAgICAgKiBFeHBvcnQgdXNlcnNcbiAgICAgKi9cbiAgICBleHBvcnRVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmV4cG9ydFVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBtZXNzYWdlIG9yIHVzZXIgZm9yIHJldmlldyBieSBtb2RlcmF0b3JzICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5mbGFnZ2VkIC0gdXNlci5mbGFnZ2VkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogRmxhZ1xuICAgICAqL1xuICAgIGZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZmxhZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9mbGFnYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBtZXNzYWdlIG9yIHVzZXIgZm9yIHJldmlldyBieSBtb2RlcmF0b3JzICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5mbGFnZ2VkIC0gdXNlci5mbGFnZ2VkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogRmxhZ1xuICAgICAqL1xuICAgIGZsYWcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IGZhbGxiYWNrIHRyYW5zcG9ydCBlbmRwb2ludCAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIExvbmcgUG9sbCAoVHJhbnNwb3J0KVxuICAgICAqL1xuICAgIGxvbmdQb2xsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2pzb24nXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2Nvbm5lY3Rpb25faWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9sb25ncG9sbGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IGZhbGxiYWNrIHRyYW5zcG9ydCBlbmRwb2ludCAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIExvbmcgUG9sbCAoVHJhbnNwb3J0KVxuICAgICAqL1xuICAgIGxvbmdQb2xsKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubG9uZ1BvbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgb25lIG9yIHNldmVyYWwgdXNlcnMgIFNlbmRzIGV2ZW50czogLSB1c2VyLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIE11dGUgdXNlclxuICAgICAqL1xuICAgIG11dGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubXV0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbXV0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tdXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtdXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9tdXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubXV0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGVzIG9uZSBvciBzZXZlcmFsIHVzZXJzICBTZW5kcyBldmVudHM6IC0gdXNlci5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZVVzZXJcbiAgICAgKiBNdXRlIHVzZXJcbiAgICAgKi9cbiAgICBtdXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm11dGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgc2NvcGVkIG9yIGdsb2JhbCB1c2VyIGJhbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogUXVlcnkgQmFubmVkIFVzZXJzXG4gICAgICovXG4gICAgcXVlcnlCYW5uZWRVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3F1ZXJ5X2Jhbm5lZF91c2Vyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgc2NvcGVkIG9yIGdsb2JhbCB1c2VyIGJhbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogUXVlcnkgQmFubmVkIFVzZXJzXG4gICAgICovXG4gICAgcXVlcnlCYW5uZWRVc2VycyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlCYW5uZWRVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIGZpbHRlciB1c2VycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VhcmNoVXNlclxuICAgICAqIFF1ZXJ5IHVzZXJzXG4gICAgICovXG4gICAgcXVlcnlVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgdXNlcnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFNlYXJjaFVzZXJcbiAgICAgKiBRdWVyeSB1c2Vyc1xuICAgICAqL1xuICAgIHF1ZXJ5VXNlcnMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5VXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdXNlciB3aG9cXCdzIGJlZW4gZGVhY3RpdmF0ZWQgcHJldmlvdXNseSAgU2VuZHMgZXZlbnRzOiAtIHVzZXIucmVhY3RpdmF0ZWRcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJcbiAgICAgKi9cbiAgICByZWFjdGl2YXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcmVhY3RpdmF0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncmVhY3RpdmF0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGl2YXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyByZWFjdGl2YXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L3JlYWN0aXZhdGVgLnJlcGxhY2UoYHske1widXNlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB1c2VyIHdob1xcJ3MgYmVlbiBkZWFjdGl2YXRlZCBwcmV2aW91c2x5ICBTZW5kcyBldmVudHM6IC0gdXNlci5yZWFjdGl2YXRlZFxuICAgICAqIFJlYWN0aXZhdGUgdXNlclxuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVhY3RpdmF0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJzIGluIGJhdGNoZXMgIFNlbmRzIGV2ZW50czogLSB1c2VyLnJlYWN0aXZhdGVkXG4gICAgICogUmVhY3RpdmF0ZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHJlYWN0aXZhdGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvcmVhY3RpdmF0ZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhY3RpdmF0ZSB1c2VycyBpbiBiYXRjaGVzICBTZW5kcyBldmVudHM6IC0gdXNlci5yZWFjdGl2YXRlZFxuICAgICAqIFJlYWN0aXZhdGUgdXNlcnNcbiAgICAgKi9cbiAgICByZWFjdGl2YXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZWFjdGl2YXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHNvZnQgZGVsZXRlZCB1c2Vyc1xuICAgICAqIFJlc3RvcmUgdXNlcnNcbiAgICAgKi9cbiAgICByZXN0b3JlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5yZXN0b3JlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3Jlc3RvcmVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyByZXN0b3JlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3Jlc3RvcmVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5yZXN0b3JlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgc29mdCBkZWxldGVkIHVzZXJzXG4gICAgICogUmVzdG9yZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlc3RvcmVVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlc3RvcmVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBhcHBsaWVkIGJhbiAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudW5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogVW5iYW4gdXNlclxuICAgICAqL1xuICAgIHVuYmFuUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50YXJnZXRVc2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndGFyZ2V0X3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldFVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3R5cGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRCeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2J5J10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9iYW5gLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBhcHBsaWVkIGJhbiAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudW5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogVW5iYW4gdXNlclxuICAgICAqL1xuICAgIHVuYmFuKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bmJhblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2ZsYWdSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bmZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHByZXZpb3VzbHkgY3JlYXRlZCB1c2VyIG9yIG1lc3NhZ2UgZmxhZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIFVuZmxhZ1xuICAgICAqL1xuICAgIHVuZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVuZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgcHJldmlvdXNseSBtdXRlZCB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIFVubXV0ZSB1c2VyXG4gICAgICovXG4gICAgdW5tdXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1bm11dGVVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bm11dGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL3VubXV0ZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgcHJldmlvdXNseSBtdXRlZCB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIFVubXV0ZSB1c2VyXG4gICAgICovXG4gICAgdW5tdXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVubXV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgb3IgY3JlYXRlIHVzZXJzIGluIGJ1bGsgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBVcHNlcnQgdXNlcnNcbiAgICAgKi9cbiAgICB1cGRhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBvciBjcmVhdGUgdXNlcnMgaW4gYnVsayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIFVwc2VydCB1c2Vyc1xuICAgICAqL1xuICAgIHVwZGF0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci5wcmVzZW5jZS5jaGFuZ2VkIC0gdXNlci51cGRhdGVkXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSB1c2VyXG4gICAgICovXG4gICAgdXBkYXRlVXNlcnNQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2VyUGFydGlhbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVVc2Vyc1BhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci5wcmVzZW5jZS5jaGFuZ2VkIC0gdXNlci51cGRhdGVkXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSB1c2VyXG4gICAgICovXG4gICAgdXBkYXRlVXNlcnNQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlcnNQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFN0cmVhbUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUNsaWVudCwgdHlwZSwgaWQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBzdHJlYW1DbGllbnQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5kZWxldGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuZGVsZXRlQ2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCAocmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDoge30pKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gKHVwZGF0ZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS51cGRhdGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdXBkYXRlQ2hhbm5lbFJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpYWwgPSAodXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS51cGRhdGVDaGFubmVsUGFydGlhbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3JDcmVhdGUgPSAoY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jaGFubmVsc0FwaS5nZXRPckNyZWF0ZUNoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0OiBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0ICE9PSBudWxsICYmIGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgIT09IHZvaWQgMCA/IGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgOiB7fSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgb3BlcmF0aW9uIGlzbid0IHlldCBpbXBsZW1lbnRlZGApO1xuICAgICAgICAgICAgICAgIC8vIGlmICghY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdD8uZGF0YT8ubWVtYmVycykge1xuICAgICAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwcm92aWRlIG1lbWJlcnMgdG8gY3JlYXRlIGEgY2hhbm5lbCB3aXRob3V0IElEJyk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jaGFubmVsc0FwaS5nZXRPckNyZWF0ZUNoYW5uZWxUeXBlMSh7dHlwZTogdGhpcy50eXBlLCBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0fSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5pZCA9IHJlc3BvbnNlLmNoYW5uZWw/LmlkO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya1JlYWQgPSAobWFya1JlYWRSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5tYXJrUmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IG1hcmtSZWFkUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFya1VucmVhZCA9IChtYXJrVW5yZWFkUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkubWFya1VucmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IG1hcmtVbnJlYWRSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93ID0gKHNob3dDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuc2hvd0NoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBzaG93Q2hhbm5lbFJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhpZGUgPSAoaGlkZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5oaWRlQ2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IGhpZGVDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJ1bmNhdGUgPSAodHJ1bmNhdGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkudHJ1bmNhdGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdHJ1bmNhdGVDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucXVlcnlNZW1iZXJzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnF1ZXJ5TWVtYmVycyh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgcmVxdWVzdCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tdXRlID0gKG11dGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkubXV0ZUNoYW5uZWwoe1xuICAgICAgICAgICAgICAgIG11dGVDaGFubmVsUmVxdWVzdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtdXRlQ2hhbm5lbFJlcXVlc3QpLCB7IGNoYW5uZWxfY2lkczogW3RoaXMuY2lkXSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVubXV0ZSA9ICh1bm11dGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkudW5tdXRlQ2hhbm5lbCh7XG4gICAgICAgICAgICAgICAgdW5tdXRlQ2hhbm5lbFJlcXVlc3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdW5tdXRlQ2hhbm5lbFJlcXVlc3QpLCB7IGNoYW5uZWxfY2lkOiB0aGlzLmNpZCwgY2hhbm5lbF9jaWRzOiBbXSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiB0aGVyZSBpcyBwcm9iYWJseSBhbiBpc3N1ZSB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZSBoZXJlXG4gICAgICAgIC8vIHVwbG9hZEZpbGUgPSAob3B0aW9uczogT21pdDxPbWl0VHlwZUlkPFVwbG9hZEZpbGVSZXF1ZXN0PiwgJ2ZpbGUnPiwgZmlsZTogQnVmZmVyKSA9PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudXBsb2FkRmlsZSh7Li4ub3B0aW9ucywgLi4udGhpcy5iYXNlUmVxdWVzdCwgZmlsZTogZmlsZSBhcyBhbnkgYXMgc3RyaW5nfSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZGVsZXRlRmlsZSA9IChyZXF1ZXN0OiBPbWl0VHlwZUlkPERlbGV0ZUZpbGVSZXF1ZXN0PikgPT4ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZUZpbGUoey4uLnJlcXVlc3QsIC4uLnRoaXMuYmFzZVJlcXVlc3R9KTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB1cGxvYWRJbWFnZSA9IChyZXF1ZXN0OiBPbWl0VHlwZUlkPFVwbG9hZEltYWdlUmVxdWVzdD4pID0+IHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS51cGxvYWRJbWFnZSh7Li4ucmVxdWVzdCwgLi4udGhpcy5iYXNlUmVxdWVzdH0pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGRlbGV0ZUltYWdlID0gKHJlcXVlc3Q6IE9taXRUeXBlSWQ8RGVsZXRlSW1hZ2VSZXF1ZXN0PikgPT4ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZUltYWdlKHsuLi5yZXF1ZXN0LCAuLi50aGlzLmJhc2VSZXF1ZXN0fSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IChzZW5kTWVzc2FnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnNlbmRNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgc2VuZE1lc3NhZ2VSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVNZXNzYWdlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZU1lc3NhZ2UocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZSA9IChpZCwgdXBkYXRlTWVzc2FnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnVwZGF0ZU1lc3NhZ2UoeyBpZCwgdXBkYXRlTWVzc2FnZVJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZVBhcnRpYWwgPSAoaWQsIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudXBkYXRlTWVzc2FnZVBhcnRpYWwoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1lc3NhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0TWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNYW55TWVzc2FnZXMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0TWFueU1lc3NhZ2VzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGVNZXNzYWdlID0gKGlkLCB0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudHJhbnNsYXRlTWVzc2FnZSh7IGlkLCB0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlc0Fyb3VuZCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5nZXRSZXBsaWVzKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE9wZW5HcmFwaERhdGEgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0T0cocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VSZWFjdGlvbiA9IChtZXNzYWdlSWQsIHNlbmRSZWFjdGlvblJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnNlbmRSZWFjdGlvbih7XG4gICAgICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBzZW5kUmVhY3Rpb25SZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlTWVzc2FnZVJlYWN0aW9uID0gKG1lc3NhZ2VJZCwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZGVsZXRlUmVhY3Rpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZDogbWVzc2FnZUlkIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlUmVhY3Rpb25zID0gKG1lc3NhZ2VJZCwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0UmVhY3Rpb25zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9KSksIHsgaWQ6IG1lc3NhZ2VJZCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZEN1c3RvbUV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNBcGkuc2VuZEV2ZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgc2VuZEV2ZW50UmVxdWVzdDogeyBldmVudCB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuc3RyZWFtQ2xpZW50LmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5jaGFubmVsc0FwaSA9IG5ldyBDaGFubmVsc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlc0FwaSA9IG5ldyBNZXNzYWdlc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5ldmVudHNBcGkgPSBuZXcgRXZlbnRzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBnZXQgY2lkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlUmVxdWVzdC50eXBlfToke3RoaXMuYmFzZVJlcXVlc3QuaWR9YDtcbiAgICB9XG4gICAgZ2V0IGJhc2VSZXF1ZXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5pdGlhbGl6ZSB0aGUgY2hhbm5lbCB3aXRoIGBnZXRPckNyZWF0ZWAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBTdHJlYW1DaGF0Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1DbGllbnQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBzdHJlYW1DbGllbnQ7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1DaGFubmVsKHRoaXMuc3RyZWFtQ2xpZW50LCB0eXBlLCBpZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlQmxvY2tMaXN0ID0gKGNyZWF0ZUJsb2NrTGlzdFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmNyZWF0ZUJsb2NrTGlzdCh7IGNyZWF0ZUJsb2NrTGlzdFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdEJsb2NrTGlzdHMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5saXN0QmxvY2tMaXN0cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEJsb2NrTGlzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5nZXRCbG9ja0xpc3QocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlQmxvY2tMaXN0ID0gKG5hbWUsIHVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLnVwZGF0ZUJsb2NrTGlzdCh7IG5hbWUsIHVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlQmxvY2tMaXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmRlbGV0ZUJsb2NrTGlzdChyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVDaGFubmVsVHlwZSA9IChjcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxUeXBlc0FwaS5jcmVhdGVDaGFubmVsVHlwZSh7IGNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVDaGFubmVsVHlwZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkuZGVsZXRlQ2hhbm5lbFR5cGUocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q2hhbm5lbFR5cGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGVzQXBpLmdldENoYW5uZWxUeXBlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RDaGFubmVsVHlwZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkubGlzdENoYW5uZWxUeXBlcygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNoYW5uZWxUeXBlID0gKG5hbWUsIHVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGVzQXBpLnVwZGF0ZUNoYW5uZWxUeXBlKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnF1ZXJ5Q2hhbm5lbHMgPSAocXVlcnlDaGFubmVsc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnF1ZXJ5Q2hhbm5lbHMoe1xuICAgICAgICAgICAgICAgIHF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0OiBxdWVyeUNoYW5uZWxzUmVxdWVzdCAhPT0gbnVsbCAmJiBxdWVyeUNoYW5uZWxzUmVxdWVzdCAhPT0gdm9pZCAwID8gcXVlcnlDaGFubmVsc1JlcXVlc3QgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VhcmNoTWVzc2FnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuc2VhcmNoKHsgcGF5bG9hZCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvcnRDaGFubmVscyA9IChleHBvcnRDaGFubmVsc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLmV4cG9ydENoYW5uZWxzKHtcbiAgICAgICAgICAgICAgICBleHBvcnRDaGFubmVsc1JlcXVlc3Q6IGV4cG9ydENoYW5uZWxzUmVxdWVzdCAhPT0gbnVsbCAmJiBleHBvcnRDaGFubmVsc1JlcXVlc3QgIT09IHZvaWQgMCA/IGV4cG9ydENoYW5uZWxzUmVxdWVzdCA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFeHBvcnRTdGF0dXMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXMocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdENvbW1hbmRzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkubGlzdENvbW1hbmRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlQ29tbWFuZCA9IChjcmVhdGVDb21tYW5kUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkuY3JlYXRlQ29tbWFuZCh7IGNyZWF0ZUNvbW1hbmRSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbW1hbmQgPSAoZ2V0Q29tbWFuZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLmdldENvbW1hbmQoZ2V0Q29tbWFuZFJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbW1hbmQgPSAobmFtZSwgdXBkYXRlQ29tbWFuZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLnVwZGF0ZUNvbW1hbmQoeyBuYW1lLCB1cGRhdGVDb21tYW5kUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVDb21tYW5kID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLmRlbGV0ZUNvbW1hbmQocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnN0cmVhbUNsaWVudC5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuc2V0dGluZ3NBcGkgPSBuZXcgU2V0dGluZ3NBcGkkMShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5jaGFubmVsVHlwZXNBcGkgPSBuZXcgQ2hhbm5lbFR5cGVzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNoYW5uZWxzQXBpID0gbmV3IENoYW5uZWxzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRzQXBpID0gbmV3IEN1c3RvbUNvbW1hbmRzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjEwMC40LjNcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5jb25zdCBCQVNFX1BBVEggPSBcImh0dHBzOi8vc3RyZWFtLWlvLWFwaS5jb21cIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIHNldCBjb25maWcoY29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggIT0gbnVsbCA/IHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCA6IEJBU0VfUEFUSDtcbiAgICB9XG4gICAgZ2V0IGZldGNoQXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmZldGNoQXBpO1xuICAgIH1cbiAgICBnZXQgbWlkZGxld2FyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5taWRkbGV3YXJlIHx8IFtdO1xuICAgIH1cbiAgICBnZXQgcXVlcnlQYXJhbXNTdHJpbmdpZnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucXVlcnlQYXJhbXNTdHJpbmdpZnkgfHwgcXVlcnlzdHJpbmc7XG4gICAgfVxuICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi51c2VybmFtZTtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnBhc3N3b3JkO1xuICAgIH1cbiAgICBnZXQgYXBpS2V5KCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5O1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFwaUtleSA9PT0gJ2Z1bmN0aW9uJyA/IGFwaUtleSA6ICgpID0+IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5jb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbicgPyBhY2Nlc3NUb2tlbiA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIGFjY2Vzc1Rva2VuOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5oZWFkZXJzO1xuICAgIH1cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uY3JlZGVudGlhbHM7XG4gICAgfVxufVxuY29uc3QgRGVmYXVsdENvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKCk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWQgQVBJIGNsYXNzZXMuXG4gKi9cbmNsYXNzIEJhc2VBUEkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24gPSBEZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuZmV0Y2hBcGkgPSAodXJsLCBpbml0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hQYXJhbXMgPSB7IHVybCwgaW5pdCB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcyA9ICh5aWVsZCBtaWRkbGV3YXJlLnByZShPYmplY3QuYXNzaWduKHsgZmV0Y2g6IHRoaXMuZmV0Y2hBcGkgfSwgZmV0Y2hQYXJhbXMpKSkgfHwgZmV0Y2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkICh0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGkgfHwgZmV0Y2gpKGZldGNoUGFyYW1zLnVybCwgZmV0Y2hQYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoUGFyYW1zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSA/IHJlc3BvbnNlLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IoZSwgJ1RoZSByZXF1ZXN0IGZhaWxlZCBhbmQgdGhlIGludGVyY2VwdG9ycyBkaWQgbm90IHJldHVybiBhbiBhbHRlcm5hdGl2ZSByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWlkZGxld2FyZS5wb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gKHlpZWxkIG1pZGRsZXdhcmUucG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZmV0Y2hQYXJhbXMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogZmV0Y2hQYXJhbXMuaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlID0gY29uZmlndXJhdGlvbi5taWRkbGV3YXJlO1xuICAgIH1cbiAgICB3aXRoTWlkZGxld2FyZSguLi5taWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBuZXh0Lm1pZGRsZXdhcmUgPSBuZXh0Lm1pZGRsZXdhcmUuY29uY2F0KC4uLm1pZGRsZXdhcmVzKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIHdpdGhQcmVNaWRkbGV3YXJlKC4uLnByZU1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gcHJlTWlkZGxld2FyZXMubWFwKChwcmUpID0+ICh7IHByZSB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKTtcbiAgICB9XG4gICAgd2l0aFBvc3RNaWRkbGV3YXJlKC4uLnBvc3RNaWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBtaWRkbGV3YXJlcyA9IHBvc3RNaWRkbGV3YXJlcy5tYXAoKHBvc3QpID0+ICh7IHBvc3QgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoTWlkZGxld2FyZSguLi5taWRkbGV3YXJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBNSU1FIGlzIGEgSlNPTiBNSU1FLlxuICAgICAqIEpTT04gTUlNRSBleGFtcGxlczpcbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGOFxuICAgICAqICAgQVBQTElDQVRJT04vSlNPTlxuICAgICAqICAgYXBwbGljYXRpb24vdm5kLmNvbXBhbnkranNvblxuICAgICAqIEBwYXJhbSBtaW1lIC0gTUlNRSAoTXVsdGlwdXJwb3NlIEludGVybmV0IE1haWwgRXh0ZW5zaW9ucylcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGdpdmVuIE1JTUUgaXMgSlNPTiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzSnNvbk1pbWUobWltZSkge1xuICAgICAgICBpZiAoIW1pbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmFzZUFQSS5qc29uUmVnZXgudGVzdChtaW1lKTtcbiAgICB9XG4gICAgcmVxdWVzdChjb250ZXh0LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgaW5pdCB9ID0geWllbGQgdGhpcy5jcmVhdGVGZXRjaFBhcmFtcyhjb250ZXh0LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5mZXRjaEFwaSh1cmwsIGluaXQpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihyZXNwb25zZSwgJ1Jlc3BvbnNlIHJldHVybmVkIGFuIGVycm9yIGNvZGUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggKyBjb250ZXh0LnBhdGg7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5xdWVyeSAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKGNvbnRleHQucXVlcnkpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRoZSBxdWVyeXN0cmluZyB0byB0aGUgVVJMIGlmIHRoZXJlIGFyZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZG9uZSB0byBhdm9pZCB1cmxzIGVuZGluZyB3aXRoIGEgXCI/XCIgY2hhcmFjdGVyIHdoaWNoIGJ1Z2d5IHdlYnNlcnZlcnNcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgaGFuZGxlIGNvcnJlY3RseSBzb21ldGltZXMuXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeShjb250ZXh0LnF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZ3VyYXRpb24uaGVhZGVycywgY29udGV4dC5oZWFkZXJzKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IGhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkID8gZGVsZXRlIGhlYWRlcnNba2V5XSA6IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRPdmVycmlkZUZuID0gdHlwZW9mIGluaXRPdmVycmlkZXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gaW5pdE92ZXJyaWRlc1xuICAgICAgICAgICAgICAgIDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gaW5pdE92ZXJyaWRlczsgfSk7XG4gICAgICAgICAgICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBjb250ZXh0LmJvZHksXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY29uZmlndXJhdGlvbi5jcmVkZW50aWFscyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZGVuSW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFBhcmFtcyksICh5aWVsZCBpbml0T3ZlcnJpZGVGbih7XG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdFBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRkZW5Jbml0KSwgeyBib2R5OiBpc0Zvcm1EYXRhKG92ZXJyaWRkZW5Jbml0LmJvZHkpIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRkZW5Jbml0LmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9iKG92ZXJyaWRkZW5Jbml0LmJvZHkpXG4gICAgICAgICAgICAgICAgICAgID8gb3ZlcnJpZGRlbkluaXQuYm9keVxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG92ZXJyaWRkZW5Jbml0LmJvZHkpIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJsLCBpbml0IH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNsb25lIG9mIGB0aGlzYCBieSBjb25zdHJ1Y3RpbmcgYSBuZXcgaW5zdGFuY2VcbiAgICAgKiBhbmQgdGhlbiBzaGFsbG93IGNsb25pbmcgZGF0YSBtZW1iZXJzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXcgY29uc3RydWN0b3IodGhpcy5jb25maWd1cmF0aW9uKTtcbiAgICAgICAgbmV4dC5taWRkbGV3YXJlID0gdGhpcy5taWRkbGV3YXJlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbn1cbkJhc2VBUEkuanNvblJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig6P2FwcGxpY2F0aW9uXFwvanNvbnxbXjsvIFxcdF0rXFwvW147LyBcXHRdK1srXWpzb24pWyBcXHRdKig6PzsuKik/JCcsICdpJyk7XG5mdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYjtcbn1cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlRXJyb3JcIjtcbiAgICB9XG59XG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdXNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIjtcbiAgICB9XG59XG5jbGFzcyBSZXF1aXJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVpcmVkRXJyb3JcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBxdWVyeXN0cmluZyhwYXJhbXMsIHByZWZpeCA9ICcnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLm1hcChrZXkgPT4gcXVlcnlzdHJpbmdTaW5nbGVLZXkoa2V5LCBwYXJhbXNba2V5XSwgcHJlZml4KSlcbiAgICAgICAgLmZpbHRlcihwYXJ0ID0+IHBhcnQubGVuZ3RoID4gMClcbiAgICAgICAgLmpvaW4oJyYnKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nU2luZ2xlS2V5KGtleSwgdmFsdWUsIGtleVByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgZnVsbEtleSA9IGtleVByZWZpeCArIChrZXlQcmVmaXgubGVuZ3RoID8gYFske2tleX1dYCA6IGtleSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgbXVsdGlWYWx1ZSA9IHZhbHVlLm1hcChzaW5nbGVWYWx1ZSA9PiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNpbmdsZVZhbHVlKSkpXG4gICAgICAgICAgICAuam9pbihgJiR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT1gKTtcbiAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09JHttdWx0aVZhbHVlfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBjb25zdCB2YWx1ZUFzQXJyYXkgPSBBcnJheS5mcm9tKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5c3RyaW5nU2luZ2xlS2V5KGtleSwgdmFsdWVBc0FycmF5LCBrZXlQcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvSVNPU3RyaW5nKCkpfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcXVlcnlzdHJpbmcodmFsdWUsIGZ1bGxLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKX1gO1xufVxuY2xhc3MgSlNPTkFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcsIHRyYW5zZm9ybWVyID0gKGpzb25WYWx1ZSkgPT4ganNvblZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtZXIoeWllbGQgdGhpcy5yYXcuanNvbigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVm9pZEFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2MTAwLjQuM1xuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgRGVmYXVsdEFwaSBleHRlbmRzIEJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGEgdXNlciwgcHJldmVudGluZyB0aGVtIGZyb20gam9pbmluZyB0aGUgY2FsbCB1bnRpbCB0aGV5IGFyZSB1bmJsb2NrZWQuICBTZW5kcyBldmVudHM6IC0gY2FsbC5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIEJsb2NrIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9CbG9ja1VzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9CbG9ja1VzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBibG9ja1VzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vYmxvY2tgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsb2NrIGEgdXNlciwgcHJldmVudGluZyB0aGVtIGZyb20gam9pbmluZyB0aGUgY2FsbCB1bnRpbCB0aGV5IGFyZSB1bmJsb2NrZWQuICBTZW5kcyBldmVudHM6IC0gY2FsbC5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIEJsb2NrIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgYmxvY2tVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBkZXZpY2UgdG8gYSB1c2VyLCBpZiB0aGUgc2FtZSBkZXZpY2UgYWxyZWFkeSBleGlzdHMgdGhlIGNhbGwgd2lsbCBoYXZlIG5vIGVmZmVjdFxuICAgICAqIENyZWF0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBjcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVEZXZpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGUgR3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlR3Vlc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2d1ZXN0YCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIEd1ZXN0XG4gICAgICovXG4gICAgY3JlYXRlR3Vlc3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVHdWVzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgb25lIGRldmljZVxuICAgICAqIERlbGV0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBkZWxldGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXNlcl9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG9uZSBkZXZpY2VcbiAgICAgKiBEZWxldGUgZGV2aWNlXG4gICAgICovXG4gICAgZGVsZXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLmVuZGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBFbmRDYWxsXG4gICAgICogRW5kIGNhbGxcbiAgICAgKi9cbiAgICBlbmRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGVuZENhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBlbmRDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9tYXJrX2VuZGVkYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuZW5kZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEVuZENhbGxcbiAgICAgKiBFbmQgY2FsbFxuICAgICAqL1xuICAgIGVuZENhbGwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5lbmRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIEdldCBDYWxsXG4gICAgICovXG4gICAgZ2V0Q2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0Q2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWVtYmVyc0xpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ21lbWJlcnNfbGltaXQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLm1lbWJlcnNMaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5yaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3JpbmcnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubm90aWZ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ25vdGlmeSddID0gcmVxdWVzdFBhcmFtZXRlcnMubm90aWZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogR2V0IENhbGxcbiAgICAgKi9cbiAgICBnZXRDYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGVkZ2VzIGF2YWlsYWJsZSBmb3IgdmlkZW8gY2FsbHMuXG4gICAgICogR2V0IEVkZ2VzXG4gICAgICovXG4gICAgZ2V0RWRnZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZWRnZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBlZGdlcyBhdmFpbGFibGUgZm9yIHZpZGVvIGNhbGxzLlxuICAgICAqIEdldCBFZGdlc1xuICAgICAqL1xuICAgIGdldEVkZ2VzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRFZGdlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBjcmVhdGVzIGEgbmV3IGNhbGwgIFNlbmRzIGV2ZW50czogLSBjYWxsLmNyZWF0ZWQgLSBjYWxsLm5vdGlmaWNhdGlvbiAtIGNhbGwucmluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQ3JlYXRlQ2FsbCAtIFJlYWRDYWxsIC0gVXBkYXRlQ2FsbFNldHRpbmdzXG4gICAgICogR2V0IG9yIGNyZWF0ZSBhIGNhbGxcbiAgICAgKi9cbiAgICBnZXRPckNyZWF0ZUNhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9HZXRPckNyZWF0ZUNhbGxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIGNyZWF0ZXMgYSBuZXcgY2FsbCAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuY3JlYXRlZCAtIGNhbGwubm90aWZpY2F0aW9uIC0gY2FsbC5yaW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVDYWxsIC0gUmVhZENhbGwgLSBVcGRhdGVDYWxsU2V0dGluZ3NcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGEgY2FsbFxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlQ2FsbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldE9yQ3JlYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubGl2ZV9zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbGl2ZVxuICAgICAqL1xuICAgIGdvTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnb0xpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnb0xpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9Hb0xpdmVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR29MaXZlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvR29MaXZlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9Hb0xpdmVSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ29MaXZlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L2dvX2xpdmVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dvTGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubGl2ZV9zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbGl2ZVxuICAgICAqL1xuICAgIGdvTGl2ZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdvTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBkZXZpY2VzXG4gICAgICogTGlzdCBkZXZpY2VzXG4gICAgICovXG4gICAgbGlzdERldmljZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1c2VyX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBkZXZpY2VzXG4gICAgICogTGlzdCBkZXZpY2VzXG4gICAgICovXG4gICAgbGlzdERldmljZXMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3REZXZpY2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgcmVjb3JkaW5ncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTGlzdFJlY29yZGluZ3NcbiAgICAgKiBMaXN0IHJlY29yZGluZ3NcbiAgICAgKi9cbiAgICBsaXN0UmVjb3JkaW5nc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBsaXN0UmVjb3JkaW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGxpc3RSZWNvcmRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9yZWNvcmRpbmdzYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgcmVjb3JkaW5ncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTGlzdFJlY29yZGluZ3NcbiAgICAgKiBMaXN0IHJlY29yZGluZ3NcbiAgICAgKi9cbiAgICBsaXN0UmVjb3JkaW5ncyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RSZWNvcmRpbmdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdHJhbnNjcmlwdGlvbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIExpc3RUcmFuc2NyaXB0aW9uc1xuICAgICAqIExpc3QgdHJhbnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBsaXN0VHJhbnNjcmlwdGlvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbGlzdFRyYW5zY3JpcHRpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbGlzdFRyYW5zY3JpcHRpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS90cmFuc2NyaXB0aW9uc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRyYW5zY3JpcHRpb25zICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBMaXN0VHJhbnNjcmlwdGlvbnNcbiAgICAgKiBMaXN0IHRyYW5zY3JpcHRpb25zXG4gICAgICovXG4gICAgbGlzdFRyYW5zY3JpcHRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdFRyYW5zY3JpcHRpb25zUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgdXNlcnMgaW4gYSBjYWxsICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlcnNcbiAgICAgKiBNdXRlIHVzZXJzXG4gICAgICovXG4gICAgbXV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb011dGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9NdXRlVXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9NdXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb011dGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtdXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vbXV0ZV91c2Vyc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvTXV0ZVVzZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgdXNlcnMgaW4gYSBjYWxsICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlcnNcbiAgICAgKiBNdXRlIHVzZXJzXG4gICAgICovXG4gICAgbXV0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubXV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbHMgd2l0aCBmaWx0ZXIgcXVlcnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogUXVlcnkgY2FsbFxuICAgICAqL1xuICAgIHF1ZXJ5Q2FsbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcXVlcnlDYWxscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNhbGxzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIFF1ZXJ5IGNhbGxcbiAgICAgKi9cbiAgICBxdWVyeUNhbGxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlDYWxsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVycyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENhbGxcbiAgICAgKiBRdWVyeSBjYWxsIG1lbWJlcnNcbiAgICAgKi9cbiAgICBxdWVyeU1lbWJlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBxdWVyeU1lbWJlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwvbWVtYmVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlNZW1iZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbCBtZW1iZXJzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVyc1xuICAgICAqL1xuICAgIHF1ZXJ5TWVtYmVycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5TWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGN1c3RvbSBldmVudCB0byB0aGUgY2FsbCAgU2VuZHMgZXZlbnRzOiAtIGN1c3RvbSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VuZEV2ZW50XG4gICAgICogU2VuZCBjdXN0b20gZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1NlbmRFdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1NlbmRFdmVudFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9ldmVudGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgY3VzdG9tIGV2ZW50IHRvIHRoZSBjYWxsICBTZW5kcyBldmVudHM6IC0gY3VzdG9tICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTZW5kRXZlbnRcbiAgICAgKiBTZW5kIGN1c3RvbSBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBITFMgYnJvYWRjYXN0aW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydEJyb2FkY2FzdGluZ1xuICAgICAqIFN0YXJ0IEhMUyBicm9hZGNhc3RpbmdcbiAgICAgKi9cbiAgICBzdGFydEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydEhMU0Jyb2FkY2FzdGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0SExTQnJvYWRjYXN0aW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9zdGFydF9icm9hZGNhc3RpbmdgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIEhMUyBicm9hZGNhc3RpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0YXJ0QnJvYWRjYXN0aW5nXG4gICAgICogU3RhcnQgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0YXJ0SExTQnJvYWRjYXN0aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRITFNCcm9hZGNhc3RpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcmVjb3JkaW5nICBTZW5kcyBldmVudHM6IC0gY2FsbC5yZWNvcmRpbmdfc3RhcnRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RhcnRSZWNvcmRpbmdcbiAgICAgKiBTdGFydCByZWNvcmRpbmdcbiAgICAgKi9cbiAgICBzdGFydFJlY29yZGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RhcnRfcmVjb3JkaW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyByZWNvcmRpbmcgIFNlbmRzIGV2ZW50czogLSBjYWxsLnJlY29yZGluZ19zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFJlY29yZGluZ1xuICAgICAqIFN0YXJ0IHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0YXJ0UmVjb3JkaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRSZWNvcmRpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJhbnNjcmlwdGlvbiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RhcnRUcmFuc2NyaXB0aW9uXG4gICAgICogU3RhcnQgdHJhbnNjcmlwdGlvblxuICAgICAqL1xuICAgIHN0YXJ0VHJhbnNjcmlwdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRUcmFuc2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0YXJ0X3RyYW5zY3JpcHRpb25gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1N0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0cmFuc2NyaXB0aW9uICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFRyYW5zY3JpcHRpb25cbiAgICAgKiBTdGFydCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RhcnRUcmFuc2NyaXB0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgSExTIGJyb2FkY2FzdGluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RvcEJyb2FkY2FzdGluZ1xuICAgICAqIFN0b3AgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0b3BITFNCcm9hZGNhc3RpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcEhMU0Jyb2FkY2FzdGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BITFNCcm9hZGNhc3RpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfYnJvYWRjYXN0aW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIEhMUyBicm9hZGNhc3RpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BCcm9hZGNhc3RpbmdcbiAgICAgKiBTdG9wIEhMUyBicm9hZGNhc3RpbmdcbiAgICAgKi9cbiAgICBzdG9wSExTQnJvYWRjYXN0aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RvcEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFxuICAgICAqIFNldCBjYWxsIGFzIG5vdCBsaXZlXG4gICAgICovXG4gICAgc3RvcExpdmVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcExpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdG9wTGl2ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RvcF9saXZlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFxuICAgICAqIFNldCBjYWxsIGFzIG5vdCBsaXZlXG4gICAgICovXG4gICAgc3RvcExpdmUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJlY29yZGluZyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucmVjb3JkaW5nX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BSZWNvcmRpbmdcbiAgICAgKiBTdG9wIHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0b3BSZWNvcmRpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BSZWNvcmRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfcmVjb3JkaW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJlY29yZGluZyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucmVjb3JkaW5nX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BSZWNvcmRpbmdcbiAgICAgKiBTdG9wIHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0b3BSZWNvcmRpbmcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wUmVjb3JkaW5nUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdHJhbnNjcmlwdGlvbiAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudHJhbnNjcmlwdGlvbl9zdG9wcGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdG9wVHJhbnNjcmlwdGlvblxuICAgICAqIFN0b3AgdHJhbnNjcmlwdGlvblxuICAgICAqL1xuICAgIHN0b3BUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BUcmFuc2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfdHJhbnNjcmlwdGlvbmAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0cmFuc2NyaXB0aW9uICBTZW5kcyBldmVudHM6IC0gY2FsbC50cmFuc2NyaXB0aW9uX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BUcmFuc2NyaXB0aW9uXG4gICAgICogU3RvcCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RvcFRyYW5zY3JpcHRpb24ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wVHJhbnNjcmlwdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGJsb2NrIGZvciBhIHVzZXIgb24gYSBjYWxsLiBUaGUgdXNlciB3aWxsIGJlIGFibGUgdG8gam9pbiB0aGUgY2FsbCBhZ2Fpbi4gIFNlbmRzIGV2ZW50czogLSBjYWxsLnVuYmxvY2tlZF91c2VyICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBCbG9ja1VzZXJcbiAgICAgKiBVbmJsb2NrcyB1c2VyIG9uIGEgY2FsbFxuICAgICAqL1xuICAgIHVuYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuYmxvY2tVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5ibG9ja1VzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bmJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS91bmJsb2NrYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGJsb2NrIGZvciBhIHVzZXIgb24gYSBjYWxsLiBUaGUgdXNlciB3aWxsIGJlIGFibGUgdG8gam9pbiB0aGUgY2FsbCBhZ2Fpbi4gIFNlbmRzIGV2ZW50czogLSBjYWxsLnVuYmxvY2tlZF91c2VyICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBCbG9ja1VzZXJcbiAgICAgKiBVbmJsb2NrcyB1c2VyIG9uIGEgY2FsbFxuICAgICAqL1xuICAgIHVuYmxvY2tVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudW5ibG9ja1VzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxcbiAgICAgKiBVcGRhdGUgQ2FsbFxuICAgICAqL1xuICAgIHVwZGF0ZUNhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9VcGRhdGVDYWxsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogVXBkYXRlIENhbGxcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubWVtYmVyX2FkZGVkIC0gY2FsbC5tZW1iZXJfcmVtb3ZlZCAtIGNhbGwubWVtYmVyX3VwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlbW92ZUNhbGxNZW1iZXIgLSBVcGRhdGVDYWxsTWVtYmVyIC0gVXBkYXRlQ2FsbE1lbWJlclJvbGVcbiAgICAgKiBVcGRhdGUgQ2FsbCBNZW1iZXJcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsTWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsTWVtYmVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGxNZW1iZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9VcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbE1lbWJlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vbWVtYmVyc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLm1lbWJlcl9hZGRlZCAtIGNhbGwubWVtYmVyX3JlbW92ZWQgLSBjYWxsLm1lbWJlcl91cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZW1vdmVDYWxsTWVtYmVyIC0gVXBkYXRlQ2FsbE1lbWJlciAtIFVwZGF0ZUNhbGxNZW1iZXJSb2xlXG4gICAgICogVXBkYXRlIENhbGwgTWVtYmVyXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbE1lbWJlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDYWxsTWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBwZXJtaXNzaW9ucyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucGVybWlzc2lvbnNfdXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFBlcm1pc3Npb25zXG4gICAgICogVXBkYXRlIHVzZXIgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVVc2VyUGVybWlzc2lvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlclBlcm1pc3Npb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlclBlcm1pc3Npb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZVVzZXJQZXJtaXNzaW9ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS91c2VyX3Blcm1pc3Npb25zYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHVzZXIgcGVybWlzc2lvbnMgIFNlbmRzIGV2ZW50czogLSBjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxQZXJtaXNzaW9uc1xuICAgICAqIFVwZGF0ZSB1c2VyIHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgdXBkYXRlVXNlclBlcm1pc3Npb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXIgdG8gdmlkZW8gIFNlbmRzIGV2ZW50czogLSBjb25uZWN0aW9uLm9rIC0gaGVhbHRoLmNoZWNrXG4gICAgICogVmlkZW8gQ29ubmVjdCAoV2ViU29ja2V0KVxuICAgICAqL1xuICAgIHZpZGVvQ29ubmVjdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9XU0F1dGhNZXNzYWdlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb0Nvbm5lY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2Nvbm5lY3RgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciB1c2VyIHRvIHZpZGVvICBTZW5kcyBldmVudHM6IC0gY29ubmVjdGlvbi5vayAtIGhlYWx0aC5jaGVja1xuICAgICAqIFZpZGVvIENvbm5lY3QgKFdlYlNvY2tldClcbiAgICAgKi9cbiAgICB2aWRlb0Nvbm5lY3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudmlkZW9Db25uZWN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpbnMgYSB0cmFjayBmb3IgYWxsIHVzZXJzIGluIHRoZSBjYWxsLiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUGluQ2FsbFRyYWNrXG4gICAgICogUGluXG4gICAgICovXG4gICAgdmlkZW9QaW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdmlkZW9QaW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1Bpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9QaW5SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9QaW5SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1Bpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9waW5gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpbnMgYSB0cmFjayBmb3IgYWxsIHVzZXJzIGluIHRoZSBjYWxsLiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUGluQ2FsbFRyYWNrXG4gICAgICogUGluXG4gICAgICovXG4gICAgdmlkZW9QaW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy52aWRlb1BpblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBVbnBpblxuICAgICAqL1xuICAgIHZpZGVvVW5waW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdmlkZW9VbnBpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHZpZGVvVW5waW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VucGluUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1VucGluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3VucGluYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBVbnBpblxuICAgICAqL1xuICAgIHZpZGVvVW5waW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy52aWRlb1VucGluUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHYxMDAuNC4zXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBTZXJ2ZXJTaWRlQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgY2hlY2tFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tFeHRlcm5hbFN0b3JhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9leHRlcm5hbF9zdG9yYWdlL3tuYW1lfS9jaGVja2AucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgY2hlY2tFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jaGVja0V4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZUNhbGxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlbGV0ZSBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBkZWxldGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVsZXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldCBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBnZXRDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0IENhbGwgVHlwZVxuICAgICAqL1xuICAgIGdldENhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExpc3QgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgbGlzdENhbGxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExpc3QgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgbGlzdENhbGxUeXBlcyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdENhbGxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXBkYXRlIEV4dGVybmFsIFN0b3JhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUV4dGVybmFsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZS97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgdXBkYXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHYxMDAuNC4zXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBTZXR0aW5nc0FwaSBleHRlbmRzIEJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKiBDcmVhdGUgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGNyZWF0ZUV4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUV4dGVybmFsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIENyZWF0ZSBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgY3JlYXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBleHRlcm5hbCBzdG9yYWdlXG4gICAgICogRGVsZXRlIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBkZWxldGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZS97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIERlbGV0ZSBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgZGVsZXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIExpc3QgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGxpc3RFeHRlcm5hbFN0b3JhZ2VSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKiBMaXN0IGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBsaXN0RXh0ZXJuYWxTdG9yYWdlKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0RXh0ZXJuYWxTdG9yYWdlUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtQ2FsbCB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtQ2xpZW50LCB0eXBlLCBpZCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmJsb2NrVXNlciA9ICh2aWRlb0Jsb2NrVXNlclJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5ibG9ja1VzZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb0Jsb2NrVXNlclJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZENhbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuZW5kQ2FsbChPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5nZXRDYWxsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9KSksIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPckNyZWF0ZSA9ICh2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5nZXRPckNyZWF0ZUNhbGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3Q6IHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCAhPT0gbnVsbCAmJiB2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QgIT09IHZvaWQgMCA/IHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCA6IHt9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSAoZ2V0T3JDcmVhdGVDYWxsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JDcmVhdGUoZ2V0T3JDcmVhdGVDYWxsUmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29MaXZlID0gKHZpZGVvR29MaXZlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LmdvTGl2ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvR29MaXZlUmVxdWVzdDogdmlkZW9Hb0xpdmVSZXF1ZXN0ICE9PSBudWxsICYmIHZpZGVvR29MaXZlUmVxdWVzdCAhPT0gdm9pZCAwID8gdmlkZW9Hb0xpdmVSZXF1ZXN0IDoge30gfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RSZWNvcmRpbmdzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50Lmxpc3RSZWNvcmRpbmdzKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0VHJhbnNjcmlwdGlvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQubGlzdFRyYW5zY3JpcHRpb25zKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tdXRlVXNlcnMgPSAodmlkZW9NdXRlVXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQubXV0ZVVzZXJzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9NdXRlVXNlcnNSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWVyeU1lbWJlcnMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnF1ZXJ5TWVtYmVycyh7XG4gICAgICAgICAgICAgICAgdmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChyZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSkpLCB0aGlzLmJhc2VSZXF1ZXN0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRDdXN0b21FdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnNlbmRFdmVudChPYmplY3QuYXNzaWduKHsgdmlkZW9TZW5kRXZlbnRSZXF1ZXN0OiB7IGN1c3RvbTogZXZlbnQgfSB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRITFNCcm9hZGNhc3RpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RhcnRITFNCcm9hZGNhc3RpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5zdGFydFJlY29yZGluZyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0OiByZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRUcmFuc2NyaXB0aW9uID0gKHZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RhcnRUcmFuc2NyaXB0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wSExTQnJvYWRjYXN0aW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BITFNCcm9hZGNhc3RpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BMaXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BMaXZlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BSZWNvcmRpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BUcmFuc2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BUcmFuc2NyaXB0aW9uKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bmJsb2NrVXNlciA9ICh2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVuYmxvY2tVc2VyKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gKHZpZGVvVXBkYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC51cGRhdGVDYWxsKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsTWVtYmVycyA9ICh2aWRlb1VwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwZGF0ZUNhbGxNZW1iZXJzKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zID0gKHZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyhPYmplY3QuYXNzaWduKHsgdmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5waW5WaWRlbyA9ICh2aWRlb1BpblJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC52aWRlb1BpbihPYmplY3QuYXNzaWduKHsgdmlkZW9QaW5SZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bnBpblZpZGVvID0gKHZpZGVvVW5waW5SZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQudmlkZW9VbnBpbihPYmplY3QuYXNzaWduKHsgdmlkZW9VbnBpblJlcXVlc3QgfSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhc2VSZXF1ZXN0ID0geyBpZDogdGhpcy5pZCwgdHlwZTogdGhpcy50eXBlIH07XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnN0cmVhbUNsaWVudC5nZXRDb25maWd1cmF0aW9uKCd2aWRlbycpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBEZWZhdWx0QXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtVmlkZW9DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUNsaWVudCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy5jYWxsID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUNhbGwodGhpcy5zdHJlYW1DbGllbnQsIHR5cGUsIGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWVyeUNhbGxzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5xdWVyeUNhbGxzKHtcbiAgICAgICAgICAgICAgICB2aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0OiByZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbGxUeXBlID0gKHZpZGVvQ3JlYXRlQ2FsbFR5cGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQuY3JlYXRlQ2FsbFR5cGUoe1xuICAgICAgICAgICAgICAgIHZpZGVvQ3JlYXRlQ2FsbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FsbFR5cGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LmRlbGV0ZUNhbGxUeXBlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENhbGxUeXBlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudC5nZXRDYWxsVHlwZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0Q2FsbFR5cGVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50Lmxpc3RDYWxsVHlwZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsVHlwZSA9IChuYW1lLCB2aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LnVwZGF0ZUNhbGxUeXBlKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZpZGVvVXBkYXRlQ2FsbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdEV4dGVybmFsU3RvcmFnZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5saXN0RXh0ZXJuYWxTdG9yYWdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlID0gKHZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlKHtcbiAgICAgICAgICAgICAgICB2aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVFeHRlcm5hbFN0b3JhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuZGVsZXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVybmFsU3RvcmFnZSA9IChuYW1lLCB2aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudC51cGRhdGVFeHRlcm5hbFN0b3JhZ2Uoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hlY2tFeHRlcm5hbFN0b3JhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LmNoZWNrRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5zdHJlYW1DbGllbnQuZ2V0Q29uZmlndXJhdGlvbigndmlkZW8nKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgRGVmYXVsdEFwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0FwaSA9IG5ldyBTZXR0aW5nc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQgPSBuZXcgU2VydmVyU2lkZUFwaShjb25maWd1cmF0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEpXVFVzZXJUb2tlbihhcGlTZWNyZXQsIHVzZXJJZCwgZXh0cmFEYXRhID0ge30sIGp3dE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2VySWQgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgdXNlcl9pZDogdXNlcklkIH0sIGV4dHJhRGF0YSk7XG4gICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIGNsZWFyIGVycm9yIHdoZW4gand0IGlzIHNoaW1tZWQgKGllLiBicm93c2VyIGJ1aWxkKVxuICAgIGlmIChqd3QgPT0gbnVsbCB8fCBqd3Quc2lnbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBqd3QgY3J5cHRvLCBpZiB5b3UgYXJlIGdldHRpbmcgdGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHlvdSBhcmUgdHJ5aW5nIHRvIGdlbmVyYXRlIHRva2VucyBvbiBicm93c2VyIG9yIFJlYWN0IE5hdGl2ZSAob3Igb3RoZXIgZW52aXJvbm1lbnQgd2hlcmUgY3J5cHRvIGZ1bmN0aW9ucyBhcmUgbm90IGF2YWlsYWJsZSkuIFBsZWFzZSBOb3RlOiB0b2tlbiBzaG91bGQgb25seSBiZSBnZW5lcmF0ZWQgc2VydmVyLXNpZGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgYWxnb3JpdGhtOiAnSFMyNTYnLCBub1RpbWVzdGFtcDogdHJ1ZSB9LCBqd3RPcHRpb25zKTtcbiAgICBpZiAocGF5bG9hZC5pYXQpIHtcbiAgICAgICAgb3B0cy5ub1RpbWVzdGFtcCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgYXBpU2VjcmV0LCBvcHRzKTtcbn1cbmZ1bmN0aW9uIEpXVFNlcnZlclRva2VuKGFwaVNlY3JldCwgand0T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc2VydmVyOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBhbGdvcml0aG06ICdIUzI1NicsIG5vVGltZXN0YW1wOiB0cnVlIH0sIGp3dE9wdGlvbnMpO1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhcGlTZWNyZXQsIG9wdHMpO1xufVxuXG5jbGFzcyBTdHJlYW1DbGllbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFwaUtleVxuICAgICAqIEBwYXJhbSBzZWNyZXRcbiAgICAgKiBAcGFyYW0gY29uZmlnIGNhbiBiZSBhIHN0cmluZywgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBiYXNlIHBhdGggKGRlcHJlY2F0ZWQpLCBvciBhIGNvbmZpZyBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIHNlY3JldCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuY3JlYXRlRGV2aWNlID0gKGNyZWF0ZURldmljZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldmljZXNBcGkuY3JlYXRlRGV2aWNlKHsgY3JlYXRlRGV2aWNlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVEZXZpY2UgPSAocmVxdWVzdFBhcmFtZXRlcnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldmljZXNBcGkuZGVsZXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0RGV2aWNlcyA9IChyZXF1ZXN0UGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlc0FwaS5saXN0RGV2aWNlcyhyZXF1ZXN0UGFyYW1ldGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdFB1c2hQcm92aWRlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoQXBpLmxpc3RQdXNoUHJvdmlkZXJzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlUHVzaFByb3ZpZGVyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hBcGkuZGVsZXRlUHVzaFByb3ZpZGVyKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwc2VydFB1c2hQcm92aWRlciA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJzaWRlQXBpLnVwc2VydFB1c2hQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgdXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdDogeyBwdXNoX3Byb3ZpZGVyOiByZXF1ZXN0IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGVja1B1c2ggPSAoY2hlY2tQdXNoUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVzdGluZ0FwaS5jaGVja1B1c2goeyBjaGVja1B1c2hSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUd1ZXN0ID0gKGd1ZXN0UmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZ3Vlc3RSZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKGd1ZXN0UmVxdWVzdC51c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5jcmVhdGVHdWVzdCh7IGd1ZXN0UmVxdWVzdCB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUocmVzcG9uc2UudXNlcik7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhblVzZXIgPSAoYmFuUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgYmFuUmVxdWVzdC51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZChiYW5SZXF1ZXN0LnVzZXIpO1xuICAgICAgICAgICAgYmFuUmVxdWVzdC5iYW5uZWRfYnkgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKGJhblJlcXVlc3QuYmFubmVkX2J5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmJhbih7IGJhblJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZVVzZXIgPSAoZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkuZGVhY3RpdmF0ZVVzZXIoe1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IGRlYWN0aXZhdGVVc2VyUmVxdWVzdC51c2VyX2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZS51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlVXNlcnMgPSAoZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkuZGVhY3RpdmF0ZVVzZXJzKHsgZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBgZGVsZXRlVXNlcnNgIGluc3RlYWRcbiAgICAgICAgICogQHBhcmFtIGRlbGV0ZVVzZXJzUmVxdWVzdFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGVVc2VyID0gKHJlcXVlc3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5kZWxldGVVc2VyKHJlcXVlc3QpO1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2VyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsZXRlVXNlcnMgPSAoZGVsZXRlVXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS5kZWxldGVVc2Vycyh7IGRlbGV0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvcnRVc2VyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmV4cG9ydFVzZXIocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXhwb3J0VXNlcnMgPSAoZXhwb3J0VXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS5leHBvcnRVc2Vycyh7IGV4cG9ydFVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mbGFnID0gKGZsYWdSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgZmxhZ1JlcXVlc3QudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQoZmxhZ1JlcXVlc3QudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkuZmxhZyh7IGZsYWdSZXF1ZXN0IH0pO1xuICAgICAgICAgICAgaWYgKChfYiA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZmxhZy51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKChfYyA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlCYW5uZWRVc2VycyA9IChwYXlsb2FkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHBheWxvYWQudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkucXVlcnlCYW5uZWRVc2Vycyh7IHBheWxvYWQgfSk7XG4gICAgICAgICAgICByZXNwb25zZS5iYW5zLmZvckVhY2goKGIpID0+IHtcbiAgICAgICAgICAgICAgICBiLmJhbm5lZF9ieSA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShiLmJhbm5lZF9ieSk7XG4gICAgICAgICAgICAgICAgYi51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKGIudXNlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlVc2VycyA9IChwYXlsb2FkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHBheWxvYWQudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkucXVlcnlVc2Vycyh7IHBheWxvYWQgfSk7XG4gICAgICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlcnMgPSByZXNwb25zZS51c2Vycy5tYXAoKHUpID0+IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZSh1KSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWN0aXZhdGVVc2VyID0gKHJlYWN0aXZhdGVVc2VyUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnJlYWN0aXZhdGVVc2VyKHtcbiAgICAgICAgICAgICAgICByZWFjdGl2YXRlVXNlclJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdXNlcklkOiByZWFjdGl2YXRlVXNlclJlcXVlc3QudXNlcl9pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhY3RpdmF0ZVVzZXJzID0gKHJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnJlYWN0aXZhdGVVc2Vycyh7IHJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzdG9yZVVzZXJzID0gKHJlc3RvcmVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnJlc3RvcmVVc2Vycyh7IHJlc3RvcmVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5iYW5Vc2VyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnVuYmFuKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuZmxhZyA9IChmbGFnUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9kO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnVuZmxhZyh7IGZsYWdSZXF1ZXN0IH0pO1xuICAgICAgICAgICAgaWYgKChfZCA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZmxhZy51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLmZsYWcudXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwc2VydFVzZXJzID0gKHVwZGF0ZVVzZXJzUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModXBkYXRlVXNlcnNSZXF1ZXN0LnVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVVc2Vyc1JlcXVlc3QudXNlcnNba2V5XSA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQodXBkYXRlVXNlcnNSZXF1ZXN0LnVzZXJzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkudXBkYXRlVXNlcnMoeyB1cGRhdGVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyZXNwb25zZS51c2VycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UudXNlcnNba2V5XSA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2Vyc1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVVc2Vyc1BhcnRpYWwgPSAocmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnVwZGF0ZVVzZXJzUGFydGlhbCh7XG4gICAgICAgICAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB1cGRhdGVVc2VyUGFydGlhbFJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3BvbnNlLnVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS51c2Vyc1trZXldID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXJzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11dGVVc2VyID0gKG11dGVVc2VyUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9lLCBfZjtcbiAgICAgICAgICAgIG11dGVVc2VyUmVxdWVzdC51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZChtdXRlVXNlclJlcXVlc3QudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkubXV0ZVVzZXIoeyBtdXRlVXNlclJlcXVlc3QgfSk7XG4gICAgICAgICAgICBpZiAoKF9lID0gcmVzcG9uc2UubXV0ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tdXRlLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUoKF9mID0gcmVzcG9uc2UubXV0ZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm11dGVzKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UubXV0ZXMgPSByZXNwb25zZS5tdXRlcy5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgdXNlcjogdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKG0udXNlcikgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVubXV0ZVVzZXIgPSAodW5tdXRlVXNlclJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHVubXV0ZVVzZXJSZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHVubXV0ZVVzZXJSZXF1ZXN0LnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkudW5tdXRlVXNlcih7IHVubXV0ZVVzZXJSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRDdXN0b21FdmVudFRvVXNlciA9ICh1c2VySWQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNBcGkuc2VuZFVzZXJDdXN0b21FdmVudCh7XG4gICAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICAgIHNlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0OiB7IGV2ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVSb2xlID0gKGNyZWF0ZVJvbGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5jcmVhdGVSb2xlKHsgY3JlYXRlUm9sZVJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlUm9sZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5kZWxldGVSb2xlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFBlcm1pc3Npb24gPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVybWlzc2lvbnNBcGkuZ2V0UGVybWlzc2lvbihyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0UGVybWlzc2lvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5saXN0UGVybWlzc2lvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0Um9sZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5saXN0Um9sZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRBcHBTZXR0aW5ncyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmdldEFwcCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUFwcFNldHRpbmdzID0gKHVwZGF0ZUFwcFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLnVwZGF0ZUFwcCh7IHVwZGF0ZUFwcFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmF0ZUxpbWl0cyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmdldFJhdGVMaW1pdHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRUYXNrU3RhdHVzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhc2tzQXBpLmdldFRhc2socmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmVyaWZ5V2ViaG9vayA9IChyZXF1ZXN0Qm9keSwgeFNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20odGhpcy5zZWNyZXQsICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvXG4gICAgICAgICAgICAgICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGtleSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLnRpbWluZ1NhZmVFcXVhbChCdWZmZXIuZnJvbShoYXNoKSwgQnVmZmVyLmZyb20oeFNpZ25hdHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDb25maWd1cmF0aW9uID0gKHByb2R1Y3QgPSAnY2hhdCcpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYXBpS2V5OiAobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1N0cmVhbS1BdXRoLVR5cGUnOiAnand0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpcy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdbbmFtZV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYXNlUGF0aDogKF9hID0gdGhpcy5vcHRpb25zLmJhc2VQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocHJvZHVjdCA9PT0gJ2NoYXQnXG4gICAgICAgICAgICAgICAgICAgID8gJ2h0dHBzOi8vY2hhdC5zdHJlYW0taW8tYXBpLmNvbSdcbiAgICAgICAgICAgICAgICAgICAgOiAnaHR0cHM6Ly92aWRlby5zdHJlYW0taW8tYXBpLmNvbScpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1gtU3RyZWFtLUNsaWVudCc6ICdzdHJlYW0tbm9kZS0nICsgXCIwLjEuMTNcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaW5pdC5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmluaXQuaGVhZGVycyksIHsgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiB2NCgpLCAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgbGFzdCBwb3N0IG1pZGRsZXdhcmUgYmVjYXVzZSB0aGF0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBGZXRjaCBBUEkgd29uJ3QgdGhyb3cgYW4gZXJyb3IgZm9yIEhUVFAgZXJyb3IgcmVzcG9uc2VzLCB3aGljaCBtZWFucyB0aGUgXCJvbkVycm9yXCIgbWlkZGxld2FyZSB3b24ndCBiZSBjYWxsZWQgc28gd2UgbmVlZCB0byB0aHJvdyBlcnJvciBmcm9tIFwicG9zdFwiIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Q6IChjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250ZXh0LnJlc3BvbnNlICYmIGNvbnRleHQucmVzcG9uc2Uuc3RhdHVzIDwgMjAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3BvbnNlLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgSlNPTkFwaVJlc3BvbnNlKGNvbnRleHQucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICh5aWVsZCByZXNwb25zZS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJlYW0gZXJyb3IgY29kZSAke3ZhbHVlLmNvZGV9OiAke3ZhbHVlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZTogKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmluaXQuc2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dCh0aGlzLm9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY29udGV4dC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKGVycm9yLCBgVGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQgZHVlIHRvIHRvIHRoZSAke3RoaXMub3B0aW9ucy50aW1lb3V0fW1zIHRpbWVvdXQsIHlvdSBjYW4gc2V0IHRoZSB0aW1lb3V0IGluIHRoZSBTdHJlYW1DbGllbnQgY29uc3RydWN0b3JgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vT3BlbkFQSVRvb2xzL29wZW5hcGktZ2VuZXJhdG9yL2lzc3Vlcy8xMzIyMlxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zU3RyaW5naWZ5OiAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXNba10pIHx8IHR5cGVvZiBwYXJhbXNba10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zLnB1c2goYCR7a309JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tdKSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcy5wdXNoKGAke2t9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcy5qb2luKCcmJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2VydmVkS2V5d29yZHMgPSBbXG4gICAgICAgICAgICAnYmFuX2V4cGlyZXMnLFxuICAgICAgICAgICAgJ2Jhbm5lZCcsXG4gICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgJ2ludmlzaWJsZScsXG4gICAgICAgICAgICAnbGFuZ3VhZ2UnLFxuICAgICAgICAgICAgJ3B1c2hfbm90aWZpY2F0aW9ucycsXG4gICAgICAgICAgICAncmV2b2tlX3Rva2Vuc19pc3N1ZWRfYmVmb3JlJyxcbiAgICAgICAgICAgICdyb2xlJyxcbiAgICAgICAgICAgICd0ZWFtcycsXG4gICAgICAgICAgICAnY3JlYXRlZF9hdCcsXG4gICAgICAgICAgICAnZGVhY3RpdmF0ZWRfYXQnLFxuICAgICAgICAgICAgJ2RlbGV0ZWRfYXQnLFxuICAgICAgICAgICAgJ2xhc3RfYWN0aXZlJyxcbiAgICAgICAgICAgICdvbmxpbmUnLFxuICAgICAgICAgICAgJ3VwZGF0ZWRfYXQnLFxuICAgICAgICAgICAgJ3NoYWRvd19iYW5uZWQnLFxuICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZCA9ICh1c2VyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIHVzZXIpO1xuICAgICAgICAgICAgZGVsZXRlIGNvcHkuY3VzdG9tO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weSksIHVzZXIuY3VzdG9tKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b2tlbiA9IEpXVFNlcnZlclRva2VuKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmFzZVBhdGggPSBjb25maWc7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudGltZW91dCA9IFN0cmVhbUNsaWVudC5ERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRpbWVvdXQgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyZWFtQ2xpZW50LkRFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZGVvID0gbmV3IFN0cmVhbVZpZGVvQ2xpZW50KHRoaXMpO1xuICAgICAgICB0aGlzLmNoYXQgPSBuZXcgU3RyZWFtQ2hhdENsaWVudCh0aGlzKTtcbiAgICAgICAgY29uc3QgY2hhdENvbmZpZ3VyYXRpb24gPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy51c2Vyc0FwaSA9IG5ldyBVc2Vyc0FwaShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuZGV2aWNlc0FwaSA9IG5ldyBEZXZpY2VzQXBpKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5wdXNoQXBpID0gbmV3IFB1c2hBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnNlcnZlcnNpZGVBcGkgPSBuZXcgU2VydmVyU2lkZUFwaSQxKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy50ZXN0aW5nQXBpID0gbmV3IFRlc3RpbmdBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zQXBpID0gbmV3IFBlcm1pc3Npb25zVjJBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzQXBpID0gbmV3IFNldHRpbmdzQXBpJDEoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmV2ZW50c0FwaSA9IG5ldyBFdmVudHNBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnRhc2tzQXBpID0gbmV3IFRhc2tzQXBpKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcklEXG4gICAgICogQHBhcmFtIGV4cFxuICAgICAqIEBwYXJhbSBpYXQgZGVwcmVjYXRlZCwgdGhlIGRlZmF1bHQgZGF0ZSB3aWxsIGJlIHNldCBpbnRlcm5hbGx5XG4gICAgICogQHBhcmFtIGNhbGxfY2lkcyB0aGlzIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIHVzZSBgY3JlYXRlQ2FsbFRva2VuYCBmb3IgY2FsbCB0b2tlbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNyZWF0ZVRva2VuKHVzZXJJRCwgZXhwID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCwgaWF0ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCksIGNhbGxfY2lkcykge1xuICAgICAgICBjb25zdCBleHRyYSA9IHt9O1xuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICBleHRyYS5leHAgPSBleHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlhdCkge1xuICAgICAgICAgICAgZXh0cmEuaWF0ID0gaWF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsX2NpZHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXNlIGNyZWF0ZUNhbGxUb2tlbiBtZXRob2QgZm9yIGNyZWF0aW5nIGNhbGwgdG9rZW5zLCB0aGUgXCJjYWxsX2NpZHNcIiBwYXJhbSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgY3JlYXRlVG9rZW4gbWV0aG9kIHdpdGggdmVyc2lvbiAwLjIuMGApO1xuICAgICAgICAgICAgZXh0cmEuY2FsbF9jaWRzID0gY2FsbF9jaWRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySURcbiAgICAgKiBAcGFyYW0gY2FsbF9jaWRzXG4gICAgICogQHBhcmFtIGV4cFxuICAgICAqIEBwYXJhbSBpYXQgdGhpcyBpcyBkZXByZWNhdGVkLCB0aGUgY3VycmVudCBkYXRlIHdpbGwgYmUgc2V0IGludGVybmFsbHlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUb2tlbih1c2VySUQsIGNhbGxfY2lkcywgZXhwID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCwgaWF0ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgZXh0cmEuZXhwID0gZXhwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpYXQpIHtcbiAgICAgICAgICAgIGV4dHJhLmlhdCA9IGlhdDtcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jYWxsX2NpZHMgPSBjYWxsX2NpZHM7XG4gICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEpO1xuICAgIH1cbiAgICBtYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHVzZXIpIHtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1c2VyKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXNlcnZlZEtleXdvcmRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5jdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN1c3RvbSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuY3VzdG9tW2tleV0gPSB1c2VyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHVzZXJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuU3RyZWFtQ2xpZW50LkRFRkFVTFRfVElNRU9VVCA9IDMwMDA7XG5cbmV4cG9ydCB7IEFQTkNvbmZpZ1JlcXVlc3RBdXRoVHlwZUVudW0sIEFwcFNlYXJjaEJhY2tlbmRFbnVtLCBBc3luY01vZGVyYXRpb25DYWxsYmFja0NvbmZpZ1JlcXVlc3RNb2RlRW51bSwgQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtLCBCbG9ja0xpc3RPcHRpb25zQmVoYXZpb3JFbnVtLCBCbG9ja0xpc3RPcHRpb25zUmVxdWVzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdBdXRvbW9kRW51bSwgQ2hhbm5lbENvbmZpZ0Jsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ1JlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb0F1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb0F1dG9tb2RFbnVtLCBDaGFubmVsQ29uZmlnV2l0aEluZm9CbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtLCBDaGFubmVsQ29uZmlnV2l0aEluZm9SZXF1ZXN0QXV0b21vZEVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxNZW1iZXJSZXF1ZXN0Um9sZUVudW0sIENoYW5uZWxNZW1iZXJSb2xlRW51bSwgQ2hhbm5lbFR5cGVDb25maWdBdXRvbW9kQmVoYXZpb3JFbnVtLCBDaGFubmVsVHlwZUNvbmZpZ0F1dG9tb2RFbnVtLCBDaGFubmVsVHlwZUNvbmZpZ0Jsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hlY2tQdXNoUmVxdWVzdFB1c2hQcm92aWRlclR5cGVFbnVtLCBDaGVja1NOU1Jlc3BvbnNlU3RhdHVzRW51bSwgQ2hlY2tTUVNSZXNwb25zZVN0YXR1c0VudW0sIENvbmZpZ0RlZmF1bHRSb2xlRW51bSwgQ29uZmlnUmVxdWVzdERlZmF1bHRSb2xlRW51bSwgQ3JlYXRlQ2FsbFJlcXVlc3RUeXBlRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEVudW0sIENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0sIENyZWF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ3JlYXRlRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0sIENyZWF0ZUltcG9ydFJlcXVlc3RNb2RlRW51bSwgRGVsZXRlVXNlcnNSZXF1ZXN0Q29udmVyc2F0aW9uc0VudW0sIERlbGV0ZVVzZXJzUmVxdWVzdE1lc3NhZ2VzRW51bSwgRGVsZXRlVXNlcnNSZXF1ZXN0VXNlckVudW0sIERldmljZUZpZWxkc1B1c2hQcm92aWRlckVudW0sIERldmljZVB1c2hQcm92aWRlckVudW0sIERldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtLCBJbWFnZVNpemVDcm9wRW51bSwgSW1hZ2VTaXplUmVzaXplRW51bSwgTGF5b3V0U2V0dGluZ3NOYW1lRW51bSwgTWVzc2FnZVJlcXVlc3QxVHlwZUVudW0sIE1lc3NhZ2VSZXF1ZXN0VHlwZUVudW0sIE1lc3NhZ2VUeXBlRW51bSwgUGVybWlzc2lvbkxldmVsRW51bSwgUG9saWN5UmVxdWVzdDFBY3Rpb25FbnVtLCBQb2xpY3lSZXF1ZXN0QWN0aW9uRW51bSwgUHVzaENvbmZpZ1JlcXVlc3RWZXJzaW9uRW51bSwgU3RyZWFtQ2FsbCwgU3RyZWFtQ2hhbm5lbCwgU3RyZWFtQ2hhdENsaWVudCwgU3RyZWFtQ2xpZW50LCBTdHJlYW1WaWRlb0NsaWVudCwgVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0sIFRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0TGFuZ3VhZ2VFbnVtLCBVcGRhdGVBcHBSZXF1ZXN0RW5mb3JjZVVuaXF1ZVVzZXJuYW1lc0VudW0sIFVwZGF0ZUFwcFJlcXVlc3RQZXJtaXNzaW9uVmVyc2lvbkVudW0sIFVwZGF0ZUFwcFJlcXVlc3RWaWRlb1Byb3ZpZGVyRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEVudW0sIFVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0sIFVwZGF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSwgVmlkZW9BdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0sIFZpZGVvQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSwgVmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSwgVmlkZW9MYXlvdXRTZXR0aW5nc05hbWVFbnVtLCBWaWRlb0xheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtLCBWaWRlb093bkNhcGFiaWxpdHksIFZpZGVvUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0sIFZpZGVvUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW0sIFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtLCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtLCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSwgVmlkZW9WaWRlb1NldHRpbmdzQ2FtZXJhRmFjaW5nRW51bSwgVmlkZW9WaWRlb1NldHRpbmdzUmVxdWVzdENhbWVyYUZhY2luZ0VudW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@stream-io/node-sdk/dist/index.es.js\n");

/***/ })

};
;